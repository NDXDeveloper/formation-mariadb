ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 19.2.2 Migration depuis SQL Server

> **Niveau** : AvancÃ© Ã  Expert  
> **DurÃ©e estimÃ©e** : 6-7 heures  
> **PrÃ©requis** : Connaissance de SQL Server (T-SQL, architecture), expÃ©rience MariaDB, comprÃ©hension des diffÃ©rences entre Ã©cosystÃ¨mes Microsoft et open-source

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Planifier une migration SQL Server â†’ MariaDB en Ã©valuant la complexitÃ©
- Convertir les types de donnÃ©es SQL Server vers leurs Ã©quivalents MariaDB
- Adapter le code T-SQL (procÃ©dures, fonctions, triggers) pour MariaDB
- Utiliser les outils de migration (SSMA, DMS, scripts personnalisÃ©s)
- GÃ©rer les fonctionnalitÃ©s SQL Server sans Ã©quivalent direct
- IntÃ©grer MariaDB dans un environnement Microsoft existant

---

## Introduction

La migration de Microsoft SQL Server vers MariaDB est une dÃ©marche de plus en plus courante, motivÃ©e par :
- **RÃ©duction des coÃ»ts** : Licences SQL Server Enterprise > 15Kâ‚¬/cÅ“ur
- **PortabilitÃ© cloud** : MariaDB s'exÃ©cute identiquement partout
- **IndÃ©pendance** : Sortir de l'Ã©cosystÃ¨me Microsoft propriÃ©taire
- **Performance** : MariaDB excelle sur certains workloads OLTP

Cependant, SQL Server et MariaDB prÃ©sentent des diffÃ©rences significatives, notamment au niveau du langage T-SQL, de la gestion des transactions et des fonctionnalitÃ©s avancÃ©es (SSIS, SSRS, SSAS).

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              MATRICE DE COMPLEXITÃ‰ MIGRATION SQL SERVER             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  Composant                  â”‚ DifficultÃ© â”‚ StratÃ©gie                â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  Tables (structure)         â”‚ â˜…â˜†â˜†â˜†â˜†     â”‚ Conversion directe        â”‚
â”‚  Types de donnÃ©es standards â”‚ â˜…â˜…â˜†â˜†â˜†     â”‚ Mapping dÃ©fini            â”‚
â”‚  Index clustered/non-clust. â”‚ â˜…â˜…â˜†â˜†â˜†     â”‚ Adaptation syntaxe        â”‚
â”‚  Vues simples               â”‚ â˜…â˜†â˜†â˜†â˜†     â”‚ Quasi-identique           â”‚
â”‚  Contraintes                â”‚ â˜…â˜†â˜†â˜†â˜†     â”‚ Syntaxe similaire         â”‚
â”‚  ProcÃ©dures stockÃ©es T-SQL  â”‚ â˜…â˜…â˜…â˜†â˜†     â”‚ RÃ©Ã©criture partielle      â”‚
â”‚  Fonctions scalaires        â”‚ â˜…â˜…â˜…â˜†â˜†     â”‚ Adaptation syntaxe        â”‚
â”‚  Fonctions table-valued     â”‚ â˜…â˜…â˜…â˜…â˜†     â”‚ RÃ©Ã©criture complÃ¨te       â”‚
â”‚  Triggers                   â”‚ â˜…â˜…â˜…â˜†â˜†     â”‚ Adaptation FOR/AFTER      â”‚
â”‚  CTEs et Window Functions   â”‚ â˜…â˜…â˜†â˜†â˜†     â”‚ Bon support MariaDB       â”‚
â”‚  XML natif                  â”‚ â˜…â˜…â˜…â˜…â˜†     â”‚ Conversion JSON/TEXT      â”‚
â”‚  Colonnes calculÃ©es         â”‚ â˜…â˜…â˜†â˜†â˜†     â”‚ Generated columns         â”‚
â”‚  IDENTITY                   â”‚ â˜…â˜†â˜†â˜†â˜†     â”‚ AUTO_INCREMENT            â”‚
â”‚  MERGE statement            â”‚ â˜…â˜…â˜…â˜†â˜†     â”‚ INSERT...ON DUPLICATE     â”‚
â”‚  TRY...CATCH                â”‚ â˜…â˜…â˜…â˜†â˜†     â”‚ HANDLER/SIGNAL            â”‚
â”‚  Linked Servers             â”‚ â˜…â˜…â˜…â˜…â˜†     â”‚ CONNECT/Federated         â”‚
â”‚  SSIS packages              â”‚ â˜…â˜…â˜…â˜…â˜…     â”‚ Refonte ETL complÃ¨te      â”‚
â”‚  SSRS reports               â”‚ â˜…â˜…â˜…â˜…â˜…     â”‚ Outil alternatif          â”‚
â”‚  Full-Text Search           â”‚ â˜…â˜…â˜…â˜†â˜†     â”‚ Support natif MariaDB     â”‚
â”‚  Temporal Tables            â”‚ â˜…â˜…â˜†â˜†â˜†     â”‚ System-Versioned ğŸ†•       â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## DiffÃ©rences architecturales

### ModÃ¨le d'instance et de base de donnÃ©es

```
SQL Server                          MariaDB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Instance           â”‚        â”‚      Instance           â”‚
â”‚   (SQL Server service)  â”‚        â”‚   (mysqld process)      â”‚
â”‚                         â”‚        â”‚                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  System DBs       â”‚  â”‚        â”‚  â”‚  System DBs       â”‚  â”‚
â”‚  â”‚  - master         â”‚  â”‚        â”‚  â”‚  - mysql          â”‚  â”‚
â”‚  â”‚  - msdb           â”‚  â”‚        â”‚  â”‚  - information_   â”‚  â”‚
â”‚  â”‚  - model          â”‚  â”‚        â”‚  â”‚    schema         â”‚  â”‚
â”‚  â”‚  - tempdb         â”‚  â”‚        â”‚  â”‚  - performance_   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚        â”‚  â”‚    schema         â”‚  â”‚
â”‚                         â”‚        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚        â”‚                         â”‚
â”‚  â”‚  User DBs         â”‚  â”‚        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  - Production     â”‚â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â–¶â”‚  production       â”‚  â”‚
â”‚  â”‚  - Reporting      â”‚â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â–¶â”‚  reporting        â”‚  â”‚
â”‚  â”‚    â””â”€ dbo schema  â”‚  â”‚        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”‚    â””â”€ sales schemaâ”‚  â”‚        â”‚                         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚        â”‚  Note: 1 DB SQL Server  â”‚
â”‚                         â”‚        â”‚  avec N schemas =       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚  N databases MariaDB    â”‚
                                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰quivalences :
â€¢ SQL Server Instance â†’ MariaDB Instance
â€¢ SQL Server Database â†’ MariaDB Database (si 1 schema)
â€¢ SQL Server Schema   â†’ MariaDB Database (gÃ©nÃ©ralement)
â€¢ SQL Server Login    â†’ MariaDB User
â€¢ SQL Server tempdb   â†’ MariaDB tmp tables (in-memory/disk)
```

### Gestion des schÃ©mas

```sql
-- SQL Server : SchÃ©mas multiples dans une base
USE Production;
CREATE SCHEMA sales;
CREATE SCHEMA inventory;

CREATE TABLE sales.orders (...);
CREATE TABLE inventory.products (...);

SELECT * FROM sales.orders o
JOIN inventory.products p ON o.product_id = p.id;

-- MariaDB : Options de migration

-- Option 1 : Une database par schema (recommandÃ©)
CREATE DATABASE production_sales;
CREATE DATABASE production_inventory;

CREATE TABLE production_sales.orders (...);
CREATE TABLE production_inventory.products (...);

SELECT * FROM production_sales.orders o
JOIN production_inventory.products p ON o.product_id = p.id;

-- Option 2 : PrÃ©fixage des tables (si schemas peu nombreux)
CREATE DATABASE production;
USE production;

CREATE TABLE sales_orders (...);
CREATE TABLE inventory_products (...);

-- Option 3 : Tout dans une database (si cross-schema queries frÃ©quentes)
CREATE DATABASE production;
USE production;

CREATE TABLE orders (...);      -- Ajouter colonne schema_source si besoin
CREATE TABLE products (...);
```

### Transactions et verrouillage

```sql
-- SQL Server : Niveau d'isolation par dÃ©faut READ COMMITTED
-- Avec READ_COMMITTED_SNAPSHOT, utilise row versioning

-- VÃ©rifier le niveau
SELECT CASE transaction_isolation_level 
    WHEN 0 THEN 'Unspecified'
    WHEN 1 THEN 'ReadUncommitted'
    WHEN 2 THEN 'ReadCommitted'
    WHEN 3 THEN 'RepeatableRead'
    WHEN 4 THEN 'Serializable'
    WHEN 5 THEN 'Snapshot'
END AS isolation_level
FROM sys.dm_exec_sessions 
WHERE session_id = @@SPID;

-- MariaDB : REPEATABLE READ par dÃ©faut (InnoDB)
-- Pour comportement SQL Server-like :
SET GLOBAL transaction_isolation = 'READ-COMMITTED';

-- SQL Server : Hints de verrouillage
SELECT * FROM orders WITH (NOLOCK);      -- Dirty reads OK
SELECT * FROM orders WITH (ROWLOCK);     -- Force row-level
SELECT * FROM orders WITH (TABLOCKX);    -- Exclusive table lock

-- MariaDB : Pas de hints Ã©quivalents directs
-- NOLOCK â‰ˆ SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
START TRANSACTION;
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT * FROM orders;
COMMIT;

-- Ou utiliser FOR UPDATE / LOCK IN SHARE MODE
SELECT * FROM orders WHERE id = 1 FOR UPDATE;
SELECT * FROM orders WHERE id = 1 LOCK IN SHARE MODE;
```

---

## Mapping des types de donnÃ©es

### Types numÃ©riques

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              TYPES NUMÃ‰RIQUES SQL SERVER â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Entiers
-- SQL Server          MariaDB              Notes
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- TINYINT             TINYINT UNSIGNED     SQL Server: 0-255
--                                          MariaDB TINYINT: -128 Ã  127
--                                          Utiliser UNSIGNED !
-- SMALLINT            SMALLINT             -32768 Ã  32767
-- INT                 INT                  Â±2.1 milliards
-- BIGINT              BIGINT               Â±9.2 quintillions

CREATE TABLE sql_server_types (
    tiny_col TINYINT,           -- 0-255 en SQL Server
    small_col SMALLINT,
    int_col INT,
    big_col BIGINT
);

CREATE TABLE mariadb_types (
    tiny_col TINYINT UNSIGNED,  -- Important : UNSIGNED pour 0-255
    small_col SMALLINT,
    int_col INT,
    big_col BIGINT
);

-- DÃ©cimaux et monÃ©taires
-- SQL Server          MariaDB              Notes
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- DECIMAL(p,s)        DECIMAL(p,s)         Identique
-- NUMERIC(p,s)        DECIMAL(p,s)         Alias en MariaDB aussi
-- MONEY               DECIMAL(19,4)        Pas de type MONEY natif
-- SMALLMONEY          DECIMAL(10,4)        Pas de type natif

-- SQL Server
CREATE TABLE financial (
    amount MONEY,                    -- Â±922 trillions, 4 dÃ©cimales
    small_amount SMALLMONEY,         -- Â±214K, 4 dÃ©cimales
    precise_val DECIMAL(18,6)
);

-- MariaDB
CREATE TABLE financial (
    amount DECIMAL(19,4),
    small_amount DECIMAL(10,4),
    precise_val DECIMAL(18,6)
);

-- Flottants
-- SQL Server          MariaDB              Notes
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- FLOAT               DOUBLE               Identique (8 bytes)
-- REAL                FLOAT                4 bytes
-- FLOAT(n) n<=24      FLOAT                4 bytes
-- FLOAT(n) n>24       DOUBLE               8 bytes

-- BIT
-- SQL Server          MariaDB              Notes
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- BIT                 TINYINT(1)           Ou BIT(1)
--                     ou BOOLEAN           Alias pour TINYINT(1)

-- SQL Server : BIT accepte 0, 1, NULL
-- MariaDB BOOLEAN : 0=FALSE, 1=TRUE, autres valeurs converties
CREATE TABLE flags (
    is_active BOOLEAN DEFAULT TRUE,
    is_deleted TINYINT(1) DEFAULT 0
);
```

### Types caractÃ¨res

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              TYPES CARACTÃˆRES SQL SERVER â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Types de base
-- SQL Server          MariaDB              Notes
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- CHAR(n)             CHAR(n)              n max: 8000 â†’ 255
-- VARCHAR(n)          VARCHAR(n)           n max: 8000 â†’ 65535
-- VARCHAR(MAX)        LONGTEXT             Jusqu'Ã  4GB
-- NCHAR(n)            CHAR(n) utf8mb4      Unicode
-- NVARCHAR(n)         VARCHAR(n) utf8mb4   Unicode
-- NVARCHAR(MAX)       LONGTEXT utf8mb4     Unicode large
-- TEXT                LONGTEXT             Deprecated SQL Server
-- NTEXT               LONGTEXT utf8mb4     Deprecated SQL Server

-- SQL Server
CREATE TABLE strings_sqlserver (
    code CHAR(10),
    name VARCHAR(100),
    description VARCHAR(MAX),
    unicode_name NVARCHAR(100),
    unicode_text NVARCHAR(MAX)
);

-- MariaDB
CREATE TABLE strings_mariadb (
    code CHAR(10),
    name VARCHAR(100),
    description LONGTEXT,
    unicode_name VARCHAR(100) CHARACTER SET utf8mb4,
    unicode_text LONGTEXT CHARACTER SET utf8mb4
);

-- Attention : Collations
-- SQL Server : Latin1_General_CI_AS (Case Insensitive, Accent Sensitive)
-- MariaDB 11.8 : utf8mb4_uca1400_ai_ci par dÃ©faut

-- Pour Ã©quivalence proche de SQL Server default :
CREATE TABLE with_collation (
    name VARCHAR(100) COLLATE utf8mb4_general_ci  -- CI = Case Insensitive
);

-- VÃ©rifier la collation par dÃ©faut
SHOW VARIABLES LIKE 'collation_server';
```

### Types date et heure

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              TYPES DATE/HEURE SQL SERVER â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Correspondances
-- SQL Server          MariaDB              PrÃ©cision / Notes
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- DATE                DATE                 YYYY-MM-DD
-- TIME                TIME(6)              HH:MI:SS.ffffff
-- TIME(n)             TIME(n)              n: 0-7 â†’ 0-6 (max MariaDB)
-- DATETIME            DATETIME             YYYY-MM-DD HH:MI:SS
-- DATETIME2           DATETIME(6)          Jusqu'Ã  microsecondes
-- DATETIME2(n)        DATETIME(n)          n: 0-7 â†’ 0-6
-- SMALLDATETIME       DATETIME             PrÃ©cision minute
-- DATETIMEOFFSET      DATETIME(6) + col    Pas de type natif avec TZ

-- SQL Server
CREATE TABLE dates_sqlserver (
    created_date DATE,
    event_time TIME(3),              -- Millisecondes
    updated_at DATETIME,
    precise_time DATETIME2(7),       -- 100 nanosecondes
    with_tz DATETIMEOFFSET           -- Avec timezone
);

-- MariaDB
CREATE TABLE dates_mariadb (
    created_date DATE,
    event_time TIME(3),
    updated_at DATETIME,
    precise_time DATETIME(6),        -- Max 6 dÃ©cimales (microsecondes)
    event_utc DATETIME(6),           -- Stocker en UTC
    event_tz_offset VARCHAR(10)      -- Stocker offset sÃ©parÃ©ment (+02:00)
);

-- Gestion DATETIMEOFFSET
-- Option 1 : Convertir tout en UTC
-- Option 2 : Deux colonnes (datetime + offset)
-- Option 3 : Utiliser TIMESTAMP (conversion auto UTC)

-- TIMESTAMP SQL Server vs MariaDB
-- SQL Server TIMESTAMP = ROWVERSION (8 bytes, auto-incrÃ©mentÃ©, pas une date!)
-- MariaDB TIMESTAMP = DATETIME avec timezone awareness

-- SQL Server (rowversion pour optimistic concurrency)
CREATE TABLE sqlserver_versioned (
    id INT PRIMARY KEY,
    data VARCHAR(100),
    row_version TIMESTAMP  -- Auto-gÃ©nÃ©rÃ©, binaire
);

-- MariaDB Ã©quivalent
CREATE TABLE mariadb_versioned (
    id INT PRIMARY KEY,
    data VARCHAR(100),
    row_version BIGINT UNSIGNED DEFAULT 0,
    -- Trigger pour incrÃ©menter
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Alternative : System-Versioned Tables (MariaDB 10.3+)
CREATE TABLE mariadb_temporal (
    id INT PRIMARY KEY,
    data VARCHAR(100),
    valid_from TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    valid_to TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME (valid_from, valid_to)
) WITH SYSTEM VERSIONING;
```

### Types binaires

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              TYPES BINAIRES SQL SERVER â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- SQL Server          MariaDB              Notes
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- BINARY(n)           BINARY(n)            Taille fixe, n max: 8000â†’255
-- VARBINARY(n)        VARBINARY(n)         Variable, n max: 8000â†’65535
-- VARBINARY(MAX)      LONGBLOB             Jusqu'Ã  4GB
-- IMAGE               LONGBLOB             Deprecated

-- SQL Server
CREATE TABLE binaries_sqlserver (
    hash BINARY(32),                 -- SHA-256
    data VARBINARY(8000),
    document VARBINARY(MAX)
);

-- MariaDB
CREATE TABLE binaries_mariadb (
    hash BINARY(32),
    data VARBINARY(8000),
    document LONGBLOB
);
```

### Types spÃ©ciaux

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              TYPES SPÃ‰CIAUX SQL SERVER â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- UNIQUEIDENTIFIER (GUID)
-- SQL Server
CREATE TABLE with_guid (
    id UNIQUEIDENTIFIER DEFAULT NEWID() PRIMARY KEY,
    name VARCHAR(100)
);

-- MariaDB Options :
-- Option 1 : UUID natif (MariaDB 10.7+)
CREATE TABLE with_uuid (
    id UUID DEFAULT UUID() PRIMARY KEY,
    name VARCHAR(100)
);

-- Option 2 : CHAR(36)
CREATE TABLE with_uuid_char (
    id CHAR(36) DEFAULT (UUID()) PRIMARY KEY,
    name VARCHAR(100)
);

-- Option 3 : BINARY(16) pour performance
CREATE TABLE with_uuid_binary (
    id BINARY(16) DEFAULT (UNHEX(REPLACE(UUID(), '-', ''))) PRIMARY KEY,
    name VARCHAR(100)
);

-- XML
-- SQL Server : Type XML natif avec validation schema
CREATE TABLE sqlserver_xml (
    id INT PRIMARY KEY,
    config XML,
    validated_xml XML(CONTENT MyXmlSchema)
);

-- MariaDB : Pas de type XML natif
-- Options : LONGTEXT ou JSON
CREATE TABLE mariadb_xml (
    id INT PRIMARY KEY,
    config LONGTEXT,  -- Stocker XML as-is
    -- Ou convertir en JSON pour requÃªtes
    config_json JSON
);

-- GEOGRAPHY / GEOMETRY
-- SQL Server
CREATE TABLE locations_sqlserver (
    id INT PRIMARY KEY,
    location GEOGRAPHY,
    shape GEOMETRY
);

-- MariaDB : Support spatial natif
CREATE TABLE locations_mariadb (
    id INT PRIMARY KEY,
    location POINT NOT NULL,
    shape GEOMETRY NOT NULL,
    SPATIAL INDEX (location),
    SPATIAL INDEX (shape)
);

-- Insertion de donnÃ©es spatiales
-- SQL Server
INSERT INTO locations_sqlserver (id, location)
VALUES (1, geography::Point(48.8566, 2.3522, 4326));

-- MariaDB
INSERT INTO locations_mariadb (id, location)
VALUES (1, ST_PointFromText('POINT(2.3522 48.8566)', 4326));

-- HIERARCHYID (SQL Server spÃ©cifique)
-- Pas d'Ã©quivalent direct en MariaDB
-- Solutions : 
-- 1. Adjacency List (parent_id)
-- 2. Nested Sets
-- 3. Materialized Path (VARCHAR stockant le chemin)
-- 4. Closure Table

-- SQL Server
CREATE TABLE org_hierarchy (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    node HIERARCHYID
);

-- MariaDB : Materialized Path
CREATE TABLE org_hierarchy (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    path VARCHAR(500),  -- '/1/3/7/' pour reprÃ©senter la hiÃ©rarchie
    level INT GENERATED ALWAYS AS (
        LENGTH(path) - LENGTH(REPLACE(path, '/', '')) - 1
    ) STORED,
    INDEX idx_path (path)
);

-- RequÃªte descendants
SELECT * FROM org_hierarchy 
WHERE path LIKE '/1/3/%';  -- Tous les descendants de /1/3/
```

### Table de conversion complÃ¨te

```sql
-- Script de gÃ©nÃ©ration des mappings de types
-- Ã€ exÃ©cuter sur SQL Server pour prÃ©parer la migration

SELECT 
    c.TABLE_SCHEMA,
    c.TABLE_NAME,
    c.COLUMN_NAME,
    c.DATA_TYPE,
    c.CHARACTER_MAXIMUM_LENGTH,
    c.NUMERIC_PRECISION,
    c.NUMERIC_SCALE,
    c.IS_NULLABLE,
    CASE 
        -- NumÃ©riques
        WHEN c.DATA_TYPE = 'tinyint' THEN 'TINYINT UNSIGNED'
        WHEN c.DATA_TYPE = 'smallint' THEN 'SMALLINT'
        WHEN c.DATA_TYPE = 'int' THEN 'INT'
        WHEN c.DATA_TYPE = 'bigint' THEN 'BIGINT'
        WHEN c.DATA_TYPE IN ('decimal', 'numeric') 
            THEN CONCAT('DECIMAL(', c.NUMERIC_PRECISION, ',', c.NUMERIC_SCALE, ')')
        WHEN c.DATA_TYPE = 'money' THEN 'DECIMAL(19,4)'
        WHEN c.DATA_TYPE = 'smallmoney' THEN 'DECIMAL(10,4)'
        WHEN c.DATA_TYPE IN ('float', 'real') THEN 'DOUBLE'
        WHEN c.DATA_TYPE = 'bit' THEN 'TINYINT(1)'
        
        -- CaractÃ¨res
        WHEN c.DATA_TYPE = 'char' THEN CONCAT('CHAR(', c.CHARACTER_MAXIMUM_LENGTH, ')')
        WHEN c.DATA_TYPE = 'varchar' AND c.CHARACTER_MAXIMUM_LENGTH = -1 THEN 'LONGTEXT'
        WHEN c.DATA_TYPE = 'varchar' THEN CONCAT('VARCHAR(', c.CHARACTER_MAXIMUM_LENGTH, ')')
        WHEN c.DATA_TYPE = 'nchar' THEN CONCAT('CHAR(', c.CHARACTER_MAXIMUM_LENGTH, ') CHARACTER SET utf8mb4')
        WHEN c.DATA_TYPE = 'nvarchar' AND c.CHARACTER_MAXIMUM_LENGTH = -1 THEN 'LONGTEXT CHARACTER SET utf8mb4'
        WHEN c.DATA_TYPE = 'nvarchar' THEN CONCAT('VARCHAR(', c.CHARACTER_MAXIMUM_LENGTH, ') CHARACTER SET utf8mb4')
        WHEN c.DATA_TYPE IN ('text', 'ntext') THEN 'LONGTEXT'
        
        -- Dates
        WHEN c.DATA_TYPE = 'date' THEN 'DATE'
        WHEN c.DATA_TYPE = 'time' THEN CONCAT('TIME(', COALESCE(c.DATETIME_PRECISION, 6), ')')
        WHEN c.DATA_TYPE = 'datetime' THEN 'DATETIME'
        WHEN c.DATA_TYPE = 'datetime2' THEN CONCAT('DATETIME(', LEAST(COALESCE(c.DATETIME_PRECISION, 6), 6), ')')
        WHEN c.DATA_TYPE = 'smalldatetime' THEN 'DATETIME'
        WHEN c.DATA_TYPE = 'datetimeoffset' THEN 'DATETIME(6) /* + timezone column */'
        
        -- Binaires
        WHEN c.DATA_TYPE = 'binary' THEN CONCAT('BINARY(', c.CHARACTER_MAXIMUM_LENGTH, ')')
        WHEN c.DATA_TYPE = 'varbinary' AND c.CHARACTER_MAXIMUM_LENGTH = -1 THEN 'LONGBLOB'
        WHEN c.DATA_TYPE = 'varbinary' THEN CONCAT('VARBINARY(', c.CHARACTER_MAXIMUM_LENGTH, ')')
        WHEN c.DATA_TYPE = 'image' THEN 'LONGBLOB'
        
        -- SpÃ©ciaux
        WHEN c.DATA_TYPE = 'uniqueidentifier' THEN 'CHAR(36) /* ou UUID */'
        WHEN c.DATA_TYPE = 'xml' THEN 'LONGTEXT /* ou JSON */'
        WHEN c.DATA_TYPE = 'timestamp' THEN 'BIGINT UNSIGNED /* rowversion */'
        WHEN c.DATA_TYPE IN ('geography', 'geometry') THEN 'GEOMETRY'
        WHEN c.DATA_TYPE = 'hierarchyid' THEN 'VARCHAR(500) /* materialized path */'
        WHEN c.DATA_TYPE = 'sql_variant' THEN 'JSON /* ou colonnes typÃ©es */'
        
        ELSE CONCAT('/* UNKNOWN: ', c.DATA_TYPE, ' */')
    END AS mariadb_type
FROM INFORMATION_SCHEMA.COLUMNS c
WHERE c.TABLE_SCHEMA NOT IN ('sys', 'INFORMATION_SCHEMA')
ORDER BY c.TABLE_SCHEMA, c.TABLE_NAME, c.ORDINAL_POSITION;
```

---

## Conversion du code T-SQL

### DiffÃ©rences syntaxiques fondamentales

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              SYNTAXE T-SQL vs MARIADB SQL
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- DÃ©limiteurs d'identifiants
-- SQL Server : [nom] ou "nom"
-- MariaDB    : `nom` ou "nom" (si ANSI_QUOTES activÃ©)

-- SQL Server
SELECT [order].[date], [user].[name]
FROM [dbo].[order]
JOIN [dbo].[user] ON [order].[user_id] = [user].[id];

-- MariaDB
SELECT `order`.`date`, `user`.`name`
FROM `order`
JOIN `user` ON `order`.`user_id` = `user`.`id`;

-- ConcatÃ©nation de chaÃ®nes
-- SQL Server : + ou CONCAT()
-- MariaDB    : CONCAT() ou || (avec sql_mode PIPES_AS_CONCAT)

-- SQL Server
SELECT first_name + ' ' + last_name AS full_name FROM users;
SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM users;

-- MariaDB
SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM users;
-- Ou avec mode ORACLE/PIPES_AS_CONCAT :
SET sql_mode = 'PIPES_AS_CONCAT';
SELECT first_name || ' ' || last_name AS full_name FROM users;

-- TOP vs LIMIT
-- SQL Server
SELECT TOP 10 * FROM orders ORDER BY created_at DESC;
SELECT TOP 10 PERCENT * FROM orders;

-- MariaDB
SELECT * FROM orders ORDER BY created_at DESC LIMIT 10;
-- Pas d'Ã©quivalent direct pour PERCENT, utiliser sous-requÃªte :
SELECT * FROM orders 
ORDER BY created_at DESC 
LIMIT (SELECT CEIL(COUNT(*) * 0.10) FROM orders);

-- OFFSET FETCH vs LIMIT OFFSET
-- SQL Server (2012+)
SELECT * FROM orders
ORDER BY id
OFFSET 20 ROWS
FETCH NEXT 10 ROWS ONLY;

-- MariaDB
SELECT * FROM orders
ORDER BY id
LIMIT 10 OFFSET 20;
-- Ou syntaxe alternative :
SELECT * FROM orders ORDER BY id LIMIT 20, 10;

-- ISNULL vs IFNULL/COALESCE
-- SQL Server
SELECT ISNULL(middle_name, '') AS middle_name FROM users;

-- MariaDB
SELECT IFNULL(middle_name, '') AS middle_name FROM users;
SELECT COALESCE(middle_name, '') AS middle_name FROM users;

-- GETDATE() vs NOW()
-- SQL Server
SELECT GETDATE();
SELECT GETUTCDATE();
SELECT SYSDATETIME();      -- Avec prÃ©cision haute

-- MariaDB
SELECT NOW();
SELECT UTC_TIMESTAMP();
SELECT NOW(6);             -- Avec microsecondes

-- DATEADD / DATEDIFF
-- SQL Server
SELECT DATEADD(day, 7, GETDATE());
SELECT DATEADD(month, -1, GETDATE());
SELECT DATEDIFF(day, start_date, end_date);

-- MariaDB
SELECT DATE_ADD(NOW(), INTERVAL 7 DAY);
SELECT DATE_SUB(NOW(), INTERVAL 1 MONTH);
SELECT DATEDIFF(end_date, start_date);  -- Attention : ordre inversÃ© !
SELECT TIMESTAMPDIFF(DAY, start_date, end_date);  -- Plus prÃ©cis

-- CAST et CONVERT
-- SQL Server
SELECT CAST(price AS VARCHAR(20));
SELECT CONVERT(VARCHAR(10), order_date, 103);  -- Format dd/mm/yyyy

-- MariaDB
SELECT CAST(price AS CHAR(20));
SELECT DATE_FORMAT(order_date, '%d/%m/%Y');

-- String functions
-- SQL Server
SELECT LEN('hello');           -- 5
SELECT DATALENGTH('hello');    -- 5 bytes
SELECT CHARINDEX('l', 'hello'); -- 3
SELECT SUBSTRING('hello', 2, 3); -- 'ell'
SELECT STUFF('hello', 2, 3, 'XYZ'); -- 'hXYZo'

-- MariaDB
SELECT CHAR_LENGTH('hello');   -- 5
SELECT LENGTH('hello');        -- 5 bytes
SELECT LOCATE('l', 'hello');   -- 3 (ou INSTR)
SELECT SUBSTRING('hello', 2, 3); -- 'ell' (identique)
SELECT INSERT('hello', 2, 3, 'XYZ'); -- 'hXYZo'
```

### IDENTITY vs AUTO_INCREMENT

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              IDENTITY â†’ AUTO_INCREMENT
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- SQL Server
CREATE TABLE orders (
    id INT IDENTITY(1,1) PRIMARY KEY,  -- Start 1, increment 1
    order_date DATE
);

-- RÃ©cupÃ©rer la derniÃ¨re valeur
SELECT SCOPE_IDENTITY();
SELECT @@IDENTITY;
SELECT IDENT_CURRENT('orders');

-- InsÃ©rer avec valeur explicite
SET IDENTITY_INSERT orders ON;
INSERT INTO orders (id, order_date) VALUES (100, '2025-01-01');
SET IDENTITY_INSERT orders OFF;

-- MariaDB
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    order_date DATE
);

-- RÃ©cupÃ©rer la derniÃ¨re valeur
SELECT LAST_INSERT_ID();

-- InsÃ©rer avec valeur explicite (pas besoin de SET spÃ©cial)
INSERT INTO orders (id, order_date) VALUES (100, '2025-01-01');

-- Reseed
-- SQL Server
DBCC CHECKIDENT ('orders', RESEED, 1000);

-- MariaDB
ALTER TABLE orders AUTO_INCREMENT = 1000;

-- Ou avec sÃ©quence (MariaDB 10.3+)
CREATE SEQUENCE order_seq START WITH 1 INCREMENT BY 1;
CREATE TABLE orders (
    id INT DEFAULT NEXT VALUE FOR order_seq PRIMARY KEY,
    order_date DATE
);
```

### ProcÃ©dures stockÃ©es

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              CONVERSION PROCÃ‰DURES T-SQL â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- SQL Server : ProcÃ©dure avec paramÃ¨tres et OUTPUT
CREATE PROCEDURE sp_GetOrderTotal
    @customer_id INT,
    @start_date DATE,
    @end_date DATE,
    @total_amount DECIMAL(18,2) OUTPUT,
    @order_count INT OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    
    SELECT 
        @total_amount = SUM(amount),
        @order_count = COUNT(*)
    FROM orders
    WHERE customer_id = @customer_id
      AND order_date BETWEEN @start_date AND @end_date;
    
    IF @total_amount IS NULL
        SET @total_amount = 0;
    IF @order_count IS NULL
        SET @order_count = 0;
END;

-- Appel SQL Server
DECLARE @total DECIMAL(18,2), @count INT;
EXEC sp_GetOrderTotal 
    @customer_id = 123, 
    @start_date = '2025-01-01',
    @end_date = '2025-12-31',
    @total_amount = @total OUTPUT,
    @order_count = @count OUTPUT;
SELECT @total, @count;

-- MariaDB : Ã‰quivalent
DELIMITER //
CREATE PROCEDURE sp_GetOrderTotal(
    IN p_customer_id INT,
    IN p_start_date DATE,
    IN p_end_date DATE,
    OUT p_total_amount DECIMAL(18,2),
    OUT p_order_count INT
)
BEGIN
    SELECT 
        COALESCE(SUM(amount), 0),
        COUNT(*)
    INTO p_total_amount, p_order_count
    FROM orders
    WHERE customer_id = p_customer_id
      AND order_date BETWEEN p_start_date AND p_end_date;
END //
DELIMITER ;

-- Appel MariaDB
CALL sp_GetOrderTotal(123, '2025-01-01', '2025-12-31', @total, @count);
SELECT @total, @count;

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              PROCÃ‰DURE COMPLEXE AVEC CURSEURS ET TRY/CATCH
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- SQL Server
CREATE PROCEDURE sp_ProcessOrders
    @batch_size INT = 100
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @order_id INT;
    DECLARE @processed INT = 0;
    
    DECLARE order_cursor CURSOR LOCAL FAST_FORWARD FOR
        SELECT TOP (@batch_size) id
        FROM orders
        WHERE status = 'PENDING'
        ORDER BY created_at;
    
    BEGIN TRY
        BEGIN TRANSACTION;
        
        OPEN order_cursor;
        FETCH NEXT FROM order_cursor INTO @order_id;
        
        WHILE @@FETCH_STATUS = 0
        BEGIN
            -- Traitement
            UPDATE orders 
            SET status = 'PROCESSING', 
                processed_at = GETDATE()
            WHERE id = @order_id;
            
            SET @processed = @processed + 1;
            FETCH NEXT FROM order_cursor INTO @order_id;
        END;
        
        CLOSE order_cursor;
        DEALLOCATE order_cursor;
        
        COMMIT TRANSACTION;
        
        SELECT @processed AS orders_processed;
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        IF CURSOR_STATUS('local', 'order_cursor') >= 0
        BEGIN
            CLOSE order_cursor;
            DEALLOCATE order_cursor;
        END;
        
        THROW;
    END CATCH;
END;

-- MariaDB : Ã‰quivalent
DELIMITER //
CREATE PROCEDURE sp_ProcessOrders(
    IN p_batch_size INT
)
BEGIN
    DECLARE v_order_id INT;
    DECLARE v_processed INT DEFAULT 0;
    DECLARE v_done INT DEFAULT FALSE;
    
    DECLARE order_cursor CURSOR FOR
        SELECT id
        FROM orders
        WHERE status = 'PENDING'
        ORDER BY created_at
        LIMIT p_batch_size;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = TRUE;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    OPEN order_cursor;
    
    read_loop: LOOP
        FETCH order_cursor INTO v_order_id;
        IF v_done THEN
            LEAVE read_loop;
        END IF;
        
        UPDATE orders 
        SET status = 'PROCESSING', 
            processed_at = NOW()
        WHERE id = v_order_id;
        
        SET v_processed = v_processed + 1;
    END LOOP;
    
    CLOSE order_cursor;
    
    COMMIT;
    
    SELECT v_processed AS orders_processed;
END //
DELIMITER ;

-- Appel
CALL sp_ProcessOrders(100);
```

### Fonctions

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              CONVERSION FONCTIONS T-SQL â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Fonction scalaire simple
-- SQL Server
CREATE FUNCTION fn_CalculateAge(@birth_date DATE)
RETURNS INT
AS
BEGIN
    RETURN DATEDIFF(YEAR, @birth_date, GETDATE()) -
           CASE WHEN DATEADD(YEAR, DATEDIFF(YEAR, @birth_date, GETDATE()), @birth_date) > GETDATE()
                THEN 1 ELSE 0 END;
END;

SELECT dbo.fn_CalculateAge('1990-05-15');

-- MariaDB
DELIMITER //
CREATE FUNCTION fn_CalculateAge(p_birth_date DATE)
RETURNS INT
DETERMINISTIC
BEGIN
    RETURN TIMESTAMPDIFF(YEAR, p_birth_date, CURDATE());
END //
DELIMITER ;

SELECT fn_CalculateAge('1990-05-15');

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              FONCTIONS TABLE-VALUED (TVF)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- SQL Server : Inline TVF
CREATE FUNCTION fn_GetCustomerOrders(@customer_id INT)
RETURNS TABLE
AS
RETURN (
    SELECT id, order_date, amount, status
    FROM orders
    WHERE customer_id = @customer_id
);

-- Utilisation
SELECT * FROM fn_GetCustomerOrders(123);

-- MariaDB : Pas de TVF native
-- Alternative 1 : Vue avec paramÃ¨tre via session variable
CREATE VIEW v_customer_orders AS
SELECT id, order_date, amount, status
FROM orders
WHERE customer_id = @p_customer_id;

SET @p_customer_id = 123;
SELECT * FROM v_customer_orders;

-- Alternative 2 : ProcÃ©dure qui retourne un resultset
DELIMITER //
CREATE PROCEDURE sp_GetCustomerOrders(IN p_customer_id INT)
BEGIN
    SELECT id, order_date, amount, status
    FROM orders
    WHERE customer_id = p_customer_id;
END //
DELIMITER ;

CALL sp_GetCustomerOrders(123);

-- Alternative 3 : Table temporaire
DELIMITER //
CREATE PROCEDURE sp_GetCustomerOrders_Temp(IN p_customer_id INT)
BEGIN
    DROP TEMPORARY TABLE IF EXISTS tmp_customer_orders;
    CREATE TEMPORARY TABLE tmp_customer_orders AS
    SELECT id, order_date, amount, status
    FROM orders
    WHERE customer_id = p_customer_id;
END //
DELIMITER ;

CALL sp_GetCustomerOrders_Temp(123);
SELECT * FROM tmp_customer_orders;

-- SQL Server : Multi-statement TVF
CREATE FUNCTION fn_GetOrdersWithRunningTotal(@customer_id INT)
RETURNS @result TABLE (
    id INT,
    order_date DATE,
    amount DECIMAL(18,2),
    running_total DECIMAL(18,2)
)
AS
BEGIN
    INSERT INTO @result
    SELECT 
        id, 
        order_date, 
        amount,
        SUM(amount) OVER (ORDER BY order_date) AS running_total
    FROM orders
    WHERE customer_id = @customer_id;
    RETURN;
END;

-- MariaDB : Utiliser directement une requÃªte ou procÃ©dure
-- Window functions supportÃ©es, pas besoin de TVF
SELECT 
    id, 
    order_date, 
    amount,
    SUM(amount) OVER (ORDER BY order_date) AS running_total
FROM orders
WHERE customer_id = 123;
```

### Triggers

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              CONVERSION TRIGGERS T-SQL â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- SQL Server : Trigger AFTER INSERT (multi-row)
CREATE TRIGGER tr_orders_after_insert
ON orders
AFTER INSERT
AS
BEGIN
    SET NOCOUNT ON;
    
    -- SQL Server : inserted/deleted sont des tables avec toutes les lignes
    INSERT INTO audit_log (table_name, action, record_id, new_values, created_at)
    SELECT 
        'orders',
        'INSERT',
        i.id,
        (SELECT i.* FOR JSON PATH, WITHOUT_ARRAY_WRAPPER),
        GETDATE()
    FROM inserted i;
    
    -- Mise Ã  jour statistiques client
    UPDATE c
    SET total_orders = total_orders + counts.cnt,
        total_amount = total_amount + counts.amt
    FROM customers c
    JOIN (
        SELECT customer_id, COUNT(*) as cnt, SUM(amount) as amt
        FROM inserted
        GROUP BY customer_id
    ) counts ON c.id = counts.customer_id;
END;

-- MariaDB : Trigger FOR EACH ROW (une ligne Ã  la fois)
DELIMITER //
CREATE TRIGGER tr_orders_after_insert
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    -- Audit (ligne par ligne)
    INSERT INTO audit_log (table_name, action, record_id, new_values, created_at)
    VALUES (
        'orders',
        'INSERT',
        NEW.id,
        JSON_OBJECT(
            'id', NEW.id,
            'customer_id', NEW.customer_id,
            'amount', NEW.amount,
            'status', NEW.status
        ),
        NOW()
    );
    
    -- Mise Ã  jour statistiques client
    UPDATE customers
    SET total_orders = total_orders + 1,
        total_amount = total_amount + NEW.amount
    WHERE id = NEW.customer_id;
END //
DELIMITER ;

-- âš ï¸ Note importante : 
-- SQL Server triggers sont set-based (traitent toutes les lignes en une fois)
-- MariaDB triggers sont row-based (dÃ©clenchÃ©s pour chaque ligne)
-- Pour insertions massives, MariaDB trigger peut impacter la performance

-- SQL Server : INSTEAD OF trigger
CREATE TRIGGER tr_orders_instead_insert
ON v_orders_editable
INSTEAD OF INSERT
AS
BEGIN
    INSERT INTO orders (customer_id, amount, status)
    SELECT customer_id, amount, 'PENDING'
    FROM inserted;
END;

-- MariaDB : Pas d'INSTEAD OF triggers
-- Alternative : Utiliser BEFORE trigger avec SIGNAL pour bloquer + logique
DELIMITER //
CREATE TRIGGER tr_orders_before_insert
BEFORE INSERT ON orders
FOR EACH ROW
BEGIN
    -- Forcer le statut
    SET NEW.status = 'PENDING';
    -- Validation
    IF NEW.amount < 0 THEN
        SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'Amount cannot be negative';
    END IF;
END //
DELIMITER ;
```

### Gestion des erreurs

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              TRY...CATCH â†’ HANDLER/SIGNAL
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- SQL Server
CREATE PROCEDURE sp_TransferFunds
    @from_account INT,
    @to_account INT,
    @amount DECIMAL(18,2)
AS
BEGIN
    SET NOCOUNT ON;
    
    BEGIN TRY
        BEGIN TRANSACTION;
        
        -- VÃ©rifier solde
        IF (SELECT balance FROM accounts WHERE id = @from_account) < @amount
        BEGIN
            RAISERROR('Insufficient funds', 16, 1);
        END;
        
        -- DÃ©bit
        UPDATE accounts SET balance = balance - @amount 
        WHERE id = @from_account;
        
        -- CrÃ©dit
        UPDATE accounts SET balance = balance + @amount 
        WHERE id = @to_account;
        
        COMMIT TRANSACTION;
        
        SELECT 'Transfer successful' AS result;
        
    END TRY
    BEGIN CATCH
        IF @@TRANCOUNT > 0
            ROLLBACK TRANSACTION;
        
        -- Log erreur
        INSERT INTO error_log (error_number, error_message, error_procedure, error_line)
        VALUES (ERROR_NUMBER(), ERROR_MESSAGE(), ERROR_PROCEDURE(), ERROR_LINE());
        
        -- Re-throw
        THROW;
    END CATCH;
END;

-- MariaDB
DELIMITER //
CREATE PROCEDURE sp_TransferFunds(
    IN p_from_account INT,
    IN p_to_account INT,
    IN p_amount DECIMAL(18,2)
)
BEGIN
    DECLARE v_balance DECIMAL(18,2);
    DECLARE v_error_msg VARCHAR(500);
    
    -- Handler pour exceptions SQL
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1
            v_error_msg = MESSAGE_TEXT;
        
        ROLLBACK;
        
        INSERT INTO error_log (error_message, error_procedure, created_at)
        VALUES (v_error_msg, 'sp_TransferFunds', NOW());
        
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    -- VÃ©rifier solde
    SELECT balance INTO v_balance 
    FROM accounts 
    WHERE id = p_from_account 
    FOR UPDATE;  -- Lock the row
    
    IF v_balance < p_amount THEN
        SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'Insufficient funds';
    END IF;
    
    -- DÃ©bit
    UPDATE accounts SET balance = balance - p_amount 
    WHERE id = p_from_account;
    
    -- CrÃ©dit
    UPDATE accounts SET balance = balance + p_amount 
    WHERE id = p_to_account;
    
    COMMIT;
    
    SELECT 'Transfer successful' AS result;
END //
DELIMITER ;
```

### MERGE statement

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              MERGE â†’ INSERT...ON DUPLICATE KEY UPDATE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- SQL Server : MERGE complet
MERGE INTO products AS target
USING staging_products AS source
ON target.product_code = source.product_code
WHEN MATCHED THEN
    UPDATE SET 
        name = source.name,
        price = source.price,
        updated_at = GETDATE()
WHEN NOT MATCHED BY TARGET THEN
    INSERT (product_code, name, price, created_at)
    VALUES (source.product_code, source.name, source.price, GETDATE())
WHEN NOT MATCHED BY SOURCE THEN
    DELETE;

-- MariaDB : Pas de MERGE natif
-- Option 1 : INSERT...ON DUPLICATE KEY UPDATE (si clÃ© unique existe)
INSERT INTO products (product_code, name, price, created_at, updated_at)
SELECT product_code, name, price, NOW(), NOW()
FROM staging_products
ON DUPLICATE KEY UPDATE
    name = VALUES(name),
    price = VALUES(price),
    updated_at = NOW();

-- Option 2 : REPLACE INTO (DELETE + INSERT, attention aux FK!)
REPLACE INTO products (product_code, name, price, created_at)
SELECT product_code, name, price, NOW()
FROM staging_products;

-- Option 3 : ProcÃ©dure pour MERGE complet avec DELETE
DELIMITER //
CREATE PROCEDURE sp_MergeProducts()
BEGIN
    -- MATCHED : Update
    UPDATE products p
    JOIN staging_products s ON p.product_code = s.product_code
    SET p.name = s.name,
        p.price = s.price,
        p.updated_at = NOW();
    
    -- NOT MATCHED BY TARGET : Insert
    INSERT INTO products (product_code, name, price, created_at)
    SELECT s.product_code, s.name, s.price, NOW()
    FROM staging_products s
    LEFT JOIN products p ON s.product_code = p.product_code
    WHERE p.product_code IS NULL;
    
    -- NOT MATCHED BY SOURCE : Delete
    DELETE p FROM products p
    LEFT JOIN staging_products s ON p.product_code = s.product_code
    WHERE s.product_code IS NULL;
END //
DELIMITER ;
```

---

## Outils de migration

### SQL Server Migration Assistant (SSMA)

```
SSMA for MySQL (gratuit Microsoft) :
- Analyse automatique du schÃ©ma SQL Server
- Conversion vers MySQL/MariaDB
- Rapport de compatibilitÃ© dÃ©taillÃ©
- Migration des donnÃ©es
- Conversion partielle du T-SQL

Workflow :
1. Installer SSMA for MySQL
2. CrÃ©er un projet de migration
3. Connecter SQL Server source
4. Connecter MariaDB cible
5. Analyser et convertir le schÃ©ma
6. RÃ©soudre les erreurs de conversion
7. Synchroniser le schÃ©ma cible
8. Migrer les donnÃ©es
9. Valider
```

### Scripts BCP et LOAD DATA

```bash
#!/bin/bash
# Export SQL Server avec BCP

# Variables
SQL_SERVER="sql-server-host"
DATABASE="production"
OUTPUT_DIR="/backup/migration"

# Liste des tables
TABLES=$(sqlcmd -S $SQL_SERVER -d $DATABASE -Q "
    SET NOCOUNT ON;
    SELECT TABLE_SCHEMA + '.' + TABLE_NAME 
    FROM INFORMATION_SCHEMA.TABLES 
    WHERE TABLE_TYPE = 'BASE TABLE'
" -h -1)

# Export chaque table
for table in $TABLES; do
    echo "Exporting $table..."
    schema=$(echo $table | cut -d'.' -f1)
    name=$(echo $table | cut -d'.' -f2)
    
    # Export CSV avec BCP
    bcp "$DATABASE.$table" out "$OUTPUT_DIR/${schema}_${name}.csv" \
        -S $SQL_SERVER \
        -T \
        -c \
        -t ',' \
        -r '\n' \
        -C 65001  # UTF-8
done

# Import dans MariaDB
for csv_file in $OUTPUT_DIR/*.csv; do
    table_name=$(basename $csv_file .csv)
    echo "Importing $table_name..."
    
    mysql -h mariadb-host -u root -p$MYSQL_PWD production << EOF
LOAD DATA LOCAL INFILE '$csv_file'
INTO TABLE \`$table_name\`
CHARACTER SET utf8mb4
FIELDS TERMINATED BY ','
OPTIONALLY ENCLOSED BY '"'
LINES TERMINATED BY '\n';
EOF
done
```

### AWS DMS pour SQL Server

```json
// Source endpoint SQL Server
{
    "EndpointType": "source",
    "EngineName": "sqlserver",
    "ServerName": "sql-server.example.com",
    "Port": 1433,
    "Username": "dms_user",
    "Password": "SecureP@ss",
    "DatabaseName": "production",
    "SslMode": "require"
}

// Target endpoint MariaDB
{
    "EndpointType": "target",
    "EngineName": "mariadb",
    "ServerName": "mariadb.example.com",
    "Port": 3306,
    "Username": "dms_user",
    "Password": "SecureP@ss",
    "DatabaseName": "production"
}

// Table mappings avec transformations
{
    "rules": [
        {
            "rule-type": "selection",
            "rule-id": "1",
            "rule-name": "include-all-tables",
            "object-locator": {
                "schema-name": "dbo",
                "table-name": "%"
            },
            "rule-action": "include"
        },
        {
            "rule-type": "transformation",
            "rule-id": "2",
            "rule-name": "convert-schema-to-db",
            "object-locator": {
                "schema-name": "dbo"
            },
            "rule-action": "rename",
            "rule-target": "schema-name",
            "value": "production"
        },
        {
            "rule-type": "transformation",
            "rule-id": "3",
            "rule-name": "lowercase-tables",
            "object-locator": {
                "schema-name": "%",
                "table-name": "%"
            },
            "rule-action": "convert-lowercase",
            "rule-target": "table"
        }
    ]
}
```

### Script de conversion automatisÃ©

```python
#!/usr/bin/env python3
"""
sql_server_to_mariadb_converter.py
Convertit les objets SQL Server vers MariaDB
"""

import pyodbc
import mysql.connector
import re
from typing import Dict, List, Tuple

class SQLServerToMariaDBConverter:
    
    def __init__(self, sql_server_conn_str: str, mariadb_config: Dict):
        self.sql_conn = pyodbc.connect(sql_server_conn_str)
        self.maria_conn = mysql.connector.connect(**mariadb_config)
        
    def convert_data_type(self, sql_type: str, max_length: int, 
                          precision: int, scale: int) -> str:
        """Convertit un type SQL Server vers MariaDB"""
        sql_type = sql_type.lower()
        
        type_mapping = {
            'tinyint': 'TINYINT UNSIGNED',
            'smallint': 'SMALLINT',
            'int': 'INT',
            'bigint': 'BIGINT',
            'bit': 'TINYINT(1)',
            'money': 'DECIMAL(19,4)',
            'smallmoney': 'DECIMAL(10,4)',
            'float': 'DOUBLE',
            'real': 'FLOAT',
            'date': 'DATE',
            'datetime': 'DATETIME',
            'datetime2': f'DATETIME({min(scale or 6, 6)})',
            'smalldatetime': 'DATETIME',
            'time': f'TIME({min(scale or 6, 6)})',
            'uniqueidentifier': 'CHAR(36)',
            'text': 'LONGTEXT',
            'ntext': 'LONGTEXT',
            'image': 'LONGBLOB',
            'xml': 'LONGTEXT',
        }
        
        if sql_type in type_mapping:
            return type_mapping[sql_type]
        
        if sql_type in ('decimal', 'numeric'):
            return f'DECIMAL({precision},{scale})'
        
        if sql_type == 'char':
            return f'CHAR({max_length})'
        
        if sql_type == 'nchar':
            return f'CHAR({max_length}) CHARACTER SET utf8mb4'
        
        if sql_type == 'varchar':
            if max_length == -1:
                return 'LONGTEXT'
            return f'VARCHAR({max_length})'
        
        if sql_type == 'nvarchar':
            if max_length == -1:
                return 'LONGTEXT CHARACTER SET utf8mb4'
            return f'VARCHAR({max_length}) CHARACTER SET utf8mb4'
        
        if sql_type == 'binary':
            return f'BINARY({max_length})'
        
        if sql_type == 'varbinary':
            if max_length == -1:
                return 'LONGBLOB'
            return f'VARBINARY({max_length})'
        
        return f'/* UNKNOWN: {sql_type} */'
    
    def convert_tsql_to_mariadb(self, tsql: str) -> str:
        """Convertit du code T-SQL vers MariaDB SQL"""
        result = tsql
        
        # DÃ©limiteurs
        result = re.sub(r'\[(\w+)\]', r'`\1`', result)
        
        # GETDATE() â†’ NOW()
        result = re.sub(r'GETDATE\(\)', 'NOW()', result, flags=re.IGNORECASE)
        
        # ISNULL â†’ IFNULL
        result = re.sub(r'ISNULL\(', 'IFNULL(', result, flags=re.IGNORECASE)
        
        # TOP N â†’ LIMIT N (simple cases)
        result = re.sub(
            r'SELECT\s+TOP\s+(\d+)\s+', 
            r'SELECT ', 
            result, 
            flags=re.IGNORECASE
        )
        # Add LIMIT at end (simplified, needs proper parsing for complex queries)
        
        # DATEADD
        result = re.sub(
            r'DATEADD\s*\(\s*(\w+)\s*,\s*(-?\d+)\s*,\s*([^)]+)\)',
            lambda m: f"DATE_ADD({m.group(3)}, INTERVAL {m.group(2)} {m.group(1).upper()})",
            result,
            flags=re.IGNORECASE
        )
        
        # LEN â†’ CHAR_LENGTH
        result = re.sub(r'\bLEN\(', 'CHAR_LENGTH(', result, flags=re.IGNORECASE)
        
        # CHARINDEX â†’ LOCATE (swap arguments)
        def swap_charindex(match):
            return f"LOCATE({match.group(1)}, {match.group(2)})"
        result = re.sub(
            r'CHARINDEX\s*\(\s*([^,]+)\s*,\s*([^)]+)\)',
            swap_charindex,
            result,
            flags=re.IGNORECASE
        )
        
        return result
    
    def generate_create_table(self, schema: str, table: str) -> str:
        """GÃ©nÃ¨re le CREATE TABLE MariaDB"""
        cursor = self.sql_conn.cursor()
        
        # RÃ©cupÃ©rer les colonnes
        cursor.execute("""
            SELECT 
                c.COLUMN_NAME,
                c.DATA_TYPE,
                c.CHARACTER_MAXIMUM_LENGTH,
                c.NUMERIC_PRECISION,
                c.NUMERIC_SCALE,
                c.IS_NULLABLE,
                c.COLUMN_DEFAULT,
                COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA + '.' + c.TABLE_NAME), 
                               c.COLUMN_NAME, 'IsIdentity') as is_identity
            FROM INFORMATION_SCHEMA.COLUMNS c
            WHERE c.TABLE_SCHEMA = ? AND c.TABLE_NAME = ?
            ORDER BY c.ORDINAL_POSITION
        """, (schema, table))
        
        columns = []
        for row in cursor.fetchall():
            col_name = row.COLUMN_NAME
            maria_type = self.convert_data_type(
                row.DATA_TYPE,
                row.CHARACTER_MAXIMUM_LENGTH or 0,
                row.NUMERIC_PRECISION or 0,
                row.NUMERIC_SCALE or 0
            )
            
            col_def = f"    `{col_name}` {maria_type}"
            
            if row.IS_NULLABLE == 'NO':
                col_def += " NOT NULL"
            
            if row.is_identity:
                col_def += " AUTO_INCREMENT"
            elif row.COLUMN_DEFAULT:
                default = self.convert_tsql_to_mariadb(row.COLUMN_DEFAULT)
                col_def += f" DEFAULT {default}"
            
            columns.append(col_def)
        
        # RÃ©cupÃ©rer la clÃ© primaire
        cursor.execute("""
            SELECT COLUMN_NAME
            FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
            WHERE OBJECTPROPERTY(OBJECT_ID(CONSTRAINT_SCHEMA + '.' + CONSTRAINT_NAME), 
                                 'IsPrimaryKey') = 1
              AND TABLE_SCHEMA = ? AND TABLE_NAME = ?
            ORDER BY ORDINAL_POSITION
        """, (schema, table))
        
        pk_columns = [row.COLUMN_NAME for row in cursor.fetchall()]
        if pk_columns:
            columns.append(f"    PRIMARY KEY (`{'`, `'.join(pk_columns)}`)")
        
        ddl = f"CREATE TABLE `{table}` (\n"
        ddl += ",\n".join(columns)
        ddl += "\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;"
        
        return ddl
    
    def migrate_table_data(self, schema: str, table: str, batch_size: int = 10000):
        """Migre les donnÃ©es d'une table"""
        sql_cursor = self.sql_conn.cursor()
        maria_cursor = self.maria_conn.cursor()
        
        # RÃ©cupÃ©rer les colonnes
        sql_cursor.execute(f"""
            SELECT COLUMN_NAME 
            FROM INFORMATION_SCHEMA.COLUMNS 
            WHERE TABLE_SCHEMA = '{schema}' AND TABLE_NAME = '{table}'
            ORDER BY ORDINAL_POSITION
        """)
        columns = [row.COLUMN_NAME for row in sql_cursor.fetchall()]
        
        # PrÃ©parer INSERT
        placeholders = ', '.join(['%s'] * len(columns))
        insert_sql = f"INSERT INTO `{table}` (`{'`, `'.join(columns)}`) VALUES ({placeholders})"
        
        # Lire et insÃ©rer par batch
        sql_cursor.execute(f"SELECT * FROM [{schema}].[{table}]")
        
        batch = []
        total = 0
        
        for row in sql_cursor:
            batch.append(tuple(row))
            
            if len(batch) >= batch_size:
                maria_cursor.executemany(insert_sql, batch)
                self.maria_conn.commit()
                total += len(batch)
                print(f"  Inserted {total} rows...")
                batch = []
        
        if batch:
            maria_cursor.executemany(insert_sql, batch)
            self.maria_conn.commit()
            total += len(batch)
        
        print(f"  Total: {total} rows migrated")
        return total


# Utilisation
if __name__ == "__main__":
    converter = SQLServerToMariaDBConverter(
        sql_server_conn_str="DRIVER={ODBC Driver 17 for SQL Server};SERVER=sql-server;DATABASE=production;UID=user;PWD=pass",
        mariadb_config={
            'host': 'mariadb-host',
            'user': 'root',
            'password': 'pass',
            'database': 'production'
        }
    )
    
    # GÃ©nÃ©rer DDL
    ddl = converter.generate_create_table('dbo', 'orders')
    print(ddl)
    
    # Migrer donnÃ©es
    converter.migrate_table_data('dbo', 'orders')
```

---

## ScÃ©narios de migration rÃ©els

### ScÃ©nario 1 : Application .NET avec Entity Framework

**Contexte** :
- SQL Server 2019, 200 GB
- Application ASP.NET Core avec Entity Framework Core
- 150 tables, 50 procÃ©dures stockÃ©es
- Objectif : RÃ©duire les coÃ»ts cloud (Azure SQL â†’ MariaDB)

**StratÃ©gie** :

```
Phase 1 : PrÃ©paration application (2 semaines)
â”œâ”€â”€ Changer le provider EF Core : SqlServer â†’ Pomelo.EntityFrameworkCore.MySql
â”œâ”€â”€ Adapter les migrations EF
â”œâ”€â”€ Identifier le code SQL raw Ã  convertir
â””â”€â”€ Configurer connection strings

Phase 2 : Migration schÃ©ma (2 semaines)
â”œâ”€â”€ Export DDL avec SSMA
â”œâ”€â”€ Conversion manuelle des procÃ©dures critiques
â”œâ”€â”€ Tests unitaires des procÃ©dures
â””â”€â”€ Validation schÃ©ma

Phase 3 : Migration donnÃ©es (1 semaine)
â”œâ”€â”€ Export via BCP
â”œâ”€â”€ Import avec LOAD DATA
â”œâ”€â”€ Validation intÃ©gritÃ©
â””â”€â”€ VÃ©rification checksums

Phase 4 : Tests et cutover (2 semaines)
â”œâ”€â”€ Tests de rÃ©gression complets
â”œâ”€â”€ Tests de performance
â”œâ”€â”€ Dry-run de migration
â””â”€â”€ Go-live
```

**Configuration Entity Framework** :

```csharp
// Avant : SQL Server
services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));

// AprÃ¨s : MariaDB avec Pomelo
services.AddDbContext<ApplicationDbContext>(options =>
    options.UseMySql(
        Configuration.GetConnectionString("DefaultConnection"),
        ServerVersion.AutoDetect(Configuration.GetConnectionString("DefaultConnection")),
        mySqlOptions =>
        {
            mySqlOptions.EnableRetryOnFailure(
                maxRetryCount: 3,
                maxRetryDelay: TimeSpan.FromSeconds(30),
                errorNumbersToAdd: null);
        }));

// appsettings.json
{
    "ConnectionStrings": {
        "DefaultConnection": "Server=mariadb-host;Database=production;User=app_user;Password=SecureP@ss;CharSet=utf8mb4"
    }
}
```

### ScÃ©nario 2 : Data Warehouse avec SSIS

**Contexte** :
- SQL Server 2017 Data Warehouse, 2 TB
- 30 packages SSIS pour ETL
- Reporting avec SSRS
- Besoin : Alternative open-source complÃ¨te

**Architecture cible** :

```
SQL Server (avant)                  Open Source (aprÃ¨s)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Sources       â”‚                â”‚   Sources               â”‚
â”‚  (ERP, CRM)     â”‚                â”‚  (ERP, CRM)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                                     â”‚
         â–¼                                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      SSIS       â”‚      â†’         â”‚  Apache Airflow         â”‚
â”‚  (ETL Packages) â”‚                â”‚  (DAGs Python)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                                     â”‚
         â–¼                                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SQL Server      â”‚      â†’        â”‚  MariaDB ColumnStore    â”‚
â”‚  (Data Warehouse)â”‚               â”‚  (OLAP optimisÃ©)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                                     â”‚
         â–¼                                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     SSRS        â”‚      â†’         â”‚  Apache Superset        â”‚
â”‚  (Reporting)    â”‚                â”‚  ou Metabase            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Exemple de conversion SSIS â†’ Airflow** :

```python
# Airflow DAG Ã©quivalent Ã  un package SSIS
from airflow import DAG
from airflow.operators.python import PythonOperator
from airflow.providers.mysql.operators.mysql import MySqlOperator
from airflow.providers.mysql.hooks.mysql import MySqlHook
from datetime import datetime, timedelta
import pandas as pd

default_args = {
    'owner': 'data-team',
    'depends_on_past': False,
    'start_date': datetime(2025, 1, 1),
    'retries': 3,
    'retry_delay': timedelta(minutes=5),
}

dag = DAG(
    'etl_sales_daily',
    default_args=default_args,
    description='Daily sales ETL (ex-SSIS package)',
    schedule_interval='0 2 * * *',  # 2h du matin
    catchup=False
)

def extract_from_source(**context):
    """Extraction depuis source (Ã©quivalent Data Flow Source)"""
    hook = MySqlHook(mysql_conn_id='source_erp')
    df = hook.get_pandas_df("""
        SELECT order_id, customer_id, product_id, quantity, amount, order_date
        FROM orders
        WHERE order_date = CURDATE() - INTERVAL 1 DAY
    """)
    # Stocker pour Ã©tape suivante
    context['ti'].xcom_push(key='extracted_data', value=df.to_json())

def transform_data(**context):
    """Transformations (Ã©quivalent Derived Column, Lookup, etc.)"""
    df = pd.read_json(context['ti'].xcom_pull(key='extracted_data'))
    
    # AgrÃ©gations
    df_agg = df.groupby(['customer_id', 'product_id', 'order_date']).agg({
        'quantity': 'sum',
        'amount': 'sum',
        'order_id': 'count'
    }).reset_index()
    df_agg.columns = ['customer_id', 'product_id', 'order_date', 
                      'total_quantity', 'total_amount', 'order_count']
    
    context['ti'].xcom_push(key='transformed_data', value=df_agg.to_json())

def load_to_warehouse(**context):
    """Chargement (Ã©quivalent OLE DB Destination)"""
    df = pd.read_json(context['ti'].xcom_pull(key='transformed_data'))
    
    hook = MySqlHook(mysql_conn_id='mariadb_warehouse')
    engine = hook.get_sqlalchemy_engine()
    
    df.to_sql(
        'fact_daily_sales',
        engine,
        if_exists='append',
        index=False,
        method='multi'
    )

# Tasks
extract_task = PythonOperator(
    task_id='extract_from_source',
    python_callable=extract_from_source,
    dag=dag
)

transform_task = PythonOperator(
    task_id='transform_data',
    python_callable=transform_data,
    dag=dag
)

load_task = PythonOperator(
    task_id='load_to_warehouse',
    python_callable=load_to_warehouse,
    dag=dag
)

# DÃ©pendances
extract_task >> transform_task >> load_task
```

### ScÃ©nario 3 : Migration Temporal Tables

**Contexte** :
- SQL Server 2016+ avec Temporal Tables (system-versioned)
- Besoin de conserver l'historique complet
- Migration vers MariaDB 11.8 avec System-Versioned Tables

```sql
-- SQL Server : Temporal Table
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name NVARCHAR(100),
    salary DECIMAL(18,2),
    department_id INT,
    valid_from DATETIME2 GENERATED ALWAYS AS ROW START,
    valid_to DATETIME2 GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME (valid_from, valid_to)
) WITH (SYSTEM_VERSIONING = ON (HISTORY_TABLE = dbo.employees_history));

-- MariaDB 11.8 : System-Versioned Table
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    salary DECIMAL(18,2),
    department_id INT,
    valid_from TIMESTAMP(6) GENERATED ALWAYS AS ROW START INVISIBLE,
    valid_to TIMESTAMP(6) GENERATED ALWAYS AS ROW END INVISIBLE,
    PERIOD FOR SYSTEM_TIME (valid_from, valid_to)
) WITH SYSTEM VERSIONING;

-- Migration des donnÃ©es avec historique
-- 1. Exporter table principale SQL Server
-- 2. Exporter table historique SQL Server
-- 3. CrÃ©er table MariaDB SANS system versioning
-- 4. Importer donnÃ©es actuelles
-- 5. Importer historique
-- 6. Activer system versioning

-- Ã‰tape 3 : CrÃ©er sans versioning
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    salary DECIMAL(18,2),
    department_id INT,
    valid_from TIMESTAMP(6),
    valid_to TIMESTAMP(6)
);

-- Ã‰tape 4-5 : Import (donnÃ©es actuelles puis historique)
LOAD DATA LOCAL INFILE 'employees_current.csv' INTO TABLE employees;
LOAD DATA LOCAL INFILE 'employees_history.csv' INTO TABLE employees;

-- Ã‰tape 6 : Activer versioning
ALTER TABLE employees 
    MODIFY valid_from TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    MODIFY valid_to TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    ADD PERIOD FOR SYSTEM_TIME (valid_from, valid_to),
    ADD SYSTEM VERSIONING;
```

ğŸ†• **MariaDB 11.8** : Changement de format timestamp pour System-Versioned Tables

```sql
-- Attention lors de migration depuis MariaDB < 11.8
-- Le format interne des timestamps a changÃ©

-- VÃ©rifier la version de la table
SELECT TABLE_NAME, ROW_FORMAT, CREATE_OPTIONS
FROM information_schema.TABLES
WHERE TABLE_NAME = 'employees';

-- Si migration depuis ancienne version, recrÃ©er peut Ãªtre nÃ©cessaire
-- pour bÃ©nÃ©ficier du nouveau format
```

---

## Checklist de migration SQL Server â†’ MariaDB

### PrÃ©-migration

- [ ] Inventaire complet des objets (tables, vues, procÃ©dures, fonctions, triggers)
- [ ] Identification des fonctionnalitÃ©s SQL Server spÃ©cifiques (SSIS, SSRS, Linked Servers)
- [ ] Analyse avec SSMA ou scripts personnalisÃ©s
- [ ] Mapping des types de donnÃ©es
- [ ] Estimation de l'effort de conversion T-SQL
- [ ] POC sur module reprÃ©sentatif
- [ ] Plan de test de rÃ©gression

### Conversion

- [ ] GÃ©nÃ©ration DDL MariaDB
- [ ] Conversion IDENTITY â†’ AUTO_INCREMENT
- [ ] Adaptation des collations
- [ ] RÃ©Ã©criture des procÃ©dures stockÃ©es
- [ ] Conversion des fonctions (attention TVF)
- [ ] Adaptation des triggers (row-based)
- [ ] Remplacement MERGE â†’ INSERT...ON DUPLICATE
- [ ] Tests unitaires de chaque objet converti

### Migration des donnÃ©es

- [ ] Export BCP ou SSMA
- [ ] Transformation des formats (dates, GUID, XML)
- [ ] Import LOAD DATA ou DMS
- [ ] VÃ©rification des volumes
- [ ] Validation des checksums
- [ ] Test des contraintes FK

### Post-migration

- [ ] Tests de rÃ©gression applicatifs
- [ ] Tests de performance
- [ ] Optimisation des index
- [ ] Configuration tuning MariaDB
- [ ] Documentation des diffÃ©rences
- [ ] Formation des Ã©quipes

---

## âœ… Points clÃ©s Ã  retenir

- **TINYINT attention** : SQL Server TINYINT = 0-255, MariaDB TINYINT = -128 Ã  127, utilisez `TINYINT UNSIGNED`

- **SchÃ©mas â†’ Databases** : Les schÃ©mas SQL Server se mappent gÃ©nÃ©ralement vers des databases MariaDB sÃ©parÃ©es

- **TVF non supportÃ©es** : Les Table-Valued Functions nÃ©cessitent une rÃ©Ã©criture en procÃ©dures ou vues

- **Triggers row-based** : MariaDB exÃ©cute les triggers pour chaque ligne, pas en mode set-based comme SQL Server

- **MERGE inexistant** : Utilisez `INSERT...ON DUPLICATE KEY UPDATE` ou une procÃ©dure dÃ©diÃ©e

- **TRY/CATCH â†’ HANDLER** : La gestion d'erreurs utilise `DECLARE HANDLER` et `SIGNAL`

- **SSIS remplacement** : Apache Airflow, Talend, ou Apache NiFi sont des alternatives open-source

- **Temporal Tables** : MariaDB System-Versioned Tables offrent une fonctionnalitÃ© Ã©quivalente

---

## ğŸ”— Ressources et rÃ©fÃ©rences

- [ğŸ“– SSMA for MySQL Download](https://www.microsoft.com/en-us/download/details.aspx?id=54257)
- [ğŸ“– MariaDB vs SQL Server Feature Comparison](https://mariadb.com/kb/en/mariadb-vs-sql-server/)
- [ğŸ“– Pomelo Entity Framework Core Provider](https://github.com/PomeloFoundation/Pomelo.EntityFrameworkCore.MySql)
- [ğŸ“– AWS DMS SQL Server Source](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.SQLServer.html)
- [ğŸ“– MariaDB System-Versioned Tables](https://mariadb.com/kb/en/system-versioned-tables/)
- [ğŸ“– BCP Utility Documentation](https://docs.microsoft.com/en-us/sql/tools/bcp-utility)

---

## â¡ï¸ Section suivante

**[19.2.3 Migration depuis PostgreSQL](./02.3-depuis-postgresql.md)** : StratÃ©gies et outils pour migrer de PostgreSQL vers MariaDB, gestion des types spÃ©cifiques (JSONB, ARRAY), conversion des fonctions PL/pgSQL et cas d'usage hybrides.

â­ï¸ [Depuis PostgreSQL](/19-migration-compatibilite/02.3-depuis-postgresql.md)
