ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 19.2.3 Migration depuis PostgreSQL

> **Niveau** : AvancÃ© Ã  Expert  
> **DurÃ©e estimÃ©e** : 6-7 heures  
> **PrÃ©requis** : Connaissance de PostgreSQL (architecture, PL/pgSQL, types avancÃ©s), expÃ©rience MariaDB, comprÃ©hension des modÃ¨les de donnÃ©es relationnels

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Ã‰valuer la complexitÃ© d'une migration PostgreSQL â†’ MariaDB
- Convertir les types de donnÃ©es PostgreSQL spÃ©cifiques (JSONB, ARRAY, hstore)
- Adapter le code PL/pgSQL vers MariaDB SQL
- Utiliser pgloader pour des migrations automatisÃ©es
- GÃ©rer les extensions PostgreSQL sans Ã©quivalent direct
- Planifier des migrations hybrides ou progressives

---

## Introduction

La migration de PostgreSQL vers MariaDB peut sembler contre-intuitive : les deux sont des SGBD open-source matures et performants. Cependant, plusieurs contextes justifient cette migration :

- **Consolidation** : Standardiser sur MariaDB dans un environnement multi-SGBD
- **Ã‰cosystÃ¨me** : IntÃ©gration avec des applications optimisÃ©es pour MySQL/MariaDB
- **CompÃ©tences** : Ã‰quipes plus expÃ©rimentÃ©es sur MySQL/MariaDB
- **FonctionnalitÃ©s spÃ©cifiques** : Galera Cluster, ColumnStore, ou ğŸ†• VECTOR (11.8)
- **Performance** : Certains workloads OLTP peuvent bÃ©nÃ©ficier de MariaDB

PostgreSQL et MariaDB partagent des fondamentaux SQL mais divergent significativement sur les types avancÃ©s, les extensions et le langage procÃ©dural.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              MATRICE DE COMPLEXITÃ‰ MIGRATION POSTGRESQL             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  Composant                  â”‚ DifficultÃ© â”‚ StratÃ©gie                â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  Tables simples             â”‚ â˜…â˜†â˜†â˜†â˜†     â”‚ Conversion directe        â”‚
â”‚  Types standards            â”‚ â˜…â˜†â˜†â˜†â˜†     â”‚ Mapping trivial           â”‚
â”‚  Index B-tree               â”‚ â˜…â˜†â˜†â˜†â˜†     â”‚ Ã‰quivalent direct         â”‚
â”‚  SÃ©quences                  â”‚ â˜…â˜†â˜†â˜†â˜†     â”‚ Syntaxe similaire         â”‚
â”‚  Vues simples               â”‚ â˜…â˜†â˜†â˜†â˜†     â”‚ Quasi-identique           â”‚
â”‚  Constraints                â”‚ â˜…â˜†â˜†â˜†â˜†     â”‚ Syntaxe proche            â”‚
â”‚  JSON/JSONB                 â”‚ â˜…â˜…â˜…â˜†â˜†     â”‚ JSON MariaDB (limitÃ©)     â”‚
â”‚  ARRAY                      â”‚ â˜…â˜…â˜…â˜…â˜†     â”‚ JSON ou normalisation     â”‚
â”‚  hstore                     â”‚ â˜…â˜…â˜…â˜†â˜†     â”‚ JSON                      â”‚
â”‚  ENUM                       â”‚ â˜…â˜…â˜†â˜†â˜†     â”‚ ENUM MariaDB              â”‚
â”‚  Composite Types            â”‚ â˜…â˜…â˜…â˜…â˜†     â”‚ JSON ou tables            â”‚
â”‚  Range Types                â”‚ â˜…â˜…â˜…â˜…â˜†     â”‚ Deux colonnes             â”‚
â”‚  Fonctions PL/pgSQL         â”‚ â˜…â˜…â˜…â˜†â˜†     â”‚ RÃ©Ã©criture SQL/MariaDB    â”‚
â”‚  Triggers                   â”‚ â˜…â˜…â˜…â˜†â˜†     â”‚ Adaptation syntaxe        â”‚
â”‚  Index GIN/GiST             â”‚ â˜…â˜…â˜…â˜…â˜†     â”‚ FULLTEXT ou virtual col   â”‚
â”‚  Full-Text Search           â”‚ â˜…â˜…â˜…â˜†â˜†     â”‚ FULLTEXT MariaDB          â”‚
â”‚  Partitionnement            â”‚ â˜…â˜…â˜†â˜†â˜†     â”‚ Syntaxe diffÃ©rente        â”‚
â”‚  Foreign Data Wrappers      â”‚ â˜…â˜…â˜…â˜…â˜…     â”‚ CONNECT engine            â”‚
â”‚  Extensions (PostGIS, etc.) â”‚ â˜…â˜…â˜…â˜…â˜…     â”‚ Cas par cas               â”‚
â”‚  Materialized Views         â”‚ â˜…â˜…â˜…â˜†â˜†     â”‚ Tables + events           â”‚
â”‚  CTEs rÃ©cursives            â”‚ â˜…â˜…â˜†â˜†â˜†     â”‚ Support natif MariaDB     â”‚
â”‚  Window Functions           â”‚ â˜…â˜†â˜†â˜†â˜†     â”‚ Support complet           â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## DiffÃ©rences architecturales

### ModÃ¨le de stockage et processus

```
PostgreSQL                          MariaDB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   PostgreSQL Cluster    â”‚        â”‚    MariaDB Instance     â”‚
â”‚   (data directory)      â”‚        â”‚    (mysqld process)     â”‚
â”‚                         â”‚        â”‚                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚    postmaster     â”‚  â”‚        â”‚  â”‚      mysqld       â”‚  â”‚
â”‚  â”‚  (main process)   â”‚  â”‚        â”‚  â”‚  (single process) â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚        â”‚  â”‚                   â”‚  â”‚
â”‚            â”‚            â”‚        â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚        â”‚  â”‚  â”‚Thread Pool  â”‚  â”‚  â”‚
â”‚  â”‚ Backend processes â”‚  â”‚        â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚ (1 per connection)â”‚  â”‚        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚        â”‚                         â”‚
â”‚                         â”‚        â”‚                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚    Databases      â”‚  â”‚        â”‚  â”‚    Databases      â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚        â”‚  â”‚  (schemas)        â”‚  â”‚
â”‚  â”‚  â”‚ postgres    â”‚  â”‚  â”‚        â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚ template0/1 â”‚  â”‚  â”‚        â”‚  â”‚  â”‚ mysql       â”‚  â”‚  â”‚
â”‚  â”‚  â”‚ mydb        â”‚â”€â”€â”¼â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”¼â”€â–¶â”‚ mydb        â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€ schemas â”‚  â”‚  â”‚        â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚        â”‚                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Ã‰quivalences :
â€¢ PostgreSQL Cluster  â†’ MariaDB Instance (data directory)
â€¢ PostgreSQL Database â†’ MariaDB Database
â€¢ PostgreSQL Schema   â†’ MariaDB Database (gÃ©nÃ©ralement)
â€¢ PostgreSQL Role     â†’ MariaDB User
â€¢ PostgreSQL Tablespace â†’ (pas d'Ã©quivalent, file-per-table InnoDB)
```

### SchÃ©mas et namespaces

```sql
-- PostgreSQL : SchÃ©mas multiples dans une database
CREATE DATABASE myapp;
\c myapp

CREATE SCHEMA core;
CREATE SCHEMA reporting;

CREATE TABLE core.users (...);
CREATE TABLE core.orders (...);
CREATE TABLE reporting.daily_stats (...);

-- Recherche cross-schema
SELECT u.*, o.*
FROM core.users u
JOIN core.orders o ON u.id = o.user_id;

-- MariaDB : Options de migration

-- Option 1 : Une database par schema (recommandÃ©)
CREATE DATABASE myapp_core;
CREATE DATABASE myapp_reporting;

CREATE TABLE myapp_core.users (...);
CREATE TABLE myapp_core.orders (...);
CREATE TABLE myapp_reporting.daily_stats (...);

-- Cross-database queries supportÃ©es
SELECT u.*, o.*
FROM myapp_core.users u
JOIN myapp_core.orders o ON u.id = o.user_id;

-- Option 2 : Tout dans une database (si schÃ©mas peu utilisÃ©s)
CREATE DATABASE myapp;
USE myapp;

CREATE TABLE users (...);
CREATE TABLE orders (...);
CREATE TABLE daily_stats (...);
```

### MVCC et isolation

```sql
-- PostgreSQL : MVCC avec VACUUM
-- READ COMMITTED par dÃ©faut
-- Utilise les xmin/xmax pour versioning

-- VÃ©rifier les dead tuples
SELECT relname, n_dead_tup, n_live_tup, 
       round(n_dead_tup::numeric / nullif(n_live_tup, 0) * 100, 2) as dead_ratio
FROM pg_stat_user_tables
ORDER BY n_dead_tup DESC;

-- MariaDB InnoDB : MVCC avec undo logs
-- REPEATABLE READ par dÃ©faut (plus strict que PostgreSQL)

-- Pour comportement PostgreSQL-like
SET GLOBAL transaction_isolation = 'READ-COMMITTED';

-- PostgreSQL : Niveaux d'isolation
-- READ UNCOMMITTED (traitÃ© comme READ COMMITTED)
-- READ COMMITTED (dÃ©faut)
-- REPEATABLE READ
-- SERIALIZABLE (vrai serializable avec SSI)

-- MariaDB : Niveaux d'isolation
-- READ UNCOMMITTED
-- READ COMMITTED
-- REPEATABLE READ (dÃ©faut)
-- SERIALIZABLE

-- PostgreSQL SERIALIZABLE est plus strict que MariaDB SERIALIZABLE
-- PostgreSQL utilise Serializable Snapshot Isolation (SSI)
-- MariaDB utilise des locks
```

---

## Mapping des types de donnÃ©es

### Types numÃ©riques

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              TYPES NUMÃ‰RIQUES POSTGRESQL â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Entiers
-- PostgreSQL          MariaDB              Notes
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- SMALLINT            SMALLINT             -32768 Ã  32767
-- INTEGER / INT       INT                  Â±2.1 milliards
-- BIGINT              BIGINT               Â±9.2 quintillions
-- SERIAL              INT AUTO_INCREMENT   SÃ©quence auto
-- BIGSERIAL           BIGINT AUTO_INCREMENT
-- SMALLSERIAL         SMALLINT AUTO_INCREMENT

-- PostgreSQL
CREATE TABLE pg_integers (
    id SERIAL PRIMARY KEY,
    small_val SMALLINT,
    int_val INTEGER,
    big_val BIGINT
);

-- MariaDB
CREATE TABLE maria_integers (
    id INT AUTO_INCREMENT PRIMARY KEY,
    small_val SMALLINT,
    int_val INT,
    big_val BIGINT
);

-- DÃ©cimaux
-- PostgreSQL          MariaDB              Notes
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- DECIMAL(p,s)        DECIMAL(p,s)         Identique
-- NUMERIC(p,s)        DECIMAL(p,s)         Alias
-- REAL                FLOAT                4 bytes
-- DOUBLE PRECISION    DOUBLE               8 bytes
-- FLOAT(p)            FLOAT/DOUBLE         Selon prÃ©cision

-- PostgreSQL
CREATE TABLE pg_decimals (
    price DECIMAL(10,2),
    rate NUMERIC(5,4),
    approx_real REAL,
    approx_double DOUBLE PRECISION
);

-- MariaDB
CREATE TABLE maria_decimals (
    price DECIMAL(10,2),
    rate DECIMAL(5,4),
    approx_real FLOAT,
    approx_double DOUBLE
);

-- MONEY PostgreSQL â†’ DECIMAL
-- PostgreSQL : MONEY avec formatage locale
CREATE TABLE pg_money (amount MONEY);
-- MariaDB : DECIMAL explicite
CREATE TABLE maria_money (amount DECIMAL(19,4));
```

### Types caractÃ¨res

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              TYPES CARACTÃˆRES POSTGRESQL â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Correspondances directes
-- PostgreSQL          MariaDB              Notes
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- CHAR(n)             CHAR(n)              Taille fixe
-- VARCHAR(n)          VARCHAR(n)           Variable
-- VARCHAR             LONGTEXT             Sans limite = TEXT
-- TEXT                LONGTEXT             IllimitÃ©
-- CHAR                CHAR(1)              Un caractÃ¨re

-- PostgreSQL
CREATE TABLE pg_strings (
    code CHAR(10),
    name VARCHAR(100),
    unlimited_name VARCHAR,  -- Pas de limite !
    description TEXT
);

-- MariaDB
CREATE TABLE maria_strings (
    code CHAR(10),
    name VARCHAR(100),
    unlimited_name LONGTEXT,  -- VARCHAR sans limite â†’ LONGTEXT
    description LONGTEXT
);

-- Collation
-- PostgreSQL utilise les collations systÃ¨me (ICU ou libc)
-- MariaDB utilise ses propres collations

-- PostgreSQL
CREATE TABLE pg_collation (
    name VARCHAR(100) COLLATE "en_US.utf8"
);

-- MariaDB
CREATE TABLE maria_collation (
    name VARCHAR(100) COLLATE utf8mb4_unicode_ci
);

-- Mapping collations courantes
-- PostgreSQL             MariaDB
-- "C" / "POSIX"         utf8mb4_bin (binaire)
-- "en_US.utf8"          utf8mb4_unicode_ci
-- "fr_FR.utf8"          utf8mb4_unicode_ci
```

### Types date et heure

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              TYPES DATE/HEURE POSTGRESQL â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- PostgreSQL          MariaDB              Notes
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- DATE                DATE                 Identique
-- TIME                TIME(6)              Sans timezone
-- TIME WITH TZ        TIME(6) + colonne    Pas de TZ natif
-- TIMESTAMP           DATETIME(6)          Sans timezone
-- TIMESTAMPTZ         DATETIME(6) ou       Avec timezone
--                     TIMESTAMP            (converti UTC)
-- INTERVAL            VARCHAR ou INT       Pas de type natif

-- PostgreSQL
CREATE TABLE pg_dates (
    birth_date DATE,
    event_time TIME,
    event_time_tz TIME WITH TIME ZONE,
    created_at TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE,
    duration INTERVAL
);

-- MariaDB
CREATE TABLE maria_dates (
    birth_date DATE,
    event_time TIME(6),
    event_time_tz TIME(6),           -- TZ perdu ou colonne sÃ©parÃ©e
    event_tz_name VARCHAR(50),        -- Stocker timezone si besoin
    created_at DATETIME(6),
    updated_at TIMESTAMP(6),          -- Conversion auto UTC
    duration_seconds BIGINT           -- Ou VARCHAR pour lisibilitÃ©
);

-- Gestion TIMESTAMPTZ
-- PostgreSQL stocke en UTC, affiche selon session timezone
-- MariaDB TIMESTAMP fait pareil

-- PostgreSQL
SET timezone = 'Europe/Paris';
INSERT INTO events (event_time) VALUES ('2025-06-15 14:30:00+02');
-- StockÃ© en UTC : 2025-06-15 12:30:00

-- MariaDB
SET time_zone = 'Europe/Paris';
INSERT INTO events (event_time) VALUES ('2025-06-15 14:30:00');
-- Si colonne TIMESTAMP : converti et stockÃ© en UTC

-- INTERVAL conversion
-- PostgreSQL
SELECT NOW() + INTERVAL '1 year 2 months 3 days';
SELECT age('2025-01-01', '1990-05-15');

-- MariaDB : Pas d'INTERVAL composÃ©
SELECT DATE_ADD(NOW(), INTERVAL 1 YEAR);
SELECT DATE_ADD(DATE_ADD(NOW(), INTERVAL 1 YEAR), INTERVAL 2 MONTH);
SELECT TIMESTAMPDIFF(YEAR, '1990-05-15', '2025-01-01');

-- Pour stocker des durÃ©es complexes, utiliser :
-- Option 1 : Secondes/minutes totales (INT/BIGINT)
-- Option 2 : Colonnes sÃ©parÃ©es (years, months, days, ...)
-- Option 3 : Format ISO 8601 en VARCHAR ('P1Y2M3D')
```

### Types binaires

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              TYPES BINAIRES POSTGRESQL â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- PostgreSQL          MariaDB              Notes
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- BYTEA               LONGBLOB             DonnÃ©es binaires
-- BIT(n)              BIT(n)               Bits fixes
-- BIT VARYING(n)      VARBINARY(n)         Bits variables

-- PostgreSQL
CREATE TABLE pg_binary (
    file_content BYTEA,
    flags BIT(8),
    var_flags BIT VARYING(64)
);

-- MariaDB
CREATE TABLE maria_binary (
    file_content LONGBLOB,
    flags BIT(8),
    var_flags VARBINARY(8)  -- 64 bits = 8 bytes
);

-- Encodage BYTEA
-- PostgreSQL : hex ou escape
-- Insertion PostgreSQL
INSERT INTO pg_binary (file_content) VALUES (E'\\xDEADBEEF');
INSERT INTO pg_binary (file_content) VALUES (decode('DEADBEEF', 'hex'));

-- MariaDB : hex
INSERT INTO maria_binary (file_content) VALUES (UNHEX('DEADBEEF'));
INSERT INTO maria_binary (file_content) VALUES (X'DEADBEEF');
```

### Types JSON

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              JSON / JSONB POSTGRESQL â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- PostgreSQL a deux types JSON :
-- JSON  : StockÃ© texte, prÃ©serve whitespace et ordre
-- JSONB : StockÃ© binaire, dÃ©composÃ©, indexable, plus performant

-- MariaDB a un type JSON :
-- JSON  : Alias pour LONGTEXT avec validation
--         StockÃ© texte (pas binaire comme JSONB)
--         Fonctions JSON disponibles
--         Pas d'index GIN natif (utiliser generated columns)

-- PostgreSQL
CREATE TABLE pg_json_example (
    id SERIAL PRIMARY KEY,
    data JSON,           -- PrÃ©serve format
    attributes JSONB     -- OptimisÃ© requÃªtes
);

-- Index GIN sur JSONB
CREATE INDEX idx_attributes ON pg_json_example USING GIN (attributes);

-- RequÃªtes JSONB
SELECT * FROM pg_json_example 
WHERE attributes @> '{"status": "active"}';  -- Containment

SELECT * FROM pg_json_example 
WHERE attributes ? 'email';  -- Key exists

SELECT * FROM pg_json_example 
WHERE attributes ->> 'status' = 'active';  -- Valeur texte

-- MariaDB
CREATE TABLE maria_json_example (
    id INT AUTO_INCREMENT PRIMARY KEY,
    data JSON,
    attributes JSON,
    -- Generated column pour indexation
    attr_status VARCHAR(50) GENERATED ALWAYS AS (
        JSON_UNQUOTE(JSON_EXTRACT(attributes, '$.status'))
    ) STORED,
    INDEX idx_status (attr_status)
);

-- RequÃªtes JSON MariaDB
SELECT * FROM maria_json_example 
WHERE JSON_CONTAINS(attributes, '"active"', '$.status');

SELECT * FROM maria_json_example 
WHERE JSON_EXISTS(attributes, '$.email');

SELECT * FROM maria_json_example 
WHERE JSON_VALUE(attributes, '$.status') = 'active';

-- OU via generated column (plus performant)
SELECT * FROM maria_json_example 
WHERE attr_status = 'active';

-- Comparaison des opÃ©rateurs
-- PostgreSQL              MariaDB
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- -> (get JSON)          JSON_EXTRACT() ou ->
-- ->> (get text)         JSON_UNQUOTE(JSON_EXTRACT()) ou ->>
-- #> (path JSON)         JSON_EXTRACT() avec path
-- #>> (path text)        JSON_VALUE()
-- @> (contains)          JSON_CONTAINS()
-- ? (key exists)         JSON_EXISTS() ou JSON_CONTAINS_PATH()
-- ?| (any key)           JSON_CONTAINS_PATH(..., 'one', ...)
-- ?& (all keys)          JSON_CONTAINS_PATH(..., 'all', ...)
-- || (concat)            JSON_MERGE_PATCH() ou JSON_MERGE_PRESERVE()
-- - (delete key)         JSON_REMOVE()
-- jsonb_set()            JSON_SET() / JSON_REPLACE() / JSON_INSERT()
```

### Types ARRAY

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              ARRAY POSTGRESQL â†’ MARIADB (JSON ou normalisation)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- PostgreSQL supporte les arrays natifs
-- MariaDB n'a pas de type ARRAY natif
-- Solutions : JSON ou tables de jointure

-- PostgreSQL
CREATE TABLE pg_tags (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    tags TEXT[],                    -- Array de textes
    scores INTEGER[]                -- Array d'entiers
);

INSERT INTO pg_tags (name, tags, scores) 
VALUES ('Article 1', ARRAY['tech', 'database', 'postgresql'], ARRAY[10, 20, 30]);

-- RequÃªtes array
SELECT * FROM pg_tags WHERE 'tech' = ANY(tags);
SELECT * FROM pg_tags WHERE tags @> ARRAY['tech', 'database'];
SELECT unnest(tags) FROM pg_tags WHERE id = 1;

-- MariaDB Option 1 : JSON Array (simple, moins performant)
CREATE TABLE maria_tags_json (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100),
    tags JSON,
    scores JSON
);

INSERT INTO maria_tags_json (name, tags, scores)
VALUES ('Article 1', '["tech", "database", "mariadb"]', '[10, 20, 30]');

-- RequÃªtes
SELECT * FROM maria_tags_json 
WHERE JSON_CONTAINS(tags, '"tech"');

SELECT * FROM maria_tags_json 
WHERE JSON_CONTAINS(tags, '["tech", "database"]');

-- Unnest Ã©quivalent avec JSON_TABLE
SELECT t.id, t.name, j.tag
FROM maria_tags_json t,
     JSON_TABLE(t.tags, '$[*]' COLUMNS (tag VARCHAR(100) PATH '$')) j;

-- MariaDB Option 2 : Table de jointure (plus performant, normalisÃ©)
CREATE TABLE maria_articles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE maria_article_tags (
    article_id INT,
    tag VARCHAR(100),
    PRIMARY KEY (article_id, tag),
    FOREIGN KEY (article_id) REFERENCES maria_articles(id)
);

CREATE TABLE maria_article_scores (
    article_id INT,
    position INT,
    score INT,
    PRIMARY KEY (article_id, position),
    FOREIGN KEY (article_id) REFERENCES maria_articles(id)
);

-- Insertion
INSERT INTO maria_articles (id, name) VALUES (1, 'Article 1');
INSERT INTO maria_article_tags VALUES (1, 'tech'), (1, 'database'), (1, 'mariadb');
INSERT INTO maria_article_scores VALUES (1, 0, 10), (1, 1, 20), (1, 2, 30);

-- RequÃªtes
SELECT a.* FROM maria_articles a
JOIN maria_article_tags t ON a.id = t.article_id
WHERE t.tag = 'tech';

-- AgrÃ©gation pour reconstituer l'array
SELECT a.id, a.name, GROUP_CONCAT(t.tag ORDER BY t.tag) as tags
FROM maria_articles a
JOIN maria_article_tags t ON a.id = t.article_id
GROUP BY a.id, a.name;
```

### Types spÃ©ciaux PostgreSQL

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              TYPES SPÃ‰CIAUX POSTGRESQL â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- UUID
-- PostgreSQL
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE TABLE pg_uuids (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    name VARCHAR(100)
);

-- MariaDB (10.7+)
CREATE TABLE maria_uuids (
    id UUID DEFAULT UUID() PRIMARY KEY,
    name VARCHAR(100)
);
-- Ou CHAR(36) pour compatibilitÃ© antÃ©rieure
CREATE TABLE maria_uuids_char (
    id CHAR(36) DEFAULT (UUID()) PRIMARY KEY,
    name VARCHAR(100)
);

-- ENUM
-- PostgreSQL
CREATE TYPE status_enum AS ENUM ('pending', 'active', 'completed', 'cancelled');
CREATE TABLE pg_orders (
    id SERIAL PRIMARY KEY,
    status status_enum DEFAULT 'pending'
);

-- MariaDB : ENUM inline (pas de type rÃ©utilisable)
CREATE TABLE maria_orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    status ENUM('pending', 'active', 'completed', 'cancelled') DEFAULT 'pending'
);

-- hstore (key-value)
-- PostgreSQL
CREATE EXTENSION IF NOT EXISTS hstore;
CREATE TABLE pg_metadata (
    id SERIAL PRIMARY KEY,
    attributes hstore
);
INSERT INTO pg_metadata (attributes) 
VALUES ('color => "red", size => "large"');
SELECT attributes -> 'color' FROM pg_metadata;

-- MariaDB : JSON
CREATE TABLE maria_metadata (
    id INT AUTO_INCREMENT PRIMARY KEY,
    attributes JSON
);
INSERT INTO maria_metadata (attributes) 
VALUES ('{"color": "red", "size": "large"}');
SELECT JSON_VALUE(attributes, '$.color') FROM maria_metadata;

-- INET / CIDR (adresses IP)
-- PostgreSQL
CREATE TABLE pg_network (
    id SERIAL PRIMARY KEY,
    ip_address INET,
    network CIDR
);
INSERT INTO pg_network VALUES (1, '192.168.1.100', '192.168.0.0/16');
SELECT * FROM pg_network WHERE ip_address << '192.168.0.0/16';

-- MariaDB : VARCHAR ou INET6 pour IPv6
CREATE TABLE maria_network (
    id INT AUTO_INCREMENT PRIMARY KEY,
    ip_address VARCHAR(45),      -- Assez pour IPv6
    network VARCHAR(45),
    -- Colonnes pour requÃªtes de range
    ip_numeric BIGINT UNSIGNED GENERATED ALWAYS AS (
        INET_ATON(ip_address)
    ) STORED
);
-- Ou utiliser INET6 (MariaDB 10.5+) pour stockage efficace
CREATE TABLE maria_network_v6 (
    id INT AUTO_INCREMENT PRIMARY KEY,
    ip_address INET6
);

-- Range Types
-- PostgreSQL
CREATE TABLE pg_events (
    id SERIAL PRIMARY KEY,
    event_name VARCHAR(100),
    during TSTZRANGE  -- Range de timestamps
);
INSERT INTO pg_events VALUES (1, 'Conference', '[2025-06-01, 2025-06-05)');
SELECT * FROM pg_events WHERE during @> '2025-06-03'::timestamptz;

-- MariaDB : Deux colonnes
CREATE TABLE maria_events (
    id INT AUTO_INCREMENT PRIMARY KEY,
    event_name VARCHAR(100),
    start_at DATETIME,
    end_at DATETIME,
    INDEX idx_dates (start_at, end_at)
);
INSERT INTO maria_events VALUES (1, 'Conference', '2025-06-01', '2025-06-05');
SELECT * FROM maria_events 
WHERE '2025-06-03' >= start_at AND '2025-06-03' < end_at;

-- Composite Types
-- PostgreSQL
CREATE TYPE address AS (
    street VARCHAR(200),
    city VARCHAR(100),
    zip VARCHAR(20),
    country VARCHAR(50)
);
CREATE TABLE pg_customers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    home_address address,
    work_address address
);

-- MariaDB Option 1 : JSON
CREATE TABLE maria_customers_json (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100),
    home_address JSON,
    work_address JSON
);

-- MariaDB Option 2 : Colonnes multiples (prÃ©fÃ©rÃ© pour requÃªtes)
CREATE TABLE maria_customers_flat (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100),
    home_street VARCHAR(200),
    home_city VARCHAR(100),
    home_zip VARCHAR(20),
    home_country VARCHAR(50),
    work_street VARCHAR(200),
    work_city VARCHAR(100),
    work_zip VARCHAR(20),
    work_country VARCHAR(50)
);

-- MariaDB Option 3 : Table sÃ©parÃ©e
CREATE TABLE maria_addresses (
    id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT,
    address_type ENUM('home', 'work'),
    street VARCHAR(200),
    city VARCHAR(100),
    zip VARCHAR(20),
    country VARCHAR(50),
    FOREIGN KEY (customer_id) REFERENCES maria_customers(id)
);

-- TSVECTOR (Full-Text)
-- PostgreSQL
CREATE TABLE pg_articles (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200),
    content TEXT,
    search_vector TSVECTOR GENERATED ALWAYS AS (
        to_tsvector('english', coalesce(title,'') || ' ' || coalesce(content,''))
    ) STORED
);
CREATE INDEX idx_search ON pg_articles USING GIN (search_vector);
SELECT * FROM pg_articles WHERE search_vector @@ to_tsquery('database & postgresql');

-- MariaDB : FULLTEXT index
CREATE TABLE maria_articles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(200),
    content TEXT,
    FULLTEXT INDEX idx_search (title, content)
) ENGINE=InnoDB;
SELECT * FROM maria_articles 
WHERE MATCH(title, content) AGAINST('+database +mariadb' IN BOOLEAN MODE);
```

### Table de mapping complÃ¨te

```sql
-- Script de gÃ©nÃ©ration des mappings PostgreSQL â†’ MariaDB
-- Ã€ exÃ©cuter sur PostgreSQL

SELECT 
    c.table_schema,
    c.table_name,
    c.column_name,
    c.data_type,
    c.character_maximum_length,
    c.numeric_precision,
    c.numeric_scale,
    c.is_nullable,
    c.column_default,
    CASE 
        -- Entiers
        WHEN c.data_type = 'smallint' THEN 'SMALLINT'
        WHEN c.data_type = 'integer' THEN 'INT'
        WHEN c.data_type = 'bigint' THEN 'BIGINT'
        
        -- DÃ©cimaux
        WHEN c.data_type IN ('decimal', 'numeric') 
            THEN 'DECIMAL(' || c.numeric_precision || ',' || c.numeric_scale || ')'
        WHEN c.data_type = 'real' THEN 'FLOAT'
        WHEN c.data_type = 'double precision' THEN 'DOUBLE'
        WHEN c.data_type = 'money' THEN 'DECIMAL(19,4)'
        
        -- CaractÃ¨res
        WHEN c.data_type = 'character' 
            THEN 'CHAR(' || coalesce(c.character_maximum_length::text, '1') || ')'
        WHEN c.data_type = 'character varying' AND c.character_maximum_length IS NOT NULL
            THEN 'VARCHAR(' || c.character_maximum_length || ')'
        WHEN c.data_type = 'character varying' THEN 'LONGTEXT'
        WHEN c.data_type = 'text' THEN 'LONGTEXT'
        
        -- Date/Heure
        WHEN c.data_type = 'date' THEN 'DATE'
        WHEN c.data_type = 'time without time zone' THEN 'TIME(6)'
        WHEN c.data_type = 'time with time zone' THEN 'TIME(6) /* + tz column */'
        WHEN c.data_type = 'timestamp without time zone' THEN 'DATETIME(6)'
        WHEN c.data_type = 'timestamp with time zone' THEN 'DATETIME(6) /* ou TIMESTAMP */'
        WHEN c.data_type = 'interval' THEN 'VARCHAR(100) /* ou BIGINT */'
        
        -- Binaires
        WHEN c.data_type = 'bytea' THEN 'LONGBLOB'
        WHEN c.data_type = 'bit' THEN 'BIT(' || c.character_maximum_length || ')'
        WHEN c.data_type = 'bit varying' THEN 'VARBINARY(' || 
            ceil(c.character_maximum_length::numeric / 8) || ')'
        
        -- JSON
        WHEN c.data_type IN ('json', 'jsonb') THEN 'JSON'
        
        -- Autres
        WHEN c.data_type = 'uuid' THEN 'UUID /* ou CHAR(36) */'
        WHEN c.data_type = 'boolean' THEN 'BOOLEAN'
        WHEN c.data_type = 'inet' THEN 'VARCHAR(45) /* ou INET6 */'
        WHEN c.data_type = 'cidr' THEN 'VARCHAR(45)'
        WHEN c.data_type = 'macaddr' THEN 'CHAR(17)'
        WHEN c.data_type = 'xml' THEN 'LONGTEXT'
        WHEN c.data_type = 'USER-DEFINED' THEN 'JSON /* type custom: ' || c.udt_name || ' */'
        WHEN c.data_type = 'ARRAY' THEN 'JSON /* array: ' || c.udt_name || ' */'
        
        ELSE '/* UNKNOWN: ' || c.data_type || ' */'
    END AS mariadb_type
FROM information_schema.columns c
WHERE c.table_schema NOT IN ('pg_catalog', 'information_schema')
ORDER BY c.table_schema, c.table_name, c.ordinal_position;
```

---

## Conversion du code PL/pgSQL

### DiffÃ©rences syntaxiques fondamentales

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              SYNTAXE PL/pgSQL vs MARIADB SQL/PSM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Structure de fonction
-- PostgreSQL
CREATE OR REPLACE FUNCTION calculate_total(p_order_id INTEGER)
RETURNS DECIMAL AS $$
DECLARE
    v_total DECIMAL := 0;
BEGIN
    SELECT SUM(quantity * price) INTO v_total
    FROM order_items
    WHERE order_id = p_order_id;
    
    RETURN COALESCE(v_total, 0);
END;
$$ LANGUAGE plpgsql;

-- MariaDB
DELIMITER //
CREATE FUNCTION calculate_total(p_order_id INT)
RETURNS DECIMAL(18,2)
DETERMINISTIC
BEGIN
    DECLARE v_total DECIMAL(18,2) DEFAULT 0;
    
    SELECT COALESCE(SUM(quantity * price), 0) INTO v_total
    FROM order_items
    WHERE order_id = p_order_id;
    
    RETURN v_total;
END //
DELIMITER ;

-- Variables et assignation
-- PostgreSQL
DECLARE
    v_name VARCHAR(100) := 'default';
    v_count INTEGER DEFAULT 0;
BEGIN
    v_name := 'new value';
    v_count := v_count + 1;
END;

-- MariaDB
BEGIN
    DECLARE v_name VARCHAR(100) DEFAULT 'default';
    DECLARE v_count INT DEFAULT 0;
    
    SET v_name = 'new value';
    SET v_count = v_count + 1;
END;

-- Conditions
-- PostgreSQL
IF v_status = 'active' THEN
    -- action
ELSIF v_status = 'pending' THEN
    -- action
ELSE
    -- action
END IF;

-- MariaDB (ELSEIF au lieu de ELSIF)
IF v_status = 'active' THEN
    -- action
ELSEIF v_status = 'pending' THEN
    -- action
ELSE
    -- action
END IF;

-- Boucles FOR
-- PostgreSQL
FOR i IN 1..10 LOOP
    -- action avec i
END LOOP;

FOR rec IN SELECT * FROM users LOOP
    -- action avec rec.column
END LOOP;

-- MariaDB
DECLARE i INT DEFAULT 1;
WHILE i <= 10 DO
    -- action avec i
    SET i = i + 1;
END WHILE;

-- Ou avec curseur pour SELECT
DECLARE done INT DEFAULT FALSE;
DECLARE v_id INT;
DECLARE v_name VARCHAR(100);
DECLARE cur CURSOR FOR SELECT id, name FROM users;
DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

OPEN cur;
read_loop: LOOP
    FETCH cur INTO v_id, v_name;
    IF done THEN LEAVE read_loop; END IF;
    -- action
END LOOP;
CLOSE cur;

-- FOREACH (array) - PostgreSQL only
-- PostgreSQL
FOREACH item IN ARRAY items_array LOOP
    -- action
END LOOP;

-- MariaDB : pas d'array, utiliser JSON_TABLE ou table temporaire

-- RETURN QUERY
-- PostgreSQL
CREATE FUNCTION get_active_users()
RETURNS TABLE(id INTEGER, name VARCHAR) AS $$
BEGIN
    RETURN QUERY
    SELECT u.id, u.name FROM users u WHERE u.is_active;
END;
$$ LANGUAGE plpgsql;

-- MariaDB : procÃ©dure avec SELECT ou table temporaire
DELIMITER //
CREATE PROCEDURE get_active_users()
BEGIN
    SELECT id, name FROM users WHERE is_active = TRUE;
END //
DELIMITER ;

-- Ou avec OUT parameters et table temporaire pour rÃ©sultat tabulaire
```

### Gestion des erreurs

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              EXCEPTION HANDLING PL/pgSQL â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- PostgreSQL
CREATE OR REPLACE FUNCTION safe_divide(a NUMERIC, b NUMERIC)
RETURNS NUMERIC AS $$
BEGIN
    RETURN a / b;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'Division by zero, returning NULL';
        RETURN NULL;
    WHEN numeric_value_out_of_range THEN
        RAISE WARNING 'Numeric overflow';
        RETURN NULL;
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Unexpected error: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;

-- MariaDB
DELIMITER //
CREATE FUNCTION safe_divide(a DECIMAL(38,10), b DECIMAL(38,10))
RETURNS DECIMAL(38,10)
DETERMINISTIC
BEGIN
    DECLARE result DECIMAL(38,10);
    
    DECLARE CONTINUE HANDLER FOR 1365  -- Division by zero
    BEGIN
        RETURN NULL;
    END;
    
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        RETURN NULL;
    END;
    
    SET result = a / b;
    RETURN result;
END //
DELIMITER ;

-- Gestion d'erreurs avancÃ©e
-- PostgreSQL
CREATE OR REPLACE FUNCTION process_order(p_order_id INTEGER)
RETURNS TEXT AS $$
DECLARE
    v_customer_id INTEGER;
    v_total DECIMAL;
BEGIN
    -- DÃ©marrer une sous-transaction
    BEGIN
        SELECT customer_id, total INTO STRICT v_customer_id, v_total
        FROM orders WHERE id = p_order_id;
        
        UPDATE orders SET status = 'PROCESSING' WHERE id = p_order_id;
        
        INSERT INTO order_log (order_id, action) VALUES (p_order_id, 'PROCESSED');
        
        RETURN 'SUCCESS';
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN 'ERROR: Order not found';
        WHEN TOO_MANY_ROWS THEN
            RETURN 'ERROR: Multiple orders found';
        WHEN OTHERS THEN
            RETURN 'ERROR: ' || SQLERRM;
    END;
END;
$$ LANGUAGE plpgsql;

-- MariaDB
DELIMITER //
CREATE PROCEDURE process_order(
    IN p_order_id INT,
    OUT p_result VARCHAR(500)
)
BEGIN
    DECLARE v_customer_id INT;
    DECLARE v_total DECIMAL(18,2);
    DECLARE v_count INT;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 
            p_result = MESSAGE_TEXT;
        SET p_result = CONCAT('ERROR: ', IFNULL(p_result, 'Unknown error'));
        ROLLBACK;
    END;
    
    START TRANSACTION;
    
    -- VÃ©rifier existence
    SELECT COUNT(*) INTO v_count FROM orders WHERE id = p_order_id;
    
    IF v_count = 0 THEN
        SET p_result = 'ERROR: Order not found';
        ROLLBACK;
    ELSEIF v_count > 1 THEN
        SET p_result = 'ERROR: Multiple orders found';
        ROLLBACK;
    ELSE
        SELECT customer_id, total INTO v_customer_id, v_total
        FROM orders WHERE id = p_order_id;
        
        UPDATE orders SET status = 'PROCESSING' WHERE id = p_order_id;
        
        INSERT INTO order_log (order_id, action) VALUES (p_order_id, 'PROCESSED');
        
        COMMIT;
        SET p_result = 'SUCCESS';
    END IF;
END //
DELIMITER ;

-- Appel
CALL process_order(123, @result);
SELECT @result;
```

### Triggers

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              TRIGGERS PL/pgSQL â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- PostgreSQL : Trigger function + Trigger
CREATE OR REPLACE FUNCTION audit_changes()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        INSERT INTO audit_log (table_name, operation, new_data, created_at)
        VALUES (TG_TABLE_NAME, 'INSERT', row_to_json(NEW), NOW());
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit_log (table_name, operation, old_data, new_data, created_at)
        VALUES (TG_TABLE_NAME, 'UPDATE', row_to_json(OLD), row_to_json(NEW), NOW());
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit_log (table_name, operation, old_data, created_at)
        VALUES (TG_TABLE_NAME, 'DELETE', row_to_json(OLD), NOW());
        RETURN OLD;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_orders_audit
AFTER INSERT OR UPDATE OR DELETE ON orders
FOR EACH ROW EXECUTE FUNCTION audit_changes();

-- MariaDB : Un trigger par opÃ©ration
DELIMITER //

CREATE TRIGGER tr_orders_audit_insert
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    INSERT INTO audit_log (table_name, operation, new_data, created_at)
    VALUES ('orders', 'INSERT', 
            JSON_OBJECT('id', NEW.id, 'customer_id', NEW.customer_id, 
                       'amount', NEW.amount, 'status', NEW.status),
            NOW());
END //

CREATE TRIGGER tr_orders_audit_update
AFTER UPDATE ON orders
FOR EACH ROW
BEGIN
    INSERT INTO audit_log (table_name, operation, old_data, new_data, created_at)
    VALUES ('orders', 'UPDATE',
            JSON_OBJECT('id', OLD.id, 'customer_id', OLD.customer_id, 
                       'amount', OLD.amount, 'status', OLD.status),
            JSON_OBJECT('id', NEW.id, 'customer_id', NEW.customer_id, 
                       'amount', NEW.amount, 'status', NEW.status),
            NOW());
END //

CREATE TRIGGER tr_orders_audit_delete
AFTER DELETE ON orders
FOR EACH ROW
BEGIN
    INSERT INTO audit_log (table_name, operation, old_data, created_at)
    VALUES ('orders', 'DELETE',
            JSON_OBJECT('id', OLD.id, 'customer_id', OLD.customer_id, 
                       'amount', OLD.amount, 'status', OLD.status),
            NOW());
END //

DELIMITER ;

-- PostgreSQL : INSTEAD OF trigger (sur vues)
CREATE VIEW v_active_orders AS
SELECT * FROM orders WHERE status = 'active';

CREATE FUNCTION instead_of_insert_active_orders()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO orders (customer_id, amount, status)
    VALUES (NEW.customer_id, NEW.amount, 'active');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER tr_v_active_orders_insert
INSTEAD OF INSERT ON v_active_orders
FOR EACH ROW EXECUTE FUNCTION instead_of_insert_active_orders();

-- MariaDB : Pas d'INSTEAD OF trigger
-- Alternative : Vue avec ALGORITHM=MERGE peut Ãªtre updatable
CREATE VIEW v_active_orders AS
SELECT * FROM orders WHERE status = 'active';
-- Si la vue est simple, elle est auto-updatable

-- Sinon, utiliser procÃ©dure stockÃ©e
DELIMITER //
CREATE PROCEDURE insert_active_order(
    IN p_customer_id INT,
    IN p_amount DECIMAL(18,2)
)
BEGIN
    INSERT INTO orders (customer_id, amount, status)
    VALUES (p_customer_id, p_amount, 'active');
END //
DELIMITER ;
```

### Fonctions analytiques et CTE

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              WINDOW FUNCTIONS & CTEs
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Window functions : Support similaire
-- PostgreSQL
SELECT 
    id,
    customer_id,
    amount,
    ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY created_at) as rn,
    SUM(amount) OVER (PARTITION BY customer_id) as customer_total,
    LAG(amount) OVER (PARTITION BY customer_id ORDER BY created_at) as prev_amount,
    LEAD(amount) OVER (PARTITION BY customer_id ORDER BY created_at) as next_amount,
    RANK() OVER (ORDER BY amount DESC) as amount_rank,
    NTILE(4) OVER (ORDER BY amount) as quartile
FROM orders;

-- MariaDB : MÃªme syntaxe (support complet depuis 10.2)
SELECT 
    id,
    customer_id,
    amount,
    ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY created_at) as rn,
    SUM(amount) OVER (PARTITION BY customer_id) as customer_total,
    LAG(amount) OVER (PARTITION BY customer_id ORDER BY created_at) as prev_amount,
    LEAD(amount) OVER (PARTITION BY customer_id ORDER BY created_at) as next_amount,
    RANK() OVER (ORDER BY amount DESC) as amount_rank,
    NTILE(4) OVER (ORDER BY amount) as quartile
FROM orders;

-- CTEs simples et rÃ©cursives
-- PostgreSQL
WITH RECURSIVE subordinates AS (
    -- Cas de base
    SELECT id, name, manager_id, 0 as level
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Cas rÃ©cursif
    SELECT e.id, e.name, e.manager_id, s.level + 1
    FROM employees e
    JOIN subordinates s ON e.manager_id = s.id
)
SELECT * FROM subordinates ORDER BY level, name;

-- MariaDB : MÃªme syntaxe (support depuis 10.2)
WITH RECURSIVE subordinates AS (
    SELECT id, name, manager_id, 0 as level
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    SELECT e.id, e.name, e.manager_id, s.level + 1
    FROM employees e
    JOIN subordinates s ON e.manager_id = s.id
)
SELECT * FROM subordinates ORDER BY level, name;

-- PostgreSQL : CTE avec modification (writeable CTE)
WITH updated AS (
    UPDATE orders SET status = 'shipped'
    WHERE status = 'processing'
    RETURNING *
)
SELECT * FROM updated;

-- MariaDB : Pas de CTE modifiante
-- Alternative : Transaction avec SELECT aprÃ¨s UPDATE
START TRANSACTION;
UPDATE orders SET status = 'shipped' WHERE status = 'processing';
SELECT * FROM orders WHERE status = 'shipped';
COMMIT;
```

---

## Outils de migration

### pgloader

L'outil principal pour migration PostgreSQL â†’ MySQL/MariaDB.

```bash
# Installation
sudo apt-get install pgloader

# Ou depuis source pour derniÃ¨re version
git clone https://github.com/dimitri/pgloader.git
cd pgloader
make
```

#### Configuration pgloader complÃ¨te

```lisp
-- migration.load
LOAD DATABASE
    FROM postgresql://pg_user:password@postgres-host:5432/source_db
    INTO mysql://root:password@mariadb-host:3306/target_db

WITH 
    include drop,
    create tables,
    create indexes,
    reset sequences,
    workers = 8,
    concurrency = 4,
    batch rows = 25000,
    batch size = 20MB,
    prefetch rows = 100000

SET 
    PostgreSQL PARAMETERS
        search_path to 'public',
    MySQL PARAMETERS
        net_read_timeout = 120,
        net_write_timeout = 120

-- Mapping des types
CAST 
    type uuid to varchar(36),
    type jsonb to json,
    type json to json,
    type inet to varchar(45),
    type cidr to varchar(45),
    type macaddr to varchar(17),
    type interval to varchar(50),
    type point to point,
    type money to decimal(19,4),
    type bytea to blob,
    type "character varying" to varchar keeping typemod,
    type "character" to char keeping typemod,
    type text to longtext,
    type smallserial to smallint,
    type serial to integer,
    type bigserial to bigint,
    type boolean to boolean,
    type "timestamp with time zone" to datetime,
    type "timestamp without time zone" to datetime,
    type "time with time zone" to time,
    type "time without time zone" to time,
    type hstore to json

-- Colonnes ARRAY â†’ JSON
CAST 
    type int[] to json using pgloader.transforms::array-to-json-array,
    type text[] to json using pgloader.transforms::array-to-json-array,
    type varchar[] to json using pgloader.transforms::array-to-json-array

-- Tables Ã  inclure/exclure
INCLUDING ONLY TABLE NAMES MATCHING 
    'users', 'orders', 'products', 'order_items'

-- Ou exclure certaines tables
EXCLUDING TABLE NAMES MATCHING 
    'pg_*', '_*', 'temp_*', '*_backup'

-- Transformations de colonnes
ALTER SCHEMA 'public' RENAME TO 'target_db'

-- Actions post-migration
AFTER LOAD DO
    $$ ALTER TABLE orders ADD INDEX idx_customer (customer_id); $$,
    $$ ALTER TABLE orders ADD INDEX idx_status (status); $$,
    $$ UPDATE orders SET updated_at = NOW() WHERE updated_at IS NULL; $$;
```

```bash
# ExÃ©cution
pgloader migration.load

# Mode verbose pour debug
pgloader --verbose migration.load

# Dry-run
pgloader --dry-run migration.load

# Avec fichier de log
pgloader --logfile migration.log migration.load
```

#### Scripts pgloader par cas d'usage

```lisp
-- Cas 1 : Migration simple
LOAD DATABASE
    FROM pgsql://user:pass@localhost/mydb
    INTO mysql://root:pass@localhost/mydb
WITH include drop, create tables, create indexes;

-- Cas 2 : Migration avec conversion JSONB avancÃ©e
LOAD DATABASE
    FROM pgsql://user:pass@localhost/mydb
    INTO mysql://root:pass@localhost/mydb
CAST type jsonb to json
BEFORE LOAD DO
    $$ CREATE TABLE IF NOT EXISTS target_db.config_json (
         id INT AUTO_INCREMENT PRIMARY KEY,
         data JSON,
         search_key VARCHAR(100) GENERATED ALWAYS AS (JSON_VALUE(data, '$.key')) STORED,
         INDEX idx_key (search_key)
       ); $$;

-- Cas 3 : Migration avec transformation des arrays
LOAD DATABASE
    FROM pgsql://user:pass@localhost/mydb
    INTO mysql://root:pass@localhost/mydb

CAST type text[] to json

AFTER LOAD DO
    $$ CREATE PROCEDURE expand_json_arrays()
       BEGIN
         -- Logique de normalisation si nÃ©cessaire
       END; $$,
    $$ CALL expand_json_arrays(); $$;
```

### Scripts de migration personnalisÃ©s

```python
#!/usr/bin/env python3
"""
pg_to_mariadb.py
Migration PostgreSQL â†’ MariaDB avec gestion des types complexes
"""

import psycopg2
import mysql.connector
import json
from typing import Any, Dict, List, Tuple
from datetime import datetime, timedelta
import re

class PGToMariaDBMigrator:
    
    def __init__(self, pg_config: Dict, maria_config: Dict):
        self.pg_conn = psycopg2.connect(**pg_config)
        self.maria_conn = mysql.connector.connect(**maria_config)
        
        # Mapping des types
        self.type_mapping = {
            'smallint': 'SMALLINT',
            'integer': 'INT',
            'bigint': 'BIGINT',
            'real': 'FLOAT',
            'double precision': 'DOUBLE',
            'numeric': 'DECIMAL',
            'money': 'DECIMAL(19,4)',
            'character varying': 'VARCHAR',
            'character': 'CHAR',
            'text': 'LONGTEXT',
            'bytea': 'LONGBLOB',
            'boolean': 'TINYINT(1)',
            'date': 'DATE',
            'time without time zone': 'TIME(6)',
            'time with time zone': 'TIME(6)',
            'timestamp without time zone': 'DATETIME(6)',
            'timestamp with time zone': 'DATETIME(6)',
            'interval': 'VARCHAR(100)',
            'uuid': 'CHAR(36)',
            'json': 'JSON',
            'jsonb': 'JSON',
            'inet': 'VARCHAR(45)',
            'cidr': 'VARCHAR(45)',
            'macaddr': 'CHAR(17)',
            'point': 'POINT',
            'ARRAY': 'JSON',
            'USER-DEFINED': 'JSON',
        }
    
    def convert_pg_value(self, value: Any, pg_type: str) -> Any:
        """Convertit une valeur PostgreSQL vers MariaDB"""
        if value is None:
            return None
            
        # Arrays â†’ JSON
        if isinstance(value, list):
            return json.dumps(value)
        
        # UUID
        if pg_type == 'uuid':
            return str(value)
        
        # Interval â†’ String ou secondes
        if pg_type == 'interval' and isinstance(value, timedelta):
            total_seconds = int(value.total_seconds())
            days = total_seconds // 86400
            hours = (total_seconds % 86400) // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            return f"{days}d {hours}h {minutes}m {seconds}s"
        
        # JSONB/JSON
        if pg_type in ('json', 'jsonb'):
            if isinstance(value, str):
                return value
            return json.dumps(value)
        
        # hstore â†’ JSON
        if pg_type == 'hstore' and isinstance(value, dict):
            return json.dumps(value)
        
        # inet/cidr
        if pg_type in ('inet', 'cidr'):
            return str(value)
        
        return value
    
    def get_mariadb_type(self, pg_type: str, char_max_len: int = None, 
                         num_precision: int = None, num_scale: int = None) -> str:
        """DÃ©termine le type MariaDB Ã©quivalent"""
        # Gestion des arrays
        if pg_type.endswith('[]') or pg_type == 'ARRAY':
            return 'JSON'
        
        base_type = self.type_mapping.get(pg_type, 'TEXT')
        
        if base_type in ('VARCHAR', 'CHAR') and char_max_len:
            return f"{base_type}({char_max_len})"
        
        if base_type == 'DECIMAL' and num_precision:
            scale = num_scale or 0
            return f"DECIMAL({num_precision},{scale})"
        
        return base_type
    
    def generate_create_table(self, schema: str, table: str) -> str:
        """GÃ©nÃ¨re le CREATE TABLE MariaDB"""
        pg_cur = self.pg_conn.cursor()
        
        # RÃ©cupÃ©rer structure
        pg_cur.execute("""
            SELECT 
                column_name,
                data_type,
                character_maximum_length,
                numeric_precision,
                numeric_scale,
                is_nullable,
                column_default,
                udt_name
            FROM information_schema.columns
            WHERE table_schema = %s AND table_name = %s
            ORDER BY ordinal_position
        """, (schema, table))
        
        columns = []
        for row in pg_cur.fetchall():
            col_name = row[0]
            data_type = row[1]
            char_len = row[2]
            num_prec = row[3]
            num_scale = row[4]
            nullable = row[5]
            default = row[6]
            udt_name = row[7]
            
            # DÃ©terminer si c'est un array
            if data_type == 'ARRAY':
                maria_type = 'JSON'
            else:
                maria_type = self.get_mariadb_type(data_type, char_len, num_prec, num_scale)
            
            col_def = f"    `{col_name}` {maria_type}"
            
            if nullable == 'NO':
                col_def += " NOT NULL"
            
            # GÃ©rer les defaults (basique)
            if default and 'nextval' in str(default).lower():
                col_def += " AUTO_INCREMENT"
            elif default and default.lower() not in ('null', 'now()', 'current_timestamp'):
                # Simplification
                pass
            
            columns.append(col_def)
        
        # ClÃ© primaire
        pg_cur.execute("""
            SELECT a.attname
            FROM pg_index i
            JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey)
            WHERE i.indrelid = %s::regclass AND i.indisprimary
            ORDER BY array_position(i.indkey, a.attnum)
        """, (f"{schema}.{table}",))
        
        pk_cols = [row[0] for row in pg_cur.fetchall()]
        if pk_cols:
            columns.append(f"    PRIMARY KEY (`{'`, `'.join(pk_cols)}`)")
        
        ddl = f"CREATE TABLE `{table}` (\n"
        ddl += ",\n".join(columns)
        ddl += "\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;"
        
        return ddl
    
    def migrate_table(self, schema: str, table: str, batch_size: int = 10000):
        """Migre les donnÃ©es d'une table"""
        pg_cur = self.pg_conn.cursor()
        maria_cur = self.maria_conn.cursor()
        
        # RÃ©cupÃ©rer les colonnes et types
        pg_cur.execute("""
            SELECT column_name, data_type
            FROM information_schema.columns
            WHERE table_schema = %s AND table_name = %s
            ORDER BY ordinal_position
        """, (schema, table))
        
        columns_info = [(row[0], row[1]) for row in pg_cur.fetchall()]
        columns = [c[0] for c in columns_info]
        types = {c[0]: c[1] for c in columns_info}
        
        # Lire donnÃ©es
        pg_cur.execute(f'SELECT * FROM "{schema}"."{table}"')
        
        # PrÃ©parer INSERT
        placeholders = ', '.join(['%s'] * len(columns))
        insert_sql = f"INSERT INTO `{table}` (`{'`, `'.join(columns)}`) VALUES ({placeholders})"
        
        batch = []
        total = 0
        
        for row in pg_cur:
            converted_row = []
            for i, val in enumerate(row):
                col_name = columns[i]
                converted = self.convert_pg_value(val, types[col_name])
                converted_row.append(converted)
            
            batch.append(tuple(converted_row))
            
            if len(batch) >= batch_size:
                maria_cur.executemany(insert_sql, batch)
                self.maria_conn.commit()
                total += len(batch)
                print(f"    {table}: {total} rows migrated")
                batch = []
        
        if batch:
            maria_cur.executemany(insert_sql, batch)
            self.maria_conn.commit()
            total += len(batch)
        
        print(f"    {table}: {total} total rows")
        return total
    
    def migrate_schema(self, schema: str = 'public'):
        """Migre un schÃ©ma complet"""
        pg_cur = self.pg_conn.cursor()
        
        # Liste des tables
        pg_cur.execute("""
            SELECT table_name 
            FROM information_schema.tables 
            WHERE table_schema = %s AND table_type = 'BASE TABLE'
            ORDER BY table_name
        """, (schema,))
        
        tables = [row[0] for row in pg_cur.fetchall()]
        
        print(f"Migrating {len(tables)} tables from schema '{schema}'")
        
        for table in tables:
            print(f"\n  Processing {table}...")
            
            # CrÃ©er table
            ddl = self.generate_create_table(schema, table)
            maria_cur = self.maria_conn.cursor()
            maria_cur.execute(f"DROP TABLE IF EXISTS `{table}`")
            maria_cur.execute(ddl)
            
            # Migrer donnÃ©es
            self.migrate_table(schema, table)
        
        print("\nMigration complete!")


# Utilisation
if __name__ == "__main__":
    migrator = PGToMariaDBMigrator(
        pg_config={
            'host': 'postgres-host',
            'port': 5432,
            'database': 'source_db',
            'user': 'pg_user',
            'password': 'pg_pass'
        },
        maria_config={
            'host': 'mariadb-host',
            'port': 3306,
            'database': 'target_db',
            'user': 'root',
            'password': 'maria_pass'
        }
    )
    
    migrator.migrate_schema('public')
```

### AWS DMS pour PostgreSQL

```json
// Source endpoint PostgreSQL
{
    "EndpointType": "source",
    "EngineName": "postgres",
    "ServerName": "postgres.example.com",
    "Port": 5432,
    "Username": "dms_user",
    "Password": "SecureP@ss",
    "DatabaseName": "source_db",
    "SslMode": "require"
}

// Target endpoint MariaDB
{
    "EndpointType": "target",
    "EngineName": "mariadb",
    "ServerName": "mariadb.example.com",
    "Port": 3306,
    "Username": "dms_user",
    "Password": "SecureP@ss",
    "DatabaseName": "target_db"
}

// Task settings avec transformations
{
    "rules": [
        {
            "rule-type": "selection",
            "rule-id": "1",
            "rule-name": "include-public-schema",
            "object-locator": {
                "schema-name": "public",
                "table-name": "%"
            },
            "rule-action": "include"
        },
        {
            "rule-type": "transformation",
            "rule-id": "2",
            "rule-name": "rename-schema",
            "object-locator": {
                "schema-name": "public"
            },
            "rule-action": "rename",
            "rule-target": "schema",
            "value": "production"
        },
        {
            "rule-type": "transformation",
            "rule-id": "3",
            "rule-name": "convert-jsonb-columns",
            "object-locator": {
                "schema-name": "%",
                "table-name": "%",
                "column-name": "%",
                "data-type": "jsonb"
            },
            "rule-action": "change-data-type",
            "rule-target": "column",
            "data-type": {
                "type": "json"
            }
        }
    ]
}
```

---

## Gestion des extensions PostgreSQL

### PostGIS â†’ MariaDB Spatial

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              POSTGIS â†’ MARIADB SPATIAL
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- PostgreSQL avec PostGIS
CREATE EXTENSION postgis;

CREATE TABLE pg_locations (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    location GEOGRAPHY(POINT, 4326),
    area GEOMETRY(POLYGON, 4326)
);

INSERT INTO pg_locations (name, location, area)
VALUES (
    'Paris',
    ST_SetSRID(ST_MakePoint(2.3522, 48.8566), 4326),
    ST_GeomFromText('POLYGON((2.2 48.8, 2.5 48.8, 2.5 48.9, 2.2 48.9, 2.2 48.8))', 4326)
);

-- RequÃªtes spatiales PostGIS
SELECT * FROM pg_locations
WHERE ST_DWithin(location, ST_MakePoint(2.35, 48.85)::geography, 1000);  -- 1km

SELECT ST_Distance(
    location,
    ST_SetSRID(ST_MakePoint(2.35, 48.85), 4326)::geography
) as distance_meters
FROM pg_locations;

-- MariaDB Spatial
CREATE TABLE maria_locations (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100),
    location POINT NOT NULL SRID 4326,
    area POLYGON NOT NULL SRID 4326,
    SPATIAL INDEX (location),
    SPATIAL INDEX (area)
);

INSERT INTO maria_locations (name, location, area)
VALUES (
    'Paris',
    ST_PointFromText('POINT(2.3522 48.8566)', 4326),
    ST_GeomFromText('POLYGON((2.2 48.8, 2.5 48.8, 2.5 48.9, 2.2 48.9, 2.2 48.8))', 4326)
);

-- RequÃªtes spatiales MariaDB
-- Distance (note: ST_Distance retourne des degrÃ©s, pas des mÃ¨tres par dÃ©faut)
SELECT *, ST_Distance(location, ST_PointFromText('POINT(2.35 48.85)', 4326)) as distance
FROM maria_locations;

-- Pour distance en mÃ¨tres, utiliser ST_Distance_Sphere
SELECT *, ST_Distance_Sphere(
    location, 
    ST_PointFromText('POINT(2.35 48.85)', 4326)
) as distance_meters
FROM maria_locations;

-- Rayon de recherche
SELECT * FROM maria_locations
WHERE ST_Distance_Sphere(location, ST_PointFromText('POINT(2.35 48.85)', 4326)) < 1000;

-- Intersection
SELECT * FROM maria_locations
WHERE ST_Contains(area, ST_PointFromText('POINT(2.35 48.85)', 4326));
```

### pg_trgm â†’ MariaDB FULLTEXT

```sql
-- PostgreSQL : Recherche similitude avec pg_trgm
CREATE EXTENSION pg_trgm;

CREATE TABLE pg_products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(200),
    description TEXT
);

CREATE INDEX idx_name_trgm ON pg_products USING GIN (name gin_trgm_ops);
CREATE INDEX idx_desc_trgm ON pg_products USING GIN (description gin_trgm_ops);

-- Recherche par similaritÃ©
SELECT *, similarity(name, 'mariabd') as sim
FROM pg_products
WHERE name % 'mariabd'  -- SimilaritÃ© > threshold
ORDER BY sim DESC;

-- Recherche LIKE optimisÃ©e par trigrammes
SELECT * FROM pg_products WHERE name LIKE '%database%';

-- MariaDB : FULLTEXT pour recherche textuelle
CREATE TABLE maria_products (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(200),
    description TEXT,
    FULLTEXT INDEX idx_name (name),
    FULLTEXT INDEX idx_desc (description),
    FULLTEXT INDEX idx_all (name, description)
);

-- Recherche FULLTEXT
SELECT *, MATCH(name, description) AGAINST('database' IN NATURAL LANGUAGE MODE) as relevance
FROM maria_products
WHERE MATCH(name, description) AGAINST('database' IN NATURAL LANGUAGE MODE);

-- Mode boolÃ©en (plus contrÃ´le)
SELECT * FROM maria_products
WHERE MATCH(name, description) AGAINST('+database -oracle' IN BOOLEAN MODE);

-- Pour recherche de similaritÃ© (fuzzy), pas d'Ã©quivalent direct
-- Options:
-- 1. SOUNDEX pour matching phonÃ©tique
SELECT * FROM maria_products WHERE SOUNDEX(name) = SOUNDEX('mariabd');

-- 2. Algorithme Levenshtein (fonction custom ou application)
-- 3. Application-level fuzzy search (Elasticsearch, Algolia)
```

### Extension uuid-ossp

```sql
-- PostgreSQL
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

SELECT uuid_generate_v4();
SELECT uuid_generate_v1();
SELECT uuid_generate_v1mc();

-- MariaDB (10.7+)
SELECT UUID();           -- Similaire Ã  uuid_generate_v1
-- UUID v4 disponible nativement

-- Pour uuid_generate_v4 Ã©quivalent exact, utiliser fonction
DELIMITER //
CREATE FUNCTION uuid_v4()
RETURNS CHAR(36)
NOT DETERMINISTIC
BEGIN
    RETURN LOWER(CONCAT(
        HEX(RANDOM_BYTES(4)), '-',
        HEX(RANDOM_BYTES(2)), '-4',
        SUBSTR(HEX(RANDOM_BYTES(2)), 2, 3), '-',
        HEX(FLOOR(ASCII(RANDOM_BYTES(1)) / 64) + 8),
        SUBSTR(HEX(RANDOM_BYTES(2)), 2, 3), '-',
        HEX(RANDOM_BYTES(6))
    ));
END //
DELIMITER ;
```

---

## ScÃ©narios de migration rÃ©els

### ScÃ©nario 1 : Application Django avec PostgreSQL

**Contexte** :
- Application Django utilisant PostgreSQL 14
- Types utilisÃ©s : JSONB, ARRAY, custom enums
- ORM Django pour la plupart des requÃªtes
- 50 tables, 2 TB de donnÃ©es

**StratÃ©gie** :

```python
# settings.py - Avant
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'myapp',
        'USER': 'django_user',
        'PASSWORD': 'secret',
        'HOST': 'postgres-host',
        'PORT': '5432',
    }
}

# settings.py - AprÃ¨s
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'myapp',
        'USER': 'django_user',
        'PASSWORD': 'secret',
        'HOST': 'mariadb-host',
        'PORT': '3306',
        'OPTIONS': {
            'charset': 'utf8mb4',
            'init_command': "SET sql_mode='STRICT_TRANS_TABLES'",
        },
    }
}

# Adaptations modÃ¨les
# Avant (PostgreSQL)
from django.contrib.postgres.fields import ArrayField, JSONField

class Product(models.Model):
    name = models.CharField(max_length=200)
    tags = ArrayField(models.CharField(max_length=50))
    metadata = JSONField()

# AprÃ¨s (MariaDB)
class Product(models.Model):
    name = models.CharField(max_length=200)
    tags = models.JSONField()  # Stocker comme JSON array
    metadata = models.JSONField()
    
    def get_tags_list(self):
        return self.tags if isinstance(self.tags, list) else []
    
    def set_tags_list(self, tags):
        self.tags = list(tags)
```

**Migration des donnÃ©es** :

```bash
# 1. Export PostgreSQL
pg_dump -Fc myapp > myapp.dump

# 2. Convertir avec pgloader
cat > django_migration.load << 'EOF'
LOAD DATABASE
    FROM pgsql://user:pass@postgres-host/myapp
    INTO mysql://user:pass@mariadb-host/myapp

WITH include drop, create tables, create indexes

CAST 
    type jsonb to json,
    type text[] to json,
    type varchar[] to json,
    type int[] to json

EXCLUDING TABLE NAMES MATCHING 
    'django_migrations', 'django_session'

AFTER LOAD DO
    $$ DELETE FROM django_migrations; $$;
EOF

pgloader django_migration.load

# 3. RecrÃ©er les migrations Django
python manage.py migrate --fake-initial
```

### ScÃ©nario 2 : Data Lake PostgreSQL vers MariaDB ColumnStore

**Contexte** :
- PostgreSQL 15 utilisÃ© comme data lake
- Tables partitionnÃ©es par date
- RequÃªtes analytiques lourdes
- 10 TB de donnÃ©es historiques

**Architecture cible** :

```
PostgreSQL (avant)                MariaDB (aprÃ¨s)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€            â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PostgreSQL 15      â”‚          â”‚  MariaDB 11.8           â”‚
â”‚                     â”‚          â”‚                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚          â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ events        â”‚  â”‚          â”‚  â”‚ InnoDB (OLTP)     â”‚  â”‚
â”‚  â”‚ (partitioned) â”‚â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â–¶â”‚ events_recent     â”‚  â”‚
â”‚  â”‚ 10 TB         â”‚  â”‚          â”‚  â”‚ (30 derniers j.)  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚          â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                     â”‚          â”‚                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚          â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ aggregations  â”‚  â”‚          â”‚  â”‚ ColumnStore (OLAP)â”‚  â”‚
â”‚  â”‚ (mat. views)  â”‚â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â–¶â”‚ events_historical â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚          â”‚  â”‚ (compression 10x) â”‚  â”‚
â”‚                     â”‚          â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Configuration ColumnStore** :

```sql
-- MariaDB ColumnStore pour donnÃ©es historiques
CREATE TABLE events_historical (
    event_id BIGINT,
    event_time DATETIME,
    user_id INT,
    event_type VARCHAR(50),
    properties JSON,
    event_date DATE
) ENGINE=ColumnStore
DEFAULT CHARSET=utf8mb4;

-- InnoDB pour donnÃ©es rÃ©centes (OLTP)
CREATE TABLE events_recent (
    event_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    event_time DATETIME(6),
    user_id INT,
    event_type VARCHAR(50),
    properties JSON,
    INDEX idx_user (user_id),
    INDEX idx_time (event_time)
) ENGINE=InnoDB;

-- Job de migration hotâ†’cold
CREATE EVENT rotate_events
ON SCHEDULE EVERY 1 DAY
STARTS CURRENT_TIMESTAMP + INTERVAL 1 HOUR
DO
BEGIN
    -- DÃ©placer donnÃ©es > 30 jours vers ColumnStore
    INSERT INTO events_historical
    SELECT event_id, event_time, user_id, event_type, properties, DATE(event_time)
    FROM events_recent
    WHERE event_time < NOW() - INTERVAL 30 DAY;
    
    -- Purger de InnoDB
    DELETE FROM events_recent
    WHERE event_time < NOW() - INTERVAL 30 DAY;
END;

-- RequÃªtes analytiques sur ColumnStore (trÃ¨s rapides)
SELECT 
    DATE(event_time) as day,
    event_type,
    COUNT(*) as event_count,
    COUNT(DISTINCT user_id) as unique_users
FROM events_historical
WHERE event_time >= NOW() - INTERVAL 1 YEAR
GROUP BY DATE(event_time), event_type;
```

### ScÃ©nario 3 : Migration avec coexistence temporaire

**Contexte** :
- Migration progressive sur 6 mois
- Certaines applications restent sur PostgreSQL
- Besoin de synchronisation bidirectionnelle

**Architecture** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     APPLICATION LAYER                          â”‚
â”‚                                                                â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚   â”‚ Service A  â”‚    â”‚ Service B   â”‚    â”‚ Service C   â”‚         â”‚
â”‚   â”‚ (migrÃ©)    â”‚    â”‚ (dual-write)â”‚    â”‚ (PostgreSQL)â”‚         â”‚
â”‚   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚         â”‚                  â”‚                  â”‚                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                  â”‚                  â”‚
          â–¼                  â–¼                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    MariaDB      â”‚   â”‚              Debezium CDC               â”‚
â”‚    11.8         â”‚â—€â”€â”€â”¤         (Synchronisation)               â”‚
â”‚                 â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                      â”‚
â”‚  â”‚ Tables A  â”‚  â”‚                      â”‚
â”‚  â”‚ Tables B  â”‚â—€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
                                         â–¼
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚           PostgreSQL 15                 â”‚
                      â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
                      â”‚  â”‚ Tables B  â”‚  â”‚ Tables C  â”‚ (source)  â”‚
                      â”‚  â”‚ (replica) â”‚  â”‚           â”‚           â”‚
                      â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Configuration Debezium** :

```json
{
  "name": "pg-to-maria-sync",
  "config": {
    "connector.class": "io.debezium.connector.postgresql.PostgresConnector",
    "database.hostname": "postgres-host",
    "database.port": "5432",
    "database.user": "debezium",
    "database.password": "password",
    "database.dbname": "source_db",
    "database.server.name": "pg_source",
    "plugin.name": "pgoutput",
    "slot.name": "debezium_slot",
    "table.include.list": "public.shared_table_b",
    "transforms": "unwrap,route",
    "transforms.unwrap.type": "io.debezium.transforms.ExtractNewRecordState",
    "transforms.route.type": "org.apache.kafka.connect.transforms.RegexRouter",
    "transforms.route.regex": "pg_source.public.(.*)",
    "transforms.route.replacement": "mariadb.$1",
    "key.converter": "org.apache.kafka.connect.json.JsonConverter",
    "value.converter": "org.apache.kafka.connect.json.JsonConverter"
  }
}
```

---

## Checklist de migration PostgreSQL â†’ MariaDB

### PrÃ©-migration

- [ ] Inventaire des tables et volumes
- [ ] Identification des types PostgreSQL spÃ©cifiques (JSONB, ARRAY, etc.)
- [ ] Liste des extensions utilisÃ©es (PostGIS, pg_trgm, etc.)
- [ ] Audit des fonctions et procÃ©dures PL/pgSQL
- [ ] Analyse des requÃªtes avec types complexes
- [ ] Test de migration sur environnement de dev
- [ ] Estimation des transformations nÃ©cessaires

### Conversion

- [ ] Mapping des types de donnÃ©es
- [ ] Conversion ARRAY â†’ JSON ou tables de jointure
- [ ] Adaptation JSONB â†’ JSON (attention aux index GIN)
- [ ] RÃ©Ã©criture des fonctions PL/pgSQL
- [ ] Conversion des triggers (1 par opÃ©ration)
- [ ] Adaptation des requÃªtes avec opÃ©rateurs spÃ©cifiques
- [ ] Migration des index (GIN â†’ FULLTEXT ou generated columns)

### Migration des donnÃ©es

- [ ] Configuration pgloader ou script personnalisÃ©
- [ ] Test de migration sur Ã©chantillon
- [ ] Migration complÃ¨te avec validation
- [ ] VÃ©rification des comptages par table
- [ ] Validation des donnÃ©es JSON/array converties
- [ ] Test des contraintes d'intÃ©gritÃ©

### Post-migration

- [ ] Tests de rÃ©gression applicatifs
- [ ] Tests de performance comparative
- [ ] Optimisation des index MariaDB
- [ ] Configuration du query cache si pertinent
- [ ] Documentation des diffÃ©rences
- [ ] Formation des Ã©quipes

---

## âœ… Points clÃ©s Ã  retenir

- **JSONB â†’ JSON** : MariaDB JSON est stockÃ© en texte, pas en binaire. Utilisez des generated columns pour indexer les chemins frÃ©quemment requÃªtÃ©s

- **ARRAY â†’ JSON** : Les arrays PostgreSQL doivent Ãªtre convertis en JSON ou normalisÃ©s en tables de jointure. JSON est plus simple, la normalisation est plus performante

- **PL/pgSQL â†’ SQL/PSM** : La syntaxe est diffÃ©rente mais les concepts sont similaires. Attention Ã  ELSIF â†’ ELSEIF et aux boucles FOR

- **Extensions** : PostGIS â†’ MariaDB Spatial fonctionne mais avec des fonctions diffÃ©rentes. pg_trgm n'a pas d'Ã©quivalent direct (utiliser FULLTEXT)

- **pgloader** : Outil de rÃ©fÃ©rence pour migration automatisÃ©e, supporte les transformations de types complexes

- **Window Functions & CTEs** : Support excellent dans MariaDB, migration quasi-transparente

- **Niveau d'isolation** : PostgreSQL READ COMMITTED vs MariaDB REPEATABLE READ par dÃ©faut - Ã  aligner si nÃ©cessaire

---

## ğŸ”— Ressources et rÃ©fÃ©rences

- [ğŸ“– pgloader Documentation](https://pgloader.readthedocs.io/)
- [ğŸ“– MariaDB JSON Functions](https://mariadb.com/kb/en/json-functions/)
- [ğŸ“– MariaDB Spatial Reference](https://mariadb.com/kb/en/spatial/)
- [ğŸ“– PostgreSQL to MySQL Migration](https://wiki.postgresql.org/wiki/Converting_from_other_Databases_to_PostgreSQL)
- [ğŸ“– AWS DMS PostgreSQL Source](https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html)
- [ğŸ“– Debezium PostgreSQL Connector](https://debezium.io/documentation/reference/connectors/postgresql.html)
- [ğŸ“– MariaDB ColumnStore](https://mariadb.com/kb/en/mariadb-columnstore/)

---


â­ï¸ [Gestion des versions : StratÃ©gie LTS vs Rolling](/19-migration-compatibilite/03-gestion-versions-lts-rolling.md)
