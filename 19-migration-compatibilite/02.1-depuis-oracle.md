ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 19.2.1 Migration depuis Oracle

> **Niveau** : AvancÃ© Ã  Expert  
> **DurÃ©e estimÃ©e** : 7-8 heures  
> **PrÃ©requis** : Connaissance d'Oracle Database (architecture, PL/SQL), expÃ©rience MariaDB, comprÃ©hension des enjeux de migration hÃ©tÃ©rogÃ¨ne

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Ã‰valuer la faisabilitÃ© et l'effort d'une migration Oracle â†’ MariaDB
- MaÃ®triser le mapping complet des types de donnÃ©es Oracle vers MariaDB
- Convertir les objets PL/SQL (procÃ©dures, packages, triggers) vers MariaDB
- Utiliser le mode de compatibilitÃ© Oracle de MariaDB efficacement
- Planifier et exÃ©cuter une migration Oracle complexe avec minimisation des risques
- GÃ©rer les diffÃ©rences architecturales fondamentales entre les deux SGBD

---

## Introduction

La migration d'Oracle Database vers MariaDB reprÃ©sente l'un des projets de migration les plus ambitieux qu'une organisation puisse entreprendre. Oracle et MariaDB diffÃ¨rent fondamentalement dans leur architecture, leur modÃ¨le de donnÃ©es et leur philosophie.

Cependant, cette migration est de plus en plus courante pour plusieurs raisons :
- **RÃ©duction des coÃ»ts de licence** : Oracle peut coÃ»ter des centaines de milliers d'euros par an
- **FlexibilitÃ©** : MariaDB open-source offre plus de libertÃ©
- **Cloud-native** : MariaDB s'intÃ¨gre mieux aux architectures modernes
- **Performance** : Pour de nombreux workloads, MariaDB offre des performances comparables

MariaDB a dÃ©veloppÃ© un **mode de compatibilitÃ© Oracle** (`sql_mode=ORACLE`) qui facilite significativement cette migration en supportant une grande partie de la syntaxe PL/SQL.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              COMPLEXITÃ‰ DE MIGRATION PAR COMPOSANT                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚  Composant              â”‚ DifficultÃ© â”‚ Effort estimÃ©                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  Tables simples         â”‚ â˜…â˜†â˜†â˜†â˜†     â”‚ Quasi-automatique              â”‚
â”‚  Types de donnÃ©es       â”‚ â˜…â˜…â˜†â˜†â˜†     â”‚ Mapping dÃ©fini                 â”‚
â”‚  Index standards        â”‚ â˜…â˜†â˜†â˜†â˜†     â”‚ Quasi-automatique              â”‚
â”‚  Vues simples           â”‚ â˜…â˜…â˜†â˜†â˜†     â”‚ Ajustements mineurs            â”‚
â”‚  SÃ©quences              â”‚ â˜…â˜†â˜†â˜†â˜†     â”‚ Syntaxe similaire              â”‚
â”‚  Contraintes            â”‚ â˜…â˜…â˜†â˜†â˜†     â”‚ Conversion directe             â”‚
â”‚  ProcÃ©dures stockÃ©es    â”‚ â˜…â˜…â˜…â˜†â˜†     â”‚ Mode ORACLE aide               â”‚
â”‚  Packages               â”‚ â˜…â˜…â˜…â˜…â˜†     â”‚ Restructuration nÃ©cessaire     â”‚
â”‚  Triggers               â”‚ â˜…â˜…â˜…â˜†â˜†     â”‚ Syntaxe diffÃ©rente             â”‚
â”‚  Types objets (OOP)     â”‚ â˜…â˜…â˜…â˜…â˜…     â”‚ Refonte complÃ¨te               â”‚
â”‚  Fonctions analytiques  â”‚ â˜…â˜…â˜†â˜†â˜†     â”‚ Bon support MariaDB            â”‚
â”‚  Partitionnement        â”‚ â˜…â˜…â˜…â˜†â˜†     â”‚ Syntaxe diffÃ©rente             â”‚
â”‚  Synonymes              â”‚ â˜…â˜…â˜…â˜…â˜†     â”‚ Non supportÃ©s nativement       â”‚
â”‚  Database Links         â”‚ â˜…â˜…â˜…â˜…â˜†     â”‚ CONNECT engine ou app          â”‚
â”‚  Materialized Views     â”‚ â˜…â˜…â˜…â˜…â˜†     â”‚ Workarounds nÃ©cessaires        â”‚
â”‚  Advanced Queuing       â”‚ â˜…â˜…â˜…â˜…â˜…     â”‚ Solution externe requise       â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## DiffÃ©rences architecturales fondamentales

### ModÃ¨le de stockage

```
Oracle                              MariaDB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Instance        â”‚            â”‚      Instance       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚            â”‚   (mysqld process)  â”‚
â”‚  â”‚     SGA       â”‚  â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”‚ (Shared mem)  â”‚  â”‚                       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚            â”‚    Databases        â”‚
â”‚  â”‚     PGA       â”‚  â”‚            â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ (Per session) â”‚  â”‚            â”‚  â”‚ db1 (schema)  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚            â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚  â”‚ db2 (schema)  â”‚  â”‚
           â”‚                       â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚     Database        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚            DiffÃ©rences clÃ©s :
â”‚  â”‚ Tablespace 1  â”‚  â”‚            â€¢ 1 instance = N databases
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚            â€¢ Database â‰ˆ Schema Oracle
â”‚  â”‚ Tablespace 2  â”‚  â”‚            â€¢ Pas de tablespaces sÃ©parÃ©s
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚              (InnoDB file-per-table)
â”‚  â”‚   Schema A    â”‚  â”‚            â€¢ Buffer Pool = SGA simplifiÃ©
â”‚  â”‚   Schema B    â”‚  â”‚            â€¢ Pas de PGA distinct
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Implications pour la migration

```sql
-- Oracle : SchÃ©mas distincts dans une mÃªme database
-- Utilisateur = Schema (propriÃ©taire d'objets)
CREATE USER hr IDENTIFIED BY password;
CREATE TABLE hr.employees (...);
CREATE TABLE hr.departments (...);

-- MariaDB : Databases distinctes (Ã©quivalent de schemas)
CREATE DATABASE hr;
USE hr;
CREATE TABLE employees (...);
CREATE TABLE departments (...);

-- Ã‰quivalence conceptuelle :
-- Oracle Database    â†’  MariaDB Instance
-- Oracle Schema      â†’  MariaDB Database
-- Oracle Tablespace  â†’  (pas d'Ã©quivalent direct, fichiers InnoDB)
```

### Transactions et isolation

```sql
-- Oracle : READ COMMITTED par dÃ©faut, pas de dirty reads possibles
-- Snapshot isolation via MVCC (undo segments)

-- MariaDB InnoDB : REPEATABLE READ par dÃ©faut
-- Configurer pour comportement Oracle-like :
SET GLOBAL transaction_isolation = 'READ-COMMITTED';

-- Oracle : Auto-commit OFF par dÃ©faut (transaction implicite)
-- MariaDB : Auto-commit ON par dÃ©faut
SET GLOBAL autocommit = 0;  -- Pour comportement Oracle
```

---

## Mapping des types de donnÃ©es

### Types numÃ©riques

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    TYPES NUMÃ‰RIQUES ORACLE â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- NUMBER sans prÃ©cision â†’ DOUBLE ou DECIMAL(65,30)
-- Oracle
CREATE TABLE t1 (val NUMBER);
-- MariaDB (selon besoin de prÃ©cision)
CREATE TABLE t1 (val DOUBLE);  -- Approximatif, performant
CREATE TABLE t1 (val DECIMAL(65,30));  -- Exact, plus lent

-- NUMBER(p) entier â†’ INT appropriÃ©
-- Oracle
CREATE TABLE t2 (
    small_val NUMBER(4),      -- -9999 Ã  9999
    medium_val NUMBER(9),     -- Â±999 millions
    large_val NUMBER(18),     -- Â±quintillions
    huge_val NUMBER(38)       -- TrÃ¨s grands nombres
);
-- MariaDB
CREATE TABLE t2 (
    small_val SMALLINT,           -- -32768 Ã  32767
    medium_val INT,               -- Â±2.1 milliards
    large_val BIGINT,             -- Â±9.2 quintillions
    huge_val DECIMAL(38,0)        -- PrÃ©cision exacte
);

-- NUMBER(p,s) dÃ©cimal â†’ DECIMAL(p,s)
-- Oracle
CREATE TABLE t3 (
    price NUMBER(10,2),       -- Prix avec 2 dÃ©cimales
    rate NUMBER(5,4),         -- Taux avec 4 dÃ©cimales
    amount NUMBER(15,6)       -- Montant prÃ©cis
);
-- MariaDB (mapping direct)
CREATE TABLE t3 (
    price DECIMAL(10,2),
    rate DECIMAL(5,4),
    amount DECIMAL(15,6)
);

-- BINARY_FLOAT / BINARY_DOUBLE â†’ FLOAT / DOUBLE
-- Oracle
CREATE TABLE t4 (
    float_val BINARY_FLOAT,
    double_val BINARY_DOUBLE
);
-- MariaDB
CREATE TABLE t4 (
    float_val FLOAT,
    double_val DOUBLE
);
```

### Types caractÃ¨res

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    TYPES CARACTÃˆRES ORACLE â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- VARCHAR2(n) â†’ VARCHAR(n)
-- Oracle (n en bytes ou chars selon NLS_LENGTH_SEMANTICS)
CREATE TABLE t1 (
    name VARCHAR2(100),           -- 100 bytes par dÃ©faut
    name_char VARCHAR2(100 CHAR)  -- 100 caractÃ¨res
);
-- MariaDB (toujours en caractÃ¨res avec utf8mb4)
CREATE TABLE t1 (
    name VARCHAR(100),
    name_char VARCHAR(100)
);

-- NVARCHAR2 â†’ VARCHAR avec CHARACTER SET utf8mb4
-- Oracle
CREATE TABLE t2 (description NVARCHAR2(500));
-- MariaDB
CREATE TABLE t2 (description VARCHAR(500) CHARACTER SET utf8mb4);

-- CHAR(n) â†’ CHAR(n) (attention au padding)
-- Oracle : CHAR padde avec espaces, comparaison ignore trailing spaces
-- MariaDB : Comportement similaire par dÃ©faut

-- CLOB â†’ LONGTEXT
-- Oracle
CREATE TABLE t3 (content CLOB);
-- MariaDB
CREATE TABLE t3 (content LONGTEXT);

-- NCLOB â†’ LONGTEXT CHARACTER SET utf8mb4
CREATE TABLE t4 (content LONGTEXT CHARACTER SET utf8mb4);

-- LONG (deprecated Oracle) â†’ LONGTEXT ou TEXT
-- Oracle (legacy)
CREATE TABLE t5 (data LONG);
-- MariaDB
CREATE TABLE t5 (data LONGTEXT);
```

âš ï¸ **Attention** : Oracle `VARCHAR2` peut stocker jusqu'Ã  32767 bytes (avec `MAX_STRING_SIZE=EXTENDED`), MariaDB `VARCHAR` est limitÃ© Ã  65535 bytes par ligne (partagÃ©s entre colonnes).

### Types date et heure

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    TYPES DATE/HEURE ORACLE â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- DATE Oracle â†’ DATETIME MariaDB
-- ATTENTION : DATE Oracle inclut l'heure !
-- Oracle
CREATE TABLE t1 (created_at DATE);  -- Inclut HH:MI:SS
INSERT INTO t1 VALUES (SYSDATE);    -- 2025-12-15 10:30:45

-- MariaDB
CREATE TABLE t1 (created_at DATETIME);  -- Ã‰quivalent exact
INSERT INTO t1 VALUES (NOW());

-- TIMESTAMP â†’ DATETIME(6)
-- Oracle
CREATE TABLE t2 (
    ts TIMESTAMP,                    -- Jusqu'Ã  6 dÃ©cimales
    ts3 TIMESTAMP(3),               -- 3 dÃ©cimales (millisecondes)
    ts9 TIMESTAMP(9)                -- 9 dÃ©cimales (nanosecondes)
);
-- MariaDB (max 6 dÃ©cimales = microsecondes)
CREATE TABLE t2 (
    ts DATETIME(6),
    ts3 DATETIME(3),
    ts9 DATETIME(6)  -- Perte de prÃ©cision pour >6 dÃ©cimales
);

-- TIMESTAMP WITH TIME ZONE â†’ DATETIME + colonne timezone ou TIMESTAMP
-- Oracle
CREATE TABLE t3 (event_time TIMESTAMP WITH TIME ZONE);
-- MariaDB Option 1 : Stocker en UTC
CREATE TABLE t3 (
    event_time DATETIME(6),
    event_timezone VARCHAR(50)
);
-- MariaDB Option 2 : TIMESTAMP (conversion auto UTC)
CREATE TABLE t3 (event_time TIMESTAMP(6));

-- TIMESTAMP WITH LOCAL TIME ZONE â†’ TIMESTAMP
-- Oracle : StockÃ© en UTC, affichÃ© selon session timezone
-- MariaDB : TIMESTAMP fonctionne de maniÃ¨re similaire
CREATE TABLE t4 (local_time TIMESTAMP(6));

-- INTERVAL YEAR TO MONTH â†’ INT (mois) ou VARCHAR
-- Oracle
CREATE TABLE t5 (duration INTERVAL YEAR(2) TO MONTH);
-- MariaDB (stocker en mois)
CREATE TABLE t5 (duration_months INT);
-- Ou en texte pour lisibilitÃ©
CREATE TABLE t5 (duration VARCHAR(20));  -- '2-6' pour 2 ans 6 mois

-- INTERVAL DAY TO SECOND â†’ INT (secondes) ou BIGINT (microsecondes)
-- Oracle
CREATE TABLE t6 (elapsed INTERVAL DAY(3) TO SECOND(6));
-- MariaDB
CREATE TABLE t6 (elapsed_microseconds BIGINT);
```

ğŸ’¡ **Conseil** : CrÃ©ez des fonctions de conversion pour les INTERVAL si votre application les utilise intensivement.

### Types binaires et LOB

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    TYPES BINAIRES ORACLE â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- RAW(n) â†’ VARBINARY(n) ou BINARY(n)
-- Oracle
CREATE TABLE t1 (
    hash RAW(32),           -- Hash SHA-256
    data RAW(2000)          -- DonnÃ©es binaires
);
-- MariaDB
CREATE TABLE t1 (
    hash BINARY(32),        -- Taille fixe
    data VARBINARY(2000)    -- Taille variable
);

-- LONG RAW (deprecated) â†’ LONGBLOB
-- Oracle
CREATE TABLE t2 (image LONG RAW);
-- MariaDB
CREATE TABLE t2 (image LONGBLOB);

-- BLOB â†’ LONGBLOB
-- Oracle (jusqu'Ã  4GB)
CREATE TABLE t3 (document BLOB);
-- MariaDB
CREATE TABLE t3 (document LONGBLOB);  -- Jusqu'Ã  4GB aussi

-- BFILE â†’ Pas d'Ã©quivalent direct
-- Oracle : Pointeur vers fichier externe
-- MariaDB : Stocker le chemin + lire via application
CREATE TABLE t4 (
    file_path VARCHAR(500),
    file_content LONGBLOB  -- Si stockage inline nÃ©cessaire
);
```

### Types spÃ©ciaux

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    TYPES SPÃ‰CIAUX ORACLE â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- ROWID â†’ Pas d'Ã©quivalent (utiliser clÃ© primaire)
-- Oracle : Adresse physique de la ligne
-- MariaDB : Utiliser une vraie clÃ© primaire

-- XMLType â†’ LONGTEXT + validation applicative
-- Oracle
CREATE TABLE t1 (config XMLTYPE);
-- MariaDB
CREATE TABLE t1 (config LONGTEXT);
-- Avec contrainte de validation (optionnel)
ALTER TABLE t1 ADD CONSTRAINT chk_xml 
    CHECK (JSON_VALID(config) OR config LIKE '<%');

-- SDO_GEOMETRY â†’ GEOMETRY
-- Oracle Spatial
CREATE TABLE locations (
    id NUMBER PRIMARY KEY,
    geom SDO_GEOMETRY
);
-- MariaDB (syntaxe diffÃ©rente)
CREATE TABLE locations (
    id BIGINT PRIMARY KEY,
    geom GEOMETRY NOT NULL,
    SPATIAL INDEX (geom)
);

-- BOOLEAN (PL/SQL seulement en Oracle) â†’ BOOLEAN ou TINYINT(1)
-- MariaDB supporte BOOLEAN (alias pour TINYINT(1))
CREATE TABLE t2 (is_active BOOLEAN DEFAULT TRUE);

-- SYS_REFCURSOR â†’ Pas d'Ã©quivalent direct
-- GÃ©rer via code applicatif ou procÃ©dures retournant resultsets
```

### Table de mapping complÃ¨te

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    SCRIPT DE CONVERSION AUTOMATIQUE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Fonction PL/SQL Oracle pour gÃ©nÃ©rer le mapping
-- Ã€ exÃ©cuter sur Oracle pour prÃ©parer la migration

CREATE OR REPLACE FUNCTION map_oracle_to_mariadb(
    p_data_type VARCHAR2,
    p_data_precision NUMBER,
    p_data_scale NUMBER,
    p_data_length NUMBER
) RETURN VARCHAR2 AS
BEGIN
    RETURN CASE
        -- NumÃ©riques
        WHEN p_data_type = 'NUMBER' AND p_data_scale = 0 AND p_data_precision <= 4 
            THEN 'SMALLINT'
        WHEN p_data_type = 'NUMBER' AND p_data_scale = 0 AND p_data_precision <= 9 
            THEN 'INT'
        WHEN p_data_type = 'NUMBER' AND p_data_scale = 0 AND p_data_precision <= 18 
            THEN 'BIGINT'
        WHEN p_data_type = 'NUMBER' AND p_data_scale = 0 
            THEN 'DECIMAL(' || NVL(p_data_precision, 38) || ',0)'
        WHEN p_data_type = 'NUMBER' AND p_data_scale > 0 
            THEN 'DECIMAL(' || p_data_precision || ',' || p_data_scale || ')'
        WHEN p_data_type = 'NUMBER' 
            THEN 'DOUBLE'
        WHEN p_data_type = 'BINARY_FLOAT' THEN 'FLOAT'
        WHEN p_data_type = 'BINARY_DOUBLE' THEN 'DOUBLE'
        
        -- CaractÃ¨res
        WHEN p_data_type = 'VARCHAR2' 
            THEN 'VARCHAR(' || p_data_length || ')'
        WHEN p_data_type = 'NVARCHAR2' 
            THEN 'VARCHAR(' || p_data_length || ') CHARACTER SET utf8mb4'
        WHEN p_data_type = 'CHAR' 
            THEN 'CHAR(' || p_data_length || ')'
        WHEN p_data_type = 'NCHAR' 
            THEN 'CHAR(' || p_data_length || ') CHARACTER SET utf8mb4'
        WHEN p_data_type = 'CLOB' THEN 'LONGTEXT'
        WHEN p_data_type = 'NCLOB' THEN 'LONGTEXT CHARACTER SET utf8mb4'
        WHEN p_data_type = 'LONG' THEN 'LONGTEXT'
        
        -- Date/Heure
        WHEN p_data_type = 'DATE' THEN 'DATETIME'
        WHEN p_data_type LIKE 'TIMESTAMP%' AND p_data_type LIKE '%TIME ZONE%'
            THEN 'DATETIME(6)'  -- + colonne timezone si besoin
        WHEN p_data_type LIKE 'TIMESTAMP%' 
            THEN 'DATETIME(' || NVL(p_data_scale, 6) || ')'
        WHEN p_data_type LIKE 'INTERVAL%' THEN 'VARCHAR(50)'
        
        -- Binaires
        WHEN p_data_type = 'RAW' 
            THEN 'VARBINARY(' || p_data_length || ')'
        WHEN p_data_type = 'LONG RAW' THEN 'LONGBLOB'
        WHEN p_data_type = 'BLOB' THEN 'LONGBLOB'
        
        -- Autres
        WHEN p_data_type = 'XMLTYPE' THEN 'LONGTEXT'
        WHEN p_data_type = 'SDO_GEOMETRY' THEN 'GEOMETRY'
        WHEN p_data_type = 'ROWID' THEN 'VARCHAR(18)'
        
        ELSE '/* UNKNOWN: ' || p_data_type || ' */'
    END;
END;
/
```

---

## Mode de compatibilitÃ© Oracle dans MariaDB

### Activation et configuration

```sql
-- Activation du mode Oracle
SET sql_mode = 'ORACLE';

-- VÃ©rification
SELECT @@sql_mode;

-- Configuration permanente dans my.cnf
-- [mysqld]
-- sql_mode = ORACLE

-- Activation par session (recommandÃ© pour migration progressive)
SET SESSION sql_mode = 'ORACLE';
```

### FonctionnalitÃ©s supportÃ©es en mode ORACLE

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    MODE ORACLE : SYNTAXE SUPPORTÃ‰E
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SET sql_mode = 'ORACLE';

-- 1. DÃ©claration de variables sans DECLARE
CREATE PROCEDURE test_vars AS
    v_count NUMBER;         -- Pas besoin de DECLARE
    v_name VARCHAR2(100);
BEGIN
    v_count := 0;
    v_name := 'Test';
END;
/

-- 2. Assignation avec :=
CREATE PROCEDURE test_assign AS
    v_total NUMBER := 0;
BEGIN
    v_total := v_total + 100;
END;
/

-- 3. ParamÃ¨tres IN/OUT sans mot-clÃ©
CREATE PROCEDURE get_employee(
    p_id IN NUMBER,
    p_name OUT VARCHAR2,
    p_salary IN OUT NUMBER
) AS
BEGIN
    SELECT name, salary INTO p_name, p_salary
    FROM employees WHERE id = p_id;
END;
/

-- 4. DÃ©limiteur / pour fin de bloc
CREATE FUNCTION calculate_tax(p_amount NUMBER) 
RETURN NUMBER AS
BEGIN
    RETURN p_amount * 0.20;
END;
/

-- 5. EXCEPTION handling Oracle-style
CREATE PROCEDURE safe_divide(
    p_num NUMBER,
    p_den NUMBER,
    p_result OUT NUMBER
) AS
BEGIN
    p_result := p_num / p_den;
EXCEPTION
    WHEN ZERO_DIVIDE THEN
        p_result := NULL;
    WHEN OTHERS THEN
        RAISE;
END;
/

-- 6. Curseurs implicites (SQL%ROWCOUNT, SQL%FOUND, SQL%NOTFOUND)
CREATE PROCEDURE update_salary(p_id NUMBER, p_increase NUMBER) AS
BEGIN
    UPDATE employees SET salary = salary + p_increase WHERE id = p_id;
    
    IF SQL%NOTFOUND THEN
        RAISE_APPLICATION_ERROR(-20001, 'Employee not found');
    END IF;
    
    DBMS_OUTPUT.PUT_LINE('Rows updated: ' || SQL%ROWCOUNT);
END;
/

-- 7. FOR loop sur curseur
CREATE PROCEDURE list_employees AS
BEGIN
    FOR emp IN (SELECT id, name, salary FROM employees) LOOP
        DBMS_OUTPUT.PUT_LINE(emp.name || ': ' || emp.salary);
    END LOOP;
END;
/

-- 8. DECODE (en plus de CASE)
SELECT DECODE(status, 'A', 'Active', 'I', 'Inactive', 'Unknown') 
FROM orders;

-- 9. NVL, NVL2
SELECT NVL(commission, 0) FROM employees;
SELECT NVL2(commission, salary + commission, salary) FROM employees;

-- 10. ConcatÃ©nation avec ||
SELECT first_name || ' ' || last_name AS full_name FROM employees;

-- 11. SYSDATE sans parenthÃ¨ses
SELECT SYSDATE FROM DUAL;

-- 12. Table DUAL
SELECT 1 + 1 FROM DUAL;

-- 13. SÃ©quences avec NEXTVAL/CURRVAL sans .nextval
SELECT emp_seq.NEXTVAL FROM DUAL;
INSERT INTO employees (id, name) VALUES (emp_seq.NEXTVAL, 'John');

-- 14. ROWNUM
SELECT * FROM employees WHERE ROWNUM <= 10;

-- 15. Packages (structure de base)
CREATE PACKAGE emp_pkg AS
    PROCEDURE hire_employee(p_name VARCHAR2, p_salary NUMBER);
    FUNCTION get_salary(p_id NUMBER) RETURN NUMBER;
END;
/

CREATE PACKAGE BODY emp_pkg AS
    PROCEDURE hire_employee(p_name VARCHAR2, p_salary NUMBER) AS
    BEGIN
        INSERT INTO employees (name, salary) VALUES (p_name, p_salary);
    END;
    
    FUNCTION get_salary(p_id NUMBER) RETURN NUMBER AS
        v_salary NUMBER;
    BEGIN
        SELECT salary INTO v_salary FROM employees WHERE id = p_id;
        RETURN v_salary;
    END;
END;
/
```

### Limitations du mode ORACLE

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              MODE ORACLE : FONCTIONNALITÃ‰S NON SUPPORTÃ‰ES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- âŒ Types objets (Object Types)
-- Oracle
CREATE TYPE address_type AS OBJECT (
    street VARCHAR2(100),
    city VARCHAR2(50),
    zip VARCHAR2(10)
);
-- MariaDB : Pas supportÃ©, utiliser JSON ou tables relationnelles

-- âŒ Collections (VARRAY, Nested Tables, Associative Arrays)
-- Oracle
CREATE TYPE number_array AS VARRAY(100) OF NUMBER;
-- MariaDB : Utiliser JSON ou tables temporaires

-- âŒ BULK COLLECT
-- Oracle
SELECT id BULK COLLECT INTO v_ids FROM employees;
-- MariaDB : Utiliser curseurs ou tables temporaires

-- âŒ FORALL
-- Oracle
FORALL i IN 1..v_ids.COUNT
    UPDATE employees SET processed = 'Y' WHERE id = v_ids(i);
-- MariaDB : Boucle standard ou requÃªte ensembliste

-- âŒ Autonomous Transactions (PRAGMA AUTONOMOUS_TRANSACTION)
-- Oracle
CREATE PROCEDURE log_error(p_msg VARCHAR2) AS
    PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
    INSERT INTO error_log (message) VALUES (p_msg);
    COMMIT;
END;
-- MariaDB : Non supportÃ©, utiliser connexion sÃ©parÃ©e ou table MEMORY

-- âŒ Synonymes (CREATE SYNONYM)
-- Oracle
CREATE SYNONYM emp FOR hr.employees;
-- MariaDB : Utiliser vues
CREATE VIEW emp AS SELECT * FROM hr.employees;

-- âŒ Database Links
-- Oracle
SELECT * FROM employees@remote_db;
-- MariaDB : Utiliser CONNECT engine ou Federated engine

-- âŒ Materialized Views avec refresh automatique
-- Oracle
CREATE MATERIALIZED VIEW mv_sales
    REFRESH FAST ON COMMIT AS
    SELECT product_id, SUM(quantity) FROM orders GROUP BY product_id;
-- MariaDB : Tables + triggers ou events pour refresh manuel

-- âŒ Flashback queries
-- Oracle
SELECT * FROM employees AS OF TIMESTAMP (SYSTIMESTAMP - INTERVAL '1' HOUR);
-- MariaDB : Utiliser System-Versioned Tables
SELECT * FROM employees FOR SYSTEM_TIME AS OF 
    (NOW() - INTERVAL 1 HOUR);

-- âŒ Edition-Based Redefinition
-- Pas d'Ã©quivalent MariaDB

-- âŒ Fine-Grained Access Control (FGAC/VPD)
-- Oracle : Policies automatiques
-- MariaDB : Vues avec filtrage ou logique applicative
```

---

## Conversion des objets PL/SQL

### ProcÃ©dures stockÃ©es

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              CONVERSION PROCÃ‰DURES ORACLE â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- ORACLE (procÃ©dure complexe)
CREATE OR REPLACE PROCEDURE process_order(
    p_order_id IN NUMBER,
    p_status OUT VARCHAR2,
    p_message OUT VARCHAR2
) AS
    v_customer_id NUMBER;
    v_total NUMBER := 0;
    v_credit_limit NUMBER;
    e_insufficient_credit EXCEPTION;
    PRAGMA EXCEPTION_INIT(e_insufficient_credit, -20001);
BEGIN
    -- RÃ©cupÃ©rer les infos commande
    SELECT customer_id, total_amount
    INTO v_customer_id, v_total
    FROM orders
    WHERE order_id = p_order_id;
    
    -- VÃ©rifier le crÃ©dit client
    SELECT credit_limit INTO v_credit_limit
    FROM customers
    WHERE customer_id = v_customer_id;
    
    IF v_total > v_credit_limit THEN
        RAISE e_insufficient_credit;
    END IF;
    
    -- Traitement
    UPDATE orders 
    SET status = 'PROCESSED', 
        processed_date = SYSDATE
    WHERE order_id = p_order_id;
    
    -- Log
    INSERT INTO order_log (order_id, action, action_date)
    VALUES (p_order_id, 'PROCESSED', SYSDATE);
    
    p_status := 'SUCCESS';
    p_message := 'Order processed successfully';
    
    COMMIT;
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        p_status := 'ERROR';
        p_message := 'Order not found';
        ROLLBACK;
    WHEN e_insufficient_credit THEN
        p_status := 'ERROR';
        p_message := 'Insufficient credit limit';
        ROLLBACK;
    WHEN OTHERS THEN
        p_status := 'ERROR';
        p_message := SQLERRM;
        ROLLBACK;
END;
/

-- MARIADB (Ã©quivalent avec mode ORACLE)
SET sql_mode = 'ORACLE';

CREATE OR REPLACE PROCEDURE process_order(
    p_order_id IN NUMBER,
    p_status OUT VARCHAR2,
    p_message OUT VARCHAR2
) AS
    v_customer_id NUMBER;
    v_total NUMBER := 0;
    v_credit_limit NUMBER;
BEGIN
    -- RÃ©cupÃ©rer les infos commande
    SELECT customer_id, total_amount
    INTO v_customer_id, v_total
    FROM orders
    WHERE order_id = p_order_id;
    
    -- VÃ©rifier le crÃ©dit client
    SELECT credit_limit INTO v_credit_limit
    FROM customers
    WHERE customer_id = v_customer_id;
    
    IF v_total > v_credit_limit THEN
        SIGNAL SQLSTATE '45000' 
            SET MESSAGE_TEXT = 'Insufficient credit limit';
    END IF;
    
    -- Traitement
    UPDATE orders 
    SET status = 'PROCESSED', 
        processed_date = SYSDATE
    WHERE order_id = p_order_id;
    
    -- Log
    INSERT INTO order_log (order_id, action, action_date)
    VALUES (p_order_id, 'PROCESSED', SYSDATE);
    
    p_status := 'SUCCESS';
    p_message := 'Order processed successfully';
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        p_status := 'ERROR';
        p_message := 'Order not found';
    WHEN OTHERS THEN
        p_status := 'ERROR';
        p_message := SQLERRM;
END;
/

-- Note : Le COMMIT/ROLLBACK dÃ©pend du contexte d'appel en MariaDB
-- MariaDB n'a pas PRAGMA EXCEPTION_INIT, utiliser SIGNAL
```

### Fonctions

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              CONVERSION FONCTIONS ORACLE â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- ORACLE
CREATE OR REPLACE FUNCTION calculate_age(p_birth_date DATE) 
RETURN NUMBER AS
    v_age NUMBER;
BEGIN
    v_age := TRUNC(MONTHS_BETWEEN(SYSDATE, p_birth_date) / 12);
    RETURN v_age;
END;
/

-- MARIADB (mode ORACLE)
SET sql_mode = 'ORACLE';

CREATE OR REPLACE FUNCTION calculate_age(p_birth_date DATE) 
RETURN NUMBER AS
    v_age NUMBER;
BEGIN
    v_age := TIMESTAMPDIFF(YEAR, p_birth_date, SYSDATE);
    RETURN v_age;
END;
/

-- Alternative MariaDB (mode standard)
DELIMITER //
CREATE FUNCTION calculate_age(p_birth_date DATE) 
RETURNS INT
DETERMINISTIC
BEGIN
    RETURN TIMESTAMPDIFF(YEAR, p_birth_date, CURDATE());
END //
DELIMITER ;

-- ORACLE : Fonction avec OUT parameters (via record)
-- Pas directement supportÃ© en MariaDB, utiliser procÃ©dure Ã  la place
```

### Triggers

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              CONVERSION TRIGGERS ORACLE â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- ORACLE : Trigger BEFORE INSERT avec sÃ©quence
CREATE OR REPLACE TRIGGER trg_employees_bi
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
    IF :NEW.id IS NULL THEN
        :NEW.id := emp_seq.NEXTVAL;
    END IF;
    :NEW.created_at := SYSDATE;
    :NEW.created_by := USER;
END;
/

-- MARIADB : Ã‰quivalent
-- Note: En MariaDB, AUTO_INCREMENT gÃ¨re souvent les IDs
-- Mais si besoin de logique similaire :
DELIMITER //
CREATE TRIGGER trg_employees_bi
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
    IF NEW.id IS NULL THEN
        SET NEW.id = (SELECT NEXTVAL(emp_seq));
    END IF;
    SET NEW.created_at = NOW();
    SET NEW.created_by = CURRENT_USER();
END //
DELIMITER ;

-- ORACLE : Trigger avec condition WHEN
CREATE OR REPLACE TRIGGER trg_audit_salary
AFTER UPDATE OF salary ON employees
FOR EACH ROW
WHEN (NEW.salary > OLD.salary * 1.5)
BEGIN
    INSERT INTO audit_log (table_name, action, old_value, new_value)
    VALUES ('EMPLOYEES', 'LARGE_RAISE', :OLD.salary, :NEW.salary);
END;
/

-- MARIADB : Condition dans le corps
DELIMITER //
CREATE TRIGGER trg_audit_salary
AFTER UPDATE ON employees
FOR EACH ROW
BEGIN
    IF NEW.salary > OLD.salary * 1.5 THEN
        INSERT INTO audit_log (table_name, action, old_value, new_value)
        VALUES ('employees', 'LARGE_RAISE', OLD.salary, NEW.salary);
    END IF;
END //
DELIMITER ;

-- ORACLE : Multiple triggers (statement level)
CREATE OR REPLACE TRIGGER trg_orders_statement
AFTER INSERT ON orders
BEGIN
    -- Log au niveau statement
    INSERT INTO operation_log VALUES (SYSDATE, 'Orders inserted');
END;
/

-- MARIADB : Pas de trigger statement-level natif
-- Workaround avec variable de session ou table de tracking
```

### Packages (conversion en modules)

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              CONVERSION PACKAGES ORACLE â†’ MARIADB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- ORACLE Package
CREATE OR REPLACE PACKAGE employee_pkg AS
    -- Constantes
    c_max_salary CONSTANT NUMBER := 100000;
    
    -- Variables de package (session state)
    g_department_id NUMBER;
    
    -- ProcÃ©dures et fonctions
    PROCEDURE set_department(p_dept_id NUMBER);
    FUNCTION get_employee_count RETURN NUMBER;
    PROCEDURE hire_employee(
        p_name VARCHAR2,
        p_salary NUMBER,
        p_emp_id OUT NUMBER
    );
END employee_pkg;
/

CREATE OR REPLACE PACKAGE BODY employee_pkg AS
    -- Variable privÃ©e
    v_last_operation DATE;
    
    PROCEDURE set_department(p_dept_id NUMBER) AS
    BEGIN
        g_department_id := p_dept_id;
        v_last_operation := SYSDATE;
    END;
    
    FUNCTION get_employee_count RETURN NUMBER AS
        v_count NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_count
        FROM employees
        WHERE department_id = g_department_id;
        RETURN v_count;
    END;
    
    PROCEDURE hire_employee(
        p_name VARCHAR2,
        p_salary NUMBER,
        p_emp_id OUT NUMBER
    ) AS
    BEGIN
        IF p_salary > c_max_salary THEN
            RAISE_APPLICATION_ERROR(-20001, 'Salary exceeds maximum');
        END IF;
        
        INSERT INTO employees (name, salary, department_id)
        VALUES (p_name, p_salary, g_department_id)
        RETURNING id INTO p_emp_id;
        
        v_last_operation := SYSDATE;
    END;
END employee_pkg;
/

-- MARIADB : Packages supportÃ©s (mode ORACLE) depuis 10.3
SET sql_mode = 'ORACLE';

CREATE OR REPLACE PACKAGE employee_pkg AS
    -- Constantes (via fonction)
    FUNCTION c_max_salary RETURN NUMBER;
    
    -- ProcÃ©dures et fonctions
    PROCEDURE set_department(p_dept_id NUMBER);
    FUNCTION get_employee_count RETURN NUMBER;
    PROCEDURE hire_employee(
        p_name VARCHAR2,
        p_salary NUMBER,
        p_emp_id OUT NUMBER
    );
END;
/

CREATE OR REPLACE PACKAGE BODY employee_pkg AS
    -- Variables de package stockÃ©es en session
    g_department_id NUMBER;
    v_last_operation DATETIME;
    
    FUNCTION c_max_salary RETURN NUMBER AS
    BEGIN
        RETURN 100000;
    END;
    
    PROCEDURE set_department(p_dept_id NUMBER) AS
    BEGIN
        g_department_id := p_dept_id;
        v_last_operation := SYSDATE;
    END;
    
    FUNCTION get_employee_count RETURN NUMBER AS
        v_count NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_count
        FROM employees
        WHERE department_id = g_department_id;
        RETURN v_count;
    END;
    
    PROCEDURE hire_employee(
        p_name VARCHAR2,
        p_salary NUMBER,
        p_emp_id OUT NUMBER
    ) AS
    BEGIN
        IF p_salary > c_max_salary() THEN
            SIGNAL SQLSTATE '45000' 
                SET MESSAGE_TEXT = 'Salary exceeds maximum';
        END IF;
        
        INSERT INTO employees (name, salary, department_id)
        VALUES (p_name, p_salary, g_department_id);
        
        SET p_emp_id = LAST_INSERT_ID();
        v_last_operation := SYSDATE;
    END;
END;
/

-- Utilisation
CALL employee_pkg.set_department(10);
SELECT employee_pkg.get_employee_count() FROM DUAL;
```

---

## Outils de migration Oracle â†’ MariaDB

### Oracle SQL Developer Migration Workbench

```
Oracle SQL Developer inclut un assistant de migration :

1. CrÃ©er un projet de migration
   - Repository : base de donnÃ©es pour stocker les mÃ©tadonnÃ©es
   - Source : connexion Oracle
   - Target : connexion MariaDB (via MySQL)

2. Capturer le schÃ©ma Oracle
   - Tables, vues, index
   - ProcÃ©dures, fonctions, packages
   - Triggers, sÃ©quences

3. Conversion automatique
   - GÃ©nÃ©ration DDL MariaDB
   - Rapport des incompatibilitÃ©s

4. Export et import
   - Scripts DDL
   - DonnÃ©es via CSV ou INSERT

Limitations :
- Conversion PL/SQL limitÃ©e
- Packages non convertis automatiquement
- Requiert rÃ©vision manuelle
```

### AWS Schema Conversion Tool (SCT)

```bash
# AWS SCT : Outil gratuit pour conversion de schÃ©ma

# Installation
# TÃ©lÃ©charger depuis : https://aws.amazon.com/dms/schema-conversion-tool/

# Workflow SCT :
# 1. CrÃ©er projet
# 2. Connecter Oracle source
# 3. Connecter MariaDB cible
# 4. Analyser et convertir le schÃ©ma
# 5. Appliquer les scripts convertis
# 6. Utiliser DMS pour les donnÃ©es

# Rapport d'Ã©valuation
# SCT gÃ©nÃ¨re un rapport dÃ©taillÃ© :
# - % de code convertible automatiquement
# - Actions manuelles requises
# - Estimation d'effort
```

### Scripts de conversion personnalisÃ©s

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--              SCRIPT D'EXTRACTION SCHÃ‰MA ORACLE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- GÃ©nÃ©rer CREATE TABLE MariaDB depuis Oracle
SELECT 
    'CREATE TABLE ' || LOWER(table_name) || ' (' || CHR(10) ||
    LISTAGG(
        '    ' || LOWER(column_name) || ' ' || 
        CASE 
            WHEN data_type = 'NUMBER' AND data_scale = 0 AND data_precision <= 9 
                THEN 'INT'
            WHEN data_type = 'NUMBER' AND data_scale = 0 
                THEN 'BIGINT'
            WHEN data_type = 'NUMBER' AND data_scale > 0 
                THEN 'DECIMAL(' || data_precision || ',' || data_scale || ')'
            WHEN data_type = 'NUMBER' 
                THEN 'DOUBLE'
            WHEN data_type = 'VARCHAR2' 
                THEN 'VARCHAR(' || data_length || ')'
            WHEN data_type = 'DATE' 
                THEN 'DATETIME'
            WHEN data_type = 'CLOB' 
                THEN 'LONGTEXT'
            WHEN data_type = 'BLOB' 
                THEN 'LONGBLOB'
            WHEN data_type LIKE 'TIMESTAMP%' 
                THEN 'DATETIME(6)'
            ELSE data_type
        END ||
        CASE WHEN nullable = 'N' THEN ' NOT NULL' ELSE '' END,
        ',' || CHR(10)
    ) WITHIN GROUP (ORDER BY column_id) ||
    CHR(10) || ');'
    AS ddl
FROM user_tab_columns
WHERE table_name = 'EMPLOYEES'
GROUP BY table_name;

-- GÃ©nÃ©rer les contraintes PK
SELECT 
    'ALTER TABLE ' || LOWER(c.table_name) || 
    ' ADD PRIMARY KEY (' ||
    LISTAGG(LOWER(cc.column_name), ', ') WITHIN GROUP (ORDER BY cc.position) ||
    ');'
FROM user_constraints c
JOIN user_cons_columns cc ON c.constraint_name = cc.constraint_name
WHERE c.constraint_type = 'P'
GROUP BY c.table_name, c.constraint_name;

-- GÃ©nÃ©rer les FK
SELECT 
    'ALTER TABLE ' || LOWER(c.table_name) ||
    ' ADD CONSTRAINT ' || LOWER(c.constraint_name) ||
    ' FOREIGN KEY (' || 
    LISTAGG(LOWER(cc.column_name), ', ') WITHIN GROUP (ORDER BY cc.position) ||
    ') REFERENCES ' || LOWER(rc.table_name) || '(' ||
    LISTAGG(LOWER(rcc.column_name), ', ') WITHIN GROUP (ORDER BY rcc.position) ||
    ');'
FROM user_constraints c
JOIN user_cons_columns cc ON c.constraint_name = cc.constraint_name
JOIN user_constraints rc ON c.r_constraint_name = rc.constraint_name
JOIN user_cons_columns rcc ON rc.constraint_name = rcc.constraint_name
WHERE c.constraint_type = 'R'
GROUP BY c.table_name, c.constraint_name, rc.table_name;

-- GÃ©nÃ©rer les sÃ©quences
SELECT 
    'CREATE SEQUENCE ' || LOWER(sequence_name) ||
    ' START WITH ' || last_number ||
    ' INCREMENT BY ' || increment_by ||
    CASE WHEN min_value IS NOT NULL THEN ' MINVALUE ' || min_value ELSE '' END ||
    CASE WHEN max_value < 999999999999999 THEN ' MAXVALUE ' || max_value ELSE '' END ||
    CASE WHEN cycle_flag = 'Y' THEN ' CYCLE' ELSE ' NOCYCLE' END ||
    ';'
FROM user_sequences;

-- GÃ©nÃ©rer les index
SELECT 
    'CREATE' || 
    CASE WHEN uniqueness = 'UNIQUE' THEN ' UNIQUE' ELSE '' END ||
    ' INDEX ' || LOWER(index_name) ||
    ' ON ' || LOWER(table_name) || ' (' ||
    LISTAGG(LOWER(column_name), ', ') WITHIN GROUP (ORDER BY column_position) ||
    ');'
FROM user_ind_columns
JOIN user_indexes USING (index_name, table_name)
WHERE index_type = 'NORMAL'
GROUP BY index_name, table_name, uniqueness;
```

### Export des donnÃ©es

```bash
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#              EXPORT DONNÃ‰ES ORACLE POUR IMPORT MARIADB
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Option 1 : SQL*Plus avec CSV
sqlplus -S user/pass@orcl << 'EOF'
SET COLSEP ','
SET PAGESIZE 0
SET TRIMSPOOL ON
SET HEADSEP OFF
SET LINESIZE 32767
SET FEEDBACK OFF

SPOOL employees.csv
SELECT 
    id || ',' ||
    '"' || REPLACE(name, '"', '""') || '",' ||
    salary || ',' ||
    TO_CHAR(hire_date, 'YYYY-MM-DD HH24:MI:SS')
FROM employees;
SPOOL OFF
EOF

# Option 2 : Oracle Data Pump + transformation
expdp user/pass@orcl \
    directory=DATA_PUMP_DIR \
    dumpfile=export.dmp \
    schemas=HR \
    content=data_only

# Puis utiliser outil de conversion DMP â†’ SQL/CSV

# Option 3 : Script Python avec cx_Oracle et mysql-connector
cat > oracle_to_mariadb.py << 'EOF'
import cx_Oracle
import mysql.connector
from datetime import datetime

# Connexions
ora_conn = cx_Oracle.connect('user/pass@oracle-host:1521/ORCL')
maria_conn = mysql.connector.connect(
    host='mariadb-host',
    user='root',
    password='pass',
    database='hr'
)

ora_cur = ora_conn.cursor()
maria_cur = maria_conn.cursor()

# Tables Ã  migrer
tables = ['employees', 'departments', 'orders']

for table in tables:
    print(f"Migrating {table}...")
    
    # Lire depuis Oracle
    ora_cur.execute(f"SELECT * FROM {table}")
    columns = [desc[0].lower() for desc in ora_cur.description]
    
    # PrÃ©parer INSERT MariaDB
    placeholders = ', '.join(['%s'] * len(columns))
    insert_sql = f"INSERT INTO {table} ({', '.join(columns)}) VALUES ({placeholders})"
    
    # Batch insert
    batch_size = 10000
    batch = []
    
    for row in ora_cur:
        # Conversion des types
        converted_row = []
        for val in row:
            if isinstance(val, cx_Oracle.LOB):
                val = val.read()
            converted_row.append(val)
        batch.append(tuple(converted_row))
        
        if len(batch) >= batch_size:
            maria_cur.executemany(insert_sql, batch)
            maria_conn.commit()
            print(f"  Inserted {batch_size} rows")
            batch = []
    
    # Reste du batch
    if batch:
        maria_cur.executemany(insert_sql, batch)
        maria_conn.commit()
        print(f"  Inserted {len(batch)} rows")

ora_conn.close()
maria_conn.close()
print("Migration complete!")
EOF

python oracle_to_mariadb.py
```

---

## ScÃ©narios de migration rÃ©els

### ScÃ©nario 1 : Application ERP legacy Oracle 11g

**Contexte** : 
- Oracle 11g R2, 500 GB de donnÃ©es
- 200 tables, 150 procÃ©dures stockÃ©es, 30 packages
- Application Java/Hibernate
- Budget : rÃ©duire les coÃ»ts de licence de 300Kâ‚¬/an

**StratÃ©gie** :

```
Phase 1 : Analyse (4 semaines)
â”œâ”€â”€ Audit schÃ©ma avec AWS SCT
â”œâ”€â”€ Classification des procÃ©dures par complexitÃ©
â”œâ”€â”€ Identification des fonctionnalitÃ©s Oracle-spÃ©cifiques
â””â”€â”€ POC sur environnement de test

Phase 2 : Conversion schÃ©ma (6 semaines)
â”œâ”€â”€ GÃ©nÃ©ration DDL MariaDB
â”œâ”€â”€ Conversion des sÃ©quences
â”œâ”€â”€ Adaptation des index
â””â”€â”€ Tests unitaires DDL

Phase 3 : Conversion PL/SQL (8 semaines)
â”œâ”€â”€ ProcÃ©dures simples (auto-conversion)
â”œâ”€â”€ Packages â†’ dÃ©composition en procÃ©dures
â”œâ”€â”€ Triggers (rÃ©Ã©criture manuelle)
â””â”€â”€ Tests unitaires procÃ©dures

Phase 4 : Migration donnÃ©es (2 semaines)
â”œâ”€â”€ Export Oracle Data Pump
â”œâ”€â”€ Transformation CSV
â”œâ”€â”€ Import parallÃ¨le mydumper
â””â”€â”€ Validation checksums

Phase 5 : Tests (4 semaines)
â”œâ”€â”€ Tests de rÃ©gression complets
â”œâ”€â”€ Tests de performance
â”œâ”€â”€ Tests de charge
â””â”€â”€ UAT utilisateurs

Phase 6 : Go-live (1 semaine)
â”œâ”€â”€ Freeze Oracle
â”œâ”€â”€ Migration delta
â”œâ”€â”€ Cutover
â””â”€â”€ Monitoring intensif
```

**RÃ©sultats** :
- 85% des procÃ©dures converties automatiquement (mode ORACLE)
- 15% rÃ©Ã©criture manuelle
- Performance Ã©quivalente (+5% sur certaines requÃªtes)
- Ã‰conomies : 280Kâ‚¬/an

### ScÃ©nario 2 : Migration Oracle RAC vers MariaDB Galera

**Contexte** :
- Oracle RAC 2 nÅ“uds, 1 TB
- Haute disponibilitÃ© critique (99.99%)
- 500 connexions simultanÃ©es
- Workload mixte OLTP/reporting

**Architecture cible** :

```
Oracle RAC (avant)                 MariaDB Galera (aprÃ¨s)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Node 1  â”‚ â”‚ Node 2  â”‚           â”‚ Node 1  â”‚ â”‚ Node 2  â”‚ â”‚ Node 3  â”‚
â”‚(Active) â”‚ â”‚(Active) â”‚   â†’       â”‚(Primary)â”‚ â”‚(Primary)â”‚ â”‚(Primary)â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚           â”‚                     â”‚           â”‚           â”‚
     â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                     â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
           â”‚                                 â”‚           â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”   â”‚
    â”‚ ASM Storage â”‚                  â”‚   MaxScale    â”‚â—€â”€â”€â”˜
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚(Load Balancer)â”‚
                                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Script de configuration Galera** :

```ini
# my.cnf pour nÅ“ud Galera
[mysqld]
# Galera Configuration
wsrep_on=ON
wsrep_provider=/usr/lib/galera/libgalera_smm.so
wsrep_cluster_name="ora_migration_cluster"
wsrep_cluster_address="gcomm://192.168.1.101,192.168.1.102,192.168.1.103"
wsrep_node_name="node1"
wsrep_node_address="192.168.1.101"
wsrep_sst_method=mariabackup
wsrep_sst_auth=sst_user:sst_password

# InnoDB optimisÃ© pour Galera
innodb_buffer_pool_size=64G
innodb_log_file_size=2G
innodb_flush_log_at_trx_commit=2
innodb_autoinc_lock_mode=2

# Thread pool (remplace Oracle connection pooling)
thread_handling=pool-of-threads
thread_pool_size=32
thread_pool_max_threads=1000

# CompatibilitÃ© Oracle
sql_mode=ORACLE
```

### ScÃ©nario 3 : Migration partielle avec coexistence

**Contexte** :
- Oracle 19c, 5 TB
- Migration impossible en une fois
- Coexistence Oracle/MariaDB pendant 18 mois
- Migration module par module

**Architecture de coexistence** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        APPLICATION LAYER                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚  Module A   â”‚  â”‚  Module B   â”‚  â”‚  Module C   â”‚              â”‚
â”‚  â”‚ (migrÃ©)     â”‚  â”‚ (en cours)  â”‚  â”‚ (Oracle)    â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                â”‚                â”‚
          â–¼                â–¼                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    MariaDB      â”‚ â”‚  Oracle GoldenGate /        â”‚
â”‚    Cluster      â”‚ â”‚  Debezium CDC               â”‚
â”‚                 â”‚ â”‚  (Sync bidirectionnel)      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”‚ Module A  â”‚  â”‚                â”‚
â”‚  â”‚  tables   â”‚â—€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚                â”‚
â”‚  â”‚ Module B  â”‚  â”‚                â”‚
â”‚  â”‚  tables   â”‚â—€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
                                   â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚         Oracle 19c          â”‚
                    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
                    â”‚  â”‚ Module A  â”‚ (read-only)  â”‚
                    â”‚  â”‚  tables   â”‚              â”‚
                    â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”‚
                    â”‚  â”‚ Module B  â”‚              â”‚
                    â”‚  â”‚  tables   â”‚              â”‚
                    â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤              â”‚
                    â”‚  â”‚ Module C  â”‚ (active)     â”‚
                    â”‚  â”‚  tables   â”‚              â”‚
                    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Configuration Debezium pour synchronisation** :

```json
{
  "name": "oracle-to-mariadb-sync",
  "config": {
    "connector.class": "io.debezium.connector.oracle.OracleConnector",
    "database.hostname": "oracle-host",
    "database.port": "1521",
    "database.user": "debezium",
    "database.password": "password",
    "database.dbname": "ORCL",
    "database.pdb.name": "PDB1",
    "table.include.list": "HR.EMPLOYEES,HR.DEPARTMENTS,HR.ORDERS",
    "database.history.kafka.bootstrap.servers": "kafka:9092",
    "database.history.kafka.topic": "schema-changes.oracle",
    "transforms": "route",
    "transforms.route.type": "org.apache.kafka.connect.transforms.RegexRouter",
    "transforms.route.regex": "oracle-server.HR.(.*)",
    "transforms.route.replacement": "mariadb.$1"
  }
}
```

---

## Checklist de migration Oracle â†’ MariaDB

### Phase prÃ©paratoire

- [ ] Inventaire complet des objets Oracle (tables, vues, index, sÃ©quences)
- [ ] Audit des procÃ©dures stockÃ©es et packages
- [ ] Identification des fonctionnalitÃ©s Oracle-spÃ©cifiques utilisÃ©es
- [ ] Analyse des types de donnÃ©es et mapping
- [ ] Ã‰valuation avec AWS SCT ou Oracle SQL Developer
- [ ] Estimation de l'effort de conversion PL/SQL
- [ ] POC sur un module reprÃ©sentatif

### Phase de conversion

- [ ] GÃ©nÃ©ration des scripts DDL MariaDB
- [ ] Conversion des sÃ©quences
- [ ] Adaptation des index (B-tree, Bitmap â†’ B-tree)
- [ ] Conversion des vues
- [ ] Conversion des procÃ©dures simples (mode ORACLE)
- [ ] DÃ©composition des packages complexes
- [ ] RÃ©Ã©criture des triggers
- [ ] CrÃ©ation des workarounds (synonymes â†’ vues, etc.)

### Phase de migration des donnÃ©es

- [ ] Export des donnÃ©es Oracle (Data Pump, CSV, direct)
- [ ] Transformation des formats (dates, LOB)
- [ ] Import dans MariaDB (LOAD DATA, mydumper)
- [ ] VÃ©rification des volumes (COUNT)
- [ ] Validation des checksums par table

### Phase de tests

- [ ] Tests unitaires de toutes les procÃ©dures converties
- [ ] Tests de rÃ©gression applicatifs
- [ ] Tests de performance (benchmarks comparatifs)
- [ ] Tests de charge
- [ ] Tests de failover/HA
- [ ] UAT avec utilisateurs mÃ©tier

### Phase de go-live

- [ ] Plan de rollback documentÃ©
- [ ] FenÃªtre de migration planifiÃ©e
- [ ] Communication aux utilisateurs
- [ ] Synchronisation finale des donnÃ©es
- [ ] Cutover DNS/application
- [ ] Monitoring post-migration intensif
- [ ] Support renforcÃ©

---

## âœ… Points clÃ©s Ã  retenir

- **Mode ORACLE** : MariaDB supporte une grande partie de la syntaxe PL/SQL (`sql_mode=ORACLE`), facilitant significativement la migration du code procÃ©dural

- **DATE Oracle inclut l'heure** : Mappez `DATE` Oracle vers `DATETIME` MariaDB, pas `DATE`

- **Packages supportÃ©s** : MariaDB 10.3+ supporte les packages Oracle-style, mais avec certaines limitations (pas de variables de package persistantes cross-session)

- **SÃ©quences natives** : MariaDB supporte `CREATE SEQUENCE` avec syntaxe similaire Ã  Oracle

- **Types objets non supportÃ©s** : Les `TYPE AS OBJECT` et collections Oracle nÃ©cessitent une refonte vers JSON ou tables relationnelles

- **Synonymes** : Utilisez des vues comme alternative aux synonymes Oracle

- **Materialized Views** : ImplÃ©mentez manuellement avec tables + triggers/events pour le refresh

- **CoÃ»t de migration typique** : 3-6 mois pour une base moyenne (100-500 tables, 50-200 procÃ©dures)

---

## ğŸ”— Ressources et rÃ©fÃ©rences

- [ğŸ“– MariaDB SQL_MODE=ORACLE](https://mariadb.com/kb/en/sql_modeoracle/)
- [ğŸ“– MariaDB Packages](https://mariadb.com/kb/en/create-package/)
- [ğŸ“– AWS Schema Conversion Tool](https://aws.amazon.com/dms/schema-conversion-tool/)
- [ğŸ“– Oracle to MariaDB Migration Guide](https://mariadb.com/resources/blog/migrating-from-oracle-to-mariadb/)
- [ğŸ“– Debezium Oracle Connector](https://debezium.io/documentation/reference/connectors/oracle.html)
- [ğŸ“– MariaDB Compatibility with Oracle](https://mariadb.com/kb/en/mariadb-vs-oracle/)

---

## â¡ï¸ Section suivante

**[19.2.2 Migration depuis SQL Server](./02.2-depuis-sql-server.md)** : StratÃ©gies et outils pour migrer de Microsoft SQL Server vers MariaDB, conversion T-SQL, gestion des types spÃ©cifiques et intÃ©gration avec l'Ã©cosystÃ¨me Microsoft.

â­ï¸ [Depuis SQL Server](/19-migration-compatibilite/02.2-depuis-sql-server.md)
