ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 14.2.2 Certification-based replication

> **Niveau** : Expert  
> **DurÃ©e estimÃ©e** : 4-5 heures  
> **PrÃ©requis** : Architecture synchrone multi-master (14.2.1), rÃ©plication asynchrone (13), thÃ©orie des systÃ¨mes distribuÃ©s

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- MaÃ®triser le protocole de certification de Galera en profondeur
- Comprendre la construction et le traitement des write-sets
- Analyser et optimiser les performances de certification
- Diagnostiquer et rÃ©soudre les conflits de certification
- ImplÃ©menter des stratÃ©gies de rÃ©duction des rejets de transactions
- Configurer finement les paramÃ¨tres de certification pour la production

---

## Introduction

La **certification-based replication** est le mÃ©canisme fondamental qui distingue Galera Cluster des autres systÃ¨mes de rÃ©plication. Contrairement Ã  la rÃ©plication traditionnelle basÃ©e sur l'ordre d'exÃ©cution (statement-based ou row-based), Galera utilise un protocole de certification **dÃ©terministe** qui garantit la cohÃ©rence globale sans nÃ©cessiter de coordination prÃ©alable entre les nÅ“uds.

Ce modÃ¨le permet d'obtenir :
- **CohÃ©rence forte** malgrÃ© les Ã©critures concurrentes sur plusieurs nÅ“uds
- **DÃ©tection dÃ©terministe** des conflits sans communication synchrone pendant l'exÃ©cution
- **ScalabilitÃ© horizontale** des lectures et Ã©critures
- **TolÃ©rance aux pannes** avec continuitÃ© de service

L'approche certification-based rÃ©sout le problÃ¨me fondamental du multi-master : comment garantir que des transactions concurrentes sur des nÅ“uds diffÃ©rents ne violent pas la cohÃ©rence des donnÃ©es, tout en maintenant des performances acceptables.

---

## Principes fondamentaux de la certification

### DiffÃ©rence avec la rÃ©plication traditionnelle

**RÃ©plication traditionnelle (Primary-Replica) :**
```
Primary:  T1 â†’ Binlog â†’ Replica
                 â†“
          Ordre garanti par Primary
          Replica applique dans l'ordre

ProblÃ¨me: Un seul point d'Ã©criture (SPOF)
```

**Certification-based (Galera) :**
```
NÅ“ud A: T1 (local) â†’ Certification (global) â†’ Application si OK
NÅ“ud B: T2 (local) â†’ Certification (global) â†’ Application si OK
         â†“                    â†“
    Ordre global dÃ©terminÃ© par certification
    DÃ©tection de conflits automatique

Avantage: Multi-master avec cohÃ©rence garantie
```

### Le concept de "Total Order"

Galera implÃ©mente un **Total Order Broadcast** garantissant que :

1. **Tous les nÅ“uds reÃ§oivent tous les messages** (Reliability)
2. **Tous les nÅ“uds reÃ§oivent les messages dans le mÃªme ordre** (Total Order)
3. **Si un nÅ“ud dÃ©livre un message, tous les nÅ“uds connectÃ©s le dÃ©livreront** (Agreement)

```
Global Transaction Sequence:

Temps â†’  [T1] [T2] [T3] [T4] [T5] [T6]
         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
NÅ“ud A:  T1   T2   T3   T4   T5   T6
NÅ“ud B:  T1   T2   T3   T4   T5   T6
NÅ“ud C:  T1   T2   T3   T4   T5   T6

Garantie: Ordre IDENTIQUE sur tous les nÅ“uds
```

ğŸ’¡ **PropriÃ©tÃ© clÃ©** : L'ordre total permet de dÃ©tecter les conflits de maniÃ¨re dÃ©terministe sans synchronisation supplÃ©mentaire.

---

## Anatomie d'un Write-Set

### Structure dÃ©taillÃ©e

Un write-set Galera contient toutes les informations nÃ©cessaires pour certifier et appliquer une transaction :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         WRITE-SET STRUCTURE         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Header:                             â”‚
â”‚  â”œâ”€ Protocol Version                â”‚
â”‚  â”œâ”€ Flags (DDL, TOI, etc.)          â”‚
â”‚  â””â”€ Checksum                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Transaction Metadata:               â”‚
â”‚  â”œâ”€ GTID (wsrep GTID)               â”‚
â”‚  â”œâ”€ Sequence Number (seqno)         â”‚
â”‚  â”œâ”€ Origin Node UUID                â”‚
â”‚  â”œâ”€ Timestamp                       â”‚
â”‚  â””â”€ Last Committed Seqno            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Certification Keys (Write-Set Keys):â”‚
â”‚  â”œâ”€ Database.Table.PrimaryKey       â”‚
â”‚  â”œâ”€ Database.Table.UniqueKey        â”‚
â”‚  â””â”€ ... (toutes les clÃ©s modifiÃ©es) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Data Changes:                       â”‚
â”‚  â”œâ”€ Row Images (binlog format ROW)  â”‚
â”‚  â”œâ”€ Before/After values             â”‚
â”‚  â””â”€ Metadata (collations, etc.)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Dependencies:                       â”‚
â”‚  â”œâ”€ Last Seen Seqno                 â”‚
â”‚  â””â”€ Certification Dependencies      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### GÃ©nÃ©ration des clÃ©s de certification

**RÃ¨gles de gÃ©nÃ©ration des certification keys :**

```sql
-- Exemple 1: UPDATE avec PRIMARY KEY
UPDATE users SET email = 'new@email.com' WHERE id = 42;

-- ClÃ© gÃ©nÃ©rÃ©e:
-- "mydb.users.PRIMARY.42"
```

```sql
-- Exemple 2: INSERT avec PRIMARY KEY et UNIQUE KEY
INSERT INTO products (sku, name, price) 
VALUES ('PROD-123', 'Widget', 99.99);

-- ClÃ©s gÃ©nÃ©rÃ©es:
-- "mydb.products.PRIMARY.<hash_of_pk_value>"
-- "mydb.products.uk_sku.PROD-123"
```

```sql
-- Exemple 3: UPDATE sans WHERE (table scan)
UPDATE inventory SET checked = 1;

-- ClÃ© gÃ©nÃ©rÃ©e (table-level lock):
-- "mydb.inventory"
-- âš ï¸ ATTENTION: Conflit avec TOUTES les autres transactions sur cette table!
```

**Algorithme de gÃ©nÃ©ration (pseudo-code) :**

```python
def generate_certification_keys(transaction):
    """
    GÃ©nÃ¨re les clÃ©s de certification pour une transaction
    """
    keys = []
    
    for statement in transaction.statements:
        if statement.type == "INSERT":
            # ClÃ©s pour tous les index UNIQUE
            for index in statement.table.unique_indexes:
                key = f"{db}.{table}.{index.name}.{hash(index.values)}"
                keys.append(key)
                
        elif statement.type == "UPDATE":
            if statement.has_where_clause:
                # ClÃ©s pour chaque ligne modifiÃ©e
                for row in statement.affected_rows:
                    for index in statement.table.unique_indexes:
                        key = f"{db}.{table}.{index.name}.{hash(row[index])}"
                        keys.append(key)
            else:
                # Table-level key (aucun WHERE)
                key = f"{db}.{table}"
                keys.append(key)
                
        elif statement.type == "DELETE":
            # Similaire Ã  UPDATE
            for row in statement.affected_rows:
                for index in statement.table.unique_indexes:
                    key = f"{db}.{table}.{index.name}.{hash(row[index])}"
                    keys.append(key)
    
    return unique(keys)  # DÃ©dupliquer
```

ğŸ’¡ **Point critique** : La granularitÃ© des clÃ©s dÃ©termine le taux de conflits. Une table sans PRIMARY KEY gÃ©nÃ¨re des clÃ©s au niveau table, causant des conflits massifs.

---

## Processus de certification dÃ©taillÃ©

### Timeline complÃ¨te d'une transaction

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   TRANSACTION LIFECYCLE                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

NÅ“ud Origine (ex: NÅ“ud A)                 Cluster (tous les nÅ“uds)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. BEGIN                                  
   â†“
2. ExÃ©cution locale (InnoDB)
   - SELECT FOR UPDATE
   - INSERT/UPDATE/DELETE
   - Locks locaux acquis
   â†“
3. COMMIT trigger
   â†“
4. GÃ©nÃ©ration Write-Set
   - Extraction row changes
   - GÃ©nÃ©ration certification keys
   - Metadata (GTID, seqno, etc.)
   â†“
5. Broadcast Write-Set â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  RÃ©ception sur tous les nÅ“uds
   (Group Communication)                   â†“
   â†“                                      6. Certification locale
   â†“                                         - VÃ©rification conflits
   â†“                                         - Vote: PASS ou FAIL
   â†“                                         â†“
   â†“                                      7. Retour votes
   â† â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (agrÃ©gation implicite)
   â†“
8. DÃ©cision finale (origine)
   - Si majoritÃ© PASS: COMMIT local
   - Si majoritÃ© FAIL: ROLLBACK local
   â†“
9. RÃ©ponse au client â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  10. Application asynchrone
   (SUCCESS ou DEADLOCK error)              (si PASS)
                                            - Apply write-set
                                            - Update certification index
```

### Algorithme de certification (dÃ©taillÃ©)

```python
class CertificationIndex:
    """
    Index de certification maintenu sur chaque nÅ“ud
    Structure: {certification_key: [list of seqno]}
    """
    
    def __init__(self):
        self.index = {}  # key -> [seqno1, seqno2, ...]
        self.current_seqno = 0
        
    def certify(self, write_set):
        """
        Algorithme de certification d'un write-set
        
        Retourne: CERTIFICATION_PASSED ou CERTIFICATION_FAILED
        """
        conflicts = []
        
        # RÃ©cupÃ©rer le dernier seqno vu par le nÅ“ud origine
        origin_last_seen = write_set.last_seen_seqno
        
        # Pour chaque clÃ© modifiÃ©e dans le write-set
        for cert_key in write_set.certification_keys:
            
            # Chercher les transactions certifiÃ©es touchant cette clÃ©
            # depuis le dernier seqno connu du nÅ“ud origine
            conflicting_seqnos = self._get_conflicting_seqnos(
                cert_key,
                from_seqno=origin_last_seen + 1,
                to_seqno=self.current_seqno
            )
            
            if conflicting_seqnos:
                # Conflit dÃ©tectÃ©
                conflicts.append({
                    'key': cert_key,
                    'conflicting_transactions': conflicting_seqnos
                })
        
        # DÃ©cision
        if conflicts:
            # Au moins un conflit â†’ FAIL
            return CertificationResult.FAILED, conflicts
        else:
            # Pas de conflit â†’ PASS
            # Ajouter au certification index
            self._add_to_index(write_set)
            return CertificationResult.PASSED, None
    
    def _get_conflicting_seqnos(self, key, from_seqno, to_seqno):
        """
        Retourne les seqno des transactions conflictuelles
        """
        if key not in self.index:
            return []
        
        # Filtrer les seqno dans la plage
        return [
            seqno for seqno in self.index[key]
            if from_seqno <= seqno <= to_seqno
        ]
    
    def _add_to_index(self, write_set):
        """
        Ajoute le write-set au certification index
        """
        seqno = write_set.global_seqno
        
        for cert_key in write_set.certification_keys:
            if cert_key not in self.index:
                self.index[cert_key] = []
            
            self.index[cert_key].append(seqno)
        
        # Nettoyage: garder seulement les N derniers seqno
        self._purge_old_entries()
    
    def _purge_old_entries(self):
        """
        Nettoie les anciennes entrÃ©es du certification index
        BasÃ© sur wsrep_certification_rules
        """
        # Garder seulement les transactions dans la fenÃªtre
        # de certification (basÃ© sur gcache.size)
        purge_seqno = self.current_seqno - CERTIFICATION_WINDOW
        
        for key in list(self.index.keys()):
            self.index[key] = [
                seqno for seqno in self.index[key]
                if seqno > purge_seqno
            ]
            
            # Supprimer la clÃ© si plus d'entrÃ©es
            if not self.index[key]:
                del self.index[key]
```

### FenÃªtre de certification

La **certification window** dÃ©termine la portÃ©e de la vÃ©rification des conflits :

```
Timeline:
         â”‚â†â”€ Certification Window â”€â†’â”‚
         â”‚                          â”‚
   T-10  T-8  T-6  T-4  T-2  T0 â† Nouvelle transaction
    â”´     â”´    â”´    â”´    â”´    â”´
    
Seqno: 90   92   94   96   98  100

T0 (seqno=100) vÃ©rifie conflits avec:
- Transactions depuis son last_seen_seqno (ex: 95)
- Jusqu'au seqno courant (100)

Window size contrÃ´lÃ©e par gcache.size et purge
```

**Configuration de la fenÃªtre :**

```ini
# my.cnf
[galera]
# Taille du gcache (stocke les write-sets)
wsrep_provider_options = "gcache.size=2G"

# Plus gcache.size est grand:
# + Grande fenÃªtre de certification possible
# + Support de nÅ“uds retardÃ©s (IST possible)
# - Plus de mÃ©moire consommÃ©e
```

---

## Gestion des conflits et rejets

### Types de conflits

**1. Conflits de certification (Certification Failure)**

```sql
-- NÅ“ud A, T1 commence Ã  t=0
BEGIN;
SELECT balance FROM accounts WHERE id = 100 FOR UPDATE;
-- balance = 1000
UPDATE accounts SET balance = 900 WHERE id = 100;
-- COMMIT Ã  t=10

-- NÅ“ud B, T2 commence Ã  t=5
BEGIN;
SELECT balance FROM accounts WHERE id = 100 FOR UPDATE;
-- balance = 1000 (snapshot local)
UPDATE accounts SET balance = 1050 WHERE id = 100;
-- COMMIT Ã  t=12

-- Timeline de certification:
-- t=10: T1 certifiÃ©e en premier (seqno=1000) â†’ PASS
-- t=12: T2 certifiÃ©e (seqno=1001)
--       Conflit dÃ©tectÃ©: clÃ© "db.accounts.PRIMARY.100" modifiÃ©e par seqno=1000
--       â†’ FAIL â†’ ROLLBACK sur NÅ“ud B
```

**Erreur retournÃ©e au client :**
```
ERROR 1213 (40001): Deadlock found when trying to get lock; 
try restarting transaction
```

ğŸ’¡ **Point important** : Le terme "Deadlock" est trompeur. C'est en fait un conflit de certification, pas un deadlock InnoDB classique.

**2. Conflits de clÃ©s multiples**

```sql
-- Transaction modifiant plusieurs lignes
UPDATE orders 
SET status = 'shipped' 
WHERE customer_id = 42 AND status = 'pending';

-- Si 100 lignes affectÃ©es:
-- â†’ 100 certification keys gÃ©nÃ©rÃ©es
-- â†’ ProbabilitÃ© de conflit Ã— 100

-- Risque: Une seule ligne en conflit â†’ toute la transaction rejetÃ©e
```

**3. Table-level conflicts**

```sql
-- Transaction sans WHERE
UPDATE products SET last_checked = NOW();

-- ClÃ© de certification: "db.products" (niveau table)
-- Conflit avec TOUTE autre transaction sur products
-- â†’ Taux de rejet trÃ¨s Ã©levÃ© en multi-master
```

### StratÃ©gies de retry

**Pattern de retry intelligent :**

```python
import mysql.connector
from mysql.connector import errorcode
import time
import random

class GaleraTransactionRetry:
    """
    Gestionnaire de retry pour conflits Galera
    """
    
    MAX_RETRIES = 3
    DEADLOCK_ERROR = 1213
    LOCK_WAIT_TIMEOUT = 1205
    
    @staticmethod
    def execute_with_retry(connection, transaction_func, *args, **kwargs):
        """
        ExÃ©cute une transaction avec retry automatique
        
        :param connection: Connexion MySQL
        :param transaction_func: Fonction contenant la logique transactionnelle
        :return: RÃ©sultat de la fonction ou raise exception
        """
        attempt = 0
        
        while attempt < GaleraTransactionRetry.MAX_RETRIES:
            try:
                cursor = connection.cursor()
                
                # ExÃ©cuter la transaction
                result = transaction_func(cursor, *args, **kwargs)
                
                # Si succÃ¨s, commit
                connection.commit()
                cursor.close()
                
                return result
                
            except mysql.connector.Error as err:
                cursor.close()
                connection.rollback()
                
                # VÃ©rifier si c'est un conflit de certification
                if err.errno == GaleraTransactionRetry.DEADLOCK_ERROR:
                    attempt += 1
                    
                    if attempt < GaleraTransactionRetry.MAX_RETRIES:
                        # Backoff exponentiel avec jitter
                        sleep_time = (2 ** attempt) * 0.1  # 0.2s, 0.4s, 0.8s
                        jitter = random.uniform(0, 0.1)
                        time.sleep(sleep_time + jitter)
                        
                        print(f"Certification conflict, retry {attempt}/{GaleraTransactionRetry.MAX_RETRIES}")
                        continue
                    else:
                        raise Exception(f"Max retries exceeded: {err}")
                else:
                    # Autre erreur, ne pas retry
                    raise
        
        raise Exception("Transaction failed after all retries")

# Utilisation
def transfer_money(cursor, from_account, to_account, amount):
    """Transaction de transfert d'argent"""
    
    # Lecture avec verrouillage
    cursor.execute(
        "SELECT balance FROM accounts WHERE id = %s FOR UPDATE",
        (from_account,)
    )
    from_balance = cursor.fetchone()[0]
    
    cursor.execute(
        "SELECT balance FROM accounts WHERE id = %s FOR UPDATE",
        (to_account,)
    )
    to_balance = cursor.fetchone()[0]
    
    # VÃ©rification
    if from_balance < amount:
        raise ValueError("Insufficient funds")
    
    # Mise Ã  jour
    cursor.execute(
        "UPDATE accounts SET balance = balance - %s WHERE id = %s",
        (amount, from_account)
    )
    cursor.execute(
        "UPDATE accounts SET balance = balance + %s WHERE id = %s",
        (amount, to_account)
    )
    
    return True

# ExÃ©cution avec retry
try:
    connection = mysql.connector.connect(
        host='galera-node-1',
        user='app_user',
        password='password',
        database='banking'
    )
    
    GaleraTransactionRetry.execute_with_retry(
        connection,
        transfer_money,
        from_account=100,
        to_account=200,
        amount=50.0
    )
    
    print("Transfer successful")
    
except Exception as e:
    print(f"Transfer failed: {e}")
finally:
    connection.close()
```

### Monitoring des conflits

**MÃ©triques essentielles :**

```sql
-- Taux de conflits de certification
SELECT 
    VARIABLE_VALUE as bf_aborts
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'wsrep_local_bf_aborts';

-- Taux de certification (calcul)
SELECT 
    commits.VARIABLE_VALUE as total_commits,
    bf_aborts.VARIABLE_VALUE as certification_failures,
    ROUND(
        (bf_aborts.VARIABLE_VALUE / commits.VARIABLE_VALUE) * 100, 
        2
    ) as failure_rate_percent
FROM 
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'wsrep_local_commits') commits,
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'wsrep_local_bf_aborts') bf_aborts;
```

**Seuils d'alerte :**

```
Taux de certification failure:
- < 1%   : âœ… Excellent (configuration optimale)
- 1-5%   : âš ï¸  Acceptable (surveiller)
- 5-10%  : ğŸ”´ ProblÃ©matique (revoir architecture)
- > 10%  : ğŸš¨ Critique (Galera non adaptÃ© ou mal configurÃ©)
```

**Dashboard de monitoring complet :**

```sql
-- Script de monitoring Galera certification
SELECT 
    'Cluster Status' as metric,
    VARIABLE_VALUE as value
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'wsrep_cluster_status'

UNION ALL

SELECT 
    'Local Commits' as metric,
    VARIABLE_VALUE as value
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'wsrep_local_commits'

UNION ALL

SELECT 
    'BF Aborts (Certification Failures)' as metric,
    VARIABLE_VALUE as value
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'wsrep_local_bf_aborts'

UNION ALL

SELECT 
    'Cert Deps Distance (ParallÃ©lisme)' as metric,
    VARIABLE_VALUE as value
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'wsrep_cert_deps_distance'

UNION ALL

SELECT 
    'Local Recv Queue' as metric,
    VARIABLE_VALUE as value
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'wsrep_local_recv_queue'

UNION ALL

SELECT 
    'Local Send Queue' as metric,
    VARIABLE_VALUE as value
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'wsrep_local_send_queue';
```

---

## Optimisations pour rÃ©duire les conflits

### StratÃ©gie 1 : Conception de schÃ©ma optimisÃ©e

**âŒ Anti-pattern : Tables sans PRIMARY KEY**

```sql
-- MAUVAIS: Pas de PRIMARY KEY
CREATE TABLE events (
    event_name VARCHAR(100),
    event_date DATE,
    description TEXT
) ENGINE=InnoDB;

-- Impact: ClÃ©s de certification au niveau table
-- â†’ Conflits systÃ©matiques sur toute opÃ©ration
```

**âœ… Solution : Toujours utiliser PRIMARY KEY**

```sql
-- BON: PRIMARY KEY explicite
CREATE TABLE events (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    event_name VARCHAR(100),
    event_date DATE,
    description TEXT,
    UNIQUE KEY uk_event_name_date (event_name, event_date)
) ENGINE=InnoDB;

-- ClÃ©s de certification au niveau ligne
-- â†’ Conflits seulement si mÃªme ligne modifiÃ©e
```

**ğŸ’¡ Recommandation AUTO_INCREMENT :**

```sql
-- Utiliser AUTO_INCREMENT avec mode interleaved
-- (dÃ©jÃ  configurÃ©: innodb_autoinc_lock_mode=2)

-- Si besoin de sÃ©quences prÃ©visibles:
CREATE SEQUENCE order_seq START WITH 1 INCREMENT BY 1;

-- Utilisation
INSERT INTO orders (id, customer_id, total)
VALUES (NEXT VALUE FOR order_seq, 42, 99.99);
```

### StratÃ©gie 2 : RÃ©duction de la portÃ©e des transactions

**âŒ Anti-pattern : Transactions larges**

```sql
-- MAUVAIS: Transaction touchant beaucoup de lignes
BEGIN;

-- Lit 1000 lignes
SELECT * FROM orders WHERE status = 'pending' FOR UPDATE;

-- Traitement long (5 secondes)
-- ...

-- Mise Ã  jour massive
UPDATE orders SET status = 'processing' WHERE status = 'pending';

COMMIT;

-- ProblÃ¨me: 
-- - 1000 certification keys
-- - FenÃªtre d'exÃ©cution longue (5s)
-- - Haute probabilitÃ© de conflit
```

**âœ… Solution : Transactions granulaires**

```sql
-- BON: Traiter par batch de 100
DELIMITER $$

CREATE PROCEDURE process_pending_orders(batch_size INT)
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE order_id BIGINT;
    DECLARE batch_count INT DEFAULT 0;
    
    -- Cursor sur les IDs seulement
    DECLARE cur CURSOR FOR 
        SELECT id FROM orders WHERE status = 'pending' LIMIT batch_size;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    
    OPEN cur;
    
    read_loop: LOOP
        FETCH cur INTO order_id;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- Transaction individuelle par ordre
        START TRANSACTION;
        
        UPDATE orders 
        SET status = 'processing',
            processed_at = NOW()
        WHERE id = order_id 
        AND status = 'pending';
        
        COMMIT;
        
        SET batch_count = batch_count + 1;
        
        -- Micro-pause tous les 10 pour ne pas saturer
        IF batch_count % 10 = 0 THEN
            DO SLEEP(0.01);
        END IF;
    END LOOP;
    
    CLOSE cur;
    
    SELECT CONCAT('Processed ', batch_count, ' orders') as result;
END$$

DELIMITER ;

-- Utilisation
CALL process_pending_orders(1000);
```

### StratÃ©gie 3 : Sharding applicatif

**Partitionnement des Ã©critures par nÅ“ud :**

```
            LoadBalancer
                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”
         â”‚       â”‚       â”‚
      Node A   Node B   Node C
         â†“       â†“       â†“
    Region EU  Region US  Region APAC
    
Routing logic:
- Transactions EU â†’ Node A
- Transactions US â†’ Node B
- Transactions APAC â†’ Node C

BÃ©nÃ©fice: RÃ©duction drastique des conflits
```

**ImplÃ©mentation avec MaxScale (voir section 14.4) :**

```ini
# maxscale.cnf
[Shard-Router]
type=service
router=schemarouter
servers=galera-node-1,galera-node-2,galera-node-3

# Route par base de donnÃ©es
[Shard-EU]
type=service
router=readwritesplit
servers=galera-node-1
user=maxscale
password=password

[Shard-US]
type=service
router=readwritesplit
servers=galera-node-2
user=maxscale
password=password
```

**Sharding au niveau applicatif :**

```python
class GaleraNodeSelector:
    """
    SÃ©lection du nÅ“ud Galera basÃ©e sur le sharding key
    """
    
    NODES = [
        {'host': 'galera-node-1', 'region': 'EU'},
        {'host': 'galera-node-2', 'region': 'US'},
        {'host': 'galera-node-3', 'region': 'APAC'}
    ]
    
    @staticmethod
    def select_node_by_customer_region(customer_region):
        """
        Route vers le nÅ“ud de la rÃ©gion du client
        """
        for node in GaleraNodeSelector.NODES:
            if node['region'] == customer_region:
                return node['host']
        
        # Fallback: node par dÃ©faut
        return GaleraNodeSelector.NODES[0]['host']
    
    @staticmethod
    def select_node_by_hash(shard_key):
        """
        Route par hash (pour distribution Ã©quitable)
        """
        node_index = hash(shard_key) % len(GaleraNodeSelector.NODES)
        return GaleraNodeSelector.NODES[node_index]['host']

# Utilisation
customer_region = get_customer_region(customer_id)
node_host = GaleraNodeSelector.select_node_by_customer_region(customer_region)

connection = mysql.connector.connect(
    host=node_host,
    user='app_user',
    password='password',
    database='ecommerce'
)
```

### StratÃ©gie 4 : Optimisation temporelle

**Exploitation des causal reads :**

```sql
-- Par dÃ©faut, lectures non-bloquantes (pas d'attente certification)
SELECT * FROM products WHERE id = 100;

-- Lecture causale (attend certification des write-sets en cours)
-- Garantit de voir les derniÃ¨res Ã©critures certifiÃ©es
SET SESSION wsrep_sync_wait = 1;
SELECT * FROM products WHERE id = 100;

-- Ou spÃ©cifiquement par requÃªte
SELECT /*+ SET_VAR(wsrep_sync_wait=1) */ * FROM products WHERE id = 100;
```

**Niveaux de wsrep_sync_wait :**

```
wsrep_sync_wait (bitmask):
0 : DÃ©sactivÃ© (dÃ©faut, lectures Ã©ventuellement inconsistantes)
1 : READ (SELECT, SHOW)
2 : UPDATE, DELETE
4 : INSERT, REPLACE
7 : Tout (READ + UPDATE/DELETE + INSERT/REPLACE)

Configuration typique:
- OLTP: wsrep_sync_wait = 0 (performance)
- Reports: wsrep_sync_wait = 1 (cohÃ©rence lectures)
```

**Impact performance :**

```sql
-- Benchmark: Sans wsrep_sync_wait
SET SESSION wsrep_sync_wait = 0;
SELECT BENCHMARK(10000, (SELECT COUNT(*) FROM users));
-- Temps: 0.5s

-- Benchmark: Avec wsrep_sync_wait
SET SESSION wsrep_sync_wait = 1;
SELECT BENCHMARK(10000, (SELECT COUNT(*) FROM users));
-- Temps: 1.2s (+140%)

-- Conclusion: Utiliser seulement quand nÃ©cessaire
```

---

## ParallÃ©lisation de l'application des write-sets

### Multi-threaded slave applier

Galera peut appliquer les write-sets en parallÃ¨le si elles sont indÃ©pendantes :

```
Certification Index:
â”œâ”€ T1: modifie users.id=100    (seqno=1000)
â”œâ”€ T2: modifie products.id=50  (seqno=1001)
â”œâ”€ T3: modifie orders.id=200   (seqno=1002)
â””â”€ T4: modifie users.id=101    (seqno=1003)

Application parallÃ¨le possible:
Thread 1: T1 (users.100)  â”‚  Thread 2: T2 (products.50)
Thread 1: T4 (users.101)  â”‚  Thread 2: T3 (orders.200)

SÃ©quence garantie UNIQUEMENT pour les transactions touchant les mÃªmes clÃ©s
```

**Configuration du parallÃ©lisme :**

```ini
# my.cnf
[galera]
# Nombre de threads appliers
wsrep_slave_threads = 4

# Recommandation: CPU_cores / 2
# Serveur 8 cores â†’ 4 threads
# Serveur 16 cores â†’ 8 threads
# Rarement utile > 16 threads
```

**MÃ©triques de parallÃ©lisme :**

```sql
-- VÃ©rifier la distance de dÃ©pendances
-- (indicateur du parallÃ©lisme possible)
SHOW STATUS LIKE 'wsrep_cert_deps_distance';

-- Valeurs typiques:
-- < 5   : Peu de parallÃ©lisme (workload sÃ©quentiel)
-- 5-20  : ParallÃ©lisme moyen
-- > 20  : Fort parallÃ©lisme (workload bien distribuÃ©)
```

**Analyse du parallÃ©lisme effectif :**

```sql
-- Commits locaux vs reÃ§us
SELECT 
    local.VARIABLE_VALUE as local_commits,
    received.VARIABLE_VALUE as received_commits,
    replayed.VARIABLE_VALUE as replayed_commits
FROM 
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'wsrep_local_commits') local,
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'wsrep_received') received,
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'wsrep_replayed') replayed;
```

---

## Gestion des transactions DDL

### Total Order Isolation (TOI)

Les DDL sont exÃ©cutÃ©s en **Total Order Isolation**, bloquant tout le cluster :

```
Timeline DDL avec TOI:

NÅ“ud A:  [Normal ops] â†’ [DDL START] â•â•â•â•â•â•â•â•â•â• [DDL END] â†’ [Normal ops]
                              â†“
NÅ“ud B:  [Normal ops] â†â”€ [BLOCK] â•â•â•â•â•â•â•â•â•â• [DDL END] â†’ [Normal ops]
                              â†“
NÅ“ud C:  [Normal ops] â†â”€ [BLOCK] â•â•â•â•â•â•â•â•â•â• [DDL END] â†’ [Normal ops]

Tous les nÅ“uds bloquÃ©s pendant la durÃ©e du DDL le plus lent!
```

**Exemple de blocage :**

```sql
-- Sur NÅ“ud A
ALTER TABLE large_table ADD COLUMN new_col VARCHAR(100);

-- Impact sur tout le cluster:
-- - NÅ“ud A: ExÃ©cution locale (peut prendre 10 minutes)
-- - NÅ“uds B, C: BloquÃ©s, exÃ©cutent le mÃªme DDL
-- - DurÃ©e totale = temps du nÅ“ud le plus lent
-- - TOUTES les Ã©critures bloquÃ©es pendant ce temps
```

### Rolling Schema Upgrade (RSU)

Alternative Ã  TOI pour Ã©viter le blocage global :

```sql
-- Configuration par nÅ“ud
SET GLOBAL wsrep_OSU_method = 'RSU';

-- ExÃ©cution DDL
-- (seulement sur ce nÅ“ud, cluster continue)
ALTER TABLE large_table ADD COLUMN new_col VARCHAR(100);

-- Remettre en TOI aprÃ¨s
SET GLOBAL wsrep_OSU_method = 'TOI';
```

**ProcÃ©dure RSU complÃ¨te :**

```bash
# 1. Isoler un nÅ“ud du cluster (le retirer du load balancer)
# 2. Basculer en RSU
mysql -e "SET GLOBAL wsrep_OSU_method='RSU';"

# 3. ExÃ©cuter le DDL
mysql mydb < schema_change.sql

# 4. Revenir en TOI
mysql -e "SET GLOBAL wsrep_OSU_method='TOI';"

# 5. Remettre le nÅ“ud dans le load balancer

# 6. RÃ©pÃ©ter pour chaque nÅ“ud (rolling upgrade)
```

âš ï¸ **Attention RSU** :
- SchÃ©ma temporairement inconsistant entre nÅ“uds
- Incompatible avec certaines modifications (changement type de donnÃ©es)
- NÃ©cessite gestion application pour compatibilitÃ© multi-versions

ğŸ†• **MariaDB 11.8 : Non-Blocking Operations (NBO)**

```ini
# my.cnf - Nouveau mode expÃ©rimental
[galera]
wsrep_OSU_method = NBO

# Permet certains ALTER TABLE non-bloquants:
# - ADD COLUMN (avec DEFAULT)
# - DROP COLUMN
# - MODIFY COLUMN (dans certains cas)
```

**CompatibilitÃ© NBO :**

```sql
-- âœ… Compatible NBO (non-bloquant)
ALTER TABLE users ADD COLUMN preferences JSON DEFAULT NULL;
ALTER TABLE users DROP COLUMN old_field;

-- âŒ Incompatible NBO (retombe en TOI)
ALTER TABLE users MODIFY id BIGINT;  -- Changement type PK
ALTER TABLE users ADD PRIMARY KEY (new_id);
```

---

## Configuration avancÃ©e de la certification

### Tuning des paramÃ¨tres de certification

**ParamÃ¨tres critiques :**

```ini
# my.cnf
[galera]
wsrep_provider_options = "
    # === Certification Configuration ===
    
    # Taille du certification index (mÃ©moire)
    cert.log_conflicts = YES;          # Logger les conflits
    
    # Optimisation certification
    cert.optimistic_pa = YES;           # Parallel apply optimiste
    
    # === Group Communication ===
    
    # Taille gcache (historique write-sets)
    gcache.size = 4G;
    gcache.page_size = 1G;
    gcache.keep_pages_size = 2G;
    
    # Flow control
    gcs.fc_limit = 256;                 # Limite avant flow control
    gcs.fc_factor = 0.9;                # Facteur ralentissement
    gcs.fc_master_slave = YES;          # FC aussi pour lectures
    
    # Timeouts
    evs.suspect_timeout = PT5S;         # Timeout suspicion nÅ“ud
    evs.inactive_timeout = PT30S;       # Timeout inactivitÃ©
    evs.install_timeout = PT15S;        # Timeout installation view
    
    # Send windows (buffer size)
    evs.send_window = 1024;             # FenÃªtre envoi
    evs.user_send_window = 512;         # FenÃªtre utilisateur
    
    # === Auto-eviction ===
    evs.auto_evict = 10;                # Eviction aprÃ¨s N pÃ©riodes suspectes
"
```

**Calcul optimal gcache.size :**

```
Formula:
gcache.size = (write_rate_MB_per_sec * max_downtime_seconds) * 1.5

Exemple:
- Taux d'Ã©criture: 5 MB/s
- Downtime max tolÃ©rÃ©: 600s (10 minutes)
- gcache.size = (5 * 600) * 1.5 = 4500 MB â‰ˆ 4.5 GB

Arrondir Ã : 5 GB

Note: 
- Si gcache plein â†’ SST au lieu de IST (plus lent)
- Monitorer: wsrep_local_cached_downto
```

### Monitoring avancÃ© de la certification

**RequÃªte complÃ¨te de diagnostic :**

```sql
-- Vue consolidÃ©e des mÃ©triques Galera
CREATE OR REPLACE VIEW galera_certification_metrics AS
SELECT 
    -- Ã‰tat gÃ©nÃ©ral
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'wsrep_cluster_status') as cluster_status,
    
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'wsrep_local_state_comment') as node_state,
    
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'wsrep_cluster_size') as cluster_size,
    
    -- Certification
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'wsrep_local_commits') as local_commits,
    
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'wsrep_local_cert_failures') as cert_failures,
    
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'wsrep_local_bf_aborts') as bf_aborts,
    
    -- Taux de conflit
    ROUND(
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
         WHERE VARIABLE_NAME = 'wsrep_local_bf_aborts') /
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
         WHERE VARIABLE_NAME = 'wsrep_local_commits') * 100,
        2
    ) as conflict_rate_percent,
    
    -- ParallÃ©lisme
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'wsrep_cert_deps_distance') as cert_deps_distance,
    
    -- Queues
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'wsrep_local_recv_queue') as recv_queue,
    
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'wsrep_local_send_queue') as send_queue,
    
    -- Flow control
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'wsrep_flow_control_paused') as fc_paused,
    
    -- GCache
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'wsrep_local_cached_downto') as gcache_oldest_seqno,
    
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'wsrep_last_committed') as last_committed_seqno;

-- Utilisation
SELECT * FROM galera_certification_metrics;
```

**Script de monitoring Prometheus :**

```sql
-- Export pour Prometheus/Grafana
-- (via mysqld_exporter)

-- Labels pour mÃ©triques
SELECT 
    'galera_cluster_status' as metric,
    CASE VARIABLE_VALUE
        WHEN 'Primary' THEN 1
        ELSE 0
    END as value
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'wsrep_cluster_status'

UNION ALL

SELECT 
    'galera_node_ready' as metric,
    CASE VARIABLE_VALUE
        WHEN 'ON' THEN 1
        ELSE 0
    END as value
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'wsrep_ready'

UNION ALL

SELECT 
    'galera_certification_failures_total' as metric,
    CAST(VARIABLE_VALUE AS UNSIGNED) as value
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'wsrep_local_cert_failures'

UNION ALL

SELECT 
    'galera_bf_aborts_total' as metric,
    CAST(VARIABLE_VALUE AS UNSIGNED) as value
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'wsrep_local_bf_aborts';
```

---

## Troubleshooting avancÃ©

### Diagnostic des slow certifications

**Identification du problÃ¨me :**

```sql
-- VÃ©rifier le temps moyen de certification
-- (via performance_schema si activÃ©)

-- Activer timing sur events Galera
UPDATE performance_schema.setup_instruments
SET ENABLED = 'YES', TIMED = 'YES'
WHERE NAME LIKE 'wait/synch/cond/galera%'
   OR NAME LIKE 'wait/synch/mutex/galera%';

-- Analyser les temps d'attente
SELECT 
    EVENT_NAME,
    COUNT_STAR,
    SUM_TIMER_WAIT / 1000000000000 as sum_wait_seconds,
    AVG_TIMER_WAIT / 1000000000000 as avg_wait_seconds
FROM performance_schema.events_waits_summary_global_by_event_name
WHERE EVENT_NAME LIKE '%galera%'
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 20;
```

**Causes frÃ©quentes de lenteur :**

1. **Latence rÃ©seau Ã©levÃ©e**
```bash
# Tester latence inter-nÅ“uds
ping -c 100 galera-node-2

# Objectif:
# - LAN: < 1ms
# - WAN: < 20ms (acceptable)
# - > 50ms: problÃ©matique pour Galera
```

2. **NÅ“ud lent (CPU/I/O)**
```sql
-- Sur chaque nÅ“ud
SHOW STATUS LIKE 'wsrep_flow_control_paused';

-- Si > 0.1 (10%) : Ce nÅ“ud ralentit le cluster
-- Solution: Investiguer CPU/I/O sur ce nÅ“ud
```

3. **Gcache trop petit (SST au lieu de IST)**
```sql
SHOW STATUS LIKE 'wsrep_local_cached_downto';
SHOW STATUS LIKE 'wsrep_last_committed';

-- Si cached_downto loin derriÃ¨re last_committed:
-- Gcache trop petit, augmenter gcache.size
```

### RÃ©solution de split-brain (cas pathologique)

Normalement impossible grÃ¢ce au quorum, mais peut arriver avec configuration incorrecte :

```bash
# SymptÃ´me: Deux partitions Primary simultanÃ©es
# (erreur de configuration pc.bootstrap)

# Identification
# Sur chaque nÅ“ud:
mysql -e "SHOW STATUS LIKE 'wsrep_cluster_status';"

# Si plusieurs retournent "Primary" â†’ split-brain

# RÃ©solution forcÃ©e:
# 1. Identifier la partition avec le plus de nÅ“uds
# 2. Sur les autres nÅ“uds, forcer Non-Primary:
mysql -e "SET GLOBAL wsrep_provider_options='pc.bootstrap=NO';"
mysql -e "SET GLOBAL wsrep_cluster_address='gcomm://';"

# 3. Reconnecter au cluster principal:
mysql -e "SET GLOBAL wsrep_cluster_address='gcomm://node-principal-ip';"

# 4. VÃ©rifier la rÃ©unification
mysql -e "SHOW STATUS LIKE 'wsrep_cluster_size';"
```

âš ï¸ **PrÃ©vention** : Ne jamais manipuler `pc.bootstrap` manuellement sauf procÃ©dure documentÃ©e.

---

## âœ… Points clÃ©s Ã  retenir

- **Certification-based replication** : Protocole dÃ©terministe de dÃ©tection des conflits basÃ© sur les write-sets
- **Write-sets** : Contiennent GTID, certification keys (clÃ©s uniques modifiÃ©es), et donnÃ©es modifiÃ©es
- **Total Order Broadcast** : Garantit que tous les nÅ“uds reÃ§oivent les write-sets dans le mÃªme ordre global
- **Algorithme de certification** : Compare les clÃ©s du write-set avec le certification index pour dÃ©tecter les conflits
- **FenÃªtre de certification** : DÃ©terminÃ©e par gcache.size et last_seen_seqno, critique pour performance
- **Conflits de certification** : Retournent `DEADLOCK` error (1213), nÃ©cessitent retry applicatif
- **Taux de conflit acceptable** : < 5% idÃ©alement, > 10% indique problÃ¨me architectural
- **Optimisations clÃ©s** : PRIMARY KEY obligatoires, transactions courtes, sharding applicatif
- **ParallÃ©lisation** : wsrep_slave_threads permet application parallÃ¨le des write-sets indÃ©pendants
- **DDL bloquants** : TOI bloque tout le cluster, utiliser RSU/NBO pour rolling upgrades
- **ğŸ†• MariaDB 11.8 NBO** : Non-Blocking Operations expÃ©rimental pour certains ALTER TABLE
- **Monitoring essentiel** : wsrep_local_bf_aborts, wsrep_cert_deps_distance, flow_control_paused
- **Gcache dimensionnement** : write_rate Ã— max_downtime Ã— 1.5, critique pour Ã©viter SST

---

## ğŸ”— Ressources et rÃ©fÃ©rences

### Documentation officielle
- [ğŸ“– Galera Certification Based Replication](https://galeracluster.com/library/documentation/certification-based-replication.html)
- [ğŸ“– Write-Set Replication](https://galeracluster.com/library/documentation/tech-desc-introduction.html)
- [ğŸ“– Galera Status Variables](https://mariadb.com/kb/en/galera-cluster-status-variables/)
- [ğŸ“– wsrep System Variables](https://mariadb.com/kb/en/galera-cluster-system-variables/)

### Articles techniques
- [Understanding Galera Write-Sets](https://www.percona.com/blog/understanding-galera-write-sets/)
- [Galera Certification Algorithm Deep Dive](https://severalnines.com/database-blog/galera-cluster-certification-algorithm)
- [Optimizing Galera Cluster Performance](https://mariadb.com/resources/blog/optimizing-galera-cluster-performance/)

### Papers acadÃ©miques
- [Virtually Synchronous Methodology for Dynamic Service Replication](https://www.cs.cornell.edu/ken/History/VS.pdf)
- [Group Communication Protocols Under Different Failure Semantics](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.2096)

### Outils
- [Galera Arbitrator (garbd)](https://galeracluster.com/library/documentation/arbitrator.html)
- [pt-online-schema-change for Galera](https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html)
- [ClusterControl](https://severalnines.com/product/clustercontrol)

---

## â¡ï¸ Section suivante

**14.2.3 Configuration et dÃ©ploiement** : Guide pratique de mise en place d'un cluster Galera en production, depuis la prÃ©paration des serveurs jusqu'au dÃ©ploiement complet avec haute disponibilitÃ©, monitoring, et procÃ©dures opÃ©rationnelles.

Nous y couvrirons l'installation step-by-step, la configuration optimisÃ©e pour diffÃ©rents cas d'usage, le bootstrap du premier cluster, l'ajout de nÅ“uds, ainsi que les procÃ©dures de maintenance et d'upgrade.

---


â­ï¸ [Configuration et dÃ©ploiement](/14-haute-disponibilite/02.3-configuration-deploiement.md)
