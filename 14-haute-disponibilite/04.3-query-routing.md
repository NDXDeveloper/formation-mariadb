ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 14.4.3 Query Routing

> **Niveau** : Expert  
> **DurÃ©e estimÃ©e** : 5-6 heures  
> **PrÃ©requis** : Load Balancing (14.4.1), Read/Write Split (14.4.2), Expressions rÃ©guliÃ¨res, Architectures distribuÃ©es

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- MaÃ®triser les diffÃ©rents routers avancÃ©s de MaxScale
- ImplÃ©menter le routage par schÃ©ma (schemarouter)
- Configurer le routage par patterns de requÃªtes (regexfilter)
- DÃ©ployer des architectures multi-tenant avec isolation
- Mettre en place du sharding applicatif avec MaxScale
- Utiliser les filtres de requÃªtes pour sÃ©curitÃ© et audit
- Optimiser les performances avec routage intelligent
- Diagnostiquer et rÃ©soudre les problÃ¨mes de routage complexes

---

## Introduction

Le **Query Routing** avancÃ© permet de router les requÃªtes non seulement basÃ© sur le type (read/write), mais aussi sur :

- Le **schÃ©ma/base de donnÃ©es** visÃ©
- Le **contenu de la requÃªte** (patterns, tables, colonnes)
- L'**utilisateur** qui exÃ©cute la requÃªte
- L'**application** source
- La **complexitÃ©** de la requÃªte
- Des **rÃ¨gles mÃ©tier** spÃ©cifiques

Cette capacitÃ© ouvre des architectures sophistiquÃ©es impossibles avec un simple read/write split :

```
Architecture Query Routing avancÃ©:

                    MaxScale
                        â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚               â”‚               â”‚
    Database A      Database B      Database C
        â”‚               â”‚               â”‚
  â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
  â”‚           â”‚   â”‚           â”‚   â”‚           â”‚
Tenant-A    Tenant-A'  Tenant-B  Tenant-B'  Tenant-C
(Master)    (Slave)    (Master)  (Slave)    (Master)

Routage automatique par:
- tenant_a.* â†’ Database A
- tenant_b.* â†’ Database B
- tenant_c.* â†’ Database C
- Analytics queries â†’ Slaves dÃ©diÃ©s
- OLTP queries â†’ Masters
```

---

## Routers MaxScale : Vue d'ensemble

### Types de routers disponibles

| Router | Usage | Routage basÃ© sur | Cas d'usage |
|--------|-------|------------------|-------------|
| **readwritesplit** | Read/Write Split | Type requÃªte (R/W) | Production OLTP standard |
| **readconnroute** | Load Balancing | Round-robin/Least conn | Distribuer charge |
| **schemarouter** | Multi-tenant | Database/Schema | Isolation par tenant |
| **binlogrouter** | Replication | Binlog events | Replication proxy |
| **cat** | Development | Concatenation | Tests/Debug |
| **cli** | Admin | CLI commands | Administration |
| **kafkacdc** | CDC | Change Data Capture | Event streaming |
| **ğŸ†• diff** | Testing | Comparaison | Validation upgrades |

**Focus de cette section :** schemarouter, regexfilter, et combinaisons avancÃ©es.

---

## SchemaRouter : Routage par base de donnÃ©es

### Principe et architecture

Le **schemarouter** route les requÃªtes vers diffÃ©rents serveurs backend basÃ© sur la base de donnÃ©es visÃ©e :

```
Client connections:
â”œâ”€ USE tenant_a; SELECT ...  â†’ Server-A
â”œâ”€ USE tenant_b; SELECT ...  â†’ Server-B
â””â”€ USE shared_db; SELECT ... â†’ Server-Shared

Architecture:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          MaxScale SchemaRouter                 â”‚
â”‚                                                â”‚
â”‚  Mapping table:                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Database     â”‚ Target Server            â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚ tenant_a     â”‚ server-a (10.0.1.11)     â”‚   â”‚
â”‚  â”‚ tenant_b     â”‚ server-b (10.0.1.12)     â”‚   â”‚
â”‚  â”‚ tenant_c     â”‚ server-c (10.0.1.13)     â”‚   â”‚
â”‚  â”‚ shared_db    â”‚ server-shared (10.0.1.14)â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Configuration de base

**Configuration schemarouter :**

```ini
# /etc/maxscale.cnf

[maxscale]
threads = auto

#
# === Servers (par tenant) ===
#
[server-tenant-a]
type = server
address = 10.0.1.11
port = 3306
protocol = MariaDBBackend

[server-tenant-b]
type = server
address = 10.0.1.12
port = 3306
protocol = MariaDBBackend

[server-tenant-c]
type = server
address = 10.0.1.13
port = 3306
protocol = MariaDBBackend

[server-shared]
type = server
address = 10.0.1.14
port = 3306
protocol = MariaDBBackend

#
# === Monitor ===
#
[MariaDB-Monitor]
type = monitor
module = mariadbmon
servers = server-tenant-a, server-tenant-b, server-tenant-c, server-shared
user = maxscale_monitor
password = Monitor_P@ssw0rd_2024!
monitor_interval = 2000ms

#
# === SchemaRouter Service ===
#
[Schema-Router-Service]
type = service
router = schemarouter
servers = server-tenant-a, server-tenant-b, server-tenant-c, server-shared

user = maxscale_router
password = Router_P@ssw0rd_2024!

# === Options SchemaRouter ===

# Ignorer bases systÃ¨me
ignore_databases = mysql,information_schema,performance_schema

# Regex pour mapper databases â†’ servers
# Option 1: Automatique (database nommÃ© comme serveur)
# tenant_a â†’ server-tenant-a

# Option 2: Patterns explicites
ignore_databases_regex = ^(mysql|sys|information_schema|performance_schema)$

# Refresh interval pour dÃ©couverte nouveaux schemas
refresh_interval = 300s

# Permissions check
auth_all_servers = true

# Connections
max_slave_connections = 1
max_sescmd_history = 50

#
# === Listener ===
#
[Schema-Router-Listener]
type = listener
service = Schema-Router-Service
protocol = MariaDBClient
port = 3306
address = 0.0.0.0
```

### Mapping database â†’ serveur

**MÃ©thode 1: Automatique par nom**

MaxScale dÃ©tecte automatiquement les bases sur chaque serveur :

```sql
-- Sur server-tenant-a:
CREATE DATABASE tenant_a;
CREATE DATABASE tenant_a_analytics;

-- Sur server-tenant-b:
CREATE DATABASE tenant_b;

-- MaxScale dÃ©couvre et mappe:
-- tenant_a* â†’ server-tenant-a
-- tenant_b* â†’ server-tenant-b
```

**MÃ©thode 2: Configuration explicite**

```ini
[Schema-Router-Service]
router = schemarouter
servers = server-tenant-a, server-tenant-b, server-tenant-c

# Sharding rules (shard key)
shard_key = customer_id

# Mapping explicite (via fichier externe)
# shard_mapping_file = /etc/maxscale.d/shard_mapping.txt
```

**Fichier de mapping (`/etc/maxscale.d/shard_mapping.txt`) :**

```
# Format: database_pattern server_name
tenant_[0-9]+ server-tenant-a
analytics_.* server-analytics
shared_.* server-shared
```

### Utilisation pratique

**Connexion et sÃ©lection de database :**

```sql
-- Client se connecte Ã  MaxScale
mysql -h maxscale-host -u app_user -p

-- SÃ©lectionner database
USE tenant_a;
-- MaxScale route automatiquement vers server-tenant-a

-- RequÃªtes
SELECT * FROM users;
-- â†’ ExÃ©cutÃ©e sur server-tenant-a

INSERT INTO orders (total) VALUES (99.99);
-- â†’ ExÃ©cutÃ©e sur server-tenant-a

-- Changer de tenant
USE tenant_b;
-- MaxScale bascule connexion vers server-tenant-b

SELECT * FROM users;
-- â†’ ExÃ©cutÃ©e sur server-tenant-b

-- AccÃ¨s cross-database (si permis)
SELECT COUNT(*) 
FROM tenant_a.users u 
JOIN tenant_b.orders o ON u.id = o.user_id;
-- â†’ MaxScale peut router vers plusieurs serveurs
-- ou retourner erreur si cross-shard interdit
```

### Gestion des requÃªtes cross-database

**ProblÃ©matique :**

```sql
-- RequÃªte impliquant 2 databases sur serveurs diffÃ©rents
SELECT a.name, b.total
FROM tenant_a.users a
JOIN tenant_b.orders b ON a.id = b.user_id;

-- Impossible si tenant_a et tenant_b sur serveurs diffÃ©rents!
```

**Configuration pour gÃ©rer cross-database :**

```ini
[Schema-Router-Service]
router = schemarouter

# Autoriser ou interdire cross-shard queries
enable_cross_shard_queries = false
# false: Retourne erreur (recommandÃ© pour isolation stricte)
# true: MaxScale tente de rÃ©soudre (performances dÃ©gradÃ©es)

# Si enable = true, serveur par dÃ©faut pour ambiguÃ¯tÃ©
default_server = server-shared
```

**Alternative : SchÃ©ma partagÃ© pour jointures**

```
Architecture avec shared database:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Tenant-A DB  â”‚  â”‚ Tenant-B DB  â”‚  â”‚  Shared DB   â”‚
â”‚  (isolÃ©)     â”‚  â”‚  (isolÃ©)     â”‚  â”‚  (lookup)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ - orders     â”‚  â”‚ - orders     â”‚  â”‚ - users      â”‚
â”‚ - products   â”‚  â”‚ - products   â”‚  â”‚ - products   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ - categories â”‚
                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RequÃªte:
SELECT u.name, o.total
FROM shared_db.users u
JOIN tenant_a.orders o ON u.id = o.user_id;
-- Possible: users lookup dans shared_db
```

---

## Regex Filter : Routage par patterns

### Principe du regexfilter

Le **regexfilter** permet d'appliquer des actions basÃ©es sur patterns de requÃªtes :

- **Router** vers serveur spÃ©cifique
- **Bloquer** certaines requÃªtes (firewall)
- **Logger/Auditer** patterns spÃ©cifiques
- **Modifier** les requÃªtes Ã  la volÃ©e

```
RegexFilter Pipeline:

RequÃªte client
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   RegexFilter (analyse pattern)      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ Rule 1: SELECT.*large_table  â”‚   â”‚
â”‚   â”‚ â†’ Route to analytics server  â”‚   â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚   â”‚ Rule 2: DELETE.*production   â”‚   â”‚
â”‚   â”‚ â†’ DENY (sÃ©curitÃ©)            â”‚   â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚   â”‚ Rule 3: INSERT INTO audit.*  â”‚   â”‚
â”‚   â”‚ â†’ LOG to file                â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â†“
          Backend appropriÃ©
```

### Configuration regexfilter

**Configuration de base :**

```ini
# /etc/maxscale.cnf

#
# === Filter: Regex Routing ===
#
[Regex-Filter]
type = filter
module = regexfilter

# Fichier de rÃ¨gles
rules = /etc/maxscale.d/regex_rules.txt

# Logging des matches
log_match = true
log_nomatch = false

#
# === Service avec filtre ===
#
[Filtered-Service]
type = service
router = readwritesplit
servers = server1, server2, server3

user = maxscale_router
password = Router_P@ssw0rd_2024!

# Appliquer le filtre
filters = Regex-Filter
```

**Fichier de rÃ¨gles (`/etc/maxscale.d/regex_rules.txt`) :**

```regex
#
# Regex Filter Rules
# Format: <regex> <action> [options]
#

# === Routage vers serveurs spÃ©cifiques ===

# RequÃªtes analytics vers slave dÃ©diÃ©
SELECT.*FROM\s+(reports|analytics|stats).*    route    server=server-analytics

# RequÃªtes heavy vers serveur puissant
SELECT.*COUNT\(\*\).*GROUP\s+BY.*             route    server=server-heavy

# === Blocage (firewall) ===

# Interdire DELETE sans WHERE (sÃ©curitÃ©)
^DELETE\s+FROM\s+\w+\s*;?\s*$                  deny

# Interdire DROP TABLE en production
DROP\s+TABLE\s+.*                              deny

# Interdire accÃ¨s table sensible
SELECT.*FROM\s+passwords.*                     deny

# === Logging/Audit ===

# Logger toutes modifications sur table audit
(INSERT|UPDATE|DELETE).*\s+audit_log.*        log

# Logger accÃ¨s donnÃ©es sensibles
SELECT.*FROM\s+(users|customers|payments).*   log

# === Modification de requÃªtes ===

# Ajouter LIMIT si absent (protection)
^SELECT.*(?!LIMIT)$                            match    replace=LIMIT 1000

# Forcer READ UNCOMMITTED pour analytics (performance)
SELECT.*FROM\s+large_table.*                   match    replace=SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```

**Actions disponibles :**

| Action | Description | Exemple |
|--------|-------------|---------|
| **route** | Router vers serveur spÃ©cifique | `route server=server-analytics` |
| **deny** | Bloquer la requÃªte | `deny` |
| **allow** | Autoriser explicitement | `allow` |
| **log** | Logger dans fichier | `log file=/var/log/maxscale/audit.log` |
| **match** | Match et continuer | `match` |
| **replace** | Remplacer pattern | `replace=LIMIT 1000` |

### Cas d'usage avancÃ©s regexfilter

**Use case 1: Query Firewall**

```regex
# /etc/maxscale.d/security_rules.txt

# Bloquer injections SQL classiques
.*;.*--.*                                      deny
.*UNION.*SELECT.*                              deny
.*OR\s+1\s*=\s*1.*                            deny
.*exec\(.*                                     deny

# Bloquer modifications masse sans WHERE
^UPDATE\s+\w+\s+SET\s+.*(?!WHERE).*$          deny
^DELETE\s+FROM\s+\w+\s*(?!WHERE).*$           deny

# Bloquer DDL en production (sauf admin)
(CREATE|ALTER|DROP)\s+(TABLE|DATABASE).*      deny    user!=admin

# Limiter taille rÃ©sultats
SELECT.*(?!LIMIT)(?!WHERE\s+id\s*=).*         match   replace=LIMIT 10000
```

**Use case 2: Multi-tier routing**

```regex
# Router requÃªtes selon complexitÃ©

# Tier 1: RequÃªtes simples â†’ Fast slaves
^SELECT\s+\*\s+FROM\s+\w+\s+WHERE\s+id\s*=.*  route   server=fast-slave-pool

# Tier 2: RequÃªtes moyennes â†’ Standard slaves  
^SELECT.*JOIN.*(?!GROUP).*                     route   server=standard-slave-pool

# Tier 3: RequÃªtes complexes â†’ Analytics cluster
SELECT.*GROUP\s+BY.*HAVING.*                   route   server=analytics-cluster
SELECT.*COUNT\(\*\).*JOIN.*JOIN.*              route   server=analytics-cluster

# Tier 4: Aggregations lourdes â†’ OLAP database
SELECT.*SUM\(.*\).*FROM.*\s+WHERE.*YEAR.*     route   server=olap-database
```

**Use case 3: Audit et compliance**

```regex
# Logging accÃ¨s donnÃ©es RGPD

# Logger accÃ¨s donnÃ©es personnelles
SELECT.*FROM\s+(users|customers|addresses).*  log     file=/var/log/maxscale/gdpr_access.log
SELECT.*(email|phone|address|ssn).*           log     file=/var/log/maxscale/pii_access.log

# Logger modifications critiques
(INSERT|UPDATE|DELETE).*\s+(payments|transactions).* log file=/var/log/maxscale/financial.log

# Logger avec metadata
SELECT.*FROM\s+audit_.*                        log     file=/var/log/maxscale/audit.log include_user=true include_timestamp=true
```

---

## Combinaison de routers et filtres

### Architecture hybride

**Combiner schemarouter + regexfilter + readwritesplit :**

```
MaxScale Pipeline:

Client Request
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. RegexFilter (Security)      â”‚
â”‚     - Block dangerous queries   â”‚
â”‚     - Log sensitive access      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. SchemaRouter                â”‚
â”‚     - Route by database         â”‚
â”‚     - tenant_a â†’ server-a       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. ReadWriteSplit              â”‚
â”‚     - Read â†’ Slaves             â”‚
â”‚     - Write â†’ Master            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â†“
          Backend Servers
```

**Configuration :**

```ini
# Filtres en cascade
[Security-Filter]
type = filter
module = regexfilter
rules = /etc/maxscale.d/security_rules.txt

[Audit-Filter]
type = filter
module = regexfilter
rules = /etc/maxscale.d/audit_rules.txt

# Service combinÃ©
[Multi-Tier-Service]
type = service
router = readwritesplit
servers = server1, server2, server3

user = maxscale_router
password = Router_P@ssw0rd_2024!

# ChaÃ®ne de filtres (ordre important!)
filters = Security-Filter, Audit-Filter

# Order of execution:
# Request â†’ Security-Filter â†’ Audit-Filter â†’ Router â†’ Backend
```

### Routage conditionnel avancÃ©

**Router personnalisÃ© avec Lua :**

MaxScale supporte scripts Lua pour logique de routage custom :

```lua
-- /etc/maxscale.d/custom_router.lua
-- Lua script pour routage avancÃ©

function route_query(query, session)
    -- Extraire metadata
    local user = session:get_user()
    local db = session:get_database()
    local client_ip = session:get_client_ip()
    
    -- Logique de routage
    if user == "analytics_user" then
        -- Utilisateur analytics â†’ Cluster OLAP
        return "olap-cluster"
    
    elseif db:match("^tenant_") then
        -- Multi-tenant routing
        local tenant_id = db:match("^tenant_(%d+)")
        local shard_id = tenant_id % 3  -- Modulo sharding
        return "shard-" .. shard_id
    
    elseif query:match("SELECT.*COUNT%(%*%).*") then
        -- Heavy aggregation â†’ Analytics
        return "analytics-server"
    
    elseif client_ip:match("^10%.0%.1%.") then
        -- Internal network â†’ Low latency servers
        return "internal-pool"
    
    else
        -- Default routing
        return "default-pool"
    end
end
```

**Configuration Lua router :**

```ini
[Lua-Router-Filter]
type = filter
module = luafilter
script = /etc/maxscale.d/custom_router.lua
```

---

## ğŸ†• MaxScale 25.01 : NouveautÃ©s Query Routing

### ğŸ†• Workload Capture pour analyse

**Capturer le workload pour analyse patterns :**

```ini
# Service avec capture
[Production-Service]
type = service
router = readwritesplit
servers = server1, server2, server3

# ğŸ†• Workload Capture
workload_capture = true
workload_capture_file = /var/lib/maxscale/workload_$(date +%Y%m%d_%H%M%S).log

# DurÃ©e de capture
workload_capture_duration = 3600s  # 1 heure

# Ã‰chantillonnage (% de requÃªtes)
workload_capture_sample_rate = 100  # 100% = tout capturer

# Filtres
workload_capture_query_types = SELECT,INSERT,UPDATE,DELETE
workload_capture_min_duration = 100ms  # Seulement requÃªtes >100ms

# Capture metadata
workload_capture_include_metadata = true
# - timestamp
# - user
# - database
# - execution time
# - rows affected
```

**Format du fichier de capture :**

```json
// /var/lib/maxscale/workload_20241215_140000.log
{
  "timestamp": "2024-12-15T14:00:01.234Z",
  "user": "app_user",
  "database": "tenant_a",
  "query": "SELECT * FROM users WHERE id = 123",
  "query_type": "SELECT",
  "execution_time_ms": 12.5,
  "rows_returned": 1,
  "server": "server1"
},
{
  "timestamp": "2024-12-15T14:00:01.456Z",
  "user": "app_user",
  "database": "tenant_a",
  "query": "UPDATE users SET last_login = NOW() WHERE id = 123",
  "query_type": "UPDATE",
  "execution_time_ms": 8.3,
  "rows_affected": 1,
  "server": "server1"
}
```

### ğŸ†• Workload Replay pour tests

**Rejouer workload capturÃ© pour tests :**

```bash
# Outil de replay (MaxScale 25.01)
maxscale-workload-replay \
    --input /var/lib/maxscale/workload_20241215_140000.log \
    --target maxscale-test:3306 \
    --user test_user \
    --password test_pass \
    --database test_db \
    --replay-speed 1.0 \
    --concurrency 10 \
    --report /tmp/replay_report.txt

# Options:
# --replay-speed: 1.0 = vitesse rÃ©elle, 2.0 = 2x plus rapide, 0.5 = 2x plus lent
# --concurrency: Nombre de threads parallÃ¨les
# --duration: Limiter durÃ©e replay
# --loop: Rejouer en boucle
```

**Use cases Workload Replay :**

1. **Validation upgrade MariaDB**
```bash
# Capturer prod (MariaDB 10.11)
# Rejouer sur test (MariaDB 11.8)
# Comparer rÃ©sultats et performance
```

2. **Test nouvelles configurations MaxScale**
```bash
# Capture prod config A
# Replay sur test config B
# Comparer latence, throughput
```

3. **Benchmark infrastructure**
```bash
# Capture prod (serveurs X)
# Replay sur nouveaux serveurs Y
# Valider migration hardware
```

### ğŸ†• Diff Router pour comparaison

**Comparer rÃ©sultats entre 2 backends :**

```ini
# ğŸ†• Diff Router - MaxScale 25.01
[Diff-Service]
type = service
router = diff

# Backend primaire (production)
primary_server = server-prod-11.8

# Backend secondaire (test upgrade)
secondary_server = server-test-12.0

user = maxscale_router
password = Router_P@ssw0rd_2024!

# === Diff Configuration ===

# Mode de comparaison
diff_mode = results
# Options:
# - results: Compare rÃ©sultats des requÃªtes
# - performance: Compare temps d'exÃ©cution
# - both: Les deux

# TolÃ©rance diffÃ©rences
diff_tolerance = 0.001  # 0.1% diffÃ©rence acceptÃ©e (floats)

# Logging
diff_log_file = /var/log/maxscale/diff.log
diff_log_threshold = 1  # Log si â‰¥1 diffÃ©rence

# Format log
diff_log_format = json
# Options: text, json, csv

# Seulement certaines requÃªtes
diff_query_types = SELECT,INSERT,UPDATE

# Ignorer certaines diffÃ©rences
diff_ignore_columns = created_at,updated_at  # Timestamps variables
diff_ignore_order = true  # Ignorer ordre rÃ©sultats
```

**Output du Diff Router :**

```json
// /var/log/maxscale/diff.log
{
  "timestamp": "2024-12-15T14:30:00Z",
  "query": "SELECT * FROM users WHERE status = 'active'",
  "primary": {
    "server": "server-prod-11.8",
    "execution_time_ms": 12.5,
    "rows_returned": 150,
    "checksum": "a1b2c3d4"
  },
  "secondary": {
    "server": "server-test-12.0",
    "execution_time_ms": 10.2,
    "rows_returned": 150,
    "checksum": "a1b2c3d4"
  },
  "differences": {
    "results": "MATCH",
    "performance_delta_ms": -2.3,
    "performance_improvement": "18.4%"
  }
}
```

**Use case : Validation upgrade MariaDB 11.8 â†’ 12.0**

```
Architecture de test:

Applications (readonly traffic) â†’ MaxScale Diff Router
                                      â†“         â†“
                                  Prod 11.8  Test 12.0
                                  
MaxScale:
1. Envoie chaque requÃªte aux 2 serveurs
2. Compare rÃ©sultats
3. Log diffÃ©rences
4. Retourne rÃ©sultat de Prod au client

AprÃ¨s analyse logs:
- 99.9% requÃªtes: rÃ©sultats identiques âœ…
- 0.1% requÃªtes: diffÃ©rences dÃ©tectÃ©es
  â†’ Investiguer incompatibilitÃ©s
```

---

## Architectures multi-tenant avancÃ©es

### Pattern 1: Database-per-tenant

**Architecture :**

```
Tenant isolation par database:

MaxScale SchemaRouter
    â”‚
    â”œâ”€ tenant_001 â†’ Server-Shard-1
    â”œâ”€ tenant_002 â†’ Server-Shard-1
    â”œâ”€ tenant_003 â†’ Server-Shard-2
    â”œâ”€ tenant_004 â†’ Server-Shard-2
    â””â”€ tenant_005 â†’ Server-Shard-3

Sharding: tenant_id % num_shards
```

**Configuration :**

```ini
[Tenant-Service]
router = schemarouter
servers = shard-1, shard-2, shard-3

# DÃ©couverte automatique databases
refresh_interval = 60s

# Isolation stricte
enable_cross_shard_queries = false

# Cache mapping
refresh_databases = true
```

**Provisioning nouveau tenant :**

```bash
#!/bin/bash
# provision-tenant.sh

TENANT_ID=$1
NUM_SHARDS=3

# Calculer shard
SHARD_ID=$((TENANT_ID % NUM_SHARDS + 1))
SHARD_SERVER="shard-${SHARD_ID}"

# CrÃ©er database
mysql -h $SHARD_SERVER -e "CREATE DATABASE tenant_${TENANT_ID};"

# Provisionner schÃ©ma
mysql -h $SHARD_SERVER tenant_${TENANT_ID} < schema.sql

# Refresh MaxScale
maxctrl call command schemarouter refresh Tenant-Service

echo "Tenant ${TENANT_ID} provisionnÃ© sur ${SHARD_SERVER}"
```

### Pattern 2: Row-level multi-tenancy avec routing

**Architecture :**

```
Shared database avec tenant_id:

Table: users
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ id      â”‚ tenant_idâ”‚ name â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1       â”‚ 100      â”‚ John â”‚
â”‚ 2       â”‚ 200      â”‚ Jane â”‚
â”‚ 3       â”‚ 100      â”‚ Bob  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜

Routing par tenant_id:
- tenant_id 1-999   â†’ Shard-1
- tenant_id 1000-1999 â†’ Shard-2
- tenant_id 2000+    â†’ Shard-3
```

**Configuration avec Lua :**

```lua
-- row_level_routing.lua
function route_query(query, session)
    -- Extraire tenant_id du contexte session
    local tenant_id = session:get_variable("@tenant_id")
    
    if tenant_id == nil then
        -- Forcer dÃ©finition tenant_id
        return "error", "Set @tenant_id before querying"
    end
    
    -- Sharding logic
    if tenant_id < 1000 then
        return "shard-1"
    elseif tenant_id < 2000 then
        return "shard-2"
    else
        return "shard-3"
    end
end
```

**Utilisation application :**

```python
# Python application
import mysql.connector

conn = mysql.connector.connect(
    host='maxscale-host',
    user='app_user',
    password='password',
    database='shared_db'
)

cursor = conn.cursor()

# DÃ©finir tenant_id pour la session
tenant_id = get_current_tenant_id()  # Ex: 1234
cursor.execute(f"SET @tenant_id = {tenant_id}")

# RequÃªtes routÃ©es automatiquement vers bon shard
cursor.execute("SELECT * FROM users WHERE tenant_id = @tenant_id")

# MaxScale route vers shard-2 (tenant_id 1234 dans range 1000-1999)
```

### Pattern 3: Hybrid tenant isolation

**Architecture combinÃ©e :**

```
Tier 1: Premium tenants (database dÃ©diÃ©e)
â”œâ”€ tenant_premium_001 â†’ Dedicated Server 1
â”œâ”€ tenant_premium_002 â†’ Dedicated Server 2
â””â”€ tenant_premium_003 â†’ Dedicated Server 3

Tier 2: Standard tenants (sharded)
â”œâ”€ tenant_std_* (1-1000) â†’ Shard-1
â”œâ”€ tenant_std_* (1001-2000) â†’ Shard-2
â””â”€ tenant_std_* (2001+) â†’ Shard-3

Tier 3: Free tenants (shared mega-database)
â””â”€ tenant_free_* â†’ Shared-DB (row-level isolation)
```

**Configuration MaxScale multi-tier :**

```ini
[Premium-Service]
router = schemarouter
servers = dedicated-1, dedicated-2, dedicated-3
# Tenant premium databases

[Standard-Service]
router = schemarouter
servers = shard-1, shard-2, shard-3
# Tenant standard databases

[Free-Service]
router = readwritesplit
servers = shared-db-master, shared-db-slave-1, shared-db-slave-2
# Shared database pour free tier

# Router principal qui dispatche
[Multi-Tier-Router]
type = service
router = schemarouter

# Regex pour identifier tier
# tenant_premium_* â†’ Premium-Service
# tenant_std_* â†’ Standard-Service  
# tenant_free_* â†’ Free-Service (row-level)
```

---

## Monitoring et diagnostic

### MÃ©triques query routing

**Commandes maxctrl :**

```bash
# Statistiques router
maxctrl show service Schema-Router-Service

# Output:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Parameter                   â”‚ Value            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Router                      â”‚ schemarouter     â”‚
â”‚ Databases Discovered        â”‚ 156              â”‚
â”‚ Servers Active              â”‚ 3                â”‚
â”‚ Queries Routed              â”‚ 1,234,567        â”‚
â”‚ Routing Errors              â”‚ 23               â”‚
â”‚ Cross-Shard Denials         â”‚ 45               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

# Mapping database â†’ server
maxctrl call command schemarouter show Schema-Router-Service

# Statistiques regex filter
maxctrl call command regexfilter stats Security-Filter

# Output:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Rule            â”‚ Matches  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ deny-delete-all â”‚ 12       â”‚
â”‚ route-analytics â”‚ 3,456    â”‚
â”‚ log-sensitive   â”‚ 789      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Analyse des logs de routing

**Activer logging dÃ©taillÃ© :**

```ini
[Schema-Router-Service]
router = schemarouter
# ...

# Logging
log_info = true
log_debug = false  # Seulement si debug nÃ©cessaire (verbeux!)
```

**Logs typiques :**

```
# /var/log/maxscale/maxscale.log

[INFO] schemarouter: Database 'tenant_123' mapped to server 'shard-2'
[INFO] schemarouter: Query 'SELECT * FROM users' routed to shard-2
[WARNING] schemarouter: Cross-shard query detected: denied
[ERROR] schemarouter: Database 'unknown_db' not found in mapping
```

### Troubleshooting problÃ¨mes de routing

**ProblÃ¨me 1: RequÃªtes non routÃ©es**

```bash
# SymptÃ´me: Erreur "No suitable server found"

# Diagnostic
maxctrl show service Schema-Router-Service
# VÃ©rifier "Servers Active"

# Si 0 serveurs actifs:
maxctrl list servers
# VÃ©rifier Ã©tat des backends

# Solution
# 1. VÃ©rifier connectivitÃ©
ping server-shard-1
mysql -h server-shard-1 -u maxscale_router -p

# 2. VÃ©rifier monitor
maxctrl show monitor MariaDB-Monitor

# 3. Refresh discovery
maxctrl call command schemarouter refresh Schema-Router-Service
```

**ProblÃ¨me 2: Mauvais mapping database â†’ serveur**

```bash
# SymptÃ´me: RequÃªte routÃ©e vers mauvais serveur

# Diagnostic: VÃ©rifier mapping
maxctrl call command schemarouter show Schema-Router-Service | grep tenant_123

# Si incorrect:
# 1. VÃ©rifier nom database exact
mysql -h server-shard-2 -e "SHOW DATABASES LIKE 'tenant_%';"

# 2. Forcer refresh
maxctrl call command schemarouter refresh Schema-Router-Service

# 3. VÃ©rifier regex rules si utilisÃ©es
cat /etc/maxscale.d/shard_mapping.txt
```

**ProblÃ¨me 3: Regex filter ne matche pas**

```bash
# Tester regex filter
maxctrl call command regexfilter test Security-Filter "DELETE FROM users"

# Output:
# Rule: deny-delete-all
# Action: DENY
# Match: YES

# Si pas de match alors que attendu:
# 1. VÃ©rifier syntaxe regex
# 2. Escape special characters
# 3. Test avec regex101.com

# Reload rules aprÃ¨s modification
maxctrl call command regexfilter reload Security-Filter
```

---

## Optimisations de performance

### Cache de metadata

```ini
[Schema-Router-Service]
router = schemarouter

# Cache discovery
refresh_interval = 300s  # Refresh toutes les 5min

# Cache en mÃ©moire
cache_databases = true
cache_database_ttl = 3600s  # 1 heure

# RÃ©duire overhead discovery
discover_databases_on_demand = true
# DÃ©couvre database seulement si USE <db> reÃ§u
```

### Connection pooling per shard

```ini
[Schema-Router-Service]
router = schemarouter
servers = shard-1, shard-2, shard-3

# Pool par shard
max_connections = 1000  # Total MaxScale

# Limite par backend
# Automatiquement: 1000 / 3 shards â‰ˆ 333 connexions par shard

# Connection reuse
connection_keepalive = 300s
```

### Query optimization hints

**Hints MaxScale pour query routing :**

```sql
-- Forcer shard spÃ©cifique
SELECT /* maxscale route to server shard-2 */ * FROM users;

-- Forcer database
SELECT /* maxscale use database tenant_123 */ * FROM users;

-- Bypass cache
SELECT /* maxscale nocache */ * FROM users;

-- Logging debug
SELECT /* maxscale debug */ * FROM users;
-- Log dÃ©taillÃ© de cette requÃªte dans maxscale.log
```

---

## âœ… Points clÃ©s Ã  retenir

- **Query Routing avancÃ©** : Route requÃªtes par database, pattern, utilisateur, complexitÃ© - au-delÃ  du simple read/write split
- **SchemaRouter** : Isolation multi-tenant par database, dÃ©couverte automatique, mapping flexible, cross-shard contrÃ´lable
- **RegexFilter** : Firewall SQL, audit, routing conditionnel par patterns, modification requÃªtes Ã  la volÃ©e
- **Combinaison filtres** : Pipeline Security â†’ Audit â†’ Router pour architecture sophistiquÃ©e
- **Lua scripting** : Logique de routage custom impossible avec configuration statique
- **ğŸ†• Workload Capture** : Enregistrement trafic production pour analyse et tests (MaxScale 25.01)
- **ğŸ†• Workload Replay** : Rejeu workload capturÃ© pour validation upgrades, benchmarks (MaxScale 25.01)
- **ğŸ†• Diff Router** : Comparaison rÃ©sultats entre 2 backends pour validation migrations (MaxScale 25.01)
- **Multi-tenant patterns** : Database-per-tenant (isolation forte), row-level (shared DB), hybrid tiers
- **Sharding** : Distribution tenants sur N shards via modulo, regex, ou Lua custom
- **Performance** : Cache metadata, connection pooling per shard, discover on-demand
- **Monitoring** : maxctrl show service, logs dÃ©taillÃ©s si troubleshooting, stats regex filter

---

## ğŸ”— Ressources et rÃ©fÃ©rences

### Documentation officielle MaxScale
- [ğŸ“– SchemaRouter](https://mariadb.com/kb/en/mariadb-maxscale-25-schemarouter/)
- [ğŸ“– RegexFilter](https://mariadb.com/kb/en/mariadb-maxscale-25-regex-filter/)
- [ğŸ“– LuaFilter](https://mariadb.com/kb/en/mariadb-maxscale-25-luafilter/)
- [ğŸ“– Query Routing](https://mariadb.com/docs/server/architecture/components/maxscale/routers/)

### NouveautÃ©s MaxScale 25.01
- [ğŸ†• Workload Capture](https://mariadb.com/docs/server/operations/workload-testing/capture/)
- [ğŸ†• Workload Replay](https://mariadb.com/docs/server/operations/workload-testing/replay/)
- [ğŸ†• Diff Router](https://mariadb.com/docs/server/architecture/components/maxscale/diff-router/)

### Guides techniques
- [Multi-Tenant Architectures with MaxScale](https://mariadb.com/resources/blog/multi-tenant-architectures-maxscale/)
- [Sharding Strategies](https://severalnines.com/database-blog/sharding-strategies-maxscale/)
- [Query Firewall Patterns](https://mariadb.com/resources/blog/database-firewall-maxscale/)

### Patterns d'architecture
- [Database Sharding at Scale](https://www.slideshare.net/MySQL/mysql-sharding-at-facebook)
- [Multi-Tenancy Patterns](https://docs.microsoft.com/en-us/azure/architecture/guide/multitenant/considerations/tenancy-models)

---

## â¡ï¸ Section suivante

**14.4.4 Database Firewall** : SÃ©curisation avancÃ©e avec MaxScale, protection contre injections SQL, whitelist/blacklist de requÃªtes, limitation par utilisateur/IP/temps, audit de sÃ©curitÃ©, et intÃ©gration avec systÃ¨mes SIEM.

---


â­ï¸ [Database Firewall](/14-haute-disponibilite/04.4-database-firewall.md)
