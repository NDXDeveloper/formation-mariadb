ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 14.4.2 Read/Write Split

> **Niveau** : Expert  
> **DurÃ©e estimÃ©e** : 5-6 heures  
> **PrÃ©requis** : Load Balancing (14.4.1), RÃ©plication (13), Galera Cluster (14.2), SQL avancÃ©

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre l'architecture Read/Write Split et ses bÃ©nÃ©fices
- Configurer le router readwritesplit de MaxScale
- MaÃ®triser les rÃ¨gles de routage automatique des requÃªtes
- GÃ©rer la consistance des lectures (causal reads, hints)
- Optimiser les performances avec sÃ©paration lecture/Ã©criture
- ImplÃ©menter des stratÃ©gies avancÃ©es de session management
- Diagnostiquer et rÃ©soudre les problÃ¨mes de routage
- Utiliser les nouveautÃ©s MaxScale 25.01 pour Read/Write Split

---

## Introduction

Le **Read/Write Split** est une technique d'optimisation qui consiste Ã  router automatiquement :
- Les **requÃªtes d'Ã©criture** (INSERT, UPDATE, DELETE) vers un nÅ“ud Master
- Les **requÃªtes de lecture** (SELECT) vers des nÅ“uds Slaves/Replicas

Cette sÃ©paration permet d'exploiter pleinement une architecture rÃ©pliquÃ©e en :

```
Avant Read/Write Split:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Application  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ Toutes les requÃªtes (R+W)
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     RÃ©plication    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Master     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚   Slave      â”‚
â”‚  (OLTP)      â”‚                    â”‚  (inutilisÃ©) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   CPU: 80%                            CPU: 5%
   â†‘ Goulot d'Ã©tranglement            â†‘ Ressources gaspillÃ©es

Avec Read/Write Split:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Application  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ RequÃªtes (R+W)
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    MaxScale      â”‚
â”‚  ReadWriteSplit  â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”˜
    â”‚          â”‚
    â”‚ Writes   â”‚ Reads (80% des requÃªtes)
    â†“          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Master  â”‚  â”‚ Slave-1 â”‚  â”‚ Slave-2 â”‚
â”‚ (Write) â”‚  â”‚ (Read)  â”‚  â”‚ (Read)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 CPU: 30%     CPU: 40%     CPU: 40%
 â†‘ Charge Ã©quilibrÃ©e sur 3 nÅ“uds
```

**BÃ©nÃ©fices mesurables :**
- **Performance** : Scaling horizontal des lectures (70-90% des workloads OLTP)
- **DisponibilitÃ©** : Failover automatique Master â†’ Slave
- **CoÃ»t** : Meilleure utilisation ressources, rÃ©duction besoins scaling vertical
- **Transparence** : Aucune modification applicative requise

---

## Architecture Read/Write Split avec MaxScale

### Topologie Master-Slaves

**Architecture classique :**

```
                    MaxScale
                        â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚             â”‚             â”‚
          â”‚ Writes      â”‚ Reads       â”‚ Reads
          â†“             â†“             â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Master   â”‚  â”‚ Slave-1  â”‚   â”‚ Slave-2  â”‚
    â”‚ (Primary)â”‚  â”‚ (Replica)â”‚   â”‚ (Replica)â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚              â”‚              â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              Async Replication
```

**Avec Galera Cluster (multi-master) :**

```
                    MaxScale
                        â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚             â”‚             â”‚
          â”‚ Writes      â”‚ Reads       â”‚ Reads
          â†“             â†“             â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚galera-01 â”‚  â”‚galera-02 â”‚   â”‚galera-03 â”‚
    â”‚ (Master) â”‚  â”‚ (Slave)  â”‚   â”‚ (Slave)  â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚              â”‚              â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           Galera Sync Replication
           (tous capables R+W)

Note: Avec Galera, la dÃ©signation Master/Slave est logique
      pour MaxScale, pas une limitation technique
```

### Composants du readwritesplit router

**Architecture interne MaxScale :**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              MaxScale ReadWriteSplit Router                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚         Query Classifier (Parser)                  â”‚     â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚     â”‚
â”‚  â”‚  â”‚ Analyse requÃªte SQL:                         â”‚  â”‚     â”‚
â”‚  â”‚  â”‚ - Type: SELECT / INSERT / UPDATE / DELETE    â”‚  â”‚     â”‚
â”‚  â”‚  â”‚ - Transaction: BEGIN / COMMIT / ROLLBACK     â”‚  â”‚     â”‚
â”‚  â”‚  â”‚ - Functions: NOW(), LAST_INSERT_ID()         â”‚  â”‚     â”‚
â”‚  â”‚  â”‚ - Locks: FOR UPDATE, LOCK IN SHARE MODE      â”‚  â”‚     â”‚
â”‚  â”‚  â”‚ - DDL: CREATE, ALTER, DROP                   â”‚  â”‚     â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                         â†“                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚         Routing Decision Engine                    â”‚     â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚     â”‚
â”‚  â”‚  â”‚ RÃ¨gles de routage:                           â”‚  â”‚     â”‚
â”‚  â”‚  â”‚ - SELECT sans FOR UPDATE â†’ Slave             â”‚  â”‚     â”‚
â”‚  â”‚  â”‚ - SELECT FOR UPDATE â†’ Master                 â”‚  â”‚     â”‚
â”‚  â”‚  â”‚ - INSERT/UPDATE/DELETE â†’ Master              â”‚  â”‚     â”‚
â”‚  â”‚  â”‚ - Transactions â†’ Master (sticky)             â”‚  â”‚     â”‚
â”‚  â”‚  â”‚ - Session vars/temp tables â†’ Master (sticky) â”‚  â”‚     â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                         â†“                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚         Session Management                         â”‚     â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚     â”‚
â”‚  â”‚  â”‚ - Connection pooling                         â”‚  â”‚     â”‚
â”‚  â”‚  â”‚ - Session commands history                   â”‚  â”‚     â”‚
â”‚  â”‚  â”‚ - Transaction state tracking                 â”‚  â”‚     â”‚
â”‚  â”‚  â”‚ - Prepared statements mapping                â”‚  â”‚     â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Configuration readwritesplit

### Configuration de base

**Fichier /etc/maxscale.cnf :**

```ini
# /etc/maxscale.cnf - Read/Write Split Configuration

[maxscale]
threads = auto
log_info = false

#
# === Servers ===
#
[server1]
type = server
address = 10.0.1.11
port = 3306
protocol = MariaDBBackend

[server2]
type = server
address = 10.0.1.12
port = 3306
protocol = MariaDBBackend

[server3]
type = server
address = 10.0.1.13
port = 3306
protocol = MariaDBBackend

#
# === Monitor (MariaDB Replication) ===
#
[MariaDB-Monitor]
type = monitor
module = mariadbmon
servers = server1, server2, server3
user = maxscale_monitor
password = Monitor_P@ssw0rd_2024!
monitor_interval = 2000ms

# Auto-failover (promote slave to master)
auto_failover = true
auto_rejoin = true

# Timeouts
backend_connect_timeout = 3s
backend_read_timeout = 3s
backend_write_timeout = 3s

#
# === Service (Read/Write Split) ===
#
[Read-Write-Service]
type = service
router = readwritesplit
servers = server1, server2, server3

# Credentials
user = maxscale_router
password = Router_P@ssw0rd_2024!

# === Core Settings ===

# Route lectures vers slaves, Ã©critures vers master
use_sql_variables_in = master
# Options: all (moins performant), master (recommandÃ©)

# Nombre max de connexions slaves par session client
max_slave_connections = 100%
# Options: <number> ou <percentage>

# Retry sur slaves en cas d'Ã©chec
slave_connections_retries = 3

# === Session Consistency ===

# Attendre rÃ©plication avant lecture sur slave
# (rÃ©sout read-after-write inconsistency)
causal_reads = false
# Note: Impact performance, activer seulement si nÃ©cessaire

# Timeout pour causal reads
causal_reads_timeout = 10s

# === Transaction Handling ===

# Sticky session pendant transactions
transaction_replay = true
transaction_replay_max_size = 10M
transaction_replay_attempts = 3

# Toutes requÃªtes d'une transaction sur master
transaction_replay_retry_on_mismatch = true

# === Failover ===

# Comportement si master Ã©choue
master_failure_mode = fail_on_write
# Options:
# - fail_on_write: Ã©chec seulement sur write
# - fail_instantly: Ã©chec immÃ©diat toutes requÃªtes
# - error_on_write: erreur mais garde connexion

# Reconnexion auto au nouveau master
master_reconnection = true
master_accept_reads = false

# === Optimizations ===

# Disable delayed retry (meilleure latence)
delayed_retry = false
delayed_retry_timeout = 10s

# Connection settings
max_connections = 1000
connection_timeout = 300s

#
# === Listener ===
#
[Read-Write-Listener]
type = listener
service = Read-Write-Service
protocol = MariaDBClient
port = 3306
address = 0.0.0.0
```

### Configuration Galera-specific

**Pour Galera Cluster :**

```ini
# /etc/maxscale.cnf - Galera Read/Write Split

[maxscale]
threads = auto

#
# === Galera Servers ===
#
[galera-01]
type = server
address = 10.0.1.11
port = 3306
protocol = MariaDBBackend
priority = 1  # PrÃ©fÃ©rÃ© comme Master

[galera-02]
type = server
address = 10.0.1.12
port = 3306
protocol = MariaDBBackend
priority = 2

[galera-03]
type = server
address = 10.0.1.13
port = 3306
protocol = MariaDBBackend
priority = 2

#
# === Galera Monitor ===
#
[Galera-Monitor]
type = monitor
module = galeramon
servers = galera-01, galera-02, galera-03

user = maxscale_monitor
password = Monitor_P@ssw0rd_2024!

monitor_interval = 2000ms

# Galera-specific
available_when_donor = true  # Accepte nÅ“ud en SST
use_priority = true          # Utilise priority pour Master selection
disable_master_failback = false
disable_master_role_setting = false

#
# === Service (Galera Read/Write Split) ===
#
[Galera-RW-Service]
type = service
router = readwritesplit
servers = galera-01, galera-02, galera-03

user = maxscale_router
password = Router_P@ssw0rd_2024!

# Galera optimizations
use_sql_variables_in = master
max_slave_connections = 100%

# Causal reads (important pour Galera multi-master)
# Garantit lecture cohÃ©rente aprÃ¨s write sur autre nÅ“ud
causal_reads = true
causal_reads_timeout = 10s

# Transaction replay (MariaDB 11.8 + MaxScale 25.01)
transaction_replay = true
transaction_replay_max_size = 10M

# Master selection
master_failure_mode = fail_on_write
master_reconnection = true

# Galera-specific: accepter lectures sur master
master_accept_reads = true

#
# === Listener ===
#
[Galera-RW-Listener]
type = listener
service = Galera-RW-Service
protocol = MariaDBClient
port = 3306
address = 0.0.0.0
```

---

## RÃ¨gles de routage des requÃªtes

### Routage automatique par type de requÃªte

**Tableau de dÃ©cision du router :**

| Type de requÃªte | Destination | Raison | Exemple |
|----------------|-------------|--------|---------|
| **SELECT** simple | Slave | Lecture seule | `SELECT * FROM users` |
| **SELECT FOR UPDATE** | Master | Lock exclusif | `SELECT * FROM accounts WHERE id=1 FOR UPDATE` |
| **SELECT LOCK IN SHARE MODE** | Master | Lock partagÃ© | `SELECT * FROM products WHERE id=1 LOCK IN SHARE MODE` |
| **INSERT** | Master | Ã‰criture | `INSERT INTO logs (msg) VALUES ('test')` |
| **UPDATE** | Master | Ã‰criture | `UPDATE users SET status='active'` |
| **DELETE** | Master | Ã‰criture | `DELETE FROM temp_data WHERE date < NOW()` |
| **BEGIN/START TRANSACTION** | Master | DÃ©but transaction | `BEGIN` |
| **COMMIT** | Master | Fin transaction | `COMMIT` |
| **ROLLBACK** | Master | Annulation | `ROLLBACK` |
| **SET variables** | Master | Session state | `SET @var = 10` |
| **CREATE TEMPORARY TABLE** | Master | Session-specific | `CREATE TEMPORARY TABLE tmp (...)` |
| **PREPARE statement** | Master | Prepared stmt | `PREPARE stmt FROM 'SELECT * FROM users WHERE id=?'` |
| **CALL procedure** | Master | ProcÃ©dure peut Ã©crire | `CALL update_stats()` |
| **DDL** (CREATE/ALTER/DROP) | Master | Modification schÃ©ma | `ALTER TABLE users ADD COLUMN age INT` |
| **LAST_INSERT_ID()** | Master | Fonction session | `SELECT LAST_INSERT_ID()` |
| **FOUND_ROWS()** | Master | Fonction session | `SELECT FOUND_ROWS()` |

### Fonctions et expressions spÃ©ciales

**Fonctions forÃ§ant routage vers Master :**

```sql
-- Fonctions non-dÃ©terministes (rÃ©sultat varie)
SELECT NOW();           -- Master (timestamp actuel)
SELECT RAND();          -- Master (alÃ©atoire)
SELECT UUID();          -- Master (unique ID)
SELECT CONNECTION_ID(); -- Master (ID session)

-- Fonctions session-dependent
SELECT LAST_INSERT_ID();  -- Master
SELECT ROW_COUNT();       -- Master
SELECT FOUND_ROWS();      -- Master

-- Variables utilisateur
SELECT @my_variable;      -- Master (si SET avant)
SET @counter = @counter + 1;  -- Master
```

**Fonctions safe pour Slaves :**

```sql
-- Fonctions dÃ©terministes
SELECT LENGTH('test');     -- Slave OK
SELECT CONCAT(a, b);       -- Slave OK
SELECT DATE('2024-01-01'); -- Slave OK
SELECT MD5('data');        -- Slave OK

-- AgrÃ©gations
SELECT COUNT(*) FROM users;        -- Slave OK
SELECT AVG(price) FROM products;   -- Slave OK
SELECT MAX(created_at) FROM logs;  -- Slave OK
```

### Gestion des transactions

**Comportement pendant une transaction :**

```sql
-- RequÃªte 1: BEGIN
BEGIN;
-- â†’ Master (toute la transaction)

-- RequÃªte 2: SELECT (dans transaction)
SELECT balance FROM accounts WHERE id = 100;
-- â†’ Master (sticky pendant transaction)

-- RequÃªte 3: UPDATE
UPDATE accounts SET balance = balance - 50 WHERE id = 100;
-- â†’ Master

-- RequÃªte 4: SELECT (dans transaction)
SELECT balance FROM accounts WHERE id = 100;
-- â†’ Master (cohÃ©rence garantie)

-- RequÃªte 5: COMMIT
COMMIT;
-- â†’ Master

-- RequÃªte 6: SELECT (hors transaction)
SELECT * FROM products;
-- â†’ Slave (transaction terminÃ©e, retour normal)
```

**Autocommit vs Transactions explicites :**

```sql
-- Avec autocommit=1 (dÃ©faut):
SELECT * FROM users;     -- Slave
UPDATE users SET ...;    -- Master (autocommit implicite)
SELECT * FROM users;     -- Slave (pas de transaction)

-- Avec autocommit=0:
SELECT * FROM users;     -- Master (transaction implicite)
SELECT * FROM products;  -- Master (mÃªme transaction)
COMMIT;                  -- Master
SELECT * FROM users;     -- Master (nouvelle transaction auto-start)
```

ğŸ’¡ **Recommandation** : Utiliser transactions explicites (BEGIN...COMMIT) pour contrÃ´le prÃ©cis du routage.

---

## Gestion de la consistance : Causal Reads

### ProblÃ©matique Read-After-Write

**ScÃ©nario d'inconsistance sans causal reads :**

```
Timeline:
T0: Client Ã©crit sur Master
    INSERT INTO orders (id, total) VALUES (123, 99.99);
    â†’ Master (commit immÃ©diat)

T1: RÃ©plication vers Slave (lag 100ms)
    [Slave pas encore Ã  jour]

T2: Client lit depuis Slave (50ms aprÃ¨s write)
    SELECT * FROM orders WHERE id = 123;
    â†’ Slave
    â†’ RÃ©sultat: VIDE (donnÃ©es pas encore rÃ©pliquÃ©es!) âŒ

T3: RÃ©plication complÃ¨te (150ms aprÃ¨s write)
    [Slave maintenant Ã  jour]

T4: Client relit depuis Slave
    SELECT * FROM orders WHERE id = 123;
    â†’ Slave
    â†’ RÃ©sultat: 1 ligne (donnÃ©es prÃ©sentes) âœ…
```

**Impact utilisateur :**

```
User story (E-commerce):
1. Utilisateur passe commande
   â†’ INSERT order (Master) â†’ Success

2. Redirection page "Merci"
   â†’ SELECT order details (Slave)
   â†’ Erreur: "Commande introuvable" âŒ

3. Utilisateur confus, contacte support

Ce problÃ¨me est frÃ©quent avec replication lag > 50ms
```

### Solution : Causal Reads

**Avec causal_reads activÃ© :**

```ini
[Read-Write-Service]
router = readwritesplit
# ...

# Activer causal reads
causal_reads = true
causal_reads_timeout = 10s
```

**Fonctionnement causal reads :**

```
Timeline avec causal_reads=true:

T0: Client Ã©crit sur Master
    INSERT INTO orders (id, total) VALUES (123, 99.99);
    â†’ Master (commit)
    â†’ MaxScale enregistre GTID: 1-1-1000

T1: Client lit depuis Slave
    SELECT * FROM orders WHERE id = 123;
    â†’ MaxScale vÃ©rifie GTID Slave

T2: MaxScale dÃ©tecte Slave lag
    Slave GTID: 1-1-995 (pas encore 1-1-1000)
    â†’ MaxScale ATTEND rÃ©plication

T3: Slave rattrappe
    Slave GTID: 1-1-1000 âœ…

T4: MaxScale route requÃªte
    SELECT * FROM orders WHERE id = 123;
    â†’ Slave (maintenant Ã  jour)
    â†’ RÃ©sultat: 1 ligne âœ…

Si timeout (10s) dÃ©passÃ©:
â†’ Route vers Master (fallback sÃ©curisÃ©)
```

**ImplÃ©mentation technique (GTID) :**

```sql
-- MaxScale utilise GTID pour tracking
-- AprÃ¨s write sur Master:
SELECT @@gtid_current_pos;
-- Exemple: '0-1-1000'

-- Avant lecture sur Slave:
-- MaxScale vÃ©rifie:
SELECT MASTER_GTID_WAIT('0-1-1000', 10);
-- Retourne:
-- 0 si Slave Ã  jour
-- -1 si timeout
-- NULL si erreur

-- Si 0: route vers Slave
-- Si -1 ou NULL: route vers Master
```

**Impact performance causal reads :**

```
Benchmark (1000 requÃªtes R+W):

Sans causal_reads:
- Latence moyenne: 5ms
- 99th percentile: 15ms
- Inconsistances: 2-5% des lectures

Avec causal_reads:
- Latence moyenne: 8ms (+60%)
- 99th percentile: 25ms (+67%)
- Inconsistances: 0% âœ…

Avec causal_reads + faible lag (<10ms):
- Latence moyenne: 6ms (+20%)
- 99th percentile: 18ms (+20%)
- Inconsistances: 0% âœ…

Conclusion: Impact acceptable si lag faible
```

### Alternatives aux causal reads

**Option 1: Query hints pour forcer Master :**

```sql
-- Forcer lecture sur Master (sans causal reads global)
SELECT /* maxscale route to master */ * FROM orders WHERE id = 123;

-- Syntax alternative
SELECT /*+ MASTER */ * FROM orders WHERE id = 123;
```

**Option 2: Session hints :**

```sql
-- Activer temporairement routing vers Master
SET @maxscale.route_to_master = 1;

SELECT * FROM orders WHERE id = 123;  -- â†’ Master
SELECT * FROM products;               -- â†’ Master

-- DÃ©sactiver
SET @maxscale.route_to_master = 0;

SELECT * FROM products;               -- â†’ Slave (retour normal)
```

**Option 3: Sticky session aprÃ¨s write :**

```ini
# /etc/maxscale.cnf
[Read-Write-Service]
router = readwritesplit

# Session reste sur Master aprÃ¨s write pendant X secondes
sticky_mode = after_write
sticky_duration = 5s

# AprÃ¨s un write, toutes lectures pendant 5s â†’ Master
# Puis retour automatique â†’ Slave
```

---

## Optimisations avancÃ©es

### Connection pooling par rÃ´le

**Configuration pooling Master vs Slaves :**

```ini
[Read-Write-Service]
router = readwritesplit
servers = server1, server2, server3

# Pooling global
max_connections = 1000

# Connexions slaves par session client
max_slave_connections = 255
# Par dÃ©faut: 1 connexion slave par session
# 255 = utilise tous slaves disponibles

# Exemple avec 3 slaves:
# - Client connecte â†’ 1 connexion master, 3 connexions slaves
# - Load balancing round-robin entre les 3 slaves

# Retry si slave Ã©choue
slave_connections_retries = 3
```

**Optimisation pour workload read-heavy :**

```ini
# Workload 95% lectures, 5% Ã©critures
[Heavy-Read-Service]
router = readwritesplit
servers = server1, server2, server3, server4, server5

# 1 master + 4 slaves
max_slave_connections = 100%  # Utilise tous slaves

# Pas de causal reads (workload tolÃ¨re eventual consistency)
causal_reads = false

# Connection pooling agressif
connection_keepalive = 300s
```

### Lazy connection (connexions paresseuses)

**Principe :** Ne pas ouvrir connexions avant besoin rÃ©el.

```ini
[Lazy-Service]
router = readwritesplit
servers = server1, server2, server3

# Lazy connections (dÃ©faut depuis MaxScale 2.5)
lazy_connect = true

# BÃ©nÃ©fice:
# - Connexion master ouverte seulement si write
# - Ã‰conomie ressources pour sessions read-only
```

**Comportement lazy connect :**

```
Session read-only:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client â”‚ Connect â†’ MaxScale
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜              â”‚
    â”‚                   â”‚ (pas encore de connexion backend)
    â”‚ SELECT ...        â”‚
    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ Ouvre connexion slave
    â”‚                   â”‚ â†’ server2 (slave)
    â”‚                   â”‚ ExÃ©cute SELECT
    â”‚ â† RÃ©sultat â”€â”€â”€â”€â”€â”€â”€â”‚
    â”‚                   â”‚
    â”‚ Disconnect        â”‚
    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ Ferme connexion slave
                        â”‚ (Jamais ouvert connexion master!)

Session avec write:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client â”‚ Connect â†’ MaxScale
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜              â”‚
    â”‚ INSERT ...        â”‚
    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ Ouvre connexion master
    â”‚                   â”‚ â†’ server1 (master)
    â”‚                   â”‚ ExÃ©cute INSERT
    â”‚ â† OK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
    â”‚                   â”‚
    â”‚ SELECT ...        â”‚
    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ Ouvre connexion slave
    â”‚                   â”‚ â†’ server2 (slave)

Ã‰conomie: Sessions read-only ne consomment pas connexions master
```

### Query optimization hints

**MaxScale supporte hints SQL :**

```sql
-- === Hints de routage ===

-- Forcer Master
SELECT /* maxscale route to master */ * FROM users;

-- Forcer Slave
SELECT /* maxscale route to slave */ * FROM products;

-- Forcer serveur spÃ©cifique
SELECT /* maxscale route to server server2 */ * FROM logs;

-- Forcer dernier serveur utilisÃ© (sticky)
SELECT /* maxscale route to last */ * FROM orders;

-- === Hints de performance ===

-- PrÃ©parer requÃªte
/* maxscale prepare start */
SELECT * FROM users WHERE id = ?;
/* maxscale prepare end */

-- Hint timeout
SELECT /* maxscale max_execution_time=5000 */ slow_query();
```

**Utilisation programmatique :**

```python
# Python avec mysql-connector
import mysql.connector

conn = mysql.connector.connect(
    host='maxscale-host',
    port=3306,
    user='app_user',
    password='password',
    database='mydb'
)

cursor = conn.cursor()

# Lecture (automatiquement â†’ Slave)
cursor.execute("SELECT * FROM products WHERE category = %s", ('Electronics',))

# Ã‰criture critique avec hint Master
cursor.execute("""
    SELECT /* maxscale route to master */ * 
    FROM inventory 
    WHERE product_id = %s 
    FOR UPDATE
""", (123,))

# Update
cursor.execute("UPDATE inventory SET qty = qty - 1 WHERE product_id = %s", (123,))

conn.commit()
```

---

## Session management avancÃ©

### Session commands et historique

**ProblÃ©matique : Session state sur Slave diffÃ©rent de Master**

```sql
-- Session 1 sur Master:
SET @discount = 0.10;
SET SESSION sql_mode = 'TRADITIONAL';
CREATE TEMPORARY TABLE cart (item_id INT);

-- Session bascule vers Slave pour lecture:
SELECT @discount;  -- NULL âŒ (variable pas sur Slave)
SELECT @@sql_mode; -- DiffÃ©rent âŒ
SELECT * FROM cart; -- Erreur âŒ (table temporaire pas sur Slave)
```

**Solution MaxScale : Session Command History**

```ini
[Read-Write-Service]
router = readwritesplit

# Historique session commands
prune_sescmd_history = false
disable_sescmd_history = false
max_sescmd_history = 100

# MaxScale rejoue automatiquement:
# - SET variables
# - CREATE TEMPORARY TABLE
# - USE database
# - PREPARE statements
# Sur nouveau backend si changement
```

**Fonctionnement automatique :**

```
Client exÃ©cute:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SET @discount = 0.10;                      â”‚ â†’ Master
â”‚ SET SESSION sql_mode = 'TRADITIONAL';      â”‚ â†’ Master
â”‚ CREATE TEMPORARY TABLE cart (id INT);      â”‚ â†’ Master
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
MaxScale enregistre dans session history
         â†“
Client exÃ©cute SELECT:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SELECT * FROM products;                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
MaxScale route vers Slave
         â†“
AVANT d'exÃ©cuter SELECT, MaxScale rejoue:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SET @discount = 0.10;                      â”‚ â†’ server2 (slave)
â”‚ SET SESSION sql_mode = 'TRADITIONAL';      â”‚ â†’ server2 (slave)
â”‚ CREATE TEMPORARY TABLE cart (id INT);      â”‚ â†’ server2 (slave)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
Puis exÃ©cute requÃªte client:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SELECT * FROM products;                    â”‚ â†’ server2 (slave)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
Ã‰tat session identique Master et Slave âœ…
```

### Variables USE_ALL_SLAVE vs USE_MASTER

**Configuration :**

```ini
[Read-Write-Service]
router = readwritesplit

# Gestion variables SQL
use_sql_variables_in = master
# Options:
# - all: variables sur tous backends (moins performant)
# - master: variables seulement sur master (recommandÃ©)
```

**Impact du choix :**

```sql
-- Avec use_sql_variables_in = master:
SET @var = 10;              -- Master
SELECT @var;                -- Master (var session-dependent)
SELECT * FROM products;     -- Slave (pas de var utilisÃ©e)
SELECT @var, name FROM users; -- Master (SELECT utilise @var)

-- Avec use_sql_variables_in = all:
SET @var = 10;              -- Master + Tous Slaves
SELECT @var;                -- Slave OK (var rÃ©pliquÃ©e)
SELECT * FROM products;     -- Slave
SELECT @var, name FROM users; -- Slave (var disponible partout)
```

**Recommandation :** `use_sql_variables_in = master` (dÃ©faut) sauf si besoin spÃ©cifique.

---

## ğŸ†• NouveautÃ©s MaxScale 25.01

### Enhanced Read/Write Split

**AmÃ©lioration du routage intelligent :**

```ini
# /etc/maxscale.cnf - MaxScale 25.01
[RW-Service-2025]
type = service
router = readwritesplit

# ğŸ†• Adaptive query routing avec ML
adaptive_routing = true
adaptive_routing_learning_period = 3600s  # 1 heure d'apprentissage

# ğŸ†• Query complexity analysis
route_by_query_complexity = true
complex_query_threshold = 1000  # ms

# RequÃªtes complexes (>1s) â†’ Slave dÃ©diÃ© (pas Master)
# RequÃªtes simples (<1s) â†’ Distribution normale
```

### ğŸ†• Workload Capture & Replay

**Capture du workload pour tests :**

```ini
# Service de capture
[Capture-Service]
type = service
router = readwritesplit
servers = server1, server2, server3

# ğŸ†• Workload Capture (MaxScale 25.01)
workload_capture = true
workload_capture_file = /var/lib/maxscale/workload_$(date +%Y%m%d).log
workload_capture_duration = 3600s  # 1 heure
workload_capture_sample_rate = 100  # 100% des requÃªtes

# Filtres (optionnel)
workload_capture_user_filter = app_user,admin
workload_capture_query_filter = SELECT,INSERT,UPDATE
```

**Replay du workload :**

```bash
# Outil de replay (nouveau dans 25.01)
maxscale-workload-replay \
    --input /var/lib/maxscale/workload_20241215.log \
    --target maxscale-test:3306 \
    --user test_user \
    --password test_pass \
    --replay-speed 1.0 \
    --concurrency 10

# Use cases:
# - Test upgrade MariaDB/MaxScale
# - Benchmark nouvelles configurations
# - Validation avant mise en production
```

### ğŸ†• Diff Router

**Comparer comportement entre 2 backends :**

```ini
# ğŸ†• Diff Router - MaxScale 25.01
[Diff-Service]
type = service
router = diff

# Backend primaire (production)
primary_server = server1

# Backend secondaire (test)
secondary_server = server-test

# Compare rÃ©sultats
diff_mode = results
# Options: results, performance, both

# Log diffÃ©rences
diff_log_file = /var/log/maxscale/diff.log
diff_log_threshold = 1  # Log si 1+ diffÃ©rence

# Use case: Validation upgrade MariaDB
# - server1: MariaDB 10.11
# - server-test: MariaDB 11.8
# â†’ DÃ©tecte incompatibilitÃ©s avant migration
```

---

## Monitoring et diagnostic

### MÃ©triques readwritesplit

**Commandes maxctrl :**

```bash
# Statistiques service
maxctrl show service Read-Write-Service

# Output exemple:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Parameter               â”‚ Value              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Current Connections     â”‚ 142                â”‚
â”‚ Total Connections       â”‚ 8,523              â”‚
â”‚ Queries Routed Master   â”‚ 12,345 (15%)       â”‚
â”‚ Queries Routed Slave    â”‚ 68,901 (85%)       â”‚
â”‚ Average Response Time   â”‚ 12ms               â”‚
â”‚ Master Server           â”‚ server1            â”‚
â”‚ Slave Servers           â”‚ server2, server3   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

# DÃ©tail par serveur
maxctrl show server server1
maxctrl show server server2

# Sessions actives
maxctrl list sessions
```

### Analyse des patterns de routage

**RequÃªte diagnostic :**

```bash
# Activer logging dÃ©taillÃ© (temporaire)
maxctrl alter service Read-Write-Service log_info true
maxctrl alter service Read-Write-Service log_debug true

# Logs dÃ©taillent chaque dÃ©cision de routage
tail -f /var/log/maxscale/maxscale.log

# Exemple log:
# [INFO] Session 0x7f8a: Query 'SELECT * FROM users' routed to slave server2
# [INFO] Session 0x7f8a: Query 'UPDATE users SET ...' routed to master server1
# [DEBUG] Session 0x7f8a: Transaction started, all queries â†’ master

# DÃ©sactiver aprÃ¨s diagnostic
maxctrl alter service Read-Write-Service log_info false
maxctrl alter service Read-Write-Service log_debug false
```

### Troubleshooting problÃ¨mes courants

**ProblÃ¨me 1: Toutes requÃªtes vont au Master**

```bash
# Diagnostic
maxctrl show service Read-Write-Service | grep "Queries Routed"
# Si 100% Master â†’ ProblÃ¨me

# Causes possibles:
# 1. Slaves down
maxctrl list servers
# â†’ VÃ©rifier Ã©tat Slaves

# 2. Transaction ouverte non fermÃ©e
# VÃ©rifier code application:
# BEGIN sans COMMIT/ROLLBACK

# 3. Session variables/temp tables
# Application utilise SET @var ou CREATE TEMPORARY TABLE
# â†’ Sticky sur Master

# 4. use_sql_variables_in = all (mauvaise config)
grep use_sql_variables_in /etc/maxscale.cnf
# â†’ Doit Ãªtre "master"
```

**ProblÃ¨me 2: Inconsistances read-after-write**

```bash
# SymptÃ´me: DonnÃ©es Ã©crites invisibles en lecture

# Solution 1: Activer causal reads
# /etc/maxscale.cnf
causal_reads = true
causal_reads_timeout = 10s

# Solution 2: Utiliser hints
SELECT /* maxscale route to master */ * FROM orders WHERE id = 123;

# Solution 3: Sticky aprÃ¨s write
sticky_mode = after_write
sticky_duration = 5s
```

**ProblÃ¨me 3: Performance dÃ©gradÃ©e avec causal reads**

```bash
# Diagnostic latence
maxctrl show service Read-Write-Service | grep "Response Time"

# Si latence Ã©levÃ©e avec causal_reads=true:
# â†’ VÃ©rifier lag rÃ©plication

# Sur slaves:
mysql -e "SHOW SLAVE STATUS\G" | grep Seconds_Behind_Master

# Si lag > 1s:
# â†’ Optimiser rÃ©plication (voir section 13)
# â†’ Augmenter causal_reads_timeout
# â†’ Ou dÃ©sactiver causal_reads si tolÃ©rable
```

---

## Cas d'usage et patterns de production

### Pattern 1: E-commerce read-heavy

**Architecture :**

```
MaxScale Read/Write Split
    â”‚
    â”œâ”€ Master (20% traffic)
    â”‚  â””â”€ Writes: Orders, Inventory, Users
    â”‚
    â””â”€ Slaves (80% traffic)
       â”œâ”€ Slave-1: Product catalog
       â”œâ”€ Slave-2: Reviews, ratings
       â””â”€ Slave-3: Analytics, reports
```

**Configuration optimisÃ©e :**

```ini
[Ecommerce-Service]
router = readwritesplit
servers = master, slave1, slave2, slave3

# Read-heavy optimizations
max_slave_connections = 100%
causal_reads = true  # Important pour cart/checkout
causal_reads_timeout = 5s

# Sticky aprÃ¨s cart add
sticky_mode = after_write
sticky_duration = 10s

# Performance
lazy_connect = true
max_connections = 5000
```

### Pattern 2: Analytics sÃ©parÃ©

**Architecture multi-services :**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  OLTP Service       â”‚  â”‚  Analytics Service  â”‚
â”‚  (App production)   â”‚  â”‚  (Reporting)        â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                        â”‚
       â”œâ”€ Master (R+W)          â””â”€ Slave-Analytics (R-only)
       â””â”€ Slave-1 (R)              (dedicated, no OLTP traffic)
```

**Configuration :**

```ini
# Service OLTP
[OLTP-Service]
router = readwritesplit
servers = master, slave1
# Production traffic

# Service Analytics (sÃ©parÃ©)
[Analytics-Service]
router = readconnroute
router_options = slave
servers = slave-analytics
# Reporting traffic isolÃ©
```

### Pattern 3: Multi-tenant avec isolation

**Architecture :**

```
         MaxScale
             â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚        â”‚        â”‚
Tenant-A  Tenant-B  Tenant-C
    â”‚        â”‚        â”‚
Master-A  Master-B  Master-C
 Slave-A   Slave-B   Slave-C
```

**Configuration avec routing par database :**

```ini
[Multi-Tenant-Service]
router = readwritesplit

# Schemarouter implicite par database
servers = server-a, server-b, server-c

# Client se connecte avec:
# mysql -h maxscale -D tenant_a_db
# â†’ Route vers server-a automatiquement
```

---

## âœ… Points clÃ©s Ã  retenir

- **Read/Write Split** : Route automatiquement reads vers slaves, writes vers master, scaling horizontal 70-90% workloads OLTP
- **Router readwritesplit** : Parse requÃªtes SQL, dÃ©cisions intelligentes basÃ©es type (SELECT/INSERT/UPDATE/DELETE), transactions, locks
- **RÃ¨gles routage** : SELECTâ†’Slave, SELECT FOR UPDATEâ†’Master, transactionsâ†’Master (sticky), session vars/temp tablesâ†’Master
- **Causal reads** : RÃ©sout inconsistances read-after-write, utilise GTID/MASTER_GTID_WAIT, impact +20-60% latence selon lag
- **Session management** : MaxScale rejoue automatiquement session commands (SET, CREATE TEMP TABLE, USE db) sur nouveaux backends
- **Lazy connect** : Connexions backend ouvertes seulement si nÃ©cessaire, Ã©conomie ressources sessions read-only
- **Query hints** : `/* maxscale route to master */` pour contrÃ´le explicite, `SET @maxscale.route_to_master=1` pour sticky temporaire
- **ğŸ†• MaxScale 25.01** : Adaptive routing ML, workload capture/replay, diff router pour validation upgrades
- **Configuration critique** : `use_sql_variables_in=master`, `max_slave_connections=100%`, `transaction_replay=true`
- **Monitoring** : maxctrl show service, mÃ©triques Prometheus, logs dÃ©taillÃ©s si troubleshooting
- **Production patterns** : E-commerce avec sticky post-write, analytics isolÃ© sur slave dÃ©diÃ©, multi-tenant par database
- **Troubleshooting** : Toutes requÃªtesâ†’Master = transaction non fermÃ©e ou slaves down, inconsistances = activer causal_reads

---

## ğŸ”— Ressources et rÃ©fÃ©rences

### Documentation officielle MaxScale
- [ğŸ“– ReadWriteSplit Router](https://mariadb.com/kb/en/mariadb-maxscale-25-readwritesplit/)
- [ğŸ“– Query Classifier](https://mariadb.com/kb/en/maxscale-query-classifier/)
- [ğŸ“– Causal Reads](https://mariadb.com/docs/server/connect/programming-languages/maxscale/causal-reads/)
- [ğŸ“– Session Commands](https://mariadb.com/kb/en/maxscale-readwritesplit/#session-commands)

### NouveautÃ©s MaxScale 25.01
- [ğŸ†• Adaptive Routing](https://mariadb.com/docs/server/architecture/components/maxscale/adaptive-routing/)
- [ğŸ†• Workload Capture & Replay](https://mariadb.com/docs/server/operations/workload-testing/)
- [ğŸ†• Diff Router](https://mariadb.com/docs/server/architecture/components/maxscale/diff-router/)
- [ğŸ†• Transaction Replay Enhanced](https://mariadb.com/docs/server/connect/programming-languages/maxscale/transaction-replay/)

### Guides techniques
- [Read/Write Split Best Practices](https://mariadb.com/resources/blog/read-write-split-best-practices/)
- [Handling Replication Lag](https://www.percona.com/blog/handling-replication-lag-maxscale/)
- [Session Consistency Patterns](https://severalnines.com/database-blog/session-consistency-maxscale/)

### Papers et articles
- [Consistency in Read/Write Split Architectures](https://queue.acm.org/detail.cfm?id=2462076)
- [Causal Consistency for Geo-Replicated Cloud Storage](https://www.cs.cornell.edu/projects/Quicksilver/public_pdfs/causal-consistency.pdf)

---

## â¡ï¸ Section suivante

**14.4.3 Query Routing** : Routage avancÃ© basÃ© sur patterns de requÃªtes, schemarouter pour architectures multi-tenant, routing par expressions rÃ©guliÃ¨res, filtres de requÃªtes, et optimisations de routage pour workloads complexes.

---

**MariaDB** : Version 11.8 LTS
**MaxScale** : Version 25.01

â­ï¸ [Query Routing](/14-haute-disponibilite/04.3-query-routing.md)
