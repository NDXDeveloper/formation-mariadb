üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.9.1 RANGE Partitioning

> **Niveau** : Expert  
> **Dur√©e estim√©e** : 3-4 heures  
> **Pr√©requis** : Section 15.1 (M√©thodologie d'optimisation), Compr√©hension des index, Architecture InnoDB

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre le fonctionnement du partitionnement RANGE et ses b√©n√©fices
- Concevoir et impl√©menter des strat√©gies de partitionnement par plages
- Exploiter le partition pruning pour des gains de performance massifs
- G√©rer le cycle de vie des partitions (cr√©ation, suppression, r√©organisation)
- Automatiser la maintenance des partitions (archivage, purge)
- Diagnostiquer et r√©soudre les probl√®mes de performance li√©s au partitionnement
- Migrer entre tables partitionn√©es et non-partitionn√©es
- Optimiser les requ√™tes pour tirer parti du partitionnement

---

## Introduction

Le **partitionnement RANGE** divise une table en plusieurs partitions bas√©es sur des **plages de valeurs** d'une colonne. C'est la m√©thode de partitionnement la plus utilis√©e en production, particuli√®rement adapt√©e aux **donn√©es temporelles** et **s√©quentielles**.

### Probl√©matique : Tables massives √† forte croissance

```
Table non-partitionn√©e (probl√®me typique):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ orders (500 millions de lignes)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 2020-01: 5M rows                             ‚îÇ
‚îÇ 2020-02: 5M rows                             ‚îÇ
‚îÇ ...                                          ‚îÇ
‚îÇ 2025-11: 5M rows                             ‚îÇ
‚îÇ 2025-12: 5M rows (actif)                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Requ√™te: SELECT * FROM orders WHERE order_date >= '2025-12-01'
‚Üí Scan complet de 500M rows pour trouver 5M rows ‚ùå
‚Üí Temps: 45 secondes
‚Üí I/O: √ânorme
```

**Solution avec RANGE partitioning** :

```
Table partitionn√©e par mois:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ p2020_01       ‚îÇ p2020_02       ‚îÇ ...            ‚îÇ
‚îÇ 5M rows        ‚îÇ 5M rows        ‚îÇ                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ...
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ p2025_11       ‚îÇ p2025_12       ‚îÇ
‚îÇ 5M rows        ‚îÇ 5M rows        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Requ√™te: SELECT * FROM orders WHERE order_date >= '2025-12-01'
‚Üí Partition pruning: Acc√®s direct partition p2025_12 ‚úì
‚Üí Scan de 5M rows seulement
‚Üí Temps: 0.8 secondes (56x plus rapide !)
‚Üí I/O: R√©duit de 99%
```

**Avantages du partitionnement RANGE** :
- ‚úÖ **Partition pruning** : Requ√™tes acc√®dent seulement aux partitions n√©cessaires
- ‚úÖ **Maintenance cibl√©e** : OPTIMIZE, ANALYZE par partition
- ‚úÖ **Archivage efficace** : DROP PARTITION quasi-instantan√©
- ‚úÖ **Performance constante** : Chaque partition reste petite
- ‚úÖ **Parall√©lisation** : Op√©rations concurrentes sur partitions diff√©rentes

---

## Concept et fonctionnement

### Architecture du partitionnement RANGE

```
CREATE TABLE orders (
    order_id BIGINT,
    order_date DATE,
    customer_id INT,
    total DECIMAL(10,2),
    PRIMARY KEY (order_id, order_date)  ‚Üê Cl√© partitionnement doit √™tre dans PK
) PARTITION BY RANGE (YEAR(order_date) * 100 + MONTH(order_date)) (
    PARTITION p2024_01 VALUES LESS THAN (202402),
    PARTITION p2024_02 VALUES LESS THAN (202403),
    PARTITION p2024_03 VALUES LESS THAN (202404),
    ...
    PARTITION p2025_12 VALUES LESS THAN (202601),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**Repr√©sentation logique** :

```
Partition p2024_01: VALUES LESS THAN (202402)
  ‚Üí Toutes les lignes o√π (YEAR(order_date)*100 + MONTH(order_date)) < 202402
  ‚Üí Janvier 2024

Partition p2024_02: VALUES LESS THAN (202403)
  ‚Üí 202402 <= valeur < 202403
  ‚Üí F√©vrier 2024

Partition p_future: VALUES LESS THAN MAXVALUE
  ‚Üí Catch-all pour dates futures
  ‚Üí √âvite les erreurs INSERT sur dates > derni√®re partition
```

### Partition pruning (√©limination de partitions)

Le **partition pruning** est l'optimisation cl√© qui permet au moteur de n'acc√©der qu'aux partitions pertinentes.

```sql
-- Requ√™te avec filtre sur colonne de partitionnement
EXPLAIN PARTITIONS
SELECT * FROM orders 
WHERE order_date BETWEEN '2025-11-01' AND '2025-11-30';

+----+-------------+--------+-------------+------+
| id | select_type | table  | partitions  | type |
+----+-------------+--------+-------------+------+
|  1 | SIMPLE      | orders | p2025_11    | ALL  |  ‚Üê 1 seule partition !
+----+-------------+--------+-------------+------+

-- Requ√™te sans filtre sur colonne de partitionnement
EXPLAIN PARTITIONS
SELECT * FROM orders 
WHERE customer_id = 12345;

+----+-------------+--------+----------------------------------+------+
| id | select_type | table  | partitions                       | type |
+----+-------------+--------+----------------------------------+------+
|  1 | SIMPLE      | orders | p2024_01,p2024_02,...,p_future  | ALL  |  ‚Üê Toutes les partitions !
+----+-------------+--------+----------------------------------+------+
```

üí° **R√®gle d'or** : Pour b√©n√©ficier du partition pruning, le `WHERE` doit **filtrer sur la colonne de partitionnement**.

---

## Cr√©ation et syntaxe

### Partitionnement par DATE

**M√©thode 1 : Partitions mensuelles avec YEAR/MONTH** :

```sql
CREATE TABLE logs (
    log_id BIGINT AUTO_INCREMENT,
    log_date DATE NOT NULL,
    message TEXT,
    severity ENUM('INFO','WARNING','ERROR'),
    PRIMARY KEY (log_id, log_date)
) PARTITION BY RANGE (YEAR(log_date) * 100 + MONTH(log_date)) (
    PARTITION p2025_01 VALUES LESS THAN (202502),
    PARTITION p2025_02 VALUES LESS THAN (202503),
    PARTITION p2025_03 VALUES LESS THAN (202504),
    PARTITION p2025_04 VALUES LESS THAN (202505),
    PARTITION p2025_05 VALUES LESS THAN (202506),
    PARTITION p2025_06 VALUES LESS THAN (202507),
    PARTITION p2025_07 VALUES LESS THAN (202508),
    PARTITION p2025_08 VALUES LESS THAN (202509),
    PARTITION p2025_09 VALUES LESS THAN (202510),
    PARTITION p2025_10 VALUES LESS THAN (202511),
    PARTITION p2025_11 VALUES LESS THAN (202512),
    PARTITION p2025_12 VALUES LESS THAN (202601),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**M√©thode 2 : Partitions journali√®res avec TO_DAYS** :

```sql
CREATE TABLE events (
    event_id BIGINT AUTO_INCREMENT,
    event_timestamp DATETIME NOT NULL,
    event_type VARCHAR(50),
    data JSON,
    PRIMARY KEY (event_id, event_timestamp)
) PARTITION BY RANGE (TO_DAYS(event_timestamp)) (
    PARTITION p2025_12_01 VALUES LESS THAN (TO_DAYS('2025-12-02')),
    PARTITION p2025_12_02 VALUES LESS THAN (TO_DAYS('2025-12-03')),
    PARTITION p2025_12_03 VALUES LESS THAN (TO_DAYS('2025-12-04')),
    -- ... une partition par jour
    PARTITION p2025_12_31 VALUES LESS THAN (TO_DAYS('2026-01-01')),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**M√©thode 3 : Partitions trimestrielles** :

```sql
CREATE TABLE sales (
    sale_id BIGINT AUTO_INCREMENT,
    sale_date DATE NOT NULL,
    amount DECIMAL(10,2),
    PRIMARY KEY (sale_id, sale_date)
) PARTITION BY RANGE (YEAR(sale_date) * 10 + QUARTER(sale_date)) (
    PARTITION p2024_Q1 VALUES LESS THAN (20242),  -- Q1 2024
    PARTITION p2024_Q2 VALUES LESS THAN (20243),  -- Q2 2024
    PARTITION p2024_Q3 VALUES LESS THAN (20244),  -- Q3 2024
    PARTITION p2024_Q4 VALUES LESS THAN (20251),  -- Q4 2024
    PARTITION p2025_Q1 VALUES LESS THAN (20252),  -- Q1 2025
    PARTITION p2025_Q2 VALUES LESS THAN (20253),  -- Q2 2025
    PARTITION p2025_Q3 VALUES LESS THAN (20254),  -- Q3 2025
    PARTITION p2025_Q4 VALUES LESS THAN (20261),  -- Q4 2025
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

### Partitionnement par ID s√©quentiel

**Cas d'usage** : Tables avec ID auto-incr√©ment√© sans dimension temporelle claire.

```sql
CREATE TABLE user_actions (
    action_id BIGINT AUTO_INCREMENT,
    user_id INT,
    action_type VARCHAR(50),
    created_at TIMESTAMP,
    PRIMARY KEY (action_id)
) PARTITION BY RANGE (action_id) (
    PARTITION p0 VALUES LESS THAN (10000000),      -- 0-10M
    PARTITION p1 VALUES LESS THAN (20000000),      -- 10M-20M
    PARTITION p2 VALUES LESS THAN (30000000),      -- 20M-30M
    PARTITION p3 VALUES LESS THAN (40000000),      -- 30M-40M
    PARTITION p4 VALUES LESS THAN (50000000),      -- 40M-50M
    PARTITION p_current VALUES LESS THAN MAXVALUE  -- > 50M
);
```

### Partitionnement par plages de valeurs m√©tier

```sql
CREATE TABLE customers (
    customer_id INT AUTO_INCREMENT,
    annual_revenue DECIMAL(15,2),
    segment VARCHAR(20),
    PRIMARY KEY (customer_id, annual_revenue)
) PARTITION BY RANGE (annual_revenue) (
    PARTITION p_small VALUES LESS THAN (10000),         -- < 10K
    PARTITION p_medium VALUES LESS THAN (100000),       -- 10K-100K
    PARTITION p_large VALUES LESS THAN (1000000),       -- 100K-1M
    PARTITION p_enterprise VALUES LESS THAN (10000000), -- 1M-10M
    PARTITION p_strategic VALUES LESS THAN MAXVALUE     -- > 10M
);
```

---

## Contraintes et r√®gles

### 1. Colonne de partitionnement dans la PRIMARY KEY

‚ö†Ô∏è **Contrainte obligatoire** : La colonne de partitionnement doit faire partie de **toutes les cl√©s uniques** (PK, UNIQUE).

```sql
-- ‚ùå INCORRECT - order_date pas dans PRIMARY KEY
CREATE TABLE orders (
    order_id BIGINT PRIMARY KEY,  -- order_date absent !
    order_date DATE,
    total DECIMAL(10,2)
) PARTITION BY RANGE (YEAR(order_date) * 100 + MONTH(order_date)) (...);
-- ERROR 1503: A PRIMARY KEY must include all columns in the table's partitioning function

-- ‚úÖ CORRECT
CREATE TABLE orders (
    order_id BIGINT,
    order_date DATE,
    total DECIMAL(10,2),
    PRIMARY KEY (order_id, order_date)  -- order_date inclus
) PARTITION BY RANGE (YEAR(order_date) * 100 + MONTH(order_date)) (...);
```

**Pourquoi cette contrainte ?**

MariaDB doit pouvoir d√©terminer **dans quelle partition** se trouve une ligne uniquement √† partir de la cl√© primaire. Sans cela, v√©rifier l'unicit√© n√©cessiterait de scanner toutes les partitions.

### 2. Expressions de partitionnement

```sql
-- ‚úÖ Expressions autoris√©es
PARTITION BY RANGE (YEAR(date_col))
PARTITION BY RANGE (TO_DAYS(date_col))
PARTITION BY RANGE (UNIX_TIMESTAMP(timestamp_col))
PARTITION BY RANGE (MONTH(date_col))
PARTITION BY RANGE (id_col)  -- Colonne directe
PARTITION BY RANGE (id_col DIV 1000000)

-- ‚ùå Expressions NON autoris√©es
PARTITION BY RANGE (SUBSTRING(varchar_col, 1, 4))  -- Pas de fonctions string
PARTITION BY RANGE (column_a + column_b)  -- Pas de multiples colonnes
```

### 3. Ordre et valeurs des partitions

```sql
-- ‚úÖ Ordre croissant obligatoire
PARTITION p1 VALUES LESS THAN (100),
PARTITION p2 VALUES LESS THAN (200),
PARTITION p3 VALUES LESS THAN (300),
PARTITION p_max VALUES LESS THAN MAXVALUE

-- ‚ùå INCORRECT - Ordre d√©croissant
PARTITION p3 VALUES LESS THAN (300),
PARTITION p2 VALUES LESS THAN (200),  -- Erreur !
```

---

## Gestion du cycle de vie des partitions

### Ajout de nouvelles partitions

```sql
-- M√©thode 1: REORGANIZE PARTITION (split de p_future)
ALTER TABLE orders
REORGANIZE PARTITION p_future INTO (
    PARTITION p2026_01 VALUES LESS THAN (202602),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- M√©thode 2: Script automatis√© mensuel
DELIMITER $$

CREATE PROCEDURE add_monthly_partition(
    IN table_name VARCHAR(64),
    IN year INT,
    IN month INT
)
BEGIN
    DECLARE partition_name VARCHAR(64);
    DECLARE next_month INT;
    DECLARE next_year INT;
    DECLARE partition_value INT;
    
    -- Calculer le mois suivant
    SET next_month = month + 1;
    SET next_year = year;
    
    IF next_month > 12 THEN
        SET next_month = 1;
        SET next_year = year + 1;
    END IF;
    
    -- Nom de la partition
    SET partition_name = CONCAT('p', year, '_', LPAD(month, 2, '0'));
    
    -- Valeur limite
    SET partition_value = next_year * 100 + next_month;
    
    -- Cr√©er la partition
    SET @sql = CONCAT(
        'ALTER TABLE ', table_name,
        ' REORGANIZE PARTITION p_future INTO (',
        ' PARTITION ', partition_name, ' VALUES LESS THAN (', partition_value, '),',
        ' PARTITION p_future VALUES LESS THAN MAXVALUE',
        ')'
    );
    
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END$$

DELIMITER ;

-- Utilisation
CALL add_monthly_partition('orders', 2026, 1);  -- Ajouter janvier 2026
```

### Suppression de partitions anciennes (archivage)

```sql
-- Supprimer une partition (INSTANTAN√â - pas de DELETE row-by-row)
ALTER TABLE orders DROP PARTITION p2023_01;

-- La suppression d'une partition est quasi-instantan√©e
-- vs DELETE FROM orders WHERE order_date < '2023-02-01' qui prendrait des heures
```

**Archivage avant suppression** :

```sql
-- 1. Cr√©er table d'archive (m√™me structure, pas partitionn√©e)
CREATE TABLE orders_archive LIKE orders;
ALTER TABLE orders_archive REMOVE PARTITIONING;

-- 2. Exporter la partition vers l'archive
ALTER TABLE orders EXCHANGE PARTITION p2023_01 WITH TABLE orders_archive;
-- orders_archive contient maintenant les donn√©es de p2023_01
-- p2023_01 est maintenant vide

-- 3. Supprimer la partition vide
ALTER TABLE orders DROP PARTITION p2023_01;

-- 4. Archiver orders_archive (dump, S3, etc.)
mysqldump orders_archive > orders_2023_01.sql
gzip orders_2023_01.sql

-- 5. Vider orders_archive pour prochaine utilisation
TRUNCATE TABLE orders_archive;
```

### Script d'automatisation de purge

```bash
#!/bin/bash
# purge-old-partitions.sh
# Supprime automatiquement les partitions > 12 mois

RETENTION_MONTHS=12
TABLE="orders"
DATABASE="ecommerce"

# Calculer le mois limite (YYYYMM)
CUTOFF_MONTH=$(date -d "$RETENTION_MONTHS months ago" +%Y%m)

# Lister les partitions √† supprimer
mysql -N -B -e "
    SELECT PARTITION_NAME 
    FROM INFORMATION_SCHEMA.PARTITIONS 
    WHERE TABLE_SCHEMA = '$DATABASE' 
      AND TABLE_NAME = '$TABLE'
      AND PARTITION_NAME LIKE 'p20%'
      AND PARTITION_NAME NOT LIKE 'p_future'
      AND CAST(REPLACE(PARTITION_NAME, 'p', '') AS UNSIGNED) < $CUTOFF_MONTH
" | while read partition; do
    echo "Dropping partition: $partition"
    
    # Archiver avant suppression (optionnel)
    # ALTER TABLE ... EXCHANGE PARTITION ...
    
    # Supprimer la partition
    mysql -e "ALTER TABLE $DATABASE.$TABLE DROP PARTITION $partition"
    
    echo "Dropped: $partition"
done
```

**Cron mensuel** :

```bash
# /etc/cron.monthly/purge-old-partitions
0 2 1 * * /usr/local/bin/purge-old-partitions.sh >> /var/log/mysql/partition-purge.log 2>&1
```

---

## Optimisation des requ√™tes

### Requ√™tes exploitant le partition pruning

```sql
-- ‚úÖ OPTIMAL - Filtre sur colonne de partitionnement
SELECT * FROM orders 
WHERE order_date >= '2025-12-01' 
  AND order_date < '2026-01-01';
-- Acc√®s: 1 partition (p2025_12)

-- ‚úÖ OPTIMAL - Plage de dates
SELECT COUNT(*) FROM orders 
WHERE order_date BETWEEN '2025-10-01' AND '2025-12-31';
-- Acc√®s: 3 partitions (p2025_10, p2025_11, p2025_12)

-- ‚ö†Ô∏è SOUS-OPTIMAL - Pas de filtre sur order_date
SELECT * FROM orders 
WHERE customer_id = 12345;
-- Acc√®s: TOUTES les partitions

-- ‚úÖ AM√âLIORATION - Ajouter filtre temporel si possible
SELECT * FROM orders 
WHERE customer_id = 12345 
  AND order_date >= '2025-01-01';  -- Filtre temporel
-- Acc√®s: Partitions depuis 2025 seulement
```

### Index et partitionnement

Chaque partition a ses **propres index** :

```sql
-- Cr√©er index sur table partitionn√©e
CREATE INDEX idx_customer ON orders(customer_id);

-- En r√©alit√©, cr√©e:
-- - idx_customer sur partition p2024_01
-- - idx_customer sur partition p2024_02
-- - ...
-- - idx_customer sur partition p_future

-- Avantage: Index plus petits, plus performants
-- Inconv√©nient: Requ√™tes sans pruning doivent chercher dans tous les index
```

**Strat√©gie d'indexation** :

```sql
-- Index composite incluant la colonne de partitionnement
CREATE INDEX idx_customer_date ON orders(customer_id, order_date);

-- Requ√™te optimale
SELECT * FROM orders 
WHERE customer_id = 12345 
  AND order_date >= '2025-11-01';
-- Utilise: Partition pruning + index idx_customer_date
```

### Agr√©gations et GROUP BY

```sql
-- Agr√©gation avec partition pruning
SELECT 
    DATE_FORMAT(order_date, '%Y-%m') AS month,
    COUNT(*) AS orders,
    SUM(total) AS revenue
FROM orders
WHERE order_date >= '2025-01-01'
GROUP BY DATE_FORMAT(order_date, '%Y-%m');

-- Optimisation: MariaDB peut parall√©liser l'agr√©gation par partition
-- Chaque partition calcule son COUNT/SUM, puis merge
```

---

## üÜï Conversion partition ‚Üî table (MariaDB 11.8)

### Convertir partition en table ind√©pendante

```sql
-- Cr√©er une table vide avec la structure
CREATE TABLE orders_2023_archive LIKE orders;
ALTER TABLE orders_2023_archive REMOVE PARTITIONING;

-- √âchanger partition avec table (MariaDB 10.0+)
ALTER TABLE orders 
EXCHANGE PARTITION p2023_01 
WITH TABLE orders_2023_archive;

-- orders_2023_archive contient maintenant les donn√©es
-- p2023_01 est vide

-- Optionnel: Supprimer la partition vide
ALTER TABLE orders DROP PARTITION p2023_01;
```

**üÜï MariaDB 11.8 : Am√©lioration de la conversion** :

```sql
-- Gestion avanc√©e avec v√©rification
ALTER TABLE orders 
EXCHANGE PARTITION p2023_01 
WITH TABLE orders_2023_archive
WITHOUT VALIDATION;  -- Plus rapide, skip validation (si s√ªr)

-- Ou avec validation stricte
ALTER TABLE orders 
EXCHANGE PARTITION p2023_01 
WITH TABLE orders_2023_archive
WITH VALIDATION;  -- V√©rifie contraintes, plus lent
```

### Convertir table en partition

```sql
-- 1. Cr√©er table partitionn√©e avec partition vide pour nouvelle donn√©e
CREATE TABLE orders_new (
    order_id BIGINT,
    order_date DATE,
    total DECIMAL(10,2),
    PRIMARY KEY (order_id, order_date)
) PARTITION BY RANGE (YEAR(order_date) * 100 + MONTH(order_date)) (
    PARTITION p_temp VALUES LESS THAN MAXVALUE
);

-- 2. √âchanger table existante avec partition
ALTER TABLE orders_new 
EXCHANGE PARTITION p_temp 
WITH TABLE orders_2023_archive;

-- 3. Renommer la partition
ALTER TABLE orders_new 
REORGANIZE PARTITION p_temp INTO (
    PARTITION p2023_archive VALUES LESS THAN (202400),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- 4. Swap tables
RENAME TABLE 
    orders TO orders_old,
    orders_new TO orders;
```

---

## Maintenance et optimisation

### ANALYZE TABLE par partition

```sql
-- Analyser une partition sp√©cifique
ALTER TABLE orders ANALYZE PARTITION p2025_12;

-- Analyser plusieurs partitions
ALTER TABLE orders ANALYZE PARTITION p2025_10, p2025_11, p2025_12;

-- Analyser toutes les partitions
ANALYZE TABLE orders;
```

### OPTIMIZE TABLE par partition

```sql
-- Optimiser partition sp√©cifique (d√©fragmentation)
ALTER TABLE orders OPTIMIZE PARTITION p2025_11;

-- Note: OPTIMIZE peut √™tre long sur grosses partitions
-- Planifier pendant heures creuses
```

### REBUILD PARTITION

```sql
-- Reconstruire partition (d√©fragmentation + r√©indexation)
ALTER TABLE orders REBUILD PARTITION p2025_12;

-- Use case: Apr√®s beaucoup de UPDATE/DELETE
```

### CHECK et REPAIR

```sql
-- V√©rifier int√©grit√© partition
ALTER TABLE orders CHECK PARTITION p2025_12;

-- R√©parer partition (si corruption d√©tect√©e)
ALTER TABLE orders REPAIR PARTITION p2025_12;
```

---

## Monitoring et diagnostic

### Informations sur les partitions

```sql
-- Liste des partitions et leur taille
SELECT 
    PARTITION_NAME,
    PARTITION_METHOD,
    PARTITION_EXPRESSION,
    PARTITION_DESCRIPTION,
    TABLE_ROWS,
    ROUND(DATA_LENGTH / 1024 / 1024, 2) AS data_mb,
    ROUND(INDEX_LENGTH / 1024 / 1024, 2) AS index_mb,
    ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) AS total_mb,
    CREATE_TIME,
    UPDATE_TIME
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_SCHEMA = 'ecommerce'
  AND TABLE_NAME = 'orders'
ORDER BY PARTITION_ORDINAL_POSITION;

+----------------+------------------+--------------------------------------+-----------+------+-----+-----+-----+
| PARTITION_NAME | PARTITION_METHOD | PARTITION_EXPRESSION                 | TABLE_ROWS| data_mb | index_mb | total_mb |
+----------------+------------------+--------------------------------------+-----------+---------+----------+----------+
| p2024_01       | RANGE            | YEAR(order_date)*100+MONTH(order...) |   4567890 | 1234.56 |   345.67 |  1580.23 |
| p2024_02       | RANGE            | YEAR(order_date)*100+MONTH(order...) |   4789012 | 1289.34 |   356.78 |  1646.12 |
| ...            |                  |                                      |           |         |          |          |
| p2025_12       | RANGE            | YEAR(order_date)*100+MONTH(order...) |   5123456 | 1456.78 |   389.01 |  1845.79 |
| p_future       | RANGE            | YEAR(order_date)*100+MONTH(order...) |         0 |    0.00 |     0.00 |     0.00 |
+----------------+------------------+--------------------------------------+-----------+---------+----------+----------+
```

### V√©rification du partition pruning

```sql
-- Utiliser EXPLAIN PARTITIONS
EXPLAIN PARTITIONS
SELECT * FROM orders 
WHERE order_date = '2025-12-15';

+----+-------------+--------+------------+------+
| id | select_type | table  | partitions | type |
+----+-------------+--------+------------+------+
|  1 | SIMPLE      | orders | p2025_12   | ALL  |
+----+-------------+--------+------------+------+

-- Si partitions = p2024_01,p2024_02,...,p_future
-- ‚Üí Pas de pruning, probl√®me de requ√™te !
```

### D√©tection de partitions d√©s√©quilibr√©es

```sql
-- Identifier partitions trop volumineuses
SELECT 
    PARTITION_NAME,
    TABLE_ROWS,
    ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) AS total_mb
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_SCHEMA = 'ecommerce'
  AND TABLE_NAME = 'orders'
  AND PARTITION_NAME IS NOT NULL
HAVING total_mb > 5000  -- Alerte si partition > 5 GB
ORDER BY total_mb DESC;
```

---

## Cas d'usage et patterns

### Pattern 1 : Table de logs avec r√©tention glissante

**Contexte** : Logs applicatifs, r√©tention 90 jours.

```sql
CREATE TABLE application_logs (
    log_id BIGINT AUTO_INCREMENT,
    log_timestamp DATETIME NOT NULL,
    level ENUM('DEBUG','INFO','WARNING','ERROR','CRITICAL'),
    message TEXT,
    PRIMARY KEY (log_id, log_timestamp)
) PARTITION BY RANGE (TO_DAYS(log_timestamp)) (
    -- Partitions journali√®res
    -- Automatiquement g√©r√©es par script
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**Automatisation** :

```bash
#!/bin/bash
# manage-log-partitions.sh

TABLE="application_logs"
DATABASE="myapp"
RETENTION_DAYS=90

# Ajouter partition pour demain
TOMORROW=$(date -d "tomorrow" +%Y-%m-%d)
PARTITION_NAME="p$(date -d "tomorrow" +%Y%m%d)"
PARTITION_VALUE=$(mysql -N -B -e "SELECT TO_DAYS('$TOMORROW') + 1")

mysql -e "
ALTER TABLE $DATABASE.$TABLE 
REORGANIZE PARTITION p_future INTO (
    PARTITION $PARTITION_NAME VALUES LESS THAN ($PARTITION_VALUE),
    PARTITION p_future VALUES LESS THAN MAXVALUE
)"

# Supprimer partitions > 90 jours
CUTOFF_DATE=$(date -d "$RETENTION_DAYS days ago" +%Y%m%d)

mysql -N -B -e "
    SELECT PARTITION_NAME 
    FROM INFORMATION_SCHEMA.PARTITIONS 
    WHERE TABLE_SCHEMA = '$DATABASE' 
      AND TABLE_NAME = '$TABLE'
      AND PARTITION_NAME LIKE 'p20%'
      AND PARTITION_NAME < 'p$CUTOFF_DATE'
" | while read partition; do
    mysql -e "ALTER TABLE $DATABASE.$TABLE DROP PARTITION $partition"
done
```

**Cron quotidien** :

```
0 0 * * * /usr/local/bin/manage-log-partitions.sh
```

### Pattern 2 : Table transactionnelle avec archivage mensuel

**Contexte** : Commandes e-commerce, archiver > 24 mois.

```sql
CREATE TABLE orders (
    order_id BIGINT AUTO_INCREMENT,
    order_date DATE NOT NULL,
    customer_id INT,
    total DECIMAL(10,2),
    status ENUM('pending','processing','shipped','delivered','cancelled'),
    PRIMARY KEY (order_id, order_date),
    INDEX idx_customer (customer_id, order_date),
    INDEX idx_status (status, order_date)
) PARTITION BY RANGE (YEAR(order_date) * 100 + MONTH(order_date)) (
    -- Partitions mensuelles depuis janvier 2023
    PARTITION p2023_01 VALUES LESS THAN (202302),
    -- ... g√©n√©r√© automatiquement
    PARTITION p2025_12 VALUES LESS THAN (202601),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**Proc√©dure d'archivage** :

```sql
DELIMITER $$

CREATE PROCEDURE archive_old_orders(
    IN retention_months INT
)
BEGIN
    DECLARE cutoff_month INT;
    DECLARE partition_to_archive VARCHAR(64);
    DECLARE done INT DEFAULT 0;
    
    DECLARE cur CURSOR FOR
        SELECT PARTITION_NAME
        FROM INFORMATION_SCHEMA.PARTITIONS
        WHERE TABLE_SCHEMA = 'ecommerce'
          AND TABLE_NAME = 'orders'
          AND PARTITION_NAME LIKE 'p20%_%'
          AND PARTITION_NAME NOT LIKE 'p_future'
          AND CAST(REPLACE(PARTITION_NAME, 'p', '') AS UNSIGNED) < 
              (YEAR(DATE_SUB(NOW(), INTERVAL retention_months MONTH)) * 100 + 
               MONTH(DATE_SUB(NOW(), INTERVAL retention_months MONTH)));
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    
    OPEN cur;
    
    read_loop: LOOP
        FETCH cur INTO partition_to_archive;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- Archiver vers S3, dump, etc.
        -- mysqldump specifique partition...
        
        -- Supprimer la partition
        SET @sql = CONCAT('ALTER TABLE orders DROP PARTITION ', partition_to_archive);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        SELECT CONCAT('Archived and dropped partition: ', partition_to_archive) AS status;
    END LOOP;
    
    CLOSE cur;
END$$

DELIMITER ;

-- Ex√©cution mensuelle via EVENT
CREATE EVENT archive_orders_monthly
ON SCHEDULE EVERY 1 MONTH
DO CALL archive_old_orders(24);  -- Archiver > 24 mois
```

### Pattern 3 : Sharding temporel pour analytics

**Contexte** : Analytics sur donn√©es massives, requ√™tes toujours filtr√©es par p√©riode.

```sql
CREATE TABLE page_views (
    view_id BIGINT AUTO_INCREMENT,
    view_date DATE NOT NULL,
    page_url VARCHAR(500),
    user_id INT,
    session_id CHAR(36),
    duration_seconds INT,
    PRIMARY KEY (view_id, view_date),
    INDEX idx_user_date (user_id, view_date),
    INDEX idx_page (page_url(100), view_date)
) PARTITION BY RANGE (TO_DAYS(view_date)) (
    -- Partitions hebdomadaires pour r√©duire le nombre de partitions
    -- Week 1
    PARTITION p2025_W01 VALUES LESS THAN (TO_DAYS('2025-01-08')),
    PARTITION p2025_W02 VALUES LESS THAN (TO_DAYS('2025-01-15')),
    -- ...
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**Requ√™tes analytics optimis√©es** :

```sql
-- Trafic par jour (derni√®re semaine)
SELECT 
    view_date,
    COUNT(*) AS page_views,
    COUNT(DISTINCT user_id) AS unique_users
FROM page_views
WHERE view_date >= CURDATE() - INTERVAL 7 DAY
GROUP BY view_date;
-- Partition pruning: 1-2 partitions seulement

-- Top 10 pages (dernier mois)
SELECT 
    page_url,
    COUNT(*) AS views,
    AVG(duration_seconds) AS avg_duration
FROM page_views
WHERE view_date >= CURDATE() - INTERVAL 30 DAY
GROUP BY page_url
ORDER BY views DESC
LIMIT 10;
-- Partition pruning: ~4 partitions
```

---

## Limitations et consid√©rations

### Limitations techniques

1. **Maximum 8192 partitions** par table (MariaDB/MySQL)
   - Suffisant pour ~682 ans de partitions journali√®res
   - Mais attention aux partitions horaires (24 √ó 365 = 8760/an !)

2. **Pas de cl√©s √©trang√®res inter-partitions**
   ```sql
   -- ‚ùå FK r√©f√©ren√ßant table partitionn√©e : Complexe
   -- Pr√©f√©rer contraintes applicatives
   ```

3. **FULLTEXT indexes** : Limitations selon versions
   - MariaDB 10.0+ : Support partiel
   - Tester en environnement staging

4. **Performance MAXVALUE** :
   - Partition `p_future VALUES LESS THAN MAXVALUE` peut devenir √©norme
   - Automatiser ajout de nouvelles partitions r√©guli√®rement

### Overhead de partitionnement

```
Overhead de gestion:
- Chaque partition = fichier .ibd s√©par√©
- Trop de partitions = overhead filesystem (inodes, descripteurs)
- Requ√™tes sans pruning = scan de tous les fichiers

R√®gle empirique:
- < 50 partitions : Aucun probl√®me
- 50-200 partitions : Acceptable
- 200-1000 partitions : Surveiller
- > 1000 partitions : R√©viser strat√©gie
```

### Quand NE PAS partitionner

‚ùå **Ne pas partitionner si** :
- Table < 10 GB et croissance lente
- Requ√™tes rarement filtr√©es sur colonne s√©quentielle
- Pas de strat√©gie d'archivage/purge claire
- Workload n√©cessite scanning complet r√©gulier
- Complexit√© de gestion > b√©n√©fices

‚úÖ **Partitionner si** :
- Table > 50 GB avec croissance continue
- Requ√™tes filtrent presque toujours sur colonne temporelle/s√©quentielle
- Besoin d'archivage/purge r√©gulier
- Performance requiert isolation des donn√©es chaudes/froides

---

## ‚úÖ Points cl√©s √† retenir

- **RANGE partitioning divise une table en plages de valeurs**, id√©al pour donn√©es temporelles (DATE, DATETIME) ou ID s√©quentiels.

- **Partition pruning = gain de performance massif** : MariaDB n'acc√®de qu'aux partitions n√©cessaires si le WHERE filtre sur la colonne de partitionnement. Gain typique : 50-99% de r√©duction des I/O.

- **Colonne de partitionnement doit √™tre dans PRIMARY KEY** : Contrainte obligatoire pour garantir l'unicit√© et d√©terminer la partition d'une ligne.

- **DROP PARTITION = quasi-instantan√©** : Suppression de millions de lignes en < 1 seconde, vs DELETE qui prendrait des heures. Id√©al pour archivage/purge.

- **Partition p_future avec MAXVALUE** : √âvite les erreurs INSERT sur donn√©es hors limites. Automatiser la cr√©ation de nouvelles partitions avant qu'elle ne grossisse trop.

- **Automatisation essentielle** : Scripts cron pour ajouter nouvelles partitions, purger anciennes, analyser. Sans automatisation, maintenance devient ing√©rable.

- **üÜï MariaDB 11.8 : Conversion partition ‚Üî table am√©lior√©e** : EXCHANGE PARTITION WITH/WITHOUT VALIDATION pour gestion avanc√©e.

- **Monitoring r√©gulier** : Surveiller taille des partitions (INFORMATION_SCHEMA.PARTITIONS), √©quilibre, et v√©rifier partition pruning avec EXPLAIN PARTITIONS.

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB
- [üìñ Partitioning Overview](https://mariadb.com/kb/en/partitioning-overview/)
- [üìñ RANGE Partitioning](https://mariadb.com/kb/en/partitioning-types/#range-partitioning)
- [üìñ Partition Pruning](https://mariadb.com/kb/en/partition-pruning-and-selection/)
- [üìñ Partition Maintenance](https://mariadb.com/kb/en/partition-maintenance/)

### Articles techniques
- [Percona Blog - Table Partitioning](https://www.percona.com/blog/)
- [MySQL Performance Blog - Partitioning](https://www.percona.com/blog/)

### Outils
- [pt-online-schema-change](https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html)
- [Partition Manager Scripts](https://github.com/mysql/mysql-server/tree/8.0/scripts)

---

## ‚û°Ô∏è Section suivante

**15.9.2 LIST Partitioning** : Nous explorerons le partitionnement par liste de valeurs discr√®tes, id√©al pour cat√©goriser par r√©gion, statut, ou type d'entit√©. Nous verrons les diff√©rences avec RANGE, les cas d'usage sp√©cifiques, et les strat√©gies de gestion.

‚è≠Ô∏è [LIST partitioning](/15-performance-tuning/09.2-list-partitioning.md)
