ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 15.12.2 mysqlslap

> **Niveau** : Expert  
> **DurÃ©e estimÃ©e** : 2-3 heures  
> **PrÃ©requis** : Section 15.12.1 (sysbench), ComprÃ©hension des mÃ©triques de performance

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Utiliser mysqlslap pour des tests de charge rapides
- CrÃ©er des scÃ©narios de test avec auto-gÃ©nÃ©ration de donnÃ©es
- Tester des requÃªtes SQL personnalisÃ©es
- Comparer diffÃ©rentes configurations MariaDB
- Identifier les goulots d'Ã©tranglement de concurrence
- Automatiser les tests de performance
- Choisir entre mysqlslap et sysbench selon le contexte
- InterprÃ©ter les rÃ©sultats et optimiser en consÃ©quence

---

## Introduction

**mysqlslap** est un outil de benchmarking **inclus nativement** avec MariaDB et MySQL. Contrairement Ã  sysbench qui nÃ©cessite une installation sÃ©parÃ©e, mysqlslap est immÃ©diatement disponible aprÃ¨s installation de MariaDB.

### Comparaison mysqlslap vs sysbench

| CritÃ¨re | mysqlslap | sysbench |
|---------|-----------|----------|
| **Installation** | Inclus avec MariaDB âœ“ | Installation sÃ©parÃ©e |
| **SimplicitÃ©** | TrÃ¨s simple, dÃ©marrage rapide âœ“ | Plus complexe |
| **FlexibilitÃ©** | Tests SQL personnalisÃ©s âœ“ | Scripts Lua personnalisÃ©s |
| **Auto-gÃ©nÃ©ration** | DonnÃ©es et requÃªtes âœ“ | SchÃ©ma prÃ©dÃ©fini |
| **MÃ©triques** | Basiques (temps, min/max/avg) | DÃ©taillÃ©es (p95, p99, etc.) |
| **Tests systÃ¨me** | Base de donnÃ©es uniquement | DB, I/O, CPU, mÃ©moire |
| **Courbe apprentissage** | Faible âœ“ | Moyenne |
| **Production** | Tests rapides, validations | Benchmarks complets |

**Quand utiliser mysqlslap** :
- âœ… Tests rapides et ad-hoc
- âœ… Validation aprÃ¨s modification configuration
- âœ… Tests de requÃªtes SQL spÃ©cifiques
- âœ… Comparaison de schÃ©mas alternatifs
- âœ… Pas d'installation supplÃ©mentaire possible

**Quand utiliser sysbench** :
- âœ… Benchmarks complets et rigoureux
- âœ… Tests de montÃ©e en charge
- âœ… Comparaison matÃ©rielle
- âœ… Tests de rÃ©gression automatisÃ©s
- âœ… MÃ©triques dÃ©taillÃ©es nÃ©cessaires

ğŸ’¡ **En pratique** : mysqlslap pour tests rapides quotidiens, sysbench pour benchmarks officiels.

---

## Utilisation basique

### VÃ©rification de l'installation

```bash
# mysqlslap est installÃ© avec MariaDB
which mysqlslap
/usr/bin/mysqlslap

mysqlslap --version
mysqlslap  Ver 1.0 Distrib 11.8.0-MariaDB
```

### Premier test simple

```bash
# Test basique : 50 clients, 100 requÃªtes chacun
mysqlslap \
    --user=root \
    --password=yourpassword \
    --host=localhost \
    --concurrency=50 \
    --iterations=1 \
    --auto-generate-sql \
    --auto-generate-sql-load-type=mixed \
    --auto-generate-sql-add-autoincrement \
    --number-of-queries=100

# RÃ©sultat:
# Benchmark
#         Average number of seconds to run all queries: 2.134 seconds
#         Minimum number of seconds to run all queries: 2.134 seconds
#         Maximum number of seconds to run all queries: 2.134 seconds
#         Number of clients running queries: 50
#         Average number of queries per client: 100
```

**ParamÃ¨tres clÃ©s** :
- `--concurrency=N` : Nombre de clients simultanÃ©s
- `--iterations=N` : Nombre de rÃ©pÃ©titions du test
- `--number-of-queries=N` : Total de requÃªtes Ã  exÃ©cuter
- `--auto-generate-sql` : GÃ©nÃ©ration automatique de schÃ©ma et donnÃ©es

---

## Auto-gÃ©nÃ©ration de donnÃ©es et requÃªtes

### Types de charge (--auto-generate-sql-load-type)

```bash
# 1. Lecture seule (SELECT)
mysqlslap \
    --user=root \
    --password=yourpassword \
    --concurrency=20 \
    --iterations=3 \
    --auto-generate-sql \
    --auto-generate-sql-load-type=read \
    --number-of-queries=1000

# 2. Ã‰criture seule (INSERT)
mysqlslap \
    --user=root \
    --password=yourpassword \
    --concurrency=20 \
    --iterations=3 \
    --auto-generate-sql \
    --auto-generate-sql-load-type=write \
    --number-of-queries=1000

# 3. Mixte (SELECT + INSERT + UPDATE)
mysqlslap \
    --user=root \
    --password=yourpassword \
    --concurrency=20 \
    --iterations=3 \
    --auto-generate-sql \
    --auto-generate-sql-load-type=mixed \
    --number-of-queries=1000

# 4. Mise Ã  jour (UPDATE)
mysqlslap \
    --user=root \
    --password=yourpassword \
    --concurrency=20 \
    --iterations=3 \
    --auto-generate-sql \
    --auto-generate-sql-load-type=update \
    --number-of-queries=1000
```

### Configuration du schÃ©ma auto-gÃ©nÃ©rÃ©

```bash
# SpÃ©cifier nombre de colonnes INTEGER et CHAR
mysqlslap \
    --user=root \
    --password=yourpassword \
    --concurrency=50 \
    --iterations=1 \
    --auto-generate-sql \
    --auto-generate-sql-add-autoincrement \
    --auto-generate-sql-guid-primary \
    --auto-generate-sql-secondary-indexes=3 \
    --auto-generate-sql-unique-write-number=1000 \
    --auto-generate-sql-unique-query-number=1000 \
    --number-int-cols=5 \
    --number-char-cols=10 \
    --number-of-queries=10000

# ParamÃ¨tres:
# --auto-generate-sql-add-autoincrement : Ajoute colonne AUTO_INCREMENT
# --auto-generate-sql-guid-primary      : Utilise GUID comme PK
# --auto-generate-sql-secondary-indexes=N : N index secondaires
# --auto-generate-sql-unique-write-number : Nombre d'INSERT uniques
# --auto-generate-sql-unique-query-number : Nombre de SELECT uniques
# --number-int-cols=N  : N colonnes INTEGER
# --number-char-cols=N : N colonnes CHAR
```

**SchÃ©ma gÃ©nÃ©rÃ© automatiquement** :

```sql
-- Exemple de table crÃ©Ã©e par mysqlslap
CREATE TABLE t1 (
    intcol1 INT NOT NULL AUTO_INCREMENT,
    intcol2 INT,
    intcol3 INT,
    intcol4 INT,
    intcol5 INT,
    charcol1 VARCHAR(128),
    charcol2 VARCHAR(128),
    charcol3 VARCHAR(128),
    charcol4 VARCHAR(128),
    charcol5 VARCHAR(128),
    charcol6 VARCHAR(128),
    charcol7 VARCHAR(128),
    charcol8 VARCHAR(128),
    charcol9 VARCHAR(128),
    charcol10 VARCHAR(128),
    PRIMARY KEY (intcol1),
    KEY idx1 (intcol2),
    KEY idx2 (intcol3),
    KEY idx3 (charcol1)
) ENGINE=InnoDB;
```

---

## Tests avec requÃªtes personnalisÃ©es

### Fichier de requÃªtes SQL

**CrÃ©er fichier `queries.sql`** :

```sql
-- queries.sql
SELECT * FROM orders WHERE customer_id = 12345;
SELECT COUNT(*) FROM orders WHERE status = 'pending';
SELECT o.*, c.customer_name FROM orders o JOIN customers c ON o.customer_id = c.customer_id WHERE o.order_date >= '2025-01-01';
UPDATE orders SET status = 'processing' WHERE order_id = 67890;
INSERT INTO order_logs (order_id, action, timestamp) VALUES (67890, 'status_change', NOW());
```

**ExÃ©cuter tests avec fichier** :

```bash
mysqlslap \
    --user=root \
    --password=yourpassword \
    --host=localhost \
    --concurrency=25 \
    --iterations=5 \
    --query=queries.sql \
    --create-schema=mydb \
    --delimiter=";" \
    --verbose

# RÃ©sultat:
# Benchmark
#         Average number of seconds to run all queries: 1.234 seconds
#         Minimum number of seconds to run all queries: 1.156 seconds
#         Maximum number of seconds to run all queries: 1.312 seconds
#         Number of clients running queries: 25
#         Average number of queries per client: 5
```

### Tests avec initialisation de schÃ©ma

**Fichier `create.sql`** :

```sql
-- create.sql
CREATE TABLE IF NOT EXISTS test_table (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user (user_id),
    INDEX idx_product (product_id)
) ENGINE=InnoDB;
```

**Fichier `insert.sql`** :

```sql
-- insert.sql
INSERT INTO test_table (user_id, product_id, quantity, price) 
VALUES (FLOOR(RAND() * 10000), FLOOR(RAND() * 1000), FLOOR(RAND() * 10), RAND() * 100);
```

**Fichier `select.sql`** :

```sql
-- select.sql
SELECT * FROM test_table WHERE user_id = FLOOR(RAND() * 10000) LIMIT 10;
SELECT COUNT(*), AVG(price) FROM test_table WHERE product_id = FLOOR(RAND() * 1000);
```

**ExÃ©cution complÃ¨te** :

```bash
# Test avec crÃ©ation, insertion et sÃ©lection
mysqlslap \
    --user=root \
    --password=yourpassword \
    --host=localhost \
    --concurrency=50 \
    --iterations=3 \
    --create=create.sql \
    --query=select.sql \
    --create-schema=test_db \
    --number-of-queries=10000 \
    --verbose \
    --delimiter=";"

# Options:
# --create=file.sql : ExÃ©cutÃ© une fois au dÃ©but
# --query=file.sql  : ExÃ©cutÃ© par chaque client
```

---

## Tests de montÃ©e en charge

### Tester diffÃ©rents niveaux de concurrence

```bash
#!/bin/bash
# concurrency-test.sh

echo "Concurrency,Avg_Time,Min_Time,Max_Time" > concurrency_results.csv

for CONCURRENCY in 1 5 10 25 50 100 200; do
    echo "Testing with $CONCURRENCY concurrent clients..."
    
    RESULT=$(mysqlslap \
        --user=root \
        --password=yourpassword \
        --host=localhost \
        --concurrency=$CONCURRENCY \
        --iterations=3 \
        --auto-generate-sql \
        --auto-generate-sql-load-type=mixed \
        --auto-generate-sql-add-autoincrement \
        --number-of-queries=1000 \
        2>&1)
    
    AVG=$(echo "$RESULT" | grep "Average" | awk '{print $8}')
    MIN=$(echo "$RESULT" | grep "Minimum" | awk '{print $8}')
    MAX=$(echo "$RESULT" | grep "Maximum" | awk '{print $8}')
    
    echo "$CONCURRENCY,$AVG,$MIN,$MAX" >> concurrency_results.csv
    
    sleep 10  # Pause entre tests
done

echo "Results saved to concurrency_results.csv"
cat concurrency_results.csv
```

**RÃ©sultats typiques** :

```
Concurrency,Avg_Time,Min_Time,Max_Time
1,0.234,0.231,0.237
5,0.456,0.441,0.468
10,0.789,0.765,0.812
25,1.234,1.201,1.267
50,2.456,2.389,2.523
100,4.789,4.612,4.956
200,9.234,8.967,9.501
```

**Analyse** :

```
Temps (s)
10 |                              â•­â”€â”€â”€â”€â”€
   |                           â•­â”€â”€â•¯
 8 |                        â•­â”€â”€â•¯
   |                     â•­â”€â”€â•¯
 6 |                  â•­â”€â”€â•¯
   |               â•­â”€â”€â•¯
 4 |            â•­â”€â”€â•¯
   |         â•­â”€â”€â•¯
 2 |      â•­â”€â”€â•¯
   |   â•­â”€â”€â•¯
 0 |â•­â”€â”€â•¯
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   1   5  10  25  50 100 200  Concurrency

Observation: Temps augmente linÃ©airement jusqu'Ã  50 threads
puis exponentiellement â†’ Saturation Ã  ~50-100 threads
```

---

## Comparaison de configurations

### Test avant/aprÃ¨s optimisation

```bash
#!/bin/bash
# compare-configs.sh

# Configuration AVANT optimisation
echo "=== Testing BEFORE optimization ==="
mysql -u root -p << 'EOF'
SET GLOBAL innodb_buffer_pool_size = 1G;
SET GLOBAL innodb_io_capacity = 200;
SET GLOBAL innodb_flush_method = fsync;
EOF

sleep 10

mysqlslap \
    --user=root \
    --password=yourpassword \
    --concurrency=50 \
    --iterations=5 \
    --auto-generate-sql \
    --auto-generate-sql-load-type=mixed \
    --number-of-queries=10000 \
    > before.txt

BEFORE_AVG=$(grep "Average" before.txt | awk '{print $8}')

# Configuration APRÃˆS optimisation
echo "=== Testing AFTER optimization ==="
mysql -u root -p << 'EOF'
SET GLOBAL innodb_buffer_pool_size = 8G;
SET GLOBAL innodb_io_capacity = 10000;
SET GLOBAL innodb_flush_method = O_DIRECT;
EOF

sleep 10

mysqlslap \
    --user=root \
    --password=yourpassword \
    --concurrency=50 \
    --iterations=5 \
    --auto-generate-sql \
    --auto-generate-sql-load-type=mixed \
    --number-of-queries=10000 \
    > after.txt

AFTER_AVG=$(grep "Average" after.txt | awk '{print $8}')

# Calculer amÃ©lioration
IMPROVEMENT=$(echo "scale=2; ($BEFORE_AVG - $AFTER_AVG) / $BEFORE_AVG * 100" | bc)

echo "=== RESULTS ==="
echo "Before optimization: $BEFORE_AVG seconds"
echo "After optimization:  $AFTER_AVG seconds"
echo "Improvement: ${IMPROVEMENT}%"
```

### Comparaison de moteurs de stockage

```bash
#!/bin/bash
# compare-engines.sh

# CrÃ©er schÃ©ma de test
cat > create_innodb.sql << 'EOF'
CREATE TABLE test_innodb (
    id INT AUTO_INCREMENT PRIMARY KEY,
    data VARCHAR(255)
) ENGINE=InnoDB;
EOF

cat > create_myisam.sql << 'EOF'
CREATE TABLE test_myisam (
    id INT AUTO_INCREMENT PRIMARY KEY,
    data VARCHAR(255)
) ENGINE=MyISAM;
EOF

cat > query.sql << 'EOF'
INSERT INTO test_table (data) VALUES (MD5(RAND()));
SELECT * FROM test_table WHERE id = FLOOR(RAND() * 10000);
EOF

# Test InnoDB
echo "=== Testing InnoDB ==="
mysqlslap \
    --user=root \
    --password=yourpassword \
    --create=create_innodb.sql \
    --query=query.sql \
    --concurrency=25 \
    --iterations=5 \
    --number-of-queries=10000 \
    --create-schema=test_innodb \
    > innodb_results.txt

# Test MyISAM
echo "=== Testing MyISAM ==="
mysqlslap \
    --user=root \
    --password=yourpassword \
    --create=create_myisam.sql \
    --query=query.sql \
    --concurrency=25 \
    --iterations=5 \
    --number-of-queries=10000 \
    --create-schema=test_myisam \
    > myisam_results.txt

# Comparer
INNODB_AVG=$(grep "Average" innodb_results.txt | awk '{print $8}')
MYISAM_AVG=$(grep "Average" myisam_results.txt | awk '{print $8}')

echo "InnoDB average: $INNODB_AVG seconds"
echo "MyISAM average: $MYISAM_AVG seconds"
```

---

## Tests de requÃªtes complexes

### Simuler workload e-commerce

```sql
-- ecommerce-schema.sql
CREATE TABLE IF NOT EXISTS products (
    product_id INT AUTO_INCREMENT PRIMARY KEY,
    product_name VARCHAR(200),
    category VARCHAR(50),
    price DECIMAL(10,2),
    stock INT,
    INDEX idx_category (category)
) ENGINE=InnoDB;

CREATE TABLE IF NOT EXISTS orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT,
    order_date DATETIME,
    total DECIMAL(10,2),
    status VARCHAR(20),
    INDEX idx_customer (customer_id),
    INDEX idx_date (order_date)
) ENGINE=InnoDB;

CREATE TABLE IF NOT EXISTS order_items (
    item_id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT,
    product_id INT,
    quantity INT,
    price DECIMAL(10,2),
    INDEX idx_order (order_id),
    INDEX idx_product (product_id)
) ENGINE=InnoDB;
```

```sql
-- ecommerce-queries.sql
-- Recherche produits
SELECT * FROM products WHERE category = 'Electronics' AND price < 500 ORDER BY price LIMIT 20;

-- DÃ©tail commande
SELECT o.order_id, o.total, oi.product_id, oi.quantity, p.product_name
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products p ON oi.product_id = p.product_id
WHERE o.customer_id = 12345
ORDER BY o.order_date DESC
LIMIT 10;

-- Statistiques ventes
SELECT category, COUNT(*) as orders, SUM(total) as revenue
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products p ON oi.product_id = p.product_id
WHERE o.order_date >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY category;

-- Mise Ã  jour stock
UPDATE products SET stock = stock - 1 WHERE product_id = 789;

-- Insertion commande
INSERT INTO orders (customer_id, order_date, total, status) 
VALUES (12345, NOW(), 299.99, 'pending');
```

**Test du workload** :

```bash
mysqlslap \
    --user=root \
    --password=yourpassword \
    --host=localhost \
    --create=ecommerce-schema.sql \
    --query=ecommerce-queries.sql \
    --concurrency=50 \
    --iterations=3 \
    --create-schema=ecommerce_test \
    --number-of-queries=5000 \
    --delimiter=";" \
    --verbose

# RÃ©sultat:
# Benchmark
#         Average number of seconds to run all queries: 3.456 seconds
#         Minimum number of seconds to run all queries: 3.234 seconds
#         Maximum number of seconds to run all queries: 3.678 seconds
#         Number of clients running queries: 50
#         Average number of queries per client: 100
```

---

## Cas d'usage pratiques

### Cas 1 : Validation rapide aprÃ¨s changement

```bash
#!/bin/bash
# quick-validation.sh

# Baseline avant changement
echo "Running baseline test..."
mysqlslap \
    --user=root \
    --password=yourpassword \
    --concurrency=25 \
    --iterations=3 \
    --auto-generate-sql \
    --auto-generate-sql-load-type=mixed \
    --number-of-queries=1000 \
    > baseline.txt

BASELINE=$(grep "Average" baseline.txt | awk '{print $8}')
echo "Baseline: $BASELINE seconds"

# Appliquer changement (exemple: modification index)
echo "Applying changes..."
mysql -u root -p mydb << 'EOF'
ALTER TABLE large_table ADD INDEX idx_new_column (new_column);
EOF

# Test aprÃ¨s changement
echo "Running validation test..."
mysqlslap \
    --user=root \
    --password=yourpassword \
    --concurrency=25 \
    --iterations=3 \
    --auto-generate-sql \
    --auto-generate-sql-load-type=mixed \
    --number-of-queries=1000 \
    > validation.txt

VALIDATION=$(grep "Average" validation.txt | awk '{print $8}')
echo "After change: $VALIDATION seconds"

# Comparer
DIFF=$(echo "scale=2; ($BASELINE - $VALIDATION) / $BASELINE * 100" | bc)

if (( $(echo "$DIFF > 5" | bc -l) )); then
    echo "âœ“ Improvement: +${DIFF}%"
elif (( $(echo "$DIFF < -5" | bc -l) )); then
    echo "âœ— Degradation: ${DIFF}%"
    echo "Consider rolling back change"
else
    echo "â‰ˆ No significant change"
fi
```

### Cas 2 : Test de scalabilitÃ© d'une requÃªte

```bash
#!/bin/bash
# query-scalability.sh

# Tester une requÃªte spÃ©cifique avec diffÃ©rents volumes
cat > test_query.sql << 'EOF'
SELECT o.order_id, c.customer_name, SUM(oi.quantity * oi.price) as total
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
JOIN order_items oi ON o.order_id = oi.order_id
WHERE o.order_date >= DATE_SUB(NOW(), INTERVAL 7 DAY)
GROUP BY o.order_id, c.customer_name
ORDER BY total DESC
LIMIT 100;
EOF

echo "Dataset_Size,Avg_Time" > scalability_results.csv

# Tester avec diffÃ©rentes tailles de dataset
for SIZE in 10000 50000 100000 500000 1000000; do
    echo "Testing with $SIZE rows..."
    
    # InsÃ©rer donnÃ©es (simulÃ© - ajuster selon besoin)
    # ... code d'insertion ...
    
    # Mesurer performance
    RESULT=$(mysqlslap \
        --user=root \
        --password=yourpassword \
        --query=test_query.sql \
        --concurrency=10 \
        --iterations=5 \
        --create-schema=mydb \
        --no-drop \
        2>&1)
    
    AVG=$(echo "$RESULT" | grep "Average" | awk '{print $8}')
    echo "$SIZE,$AVG" >> scalability_results.csv
done

echo "Scalability test complete"
```

### Cas 3 : Comparaison de versions MariaDB

```bash
#!/bin/bash
# compare-versions.sh

TEST_QUERY="SELECT COUNT(*) FROM large_table WHERE indexed_column > 1000;"

# Test MariaDB 11.4 (existant)
echo "=== Testing MariaDB 11.4 ==="
docker run -d --name mariadb-11.4 -e MYSQL_ROOT_PASSWORD=root mariadb:11.4
sleep 30

mysqlslap \
    --host=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' mariadb-11.4) \
    --user=root \
    --password=root \
    --concurrency=50 \
    --iterations=5 \
    --auto-generate-sql \
    --number-of-queries=10000 \
    > version_11.4.txt

# Test MariaDB 11.8 (nouveau)
echo "=== Testing MariaDB 11.8 ==="
docker run -d --name mariadb-11.8 -e MYSQL_ROOT_PASSWORD=root mariadb:11.8
sleep 30

mysqlslap \
    --host=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' mariadb-11.8) \
    --user=root \
    --password=root \
    --concurrency=50 \
    --iterations=5 \
    --auto-generate-sql \
    --number-of-queries=10000 \
    > version_11.8.txt

# Comparer
V114=$(grep "Average" version_11.4.txt | awk '{print $8}')
V118=$(grep "Average" version_11.8.txt | awk '{print $8}')

echo "MariaDB 11.4: $V114 seconds"
echo "MariaDB 11.8: $V118 seconds"

# Cleanup
docker stop mariadb-11.4 mariadb-11.8
docker rm mariadb-11.4 mariadb-11.8
```

---

## Automatisation et intÃ©gration

### Script de monitoring de performance

```bash
#!/bin/bash
# performance-monitor.sh

ALERT_THRESHOLD=3.0  # Alerter si temps > 3 secondes
RESULTS_DIR="./performance-logs"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

mkdir -p $RESULTS_DIR

# Test de rÃ©fÃ©rence quotidien
mysqlslap \
    --user=root \
    --password=yourpassword \
    --concurrency=25 \
    --iterations=5 \
    --auto-generate-sql \
    --auto-generate-sql-load-type=mixed \
    --number-of-queries=5000 \
    > $RESULTS_DIR/daily_test_$TIMESTAMP.txt

AVG_TIME=$(grep "Average" $RESULTS_DIR/daily_test_$TIMESTAMP.txt | awk '{print $8}')

echo "$TIMESTAMP,$AVG_TIME" >> $RESULTS_DIR/performance_history.csv

# VÃ©rifier seuil
if (( $(echo "$AVG_TIME > $ALERT_THRESHOLD" | bc -l) )); then
    echo "âš ï¸ PERFORMANCE ALERT: $AVG_TIME seconds (threshold: $ALERT_THRESHOLD)"
    
    # Envoyer alerte (exemple: email)
    mail -s "Performance Alert - MariaDB" dba@example.com << EOF
Performance degradation detected.
Average query time: $AVG_TIME seconds
Threshold: $ALERT_THRESHOLD seconds
Timestamp: $TIMESTAMP

Please investigate.
EOF
else
    echo "âœ“ Performance OK: $AVG_TIME seconds"
fi
```

**Cron quotidien** :

```bash
# /etc/cron.daily/performance-monitor
0 2 * * * /usr/local/bin/performance-monitor.sh >> /var/log/mysql/performance-monitor.log 2>&1
```

### IntÃ©gration dans pipeline CI/CD

```yaml
# .gitlab-ci.yml
db_performance_test:
  stage: test
  script:
    # DÃ©marrer MariaDB de test
    - docker run -d --name mariadb-test -e MYSQL_ROOT_PASSWORD=testpass mariadb:11.8
    - sleep 30
    
    # RÃ©cupÃ©rer IP container
    - MARIADB_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' mariadb-test)
    
    # CrÃ©er schÃ©ma de test
    - mysql -h $MARIADB_IP -u root -ptestpass < schema.sql
    
    # Test de performance
    - mysqlslap \
        --host=$MARIADB_IP \
        --user=root \
        --password=testpass \
        --concurrency=25 \
        --iterations=3 \
        --query=test-queries.sql \
        --create-schema=testdb \
        --number-of-queries=1000 \
        > performance_results.txt
    
    # VÃ©rifier rÃ©sultats
    - AVG_TIME=$(grep "Average" performance_results.txt | awk '{print $8}')
    - |
      if [ $(echo "$AVG_TIME > 2.0" | bc) -eq 1 ]; then
        echo "Performance test failed: $AVG_TIME seconds (max: 2.0)"
        exit 1
      fi
    
    - echo "Performance test passed: $AVG_TIME seconds"
  
  artifacts:
    paths:
      - performance_results.txt
    expire_in: 7 days
  
  after_script:
    - docker stop mariadb-test
    - docker rm mariadb-test
```

---

## Bonnes pratiques et limitations

### âœ… Bonnes pratiques

1. **Tests rÃ©pÃ©tÃ©s avec --iterations**

```bash
# âŒ Mauvais: 1 seule exÃ©cution
mysqlslap --concurrency=50 --iterations=1 --number-of-queries=1000

# âœ“ Bon: Moyenne de 5 exÃ©cutions
mysqlslap --concurrency=50 --iterations=5 --number-of-queries=1000
```

2. **Utiliser --create-schema pour isolation**

```bash
# CrÃ©er schÃ©ma de test dÃ©diÃ©
mysqlslap \
    --create-schema=test_performance \
    --auto-generate-sql \
    --concurrency=25 \
    --iterations=3
```

3. **Nettoyer avec --post-system**

```bash
# Nettoyer aprÃ¨s test
cat > cleanup.sql << 'EOF'
DROP DATABASE IF EXISTS test_performance;
EOF

mysqlslap \
    --create-schema=test_performance \
    --auto-generate-sql \
    --concurrency=25 \
    --iterations=3 \
    --post-system="mysql -u root -p < cleanup.sql"
```

4. **Mode verbeux pour debugging**

```bash
# Afficher dÃ©tails d'exÃ©cution
mysqlslap \
    --verbose \
    --debug-info \
    --auto-generate-sql \
    --concurrency=25
```

### âš ï¸ Limitations de mysqlslap

1. **MÃ©triques limitÃ©es**
   - Pas de percentiles (p95, p99)
   - Pas de distribution dÃ©taillÃ©e
   - Uniquement min/avg/max

2. **Pas de tests I/O systÃ¨me**
   - Seulement base de donnÃ©es
   - Pas de fileio, CPU, mÃ©moire

3. **Auto-gÃ©nÃ©ration simpliste**
   - SchÃ©ma basique
   - DonnÃ©es alÃ©atoires peu rÃ©alistes
   - Mieux avec fichiers SQL personnalisÃ©s

4. **Concurrence limitÃ©e**
   - Performance diminue avec > 200 threads
   - Pour trÃ¨s haute concurrence, utiliser sysbench

### Comparaison finale mysqlslap vs sysbench

**Utiliser mysqlslap pour** :
- âœ… Tests rapides et simples
- âœ… Validation post-changement
- âœ… Pas d'installation supplÃ©mentaire
- âœ… Scripts SQL personnalisÃ©s
- âœ… Comparaisons simples

**Utiliser sysbench pour** :
- âœ… Benchmarks officiels
- âœ… MÃ©triques dÃ©taillÃ©es (p95, p99)
- âœ… Tests de montÃ©e en charge
- âœ… Tests systÃ¨me complets
- âœ… Automatisation CI/CD avancÃ©e

---

## âœ… Points clÃ©s Ã  retenir

- **mysqlslap est inclus avec MariaDB**, pas d'installation sÃ©parÃ©e. IdÃ©al pour tests rapides et validations ad-hoc.

- **Auto-gÃ©nÃ©ration** de schÃ©ma et requÃªtes avec `--auto-generate-sql`. Types de charge : read, write, update, mixed. Utile pour tests rapides mais donnÃ©es peu rÃ©alistes.

- **RequÃªtes personnalisÃ©es** via fichiers SQL (`--query=file.sql`). Permet de tester workload applicatif rÃ©el, plus pertinent que auto-gÃ©nÃ©ration.

- **Tests de concurrence** avec `--concurrency=N` et `--iterations=N`. ExÃ©cuter 3-5 iterations minimum pour moyenne fiable.

- **MÃ©triques basiques** : Average, Min, Max time. Pas de percentiles (p95, p99) contrairement Ã  sysbench. Suffisant pour comparaisons simples.

- **Comparaisons** avant/aprÃ¨s optimisation, diffÃ©rents moteurs, versions MariaDB. Automatiser avec scripts bash pour suivi historique.

- **Limitations** : Pas de tests I/O/CPU/mÃ©moire, mÃ©triques simplifiÃ©es, concurrence limitÃ©e Ã  ~200 threads. ComplÃ©ter avec sysbench pour benchmarks complets.

- **Use case principal** : Validation rapide quotidienne, tests de rÃ©gression simples, comparaisons de configurations. Sysbench pour benchmarks officiels.

---

## ğŸ”— Ressources et rÃ©fÃ©rences

### Documentation officielle
- [ğŸ“– mysqlslap Documentation](https://mariadb.com/kb/en/mysqlslap/)
- [ğŸ“– MySQL mysqlslap Reference](https://dev.mysql.com/doc/refman/8.0/en/mysqlslap.html)

### Articles et guides
- [Percona Blog - mysqlslap Usage](https://www.percona.com/blog/)
- [MariaDB Blog - Performance Testing](https://mariadb.com/resources/blog/)

### Outils complÃ©mentaires
- [sysbench](https://github.com/akopytov/sysbench) - Benchmarking avancÃ©
- [HammerDB](https://www.hammerdb.com/) - Alternative avec GUI
- [DBT-2](https://github.com/osdldbt/dbt2) - TPC-C benchmark

---

## â¡ï¸ Conclusion

mysqlslap et sysbench sont **complÃ©mentaires** :

| Contexte | Outil recommandÃ© |
|----------|------------------|
| Validation rapide aprÃ¨s changement | mysqlslap âœ“ |
| Test de requÃªte SQL spÃ©cifique | mysqlslap âœ“ |
| Comparaison simple de configs | mysqlslap âœ“ |
| Benchmark complet et rigoureux | sysbench âœ“ |
| Tests de rÃ©gression automatisÃ©s | sysbench âœ“ |
| MÃ©triques dÃ©taillÃ©es (p95, p99) | sysbench âœ“ |
| Tests I/O, CPU, mÃ©moire | sysbench âœ“ |

ğŸ’¡ **En pratique** : Utiliser mysqlslap pour 80% des tests quotidiens, sysbench pour les 20% de benchmarks critiques.

â­ï¸ [Adaptive Hash Index et Buffer Pool optimizations](/15-performance-tuning/13-adaptive-hash-index.md)
