üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.9.2 LIST Partitioning

> **Niveau** : Expert  
> **Dur√©e estim√©e** : 2-3 heures  
> **Pr√©requis** : Section 15.9.1 (RANGE partitioning), Compr√©hension du partitionnement

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre le partitionnement LIST et ses diff√©rences avec RANGE
- Concevoir des strat√©gies de partitionnement par valeurs discr√®tes
- Impl√©menter le partitionnement g√©ographique et cat√©goriel
- G√©rer l'ajout et la suppression de valeurs dans les partitions
- Optimiser les requ√™tes pour exploiter le partition pruning LIST
- Diagnostiquer les probl√®mes de distribution des donn√©es
- Convertir entre partitionnement LIST et RANGE
- Choisir entre LIST, RANGE et HASH selon le cas d'usage

---

## Introduction

Le **partitionnement LIST** divise une table en partitions bas√©es sur des **listes de valeurs discr√®tes** plut√¥t que des plages continues. C'est la m√©thode id√©ale pour les **donn√©es cat√©gorielles** : r√©gions g√©ographiques, statuts, types de produits, etc.

### Comparaison RANGE vs LIST

```
RANGE Partitioning (valeurs continues):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Partition p_low:  VALUES < 100       ‚îÇ  [0...99]
‚îÇ Partition p_mid:  VALUES < 500       ‚îÇ  [100...499]
‚îÇ Partition p_high: VALUES < MAXVALUE  ‚îÇ  [500...‚àû]
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Use case: Dates, IDs s√©quentiels, √¢ges, prix

LIST Partitioning (valeurs discr√®tes):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Partition p_north: VALUES IN ('NY', 'MA', 'CT')        ‚îÇ
‚îÇ Partition p_south: VALUES IN ('FL', 'GA', 'TX')        ‚îÇ
‚îÇ Partition p_west:  VALUES IN ('CA', 'OR', 'WA')        ‚îÇ
‚îÇ Partition p_central: VALUES IN ('IL', 'OH', 'MI')      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Use case: √âtats, cat√©gories, statuts, codes
```

### Probl√©matique r√©solue par LIST

**Exemple : Application multi-r√©gionale**

```
Table non-partitionn√©e (probl√®me):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ users (100M utilisateurs, tous pays)         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ France: 15M users                            ‚îÇ
‚îÇ Germany: 12M users                           ‚îÇ
‚îÇ UK: 10M users                                ‚îÇ
‚îÇ Spain: 8M users                              ‚îÇ
‚îÇ Italy: 7M users                              ‚îÇ
‚îÇ Others: 48M users                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Requ√™te: SELECT * FROM users WHERE country = 'FR'
‚Üí Scan de 100M rows pour trouver 15M rows ‚ùå
‚Üí Temps: 25 secondes
```

**Solution avec LIST partitioning** :

```
Table partitionn√©e par pays:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ p_france     ‚îÇ p_germany    ‚îÇ p_uk         ‚îÇ p_spain      ‚îÇ
‚îÇ FR: 15M      ‚îÇ DE: 12M      ‚îÇ GB: 10M      ‚îÇ ES: 8M       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ p_italy      ‚îÇ p_others     ‚îÇ
‚îÇ IT: 7M       ‚îÇ 48M (reste)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Requ√™te: SELECT * FROM users WHERE country = 'FR'
‚Üí Partition pruning: Acc√®s direct partition p_france ‚úì
‚Üí Scan de 15M rows seulement
‚Üí Temps: 2.1 secondes (12x plus rapide !)
```

**Avantages du LIST partitioning** :
- ‚úÖ **Partition pruning** sur valeurs discr√®tes
- ‚úÖ **Isolation g√©ographique** : Donn√©es par r√©gion/datacenter
- ‚úÖ **Maintenance cibl√©e** : OPTIMIZE partition sp√©cifique
- ‚úÖ **Archivage cat√©goriel** : Suppression par cat√©gorie
- ‚úÖ **Distribution logique** : Align partitions avec logique m√©tier

---

## Syntaxe et cr√©ation

### Partitionnement g√©ographique

```sql
CREATE TABLE users (
    user_id BIGINT AUTO_INCREMENT,
    username VARCHAR(50),
    email VARCHAR(100),
    country CHAR(2) NOT NULL,
    created_at TIMESTAMP,
    PRIMARY KEY (user_id, country)  -- country doit √™tre dans PK
) PARTITION BY LIST COLUMNS(country) (
    PARTITION p_france VALUES IN ('FR'),
    PARTITION p_germany VALUES IN ('DE'),
    PARTITION p_uk VALUES IN ('GB'),
    PARTITION p_spain VALUES IN ('ES'),
    PARTITION p_italy VALUES IN ('IT'),
    PARTITION p_benelux VALUES IN ('BE', 'NL', 'LU'),
    PARTITION p_nordics VALUES IN ('SE', 'NO', 'DK', 'FI'),
    PARTITION p_others VALUES IN (DEFAULT)  -- MariaDB 10.2+
);
```

üí° **DEFAULT partition** : Capture toutes les valeurs non list√©es ailleurs (√©vite erreurs INSERT).

### Partitionnement par statut

```sql
CREATE TABLE orders (
    order_id BIGINT AUTO_INCREMENT,
    order_date DATE,
    customer_id INT,
    status ENUM('pending','processing','shipped','delivered','cancelled','returned') NOT NULL,
    total DECIMAL(10,2),
    PRIMARY KEY (order_id, status)
) PARTITION BY LIST COLUMNS(status) (
    PARTITION p_active VALUES IN ('pending', 'processing', 'shipped'),
    PARTITION p_completed VALUES IN ('delivered'),
    PARTITION p_issues VALUES IN ('cancelled', 'returned')
);
```

### Partitionnement par cat√©gorie de produit

```sql
CREATE TABLE products (
    product_id INT AUTO_INCREMENT,
    product_name VARCHAR(200),
    category VARCHAR(50) NOT NULL,
    price DECIMAL(10,2),
    PRIMARY KEY (product_id, category)
) PARTITION BY LIST COLUMNS(category) (
    PARTITION p_electronics VALUES IN ('laptops', 'smartphones', 'tablets', 'cameras'),
    PARTITION p_clothing VALUES IN ('shirts', 'pants', 'shoes', 'accessories'),
    PARTITION p_home VALUES IN ('furniture', 'appliances', 'decor'),
    PARTITION p_books VALUES IN ('fiction', 'non-fiction', 'textbooks'),
    PARTITION p_others VALUES IN (DEFAULT)
);
```

### Partitionnement multi-colonnes

MariaDB 10.0+ permet le partitionnement sur **plusieurs colonnes** :

```sql
CREATE TABLE sales (
    sale_id BIGINT AUTO_INCREMENT,
    region VARCHAR(20) NOT NULL,
    category VARCHAR(20) NOT NULL,
    amount DECIMAL(10,2),
    sale_date DATE,
    PRIMARY KEY (sale_id, region, category)
) PARTITION BY LIST COLUMNS(region, category) (
    -- R√©gion Nord √ó √âlectronique
    PARTITION p_north_electronics VALUES IN (
        ('North', 'electronics')
    ),
    -- R√©gion Nord √ó V√™tements
    PARTITION p_north_clothing VALUES IN (
        ('North', 'clothing')
    ),
    -- R√©gion Sud √ó √âlectronique
    PARTITION p_south_electronics VALUES IN (
        ('South', 'electronics')
    ),
    -- R√©gion Sud √ó V√™tements
    PARTITION p_south_clothing VALUES IN (
        ('South', 'clothing')
    )
    -- Etc. pour toutes les combinaisons
);
```

‚ö†Ô∏è **Attention** : Le nombre de partitions cro√Æt rapidement avec multi-colonnes. √âvaluer si n√©cessaire.

---

## Diff√©rences avec RANGE partitioning

| Crit√®re | RANGE | LIST |
|---------|-------|------|
| **Type de valeurs** | Continues (dates, nombres) | Discr√®tes (cat√©gories, codes) |
| **Syntaxe** | `VALUES LESS THAN (value)` | `VALUES IN (value1, value2, ...)` |
| **Ordre** | Doit √™tre croissant | Aucun ordre requis |
| **Distribution** | Plages √©gales ou in√©gales | Distribution arbitraire |
| **Catch-all** | `VALUES LESS THAN MAXVALUE` | `VALUES IN (DEFAULT)` (10.2+) |
| **Use case typique** | Donn√©es temporelles, IDs | R√©gions, statuts, cat√©gories |
| **Ajout de valeurs** | REORGANIZE partition haute | ALTER TABLE ... ADD PARTITION |
| **NULL handling** | Va dans partition la plus basse | Doit √™tre explicitement list√© |

### Gestion des valeurs NULL

```sql
-- RANGE: NULL va dans premi√®re partition
CREATE TABLE test_range (...) 
PARTITION BY RANGE (value) (
    PARTITION p0 VALUES LESS THAN (0),      -- Contient les NULL
    PARTITION p1 VALUES LESS THAN (100)
);

-- LIST: NULL doit √™tre explicitement list√©
CREATE TABLE test_list (...)
PARTITION BY LIST (value) (
    PARTITION p_null VALUES IN (NULL),      -- Partition pour NULL
    PARTITION p_active VALUES IN (1, 2, 3),
    PARTITION p_inactive VALUES IN (4, 5, 6)
);

-- Sans partition pour NULL:
-- INSERT avec value=NULL ‚Üí ERROR 1526: Table has no partition for value NULL
```

---

## Gestion des partitions

### Ajout de nouvelles valeurs

**M√©thode 1 : Ajouter partition pour nouvelle valeur** :

```sql
-- Initialement: France, Allemagne, UK
CREATE TABLE users (...)
PARTITION BY LIST COLUMNS(country) (
    PARTITION p_france VALUES IN ('FR'),
    PARTITION p_germany VALUES IN ('DE'),
    PARTITION p_uk VALUES IN ('GB')
);

-- Ajouter partition pour Espagne
ALTER TABLE users 
ADD PARTITION (
    PARTITION p_spain VALUES IN ('ES')
);
```

**M√©thode 2 : Ajouter valeur √† partition existante** :

```sql
-- Partition p_benelux: BE, NL
-- Ajouter Luxembourg (LU)
ALTER TABLE users 
REORGANIZE PARTITION p_benelux INTO (
    PARTITION p_benelux VALUES IN ('BE', 'NL', 'LU')
);
```

**M√©thode 3 : Utiliser DEFAULT partition** :

```sql
-- Avec DEFAULT, pas besoin d'ajouter explicitement
CREATE TABLE users (...)
PARTITION BY LIST COLUMNS(country) (
    PARTITION p_france VALUES IN ('FR'),
    PARTITION p_germany VALUES IN ('DE'),
    PARTITION p_uk VALUES IN ('GB'),
    PARTITION p_others VALUES IN (DEFAULT)  -- Capture tout le reste
);

-- INSERT avec country='ES' ‚Üí Va dans p_others automatiquement ‚úì
```

### R√©organisation de partitions

```sql
-- S√©parer partition p_others en partitions sp√©cifiques
ALTER TABLE users
REORGANIZE PARTITION p_others INTO (
    PARTITION p_spain VALUES IN ('ES'),
    PARTITION p_italy VALUES IN ('IT'),
    PARTITION p_others VALUES IN (DEFAULT)
);

-- Fusionner partitions
ALTER TABLE users
REORGANIZE PARTITION p_spain, p_italy INTO (
    PARTITION p_south_europe VALUES IN ('ES', 'IT', 'PT', 'GR')
);
```

### Suppression de partitions

```sql
-- Supprimer partition et ses donn√©es
ALTER TABLE users DROP PARTITION p_others;

-- ‚ö†Ô∏è Attention: Toutes les donn√©es de p_others sont supprim√©es !
-- Pour archiver avant suppression:

-- 1. Cr√©er table archive
CREATE TABLE users_others LIKE users;
ALTER TABLE users_others REMOVE PARTITIONING;

-- 2. √âchanger partition avec table
ALTER TABLE users EXCHANGE PARTITION p_others WITH TABLE users_others;

-- 3. users_others contient maintenant les donn√©es
-- 4. Supprimer partition vide
ALTER TABLE users DROP PARTITION p_others;

-- 5. Archiver users_others (dump, S3...)
```

---

## Optimisation des requ√™tes

### Requ√™tes avec partition pruning

```sql
-- ‚úÖ OPTIMAL - Filtre sur colonne de partitionnement
SELECT * FROM users WHERE country = 'FR';
-- Acc√®s: Partition p_france uniquement

EXPLAIN PARTITIONS
SELECT * FROM users WHERE country = 'FR';
+----+-------------+-------+------------+------+
| id | select_type | table | partitions | type |
+----+-------------+-------+------------+------+
|  1 | SIMPLE      | users | p_france   | ALL  |
+----+-------------+-------+------------+------+

-- ‚úÖ OPTIMAL - Liste de valeurs (IN)
SELECT * FROM users WHERE country IN ('FR', 'DE');
-- Acc√®s: Partitions p_france, p_germany

-- ‚úÖ OPTIMAL - Combinaison avec autres filtres
SELECT * FROM users 
WHERE country = 'FR' 
  AND created_at >= '2025-01-01';
-- Pruning + index sur created_at

-- ‚ö†Ô∏è SOUS-OPTIMAL - Pas de filtre sur country
SELECT * FROM users WHERE email LIKE '%@gmail.com';
-- Acc√®s: TOUTES les partitions

-- ‚ùå INEFFICACE - Fonction sur colonne de partitionnement
SELECT * FROM users WHERE UPPER(country) = 'FR';
-- Pruning impossible ‚Üí Scan toutes partitions
```

### Index et LIST partitioning

```sql
-- Index cr√©√©s sur chaque partition ind√©pendamment
CREATE INDEX idx_email ON users(email);

-- Cr√©e en r√©alit√©:
-- - idx_email sur p_france
-- - idx_email sur p_germany
-- - idx_email sur p_uk
-- - etc.

-- Index composite incluant colonne de partitionnement
CREATE INDEX idx_country_created ON users(country, created_at);

-- Requ√™te optimale
SELECT * FROM users 
WHERE country = 'FR' 
  AND created_at >= '2025-01-01';
-- Partition pruning (p_france) + index idx_country_created
```

---

## Cas d'usage pratiques

### Cas 1 : Application SaaS multi-tenant

**Contexte** : Application SaaS avec clients de diff√©rentes tailles.

```sql
CREATE TABLE tenant_data (
    data_id BIGINT AUTO_INCREMENT,
    tenant_id INT NOT NULL,
    tenant_tier ENUM('free','basic','premium','enterprise') NOT NULL,
    data_type VARCHAR(50),
    payload JSON,
    created_at TIMESTAMP,
    PRIMARY KEY (data_id, tenant_tier),
    INDEX idx_tenant (tenant_id, created_at)
) PARTITION BY LIST COLUMNS(tenant_tier) (
    PARTITION p_enterprise VALUES IN ('enterprise'),  -- Clients premium isol√©s
    PARTITION p_premium VALUES IN ('premium'),
    PARTITION p_basic VALUES IN ('basic'),
    PARTITION p_free VALUES IN ('free')
);
```

**Avantages** :
- ‚úÖ Isolation performance : Clients enterprise sur partition d√©di√©e
- ‚úÖ Maintenance cibl√©e : OPTIMIZE p_enterprise sans impacter free users
- ‚úÖ Archivage : Purger p_free r√©guli√®rement

**Requ√™tes optimis√©es** :

```sql
-- Analytics par tier
SELECT 
    tenant_tier,
    COUNT(*) AS records,
    ROUND(SUM(JSON_LENGTH(payload)) / 1024 / 1024, 2) AS total_mb
FROM tenant_data
WHERE created_at >= '2025-01-01'
GROUP BY tenant_tier;
-- Pruning sur chaque partition avec filtre temporel

-- Donn√©es client enterprise
SELECT * FROM tenant_data
WHERE tenant_tier = 'enterprise'
  AND tenant_id = 12345;
-- Acc√®s partition p_enterprise uniquement
```

### Cas 2 : E-commerce avec gestion des statuts

**Contexte** : Commandes avec lifecycle complexe.

```sql
CREATE TABLE orders (
    order_id BIGINT AUTO_INCREMENT,
    order_date DATE,
    customer_id INT,
    status ENUM('cart','pending','paid','processing','shipped','delivered','cancelled','returned','refunded') NOT NULL,
    total DECIMAL(10,2),
    PRIMARY KEY (order_id, status),
    INDEX idx_customer (customer_id, order_date),
    INDEX idx_date (order_date)
) PARTITION BY LIST COLUMNS(status) (
    PARTITION p_active VALUES IN ('cart', 'pending', 'paid', 'processing', 'shipped'),
    PARTITION p_completed VALUES IN ('delivered'),
    PARTITION p_cancelled VALUES IN ('cancelled'),
    PARTITION p_returns VALUES IN ('returned', 'refunded')
);
```

**Strat√©gie de maintenance** :

```sql
-- Purger vieux paniers abandonn√©s (partition p_active)
DELETE FROM orders 
WHERE status = 'cart' 
  AND order_date < DATE_SUB(NOW(), INTERVAL 30 DAY);

-- Archiver commandes livr√©es > 2 ans (partition p_completed)
-- 1. Cr√©er table archive
CREATE TABLE orders_archive_2023 LIKE orders;
ALTER TABLE orders_archive_2023 REMOVE PARTITIONING;

-- 2. D√©placer anciennes commandes compl√©t√©es
INSERT INTO orders_archive_2023
SELECT * FROM orders PARTITION (p_completed)
WHERE order_date < '2024-01-01';

DELETE FROM orders 
WHERE status = 'delivered' 
  AND order_date < '2024-01-01';

-- 3. OPTIMIZE partition
ALTER TABLE orders OPTIMIZE PARTITION p_completed;
```

**Requ√™tes m√©tier** :

```sql
-- Dashboard: Commandes actives
SELECT COUNT(*) AS active_orders
FROM orders PARTITION (p_active);
-- Acc√®s partition p_active uniquement

-- Taux de retour
SELECT 
    (SELECT COUNT(*) FROM orders PARTITION (p_returns)) * 100.0 /
    (SELECT COUNT(*) FROM orders PARTITION (p_completed))
AS return_rate_pct;
```

### Cas 3 : Logs applicatifs par niveau de s√©v√©rit√©

**Contexte** : Logs avec diff√©rents niveaux (DEBUG, INFO, WARNING, ERROR, CRITICAL).

```sql
CREATE TABLE application_logs (
    log_id BIGINT AUTO_INCREMENT,
    log_timestamp DATETIME NOT NULL,
    severity ENUM('DEBUG','INFO','WARNING','ERROR','CRITICAL') NOT NULL,
    service VARCHAR(50),
    message TEXT,
    stack_trace TEXT,
    PRIMARY KEY (log_id, severity),
    INDEX idx_timestamp (log_timestamp),
    INDEX idx_service (service, log_timestamp)
) PARTITION BY LIST COLUMNS(severity) (
    PARTITION p_debug VALUES IN ('DEBUG'),           -- Volume √©lev√©
    PARTITION p_info VALUES IN ('INFO'),             -- Volume √©lev√©
    PARTITION p_warning VALUES IN ('WARNING'),       -- Volume mod√©r√©
    PARTITION p_error VALUES IN ('ERROR'),           -- Volume faible, critique
    PARTITION p_critical VALUES IN ('CRITICAL')      -- Volume tr√®s faible, tr√®s critique
);
```

**Strat√©gies de r√©tention diff√©renci√©es** :

```sql
-- Event automatis√© de purge
DELIMITER $$

CREATE EVENT purge_old_logs
ON SCHEDULE EVERY 1 DAY
DO
BEGIN
    -- DEBUG: 7 jours seulement
    DELETE FROM application_logs PARTITION (p_debug)
    WHERE log_timestamp < DATE_SUB(NOW(), INTERVAL 7 DAY);
    
    -- INFO: 30 jours
    DELETE FROM application_logs PARTITION (p_info)
    WHERE log_timestamp < DATE_SUB(NOW(), INTERVAL 30 DAY);
    
    -- WARNING: 90 jours
    DELETE FROM application_logs PARTITION (p_warning)
    WHERE log_timestamp < DATE_SUB(NOW(), INTERVAL 90 DAY);
    
    -- ERROR et CRITICAL: 365 jours (conserver plus longtemps)
    DELETE FROM application_logs PARTITION (p_error, p_critical)
    WHERE log_timestamp < DATE_SUB(NOW(), INTERVAL 365 DAY);
    
    -- OPTIMIZE partitions apr√®s purge
    ALTER TABLE application_logs 
    OPTIMIZE PARTITION p_debug, p_info, p_warning;
END$$

DELIMITER ;
```

**Requ√™tes monitoring** :

```sql
-- Erreurs critiques derni√®res 24h
SELECT * FROM application_logs PARTITION (p_critical, p_error)
WHERE log_timestamp >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
ORDER BY log_timestamp DESC;

-- Distribution des logs par s√©v√©rit√© (derni√®re heure)
SELECT 
    severity,
    COUNT(*) AS log_count
FROM application_logs
WHERE log_timestamp >= DATE_SUB(NOW(), INTERVAL 1 HOUR)
GROUP BY severity;
-- Partition pruning sur chaque partition
```

---

## Combinaison LIST + RANGE (subpartitioning)

MariaDB supporte le **subpartitioning** : partitionner d'abord par LIST, puis chaque partition LIST est elle-m√™me partitionn√©e par RANGE.

```sql
CREATE TABLE sales (
    sale_id BIGINT AUTO_INCREMENT,
    sale_date DATE NOT NULL,
    region VARCHAR(20) NOT NULL,
    amount DECIMAL(10,2),
    PRIMARY KEY (sale_id, region, sale_date)
)
PARTITION BY LIST COLUMNS(region)
SUBPARTITION BY RANGE (YEAR(sale_date) * 100 + MONTH(sale_date)) (
    PARTITION p_north VALUES IN ('North') (
        SUBPARTITION p_north_2024_01 VALUES LESS THAN (202402),
        SUBPARTITION p_north_2024_02 VALUES LESS THAN (202403),
        SUBPARTITION p_north_2025_01 VALUES LESS THAN (202502),
        SUBPARTITION p_north_future VALUES LESS THAN MAXVALUE
    ),
    PARTITION p_south VALUES IN ('South') (
        SUBPARTITION p_south_2024_01 VALUES LESS THAN (202402),
        SUBPARTITION p_south_2024_02 VALUES LESS THAN (202403),
        SUBPARTITION p_south_2025_01 VALUES LESS THAN (202502),
        SUBPARTITION p_south_future VALUES LESS THAN MAXVALUE
    )
);
```

**Avantages du subpartitioning** :
- ‚úÖ Isolation g√©ographique + archivage temporel
- ‚úÖ Purge par r√©gion ET par p√©riode
- ‚úÖ Double partition pruning

**Inconv√©nients** :
- ‚ö†Ô∏è Complexit√© de gestion accrue
- ‚ö†Ô∏è Nombre de fichiers √ó nombre de r√©gions √ó nombre de p√©riodes
- ‚ö†Ô∏è Maintenance plus difficile

üí° **Recommandation** : R√©server aux cas o√π les deux dimensions sont critiques. Sinon, choisir la dimension principale.

---

## üÜï Conversion LIST ‚Üî RANGE (MariaDB 11.8)

### Convertir de LIST vers RANGE

**Sc√©nario** : Partition LIST par ann√©e devient obsol√®te, migration vers RANGE mensuel.

```sql
-- Table initiale LIST par ann√©e
CREATE TABLE events (
    event_id BIGINT AUTO_INCREMENT,
    event_date DATE NOT NULL,
    event_year INT AS (YEAR(event_date)) STORED,
    data JSON,
    PRIMARY KEY (event_id, event_year)
) PARTITION BY LIST (event_year) (
    PARTITION p2023 VALUES IN (2023),
    PARTITION p2024 VALUES IN (2024),
    PARTITION p2025 VALUES IN (2025)
);

-- Migration vers RANGE mensuel
-- 1. Cr√©er nouvelle table avec RANGE partitioning
CREATE TABLE events_new (
    event_id BIGINT AUTO_INCREMENT,
    event_date DATE NOT NULL,
    data JSON,
    PRIMARY KEY (event_id, event_date)
) PARTITION BY RANGE (YEAR(event_date) * 100 + MONTH(event_date)) (
    PARTITION p2023_01 VALUES LESS THAN (202302),
    PARTITION p2023_02 VALUES LESS THAN (202303),
    -- ... toutes les partitions mensuelles
    PARTITION p2025_12 VALUES LESS THAN (202601),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- 2. Migrer donn√©es partition par partition
INSERT INTO events_new 
SELECT event_id, event_date, data 
FROM events PARTITION (p2023);

INSERT INTO events_new 
SELECT event_id, event_date, data 
FROM events PARTITION (p2024);

-- 3. V√©rifier et basculer
-- RENAME TABLE events TO events_old, events_new TO events;
```

### Convertir de RANGE vers LIST

**Sc√©nario** : Donn√©es temporelles deviennent cat√©gorielles (archivage par p√©riode).

```sql
-- Table RANGE initiale
CREATE TABLE orders_range (
    order_id BIGINT,
    order_date DATE,
    status VARCHAR(20),
    PRIMARY KEY (order_id, order_date)
) PARTITION BY RANGE (YEAR(order_date)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026)
);

-- Migration vers LIST par p√©riode (archivage)
CREATE TABLE orders_list (
    order_id BIGINT,
    order_date DATE,
    archive_period VARCHAR(20) AS (
        CASE 
            WHEN YEAR(order_date) < 2024 THEN 'archived'
            WHEN YEAR(order_date) = 2024 THEN 'historical'
            ELSE 'active'
        END
    ) STORED,
    status VARCHAR(20),
    PRIMARY KEY (order_id, archive_period)
) PARTITION BY LIST COLUMNS(archive_period) (
    PARTITION p_archived VALUES IN ('archived'),
    PARTITION p_historical VALUES IN ('historical'),
    PARTITION p_active VALUES IN ('active')
);

-- Migrer donn√©es
INSERT INTO orders_list (order_id, order_date, status)
SELECT order_id, order_date, status FROM orders_range;
```

---

## Monitoring et diagnostic

### Informations sur partitions LIST

```sql
-- Vue d√©taill√©e des partitions
SELECT 
    PARTITION_NAME,
    PARTITION_METHOD,
    PARTITION_EXPRESSION,
    PARTITION_DESCRIPTION,  -- Valeurs dans VALUES IN (...)
    TABLE_ROWS,
    ROUND(DATA_LENGTH / 1024 / 1024, 2) AS data_mb,
    ROUND(INDEX_LENGTH / 1024 / 1024, 2) AS index_mb,
    ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) AS total_mb
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_SCHEMA = 'mydb'
  AND TABLE_NAME = 'users'
ORDER BY PARTITION_ORDINAL_POSITION;

+----------------+------------------+----------------------+-------------------------+-----------+---------+----------+----------+
| PARTITION_NAME | PARTITION_METHOD | PARTITION_EXPRESSION | PARTITION_DESCRIPTION   | TABLE_ROWS| data_mb | index_mb | total_mb |
+----------------+------------------+----------------------+-------------------------+-----------+---------+----------+----------+
| p_france       | LIST             | country              | 'FR'                    |  15234567 | 4567.89 |  1234.56 |  5802.45 |
| p_germany      | LIST             | country              | 'DE'                    |  12456789 | 3789.12 |  1023.45 |  4812.57 |
| p_uk           | LIST             | country              | 'GB'                    |  10123456 | 3012.34 |   890.12 |  3902.46 |
| p_others       | LIST             | country              | DEFAULT                 |  48765432 |14567.23 |  4012.34 | 18579.57 |
+----------------+------------------+----------------------+-------------------------+-----------+---------+----------+----------+
```

### D√©tection de d√©s√©quilibres

```sql
-- Identifier partitions d√©s√©quilibr√©es
WITH partition_stats AS (
    SELECT 
        PARTITION_NAME,
        TABLE_ROWS,
        (DATA_LENGTH + INDEX_LENGTH) AS total_bytes
    FROM INFORMATION_SCHEMA.PARTITIONS
    WHERE TABLE_SCHEMA = 'mydb'
      AND TABLE_NAME = 'users'
      AND PARTITION_NAME IS NOT NULL
)
SELECT 
    PARTITION_NAME,
    TABLE_ROWS,
    ROUND(total_bytes / 1024 / 1024, 2) AS total_mb,
    ROUND(TABLE_ROWS * 100.0 / SUM(TABLE_ROWS) OVER (), 2) AS rows_pct,
    ROUND(total_bytes * 100.0 / SUM(total_bytes) OVER (), 2) AS size_pct
FROM partition_stats
ORDER BY TABLE_ROWS DESC;

+----------------+------------+----------+----------+----------+
| PARTITION_NAME | TABLE_ROWS | total_mb | rows_pct | size_pct |
+----------------+------------+----------+----------+----------+
| p_others       |   48765432 | 18579.57 |    56.83 |    56.92 |  ‚Üê D√©s√©quilibr√© !
| p_france       |   15234567 |  5802.45 |    17.76 |    17.77 |
| p_germany      |   12456789 |  4812.57 |    14.52 |    14.74 |
| p_uk           |   10123456 |  3902.46 |    11.80 |    11.95 |
+----------------+------------+----------+----------+----------+
```

**Action** : Subdiviser partition `p_others` si elle contient des valeurs fr√©quentes :

```sql
-- Analyser contenu de p_others
SELECT 
    country,
    COUNT(*) AS user_count
FROM users PARTITION (p_others)
GROUP BY country
ORDER BY user_count DESC
LIMIT 10;

+----------+------------+
| country  | user_count |
+----------+------------+
| IT       |   7890123  |  ‚Üê Extraire en partition d√©di√©e
| ES       |   6543210  |  ‚Üê Extraire en partition d√©di√©e
| NL       |   2345678  |
| BE       |   1987654  |
+----------+------------+

-- R√©organiser
ALTER TABLE users
REORGANIZE PARTITION p_others INTO (
    PARTITION p_italy VALUES IN ('IT'),
    PARTITION p_spain VALUES IN ('ES'),
    PARTITION p_benelux VALUES IN ('NL', 'BE', 'LU'),
    PARTITION p_others VALUES IN (DEFAULT)
);
```

---

## Limitations et bonnes pratiques

### Limitations techniques

1. **Toutes les valeurs doivent √™tre list√©es explicitement**
   ```sql
   -- ‚ùå Impossible de dire "tous les pays sauf FR"
   -- Doit lister explicitement: DE, GB, ES, IT, ...
   
   -- ‚úÖ Solution: Utiliser DEFAULT
   PARTITION p_others VALUES IN (DEFAULT)
   ```

2. **Pas de wildcards ou patterns**
   ```sql
   -- ‚ùå Impossible
   PARTITION p_us_states VALUES IN ('US-%')
   
   -- ‚úÖ Doit lister explicitement
   PARTITION p_us_states VALUES IN ('US-CA', 'US-NY', 'US-TX', ...)
   ```

3. **Maximum 8192 partitions** (m√™me que RANGE)

4. **Modification d'une valeur de partitionnement = d√©placement de ligne**
   ```sql
   -- UPDATE qui change country = d√©placement inter-partition
   UPDATE users SET country = 'DE' WHERE user_id = 123;
   -- Si user_id=123 √©tait dans p_france, d√©plac√© vers p_germany
   -- Co√ªteux si fr√©quent !
   ```

### Quand utiliser LIST vs RANGE

‚úÖ **Utiliser LIST si** :
- Valeurs **discr√®tes et cat√©gorielles** (pays, statuts, types)
- Nombre de valeurs **limit√© et connu** (< 100 cat√©gories typiquement)
- Distribution **logique m√©tier** plus importante que distribution temporelle
- Besoin d'**isolation par cat√©gorie** (maintenance, archivage)

‚úÖ **Utiliser RANGE si** :
- Valeurs **continues** (dates, IDs s√©quentiels, montants)
- **Croissance temporelle** des donn√©es
- Besoin d'**archivage chronologique**
- Distribution **temporelle** des requ√™tes

‚úÖ **Utiliser HASH si** :
- Valeurs **distribu√©es uniform√©ment** souhait√©e
- Pas de logique m√©tier dans le partitionnement
- Juste besoin de **diviser la charge**

### Bonnes pratiques

**1. Pr√©voir la partition DEFAULT**

```sql
-- ‚úÖ Recommand√©
PARTITION BY LIST COLUMNS(country) (
    PARTITION p_france VALUES IN ('FR'),
    PARTITION p_germany VALUES IN ('DE'),
    PARTITION p_others VALUES IN (DEFAULT)  -- √âvite erreurs INSERT
);

-- ‚ùå Risqu√©
PARTITION BY LIST COLUMNS(country) (
    PARTITION p_france VALUES IN ('FR'),
    PARTITION p_germany VALUES IN ('DE')
    -- Pas de DEFAULT ‚Üí INSERT country='ES' = ERROR !
);
```

**2. Monitorer r√©guli√®rement la partition DEFAULT**

```sql
-- Si p_others grossit trop, identifier valeurs fr√©quentes
SELECT country, COUNT(*) 
FROM users PARTITION (p_others)
GROUP BY country
ORDER BY COUNT(*) DESC
LIMIT 20;
```

**3. Documenter les valeurs de chaque partition**

```sql
-- Commentaires explicites
CREATE TABLE orders (...)
PARTITION BY LIST COLUMNS(status) (
    PARTITION p_active 
        VALUES IN ('pending', 'processing', 'shipped')
        COMMENT 'Commandes en cours de traitement',
    PARTITION p_completed 
        VALUES IN ('delivered')
        COMMENT 'Commandes livr√©es avec succ√®s',
    PARTITION p_issues 
        VALUES IN ('cancelled', 'returned', 'refunded')
        COMMENT 'Commandes avec probl√®mes'
);
```

**4. √âviter trop de partitions**

```
R√®gle empirique:
- 5-20 partitions : Optimal
- 20-50 partitions : Acceptable
- > 50 partitions : R√©viser strat√©gie (consid√©rer HASH)
```

---

## ‚úÖ Points cl√©s √† retenir

- **LIST partitioning divise par valeurs discr√®tes** (cat√©gories, codes, statuts) plut√¥t que plages continues. Id√©al pour donn√©es cat√©gorielles.

- **Partition DEFAULT (MariaDB 10.2+)** capture toutes les valeurs non list√©es. Essentiel pour √©viter erreurs INSERT et g√©rer √©volution des donn√©es.

- **Partition pruning sur √©galit√© et IN** : `WHERE country = 'FR'` ou `WHERE country IN ('FR', 'DE')` exploite le pruning. √âviter fonctions sur colonne de partitionnement.

- **R√©organisation simple** : ALTER TABLE ... REORGANIZE PARTITION pour ajouter valeurs, fusionner ou diviser partitions. Plus flexible que RANGE pour ajustements.

- **Monitoring de la distribution** : Partition DEFAULT qui grossit trop = signal d'extraire valeurs fr√©quentes en partitions d√©di√©es.

- **Subpartitioning LIST + RANGE** : Possible mais complexe. R√©server aux cas o√π les deux dimensions sont critiques (r√©gion √ó temps).

- **Cas d'usage typiques** : Multi-r√©gional, multi-tenant par tier, gestion statuts avec r√©tention diff√©renci√©e, isolation cat√©gorielle.

- **üÜï MariaDB 11.8** : Conversion am√©lior√©e partition ‚Üî table avec EXCHANGE PARTITION WITH/WITHOUT VALIDATION.

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB
- [üìñ LIST Partitioning](https://mariadb.com/kb/en/partitioning-types/#list-partitioning)
- [üìñ LIST COLUMNS Partitioning](https://mariadb.com/kb/en/partitioning-types/#list-columns-partitioning)
- [üìñ Partition Management](https://mariadb.com/kb/en/partition-maintenance/)

### Articles techniques
- [Percona Blog - LIST vs RANGE Partitioning](https://www.percona.com/blog/)
- [MySQL Performance Blog - Partitioning Strategies](https://www.percona.com/blog/)

### Comparaison avec autres moteurs
- [PostgreSQL Table Partitioning](https://www.postgresql.org/docs/current/ddl-partitioning.html)
- [Oracle Partitioning Guide](https://docs.oracle.com/en/database/oracle/oracle-database/)

---

## ‚û°Ô∏è Section suivante

**15.9.3 HASH Partitioning** : Nous explorerons le partitionnement par hachage pour distribution automatique et uniforme des donn√©es, sans logique m√©tier explicite. Nous verrons LINEAR HASH, KEY partitioning, et quand pr√©f√©rer HASH √† RANGE/LIST.

‚è≠Ô∏è [HASH partitioning](/15-performance-tuning/09.3-hash-partitioning.md)
