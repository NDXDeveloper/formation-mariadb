üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.7.1 Slow Query Log

> **Niveau** : Expert  
> **Dur√©e estim√©e** : 2-3 heures  
> **Pr√©requis** : Section 15.1 (M√©thodologie d'optimisation), Compr√©hension de l'analyse de performance SQL

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Configurer et activer le slow query log de mani√®re optimale
- Comprendre et interpr√©ter les m√©triques du slow query log
- Filtrer efficacement les requ√™tes √† logger pour minimiser l'overhead
- Analyser manuellement les logs pour identifier les probl√®mes de performance
- G√©rer la rotation et l'archivage des logs en production
- Optimiser l'impact du logging sur les performances
- Utiliser les fonctionnalit√©s avanc√©es de logging (microseconds, query plan)
- Automatiser la collecte et l'analyse des requ√™tes lentes

---

## Introduction

Le **slow query log** est l'outil d'analyse de performance le plus important de MariaDB. Il enregistre toutes les requ√™tes dont le temps d'ex√©cution d√©passe un seuil configurable, permettant d'identifier pr√©cis√©ment les bottlenecks de performance.

### Pourquoi le slow query log est essentiel

```
Probl√®me typique en production:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Utilisateurs se plaignent:           ‚îÇ
‚îÇ "L'application est lente"            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì
    O√π est le probl√®me ?
    - Code applicatif ?
    - R√©seau ?
    - Base de donn√©es ? ‚Üê Slow query log r√©pond
         ‚Üì
    Analyse slow query log
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ D√©couverte:                          ‚îÇ
‚îÇ - 1 requ√™te prend 15s                ‚îÇ
‚îÇ - Ex√©cut√©e 1000 fois/minute          ‚îÇ
‚îÇ - Pas d'index sur la colonne filtr√©e ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì
    Cr√©ation index
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ R√©sultat:                            ‚îÇ
‚îÇ - Requ√™te: 15s ‚Üí 0.05s               ‚îÇ
‚îÇ - Application: Rapide ‚úì              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Avantages du slow query log** :
- ‚úÖ Identifie **pr√©cis√©ment** les requ√™tes probl√©matiques
- ‚úÖ Fournit des **m√©triques d√©taill√©es** (temps, locks, rows examined)
- ‚úÖ Capture le **contexte r√©el** de production
- ‚úÖ Permet l'**optimisation cibl√©e** (ROI maximum)
- ‚úÖ S'active **sans modification** du code applicatif

---

## Configuration de base

### Activation du slow query log

```sql
-- V√©rifier l'√©tat actuel
SHOW VARIABLES LIKE 'slow_query%';

+---------------------+-------------------------------+
| Variable_name       | Value                         |
+---------------------+-------------------------------+
| slow_query_log      | OFF                           |
| slow_query_log_file | /var/lib/mysql/slow-query.log |
+---------------------+-------------------------------+

-- Activer temporairement (runtime)
SET GLOBAL slow_query_log = ON;

-- D√©finir le seuil (secondes)
SET GLOBAL long_query_time = 2;  -- Requ√™tes > 2s
```

**Configuration permanente** dans `my.cnf` :

```ini
[mysqld]
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Slow Query Log - Configuration de base
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# Activation
slow_query_log = ON
slow_query_log_file = /var/log/mysql/slow-query.log

# Seuil de temps (secondes)
long_query_time = 2  # Requ√™tes > 2 secondes

# Logger aussi les requ√™tes sans index
log_queries_not_using_indexes = ON

# Limiter le logging des requ√™tes sans index (√©viter spam)
min_examined_row_limit = 1000  # Au moins 1000 rows examin√©es
```

### Variables de configuration essentielles

| Variable | D√©faut | Recommandation | Description |
|----------|--------|----------------|-------------|
| `slow_query_log` | OFF | **ON** | Active/d√©sactive le logging |
| `slow_query_log_file` | hostname-slow.log | `/var/log/mysql/slow.log` | Chemin du fichier |
| `long_query_time` | 10 | **1-5** | Seuil en secondes (peut √™tre d√©cimal) |
| `log_queries_not_using_indexes` | OFF | **ON** | Log requ√™tes full scan |
| `min_examined_row_limit` | 0 | **1000** | Minimum rows pour logger |
| `log_slow_admin_statements` | OFF | ON | Log ALTER, OPTIMIZE, etc. |
| `log_slow_slave_statements` | OFF | ON (replica) | Log slow queries sur replica |

### Seuil optimal (long_query_time)

Le choix du seuil d√©pend du workload :

```
Environnement de d√©veloppement:
long_query_time = 0.1  # 100ms - Tr√®s sensible

Production OLTP (web, e-commerce):
long_query_time = 1    # 1 seconde - Standard

Production Analytics:
long_query_time = 5    # 5 secondes - Tol√©rance plus √©lev√©e

Audit complet:
long_query_time = 0    # Toutes les requ√™tes (temporaire !)
```

üí° **Recommandation** : Commencer avec `long_query_time = 2`, puis ajuster selon le volume de logs g√©n√©r√©.

---

## Structure et format des logs

### Anatomie d'une entr√©e de log

```
# Time: 2025-12-14T14:23:45.123456Z
# User@Host: appuser[appuser] @ webapp01.example.com [192.168.1.10]
# Thread_id: 12345  Schema: ecommerce  QC_hit: No
# Query_time: 15.234567  Lock_time: 0.000234  Rows_sent: 1  Rows_examined: 5678901
# Rows_affected: 0  Bytes_sent: 234
SET timestamp=1702563825;
SELECT o.order_id, o.total, c.customer_name
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE o.order_date >= '2025-01-01'
  AND o.status = 'pending'
ORDER BY o.order_date DESC;
```

**D√©cryptage des m√©triques** :

| M√©trique | Valeur exemple | Signification |
|----------|----------------|---------------|
| **Time** | 2025-12-14T14:23:45.123456Z | Timestamp fin d'ex√©cution (UTC) |
| **User@Host** | appuser@webapp01 | Utilisateur et origine connexion |
| **Thread_id** | 12345 | ID du thread MariaDB |
| **Schema** | ecommerce | Base de donn√©es active |
| **Query_time** | 15.234567 | **Temps total ex√©cution (secondes)** |
| **Lock_time** | 0.000234 | Temps d'attente verrous |
| **Rows_sent** | 1 | Lignes retourn√©es au client |
| **Rows_examined** | 5,678,901 | Lignes examin√©es par MariaDB |
| **Rows_affected** | 0 | Lignes modifi√©es (INSERT/UPDATE/DELETE) |

### M√©triques cl√©s √† analyser

#### 1. Ratio Rows_examined / Rows_sent

```
Requ√™te efficace:
Rows_examined: 150
Rows_sent: 100
Ratio: 1.5  ‚úì Bon

Requ√™te inefficace (full scan):
Rows_examined: 5,678,901
Rows_sent: 1
Ratio: 5,678,901  ‚úó Probl√©matique !

Action: Cr√©er un index appropri√©
```

**R√®gle empirique** :
- Ratio < 10 : ‚úì Efficace
- Ratio 10-100 : ‚ö†Ô∏è √Ä surveiller
- Ratio > 100 : ‚ùå Optimisation n√©cessaire

#### 2. Lock_time vs Query_time

```
Cas 1: I/O bound
Query_time: 15.5s
Lock_time: 0.002s
‚Üí Probl√®me: Lecture disque, index manquant

Cas 2: Lock contention
Query_time: 12.3s
Lock_time: 11.8s
‚Üí Probl√®me: Attente de verrous, concurrence √©lev√©e
```

Si `Lock_time` > 50% de `Query_time` ‚Üí Probl√®me de concurrence.

#### 3. Rows_affected (pour √©critures)

```sql
-- Slow query log pour UPDATE
# Query_time: 25.5  Lock_time: 0.5  Rows_affected: 8,456,123

UPDATE products SET stock = stock - 1 WHERE category = 'electronics';
-- Probl√®me: Mise √† jour de millions de lignes sans WHERE appropri√©
```

---

## Configuration avanc√©e

### Logging avec pr√©cision microseconde

```ini
[mysqld]
# Pr√©cision microseconde (par d√©faut depuis MariaDB 10.1)
log_slow_verbosity = query_plan,explain

# Inclure le query plan dans les logs
log_slow_verbosity = query_plan,innodb,explain
```

**Exemple de log verbeux** :

```
# Query_time: 2.345678  Lock_time: 0.000123  Rows_sent: 50  Rows_examined: 1234567
# InnoDB_trx_id: 123ABC
# QC_Hit: No  Full_scan: Yes  Full_join: No  Tmp_table: Yes  Tmp_table_on_disk: Yes
# Filesort: Yes  Filesort_on_disk: Yes
# Merge_passes: 2  InnoDB_IO_r_ops: 45678  InnoDB_IO_r_bytes: 123456789
# InnoDB_pages_distinct: 23456
# explain: id  select_type  table  type  possible_keys  key  key_len  ref  rows  Extra
# explain: 1   SIMPLE       orders ALL   NULL           NULL NULL     NULL 1234567 Using where; Using temporary; Using filesort
```

**M√©triques avanc√©es importantes** :

| M√©trique | Signification | Action si pr√©sent |
|----------|---------------|-------------------|
| **Full_scan: Yes** | Table scan complet | Cr√©er index |
| **Tmp_table: Yes** | Table temporaire | Optimiser GROUP BY/ORDER BY |
| **Tmp_table_on_disk: Yes** | Tmp table d√©borde RAM | Augmenter tmp_table_size |
| **Filesort: Yes** | Tri en m√©moire/disque | Cr√©er index pour ORDER BY |
| **Filesort_on_disk: Yes** | Tri d√©borde RAM | Augmenter sort_buffer_size |

### Filtrage intelligent

```ini
[mysqld]
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Configuration production recommand√©e
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

slow_query_log = ON
slow_query_log_file = /var/log/mysql/slow-query.log

# Seuil: 1 seconde
long_query_time = 1

# Logger requ√™tes sans index (avec filtre)
log_queries_not_using_indexes = ON
min_examined_row_limit = 1000  # Au moins 1000 rows

# Logger les commandes admin lentes (ALTER, OPTIMIZE...)
log_slow_admin_statements = ON

# Taux d'√©chantillonnage (logger 1 requ√™te sur N)
log_slow_rate_limit = 1  # D√©faut: tout logger

# Verbosit√©
log_slow_verbosity = query_plan,innodb,explain

# Exclure certaines requ√™tes (MariaDB 10.3+)
log_slow_filter = admin,filesort,filesort_on_disk,tmp_table,tmp_table_on_disk
```

### √âchantillonnage (log_slow_rate_limit)

Pour environnements **tr√®s** haute charge :

```ini
[mysqld]
# Logger seulement 1 requ√™te lente sur 10
log_slow_rate_limit = 10

# Utile quand:
# - Volume de slow queries tr√®s √©lev√© (> 1000/min)
# - Disque limit√©
# - M√™me requ√™te r√©p√©t√©e des milliers de fois
```

‚ö†Ô∏è **Attention** : L'√©chantillonnage perd de l'information. Pr√©f√©rer d'abord :
1. Augmenter `long_query_time`
2. Utiliser `min_examined_row_limit`
3. En dernier recours : `log_slow_rate_limit`

---

## Analyse manuelle des logs

### Extraction de statistiques basiques

```bash
# Nombre total de requ√™tes lentes
grep -c "^# Query_time:" /var/log/mysql/slow-query.log
1234

# Top 10 des requ√™tes les plus lentes
grep "^# Query_time:" /var/log/mysql/slow-query.log | \
  sort -t: -k2 -rn | \
  head -10

# Requ√™tes avec le plus de rows examin√©es
grep "Rows_examined:" /var/log/mysql/slow-query.log | \
  sort -t: -k4 -rn | \
  head -10
```

### Identification des patterns

```bash
# Compter les requ√™tes par table
grep -oP "FROM \K\w+" /var/log/mysql/slow-query.log | \
  sort | uniq -c | sort -rn | head -10

    456 orders
    234 customers
    123 products
     89 inventory
     67 sessions

# Compter les slow queries par utilisateur
grep "^# User@Host:" /var/log/mysql/slow-query.log | \
  cut -d'[' -f2 | cut -d']' -f1 | \
  sort | uniq -c | sort -rn

    567 appuser
    234 reporting_user
     89 batch_job
```

### Script d'analyse personnalis√©

```bash
#!/bin/bash
# analyze-slow-log.sh - Analyse basique du slow query log

LOGFILE="/var/log/mysql/slow-query.log"

echo "=== Slow Query Log Analysis ==="
echo "File: $LOGFILE"
echo "Generated: $(date)"
echo ""

echo "=== Summary ==="
TOTAL=$(grep -c "^# Query_time:" "$LOGFILE")
echo "Total slow queries: $TOTAL"
echo ""

echo "=== Top 10 slowest queries (by time) ==="
grep "^# Query_time:" "$LOGFILE" | \
  awk '{print $3}' | \
  sort -rn | \
  head -10 | \
  awk '{printf "  %.3f seconds\n", $1}'
echo ""

echo "=== Top 5 queries by rows examined ==="
grep "Rows_examined:" "$LOGFILE" | \
  awk '{print $6}' | \
  sort -rn | \
  head -5 | \
  awk '{printf "  %'\''d rows\n", $1}'
echo ""

echo "=== Queries with tmp tables on disk ==="
grep -c "Tmp_table_on_disk: Yes" "$LOGFILE"
echo ""

echo "=== Queries with filesort on disk ==="
grep -c "Filesort_on_disk: Yes" "$LOGFILE"
```

---

## Rotation et gestion des logs

### Rotation automatique avec logrotate

```bash
# /etc/logrotate.d/mysql-slow
/var/log/mysql/slow-query.log {
    daily                    # Rotation quotidienne
    rotate 7                 # Garder 7 jours
    compress                 # Compresser les anciens logs
    delaycompress            # Compresser J-1 (pas le jour m√™me)
    missingok                # Pas d'erreur si fichier absent
    notifempty               # Ne pas rotate si vide
    create 640 mysql mysql   # Permissions du nouveau fichier
    sharedscripts
    postrotate
        # Flush logs apr√®s rotation
        if [ -x /usr/bin/mysqladmin ]; then
            /usr/bin/mysqladmin --defaults-file=/etc/mysql/debian.cnf flush-logs
        fi
    endscript
}
```

### Rotation manuelle

```sql
-- M√©thode 1: FLUSH SLOW LOGS
FLUSH SLOW LOGS;

-- Le fichier actuel est ferm√© et renomm√©
-- Un nouveau fichier est cr√©√©
```

```bash
# M√©thode 2: Renommage manuel
mv /var/log/mysql/slow-query.log /var/log/mysql/slow-query.log.$(date +%Y%m%d)

# Indiquer √† MariaDB de cr√©er un nouveau fichier
mysql -e "FLUSH SLOW LOGS;"

# Compresser l'ancien
gzip /var/log/mysql/slow-query.log.$(date +%Y%m%d)
```

### Archivage long terme

```bash
#!/bin/bash
# archive-slow-logs.sh

ARCHIVE_DIR="/backup/mysql-slow-logs"
LOG_DIR="/var/log/mysql"
RETENTION_DAYS=90

# Cr√©er r√©pertoire archives
mkdir -p "$ARCHIVE_DIR"

# Archiver les logs > 7 jours
find "$LOG_DIR" -name "slow-query.log.*" -mtime +7 -exec mv {} "$ARCHIVE_DIR/" \;

# Supprimer archives > 90 jours
find "$ARCHIVE_DIR" -name "slow-query.log.*" -mtime +$RETENTION_DAYS -delete

# Rotation
mysql -e "FLUSH SLOW LOGS;"
```

**Cron hebdomadaire** :

```bash
# /etc/cron.weekly/archive-slow-logs
0 2 * * 0 /usr/local/bin/archive-slow-logs.sh
```

---

## Impact sur les performances

### Overhead du slow query log

Le slow query log a un **co√ªt de performance**, variable selon la configuration.

**Benchmark impact** (serveur 16 cores, SSD NVMe) :

| Configuration | TPS | Overhead | Notes |
|---------------|-----|----------|-------|
| Slow log OFF | 18,500 | 0% | Baseline |
| long_query_time=2, verbosity=minimal | 18,200 | 1.6% | ‚úì Acceptable |
| long_query_time=1, verbosity=query_plan | 17,800 | 3.8% | ‚úì Acceptable |
| long_query_time=0.1, verbosity=full | 16,200 | 12.4% | ‚ö†Ô∏è √âlev√© |
| long_query_time=0, verbosity=full | 12,300 | 33.5% | ‚ùå Prohibitif |

**Facteurs d'overhead** :

1. **Volume de requ√™tes logg√©es**
   - Plus de requ√™tes slow = plus d'overhead
   - `long_query_time` bas = plus de requ√™tes

2. **Verbosit√©** (`log_slow_verbosity`)
   - Minimal : ~1-2% overhead
   - Full (avec explain) : ~5-10% overhead

3. **D√©bit disque**
   - SSD : overhead minimal (< 2%)
   - HDD : overhead plus √©lev√© (3-8%)

### Strat√©gies de minimisation de l'overhead

**1. Seuil adapt√© au workload**

```ini
# OLTP haute concurrence
long_query_time = 2  # Seuil √©lev√©

# Analyse ponctuelle
long_query_time = 0.5  # Temporaire, puis remonter
```

**2. Filtrage intelligent**

```ini
# √âviter le spam de requ√™tes triviales
min_examined_row_limit = 1000

# √âchantillonnage si volume tr√®s √©lev√©
log_slow_rate_limit = 10  # 1 sur 10
```

**3. Activation ponctuelle**

```sql
-- D√©sactiver par d√©faut
SET GLOBAL slow_query_log = OFF;

-- Activer temporairement pour diagnostic
SET GLOBAL slow_query_log = ON;
SET GLOBAL long_query_time = 0.5;

-- Laisser tourner 1-2 heures
-- Puis d√©sactiver
SET GLOBAL slow_query_log = OFF;
```

**4. Logger sur disque d√©di√© (si HDD)**

```ini
[mysqld]
# Slow log sur disque s√©par√©
slow_query_log_file = /var/log/mysql-slow/slow-query.log

# /var/log/mysql-slow mont√© sur disque/partition s√©par√©(e)
```

---

## Cas d'usage pratiques

### Cas 1 : Identification d'une requ√™te probl√©matique

**Sympt√¥me** : Application lente depuis ce matin.

**Investigation** :

```bash
# Extraire les requ√™tes depuis 8h00 ce matin
tail -n 10000 /var/log/mysql/slow-query.log | \
  awk '/^# Time: 2025-12-14T08/,/^# Time: 2025-12-14T09/' > today-slow.log

# Analyser
grep "^# Query_time:" today-slow.log | wc -l
# 156 requ√™tes lentes en 1h (anormal !)

# Identifier la plus lente
grep "^# Query_time:" today-slow.log | \
  sort -t: -k2 -rn | \
  head -1
# Query_time: 45.678901
```

**Extraction de la requ√™te** :

```bash
# Contexte autour de la requ√™te la plus lente
grep -A 10 "Query_time: 45.678901" today-slow.log

# Query_time: 45.678901  Lock_time: 0.002  Rows_sent: 1  Rows_examined: 12345678
SELECT COUNT(*) FROM orders WHERE status = 'pending';
```

**Diagnostic** :
- `Rows_examined: 12,345,678` pour `Rows_sent: 1` ‚Üí Full table scan
- Pas d'index sur `status`

**Solution** :

```sql
-- Cr√©er index
CREATE INDEX idx_status ON orders(status);

-- V√©rifier am√©lioration
EXPLAIN SELECT COUNT(*) FROM orders WHERE status = 'pending';
-- type: ref (au lieu de ALL) ‚úì
```

### Cas 2 : Requ√™tes avec tables temporaires sur disque

**Probl√®me** : Serveur en alerte "tmp_table_size d√©pass√©".

```bash
# Compter les requ√™tes avec tmp table on disk
grep -c "Tmp_table_on_disk: Yes" /var/log/mysql/slow-query.log
234  # Beaucoup !

# Identifier les requ√™tes concern√©es
grep -B 5 "Tmp_table_on_disk: Yes" /var/log/mysql/slow-query.log | \
  grep "^SELECT" | \
  sort | uniq -c | sort -rn | head -5
```

**Solution** :

```ini
[mysqld]
# Augmenter tmp_table_size et max_heap_table_size
tmp_table_size = 256M  # Au lieu de 16M
max_heap_table_size = 256M
```

### Cas 3 : Lock contention

```bash
# Identifier requ√™tes avec lock_time √©lev√©
grep "Lock_time:" /var/log/mysql/slow-query.log | \
  awk '{if ($3 > 5) print}' | \
  wc -l
78  # 78 requ√™tes avec lock_time > 5s

# Analyser les requ√™tes concern√©es
grep -B 2 "Lock_time: [5-9]\." /var/log/mysql/slow-query.log
```

**Diagnostic** :
- Beaucoup de requ√™tes bloqu√©es sur la m√™me table
- Probablement une transaction longue qui verrouille

**Solutions** :
- Identifier la transaction longue (SHOW PROCESSLIST)
- Optimiser pour r√©duire la dur√©e de la transaction
- Envisager isolation level plus faible si appropri√©

---

## Monitoring et alerting

### Collecte de m√©triques

```sql
-- Vue pour monitoring du slow log
CREATE OR REPLACE VIEW v_slow_query_stats AS
SELECT 
    DATE(FROM_UNIXTIME(UNIX_TIMESTAMP())) AS date,
    COUNT(*) AS slow_queries_today,
    AVG(query_time) AS avg_query_time,
    MAX(query_time) AS max_query_time,
    SUM(CASE WHEN lock_time > 1 THEN 1 ELSE 0 END) AS high_lock_queries
FROM mysql.slow_log
WHERE start_time >= CURDATE();
```

### Alerting automatique

```bash
#!/bin/bash
# slow-query-alert.sh

LOGFILE="/var/log/mysql/slow-query.log"
THRESHOLD=50  # Alert si > 50 slow queries en 1h
EMAIL="dba@example.com"

# Compter slow queries derni√®re heure
COUNT=$(grep "^# Time:" "$LOGFILE" | \
  awk -v date="$(date -u -d '1 hour ago' +%Y-%m-%dT%H)" \
  '$3 > date' | wc -l)

if [ $COUNT -gt $THRESHOLD ]; then
    SUBJECT="ALERT: $COUNT slow queries in last hour"
    
    {
        echo "Slow query alert on $(hostname)"
        echo "Count: $COUNT queries"
        echo ""
        echo "Top 5 slowest:"
        tail -n 1000 "$LOGFILE" | \
          grep "^# Query_time:" | \
          sort -t: -k2 -rn | \
          head -5
    } | mail -s "$SUBJECT" "$EMAIL"
fi
```

**Cron horaire** :

```
0 * * * * /usr/local/bin/slow-query-alert.sh
```

### Int√©gration Prometheus

```bash
# Exporter m√©triques du slow query log via node_exporter textfile
#!/bin/bash
# slow-query-metrics.sh

LOGFILE="/var/log/mysql/slow-query.log"
METRICS_FILE="/var/lib/node_exporter/textfile_collector/slow_query.prom"

# Compter slow queries derni√®re heure
COUNT_1H=$(grep "^# Time:" "$LOGFILE" | \
  awk -v date="$(date -u -d '1 hour ago' +%Y-%m-%dT%H)" \
  '$3 > date' | wc -l)

# Temps max derni√®re heure
MAX_TIME=$(tail -n 5000 "$LOGFILE" | \
  grep "^# Query_time:" | \
  awk '{print $3}' | \
  sort -rn | \
  head -1)

# √âcrire m√©triques Prometheus
cat > "$METRICS_FILE" << EOF
# HELP mysql_slow_queries_1h Slow queries in last hour
# TYPE mysql_slow_queries_1h gauge
mysql_slow_queries_1h $COUNT_1H

# HELP mysql_slow_query_max_time_1h Maximum query time in last hour
# TYPE mysql_slow_query_max_time_1h gauge
mysql_slow_query_max_time_1h ${MAX_TIME:-0}
EOF
```

---

## Bonnes pratiques de production

### Checklist d'activation

- [ ] **Emplacement** : Log sur partition/disque s√©par√© si possible
- [ ] **Permissions** : Fichier accessible uniquement par mysql user (640)
- [ ] **Rotation** : logrotate configur√© (quotidien ou hebdomadaire)
- [ ] **Seuil** : `long_query_time` adapt√© au workload (1-5s)
- [ ] **Filtrage** : `min_examined_row_limit` d√©fini (> 1000)
- [ ] **Verbosit√©** : `log_slow_verbosity` minimal en production
- [ ] **Monitoring** : Alerting sur volume anormal de slow queries
- [ ] **Archivage** : Politique de r√©tention d√©finie (7-90 jours)
- [ ] **Documentation** : Proc√©dure d'analyse document√©e

### Configuration recommand√©e par environnement

**D√©veloppement** :

```ini
[mysqld]
slow_query_log = ON
long_query_time = 0.1  # Tr√®s sensible
log_queries_not_using_indexes = ON
min_examined_row_limit = 0  # Tout logger
log_slow_verbosity = query_plan,explain,innodb
```

**Staging/Pr√©-production** :

```ini
[mysqld]
slow_query_log = ON
long_query_time = 1
log_queries_not_using_indexes = ON
min_examined_row_limit = 1000
log_slow_verbosity = query_plan
log_slow_admin_statements = ON
```

**Production** :

```ini
[mysqld]
slow_query_log = ON
long_query_time = 2  # Ou 5 selon SLA
log_queries_not_using_indexes = ON
min_examined_row_limit = 5000  # Filtre plus strict
log_slow_verbosity = minimal  # Overhead minimal
log_slow_rate_limit = 1  # Pas d'√©chantillonnage par d√©faut
```

### Anti-patterns √† √©viter

‚ùå **Ne jamais** :
- Logger toutes les requ√™tes (`long_query_time = 0`) en production continue
- Garder `log_slow_verbosity = full` avec `explain` en permanence
- Logger sur le m√™me disque que les data files InnoDB (sur HDD)
- Ignorer les logs pendant des mois (stockage, analyse)

‚úÖ **Toujours** :
- Analyser r√©guli√®rement les logs (hebdomadaire minimum)
- Ajuster `long_query_time` selon le workload
- Monitorer la taille des fichiers de logs
- Tester l'impact performance lors de l'activation

---

## Limitations et alternatives

### Limitations du slow query log

1. **Overhead non nul** : 1-10% selon configuration
2. **Pas de temps r√©el** : Analyse post-mortem uniquement
3. **Pas d'agr√©gation** : Fichier texte √† parser
4. **Verbosit√© limit√©e** : Pas de statistiques sur buffer pool, etc.

### Alternatives compl√©mentaires

**Performance Schema** (section 15.8) :
- ‚úÖ Z√©ro overhead de logging fichier
- ‚úÖ Requ√™tes temps r√©el via SQL
- ‚úÖ Statistiques d√©taill√©es par statement digest
- ‚ö†Ô∏è Configuration plus complexe

**Query Analytics (Percona)** :
- ‚úÖ Interface graphique
- ‚úÖ Agr√©gation automatique
- ‚úÖ Comparaison temporelle
- ‚ö†Ô∏è Requiert infrastructure suppl√©mentaire

üí° **Recommandation** : Utiliser **slow query log** ET **Performance Schema** en compl√©mentarit√©.

---

## ‚úÖ Points cl√©s √† retenir

- **Le slow query log est l'outil fondamental** pour identifier les requ√™tes probl√©matiques en production. Activer syst√©matiquement avec un seuil adapt√©.

- **long_query_time = 1-5 secondes** en production OLTP. Ajuster selon le SLA et le volume de logs g√©n√©r√©.

- **M√©triques critiques** : `Rows_examined / Rows_sent` (ratio d'efficacit√©), `Lock_time` (contention), `Tmp_table_on_disk` (d√©bordement m√©moire).

- **log_queries_not_using_indexes = ON** pour capturer les full table scans, mais combiner avec `min_examined_row_limit` pour √©viter le spam.

- **Rotation obligatoire** : Configurer logrotate pour √©viter de saturer le disque. Retention typique : 7-30 jours.

- **Overhead 1-10%** selon configuration. Minimiser avec verbosit√© minimal, seuil √©lev√©, et filtrage intelligent. Activer ponctuellement avec seuil bas pour diagnostic.

- **Analyse r√©guli√®re essentielle** : Les logs ne servent √† rien s'ils ne sont pas analys√©s. Automatiser avec pt-query-digest (section suivante).

- **Compl√©ter avec Performance Schema** : Le slow query log capture l'historique, Performance Schema offre la vue temps r√©el.

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB
- [üìñ Slow Query Log](https://mariadb.com/kb/en/slow-query-log/)
- [üìñ Server System Variables - Slow Query Log](https://mariadb.com/kb/en/server-system-variables/#slow_query_log)
- [üìñ Log Files Overview](https://mariadb.com/kb/en/log-files/)

### Outils d'analyse
- [pt-query-digest - Percona Toolkit](https://www.percona.com/doc/percona-toolkit/LATEST/pt-query-digest.html)
- [mysqldumpslow - MySQL slow log analyzer](https://dev.mysql.com/doc/refman/8.0/en/mysqldumpslow.html)

### Articles et guides
- [Percona Blog - Slow Query Log Best Practices](https://www.percona.com/blog/)
- [MySQL Performance Blog - Query Analysis](https://www.percona.com/blog/)

### Scripts et automatisation
- [logrotate Documentation](https://linux.die.net/man/8/logrotate)
- [Prometheus node_exporter](https://github.com/prometheus/node_exporter)

---

## ‚û°Ô∏è Section suivante

**15.7.2 pt-query-digest (Percona Toolkit)** : Nous explorerons l'outil le plus puissant pour analyser les slow query logs, avec agr√©gation automatique, identification des patterns, g√©n√©ration de rapports, et int√©gration dans les workflows DevOps.

‚è≠Ô∏è [pt-query-digest (Percona Toolkit)](/15-performance-tuning/07.2-pt-query-digest.md)
