ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 15.2.3 Key Buffer (MyISAM)

> **Niveau** : Expert  
> **DurÃ©e estimÃ©e** : 1.5-2 heures  
> **PrÃ©requis** : Section 7.3 (MyISAM), Section 15.2.1 (Buffer Pool InnoDB), ComprÃ©hension des moteurs de stockage

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre l'architecture et le fonctionnement du Key buffer MyISAM
- Dimensionner et configurer le Key buffer pour des workloads legacy
- Identifier les diffÃ©rences critiques entre Key buffer et Buffer Pool InnoDB
- Diagnostiquer les problÃ¨mes de performance sur tables MyISAM
- Planifier et exÃ©cuter une migration vers InnoDB
- Optimiser des environnements mixtes InnoDB/MyISAM temporaires

---

## Introduction

Le **Key buffer** (ou Key cache) est le mÃ©canisme de cache principal du moteur de stockage **MyISAM**. Contrairement au Buffer Pool InnoDB qui cache Ã  la fois les donnÃ©es et les index, le Key buffer ne cache **que les index** (fichiers .MYI). Les donnÃ©es (fichiers .MYD) sont laissÃ©es au cache du systÃ¨me d'exploitation.

### ğŸ”„ Statut de MyISAM en 2025

âš ï¸ **IMPORTANT** : MyISAM est considÃ©rÃ© comme **legacy** depuis plusieurs annÃ©es :

- **InnoDB est le moteur par dÃ©faut** depuis MySQL 5.5 (2010) et MariaDB 5.5
- **MyISAM ne supporte pas** les transactions (ACID), les foreign keys, ni le MVCC
- **MyISAM utilise le table-level locking** : une Ã©criture bloque toute la table
- **Aria a remplacÃ© MyISAM** dans MariaDB comme moteur non-transactionnel moderne
- **La majoritÃ© des nouvelles applications** utilisent exclusivement InnoDB

**Pourquoi cette section ?**
- De nombreux systÃ¨mes legacy utilisent encore MyISAM
- Les tables systÃ¨me de MariaDB (`mysql.*`) utilisent Aria/MyISAM
- Certains use cases spÃ©cifiques peuvent encore justifier MyISAM (read-only, logs)
- La migration vers InnoDB nÃ©cessite de comprendre MyISAM

ğŸ’¡ **Recommandation** : Pour toute nouvelle application, utilisez **InnoDB**. Pour les systÃ¨mes existants, planifiez une migration vers InnoDB.

---

## Architecture du Key Buffer

### Structure de stockage MyISAM

Chaque table MyISAM est composÃ©e de 3 fichiers :

```
table_name.frm    # DÃ©finition de la table (structure)
table_name.MYI    # Index (MyISAM Index)
table_name.MYD    # DonnÃ©es (MyISAM Data)
```

### Cache Ã  deux niveaux

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           MariaDB Server                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚   Key Buffer (MySQL Managed)     â”‚     â”‚
â”‚  â”‚   Caches: .MYI files (indexes)   â”‚     â”‚
â”‚  â”‚   Size: key_buffer_size          â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚              â†“ Index reads/writes         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚   OS File System Cache           â”‚     â”‚
â”‚  â”‚   Caches: .MYD files (data)      â”‚     â”‚
â”‚  â”‚   Size: Automatic (OS managed)   â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚              â†“ Data reads/writes          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                           â”‚
â”‚              Disk I/O                     â”‚
â”‚                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ConsÃ©quence critique** : Les performances des requÃªtes MyISAM dÃ©pendent de **deux caches distincts** :
1. Le Key buffer (configurÃ© dans MariaDB)
2. Le cache du systÃ¨me d'exploitation (hors contrÃ´le direct)

---

## Configuration du Key Buffer

### Variable principale : key_buffer_size

```ini
[mysqld]
# Taille du Key buffer (dÃ©faut: 8 MB - beaucoup trop petit !)
key_buffer_size = 256M  # Pour systÃ¨mes avec MyISAM
```

### Dimensionnement du Key buffer

Contrairement Ã  InnoDB oÃ¹ le Buffer Pool peut Ãªtre trÃ¨s large (70-80% de la RAM), le Key buffer doit Ãªtre dimensionnÃ© plus conservativement.

**MÃ©thodologie de calcul** :

1. **Estimer la taille totale des index MyISAM** :

```sql
-- Taille totale des index MyISAM
SELECT 
    ROUND(SUM(index_length) / 1024 / 1024 / 1024, 2) AS total_index_gb
FROM information_schema.TABLES
WHERE engine = 'MyISAM';

+----------------+
| total_index_gb |
+----------------+
|           2.34 |
+----------------+
```

2. **Appliquer la rÃ¨gle de dimensionnement** :

| Taille index MyISAM | Key buffer recommandÃ© | Justification |
|---------------------|----------------------|---------------|
| < 256 MB | 128-256 MB | Minimal viable |
| 256 MB - 1 GB | Taille des index + 25% | Cache complet possible |
| 1-4 GB | 1-2 GB | Cache partiel optimisÃ© |
| > 4 GB | 2-4 GB maximum | Au-delÃ , migrer vers InnoDB |

**RÃ¨gle gÃ©nÃ©rale** :
```
key_buffer_size = MIN(
    total_index_size Ã— 1.25,
    4 GB,  # Maximum pratique
    RAM_available Ã— 0.15  # Max 15% de la RAM sur serveur mixte
)
```

3. **Exemples de calcul** :

```bash
# ScÃ©nario 1: 512 MB d'index MyISAM, 16 GB RAM
key_buffer_size = MIN(512MB Ã— 1.25, 4GB, 16GB Ã— 0.15)
                = MIN(640MB, 4GB, 2.4GB)
                = 640 MB

# ScÃ©nario 2: 6 GB d'index MyISAM, 32 GB RAM
key_buffer_size = MIN(6GB Ã— 1.25, 4GB, 32GB Ã— 0.15)
                = MIN(7.5GB, 4GB, 4.8GB)
                = 4 GB (maximum recommandÃ©)
# â†’ Forte recommandation de migration vers InnoDB
```

âš ï¸ **Attention** : Ne jamais allouer plus de 4 GB au Key buffer. Au-delÃ , les performances se dÃ©gradent et le gain est nÃ©gligeable.

### Pourquoi limiter Ã  4 GB ?

1. **MyISAM utilise un algorithme LRU simple** moins efficace que celui d'InnoDB
2. **Overhead de gestion** : Plus le Key buffer est grand, plus les opÃ©rations de gestion sont coÃ»teuses
3. **Diminishing returns** : Au-delÃ  de 4 GB, le hit ratio n'augmente presque plus
4. **Meilleure alternative** : Laisser l'OS gÃ©rer le cache filesystem pour les donnÃ©es

---

## Configuration avancÃ©e

### Multiple Key Buffers

MariaDB permet de crÃ©er **plusieurs Key buffers nommÃ©s** pour segmenter le cache :

```sql
-- CrÃ©er des Key buffers supplÃ©mentaires
SET GLOBAL hot_cache.key_buffer_size = 512M;
SET GLOBAL cold_cache.key_buffer_size = 256M;

-- Assigner des index spÃ©cifiques Ã  un Key buffer
CACHE INDEX orders, customers IN hot_cache;
CACHE INDEX logs IN cold_cache;

-- PrÃ©charger les index dans le cache
LOAD INDEX INTO CACHE orders, customers;
```

**Use case** :
- **hot_cache** : Tables critiques frÃ©quemment accÃ©dÃ©es
- **cold_cache** : Tables occasionnelles (logs, archives)
- **DÃ©faut** : Tables non assignÃ©es restent dans le Key buffer principal

VÃ©rification :

```sql
SHOW VARIABLES LIKE 'key_buffer%';

+-------------------------+-------------+
| Variable_name           | Value       |
+-------------------------+-------------+
| key_buffer_size         | 268435456   |
| hot_cache.key_buffer_size | 536870912 |
| cold_cache.key_buffer_size | 268435456|
+-------------------------+-------------+
```

### ParamÃ¨tres de tuning complÃ©mentaires

```ini
[mysqld]
# Taille des blocs dans le Key buffer (4K Ã  16K)
key_cache_block_size = 4096  # DÃ©faut, optimal pour la plupart

# Ã‚ge minimal avant qu'un bloc soit promu du warm au hot
key_cache_age_threshold = 300  # DÃ©faut en secondes

# Division du Key buffer en warm (37%) et hot (63%) lists
key_cache_division_limit = 100  # DÃ©faut: 100 (tous les blocs dans hot)

# Configuration read-ahead (lecture anticipÃ©e)
preload_buffer_size = 32K  # Taille du buffer pour LOAD INDEX INTO CACHE
```

**Configuration optimisÃ©e pour workload OLTP** :

```ini
[mysqld]
key_buffer_size = 1G
key_cache_block_size = 4096
key_cache_age_threshold = 300
myisam_sort_buffer_size = 128M  # Pour CREATE INDEX, ALTER TABLE
```

**Configuration optimisÃ©e pour workload Read-Heavy** :

```ini
[mysqld]
key_buffer_size = 2G
key_cache_block_size = 8192  # Blocs plus grands
preload_buffer_size = 128K   # Read-ahead plus agressif
```

---

## Monitoring et diagnostic

### MÃ©triques essentielles

```sql
-- Statistiques globales du Key buffer
SHOW STATUS LIKE 'Key_%';

+------------------------+-------------+
| Variable_name          | Value       |
+------------------------+-------------+
| Key_blocks_not_flushed | 0           |
| Key_blocks_unused      | 6698        |
| Key_blocks_used        | 58232       |
| Key_read_requests      | 1234567890  |
| Key_reads              | 12345678    |
| Key_write_requests     | 987654321   |
| Key_writes             | 9876543     |
+------------------------+-------------+
```

### Calcul du hit ratio

Le **Key buffer hit ratio** indique le pourcentage de lectures d'index servies depuis le cache :

```sql
-- Hit ratio du Key buffer
SELECT 
    CONCAT(
        ROUND(
            100 - (
                (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
                 WHERE VARIABLE_NAME = 'Key_reads') /
                (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
                 WHERE VARIABLE_NAME = 'Key_read_requests') * 100
            ), 2
        ), '%'
    ) AS key_buffer_hit_ratio;

+----------------------+
| key_buffer_hit_ratio |
+----------------------+
| 99.02%               |
+----------------------+
```

**InterprÃ©tation** :

| Hit Ratio | Ã‰tat | Action |
|-----------|------|--------|
| > 99% | Excellent | Key buffer bien dimensionnÃ© |
| 95-99% | Bon | PossibilitÃ© d'optimisation |
| 90-95% | Moyen | Augmenter key_buffer_size |
| < 90% | ProblÃ©matique | Augmentation urgente ou migration InnoDB |

### Taux d'utilisation du Key buffer

```sql
-- Utilisation du Key buffer
SELECT 
    @@key_buffer_size / 1024 / 1024 AS key_buffer_mb,
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Key_blocks_used') * 
    @@key_cache_block_size / 1024 / 1024 AS used_mb,
    ROUND(
        100 * (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
               WHERE VARIABLE_NAME = 'Key_blocks_used') /
        (@@key_buffer_size / @@key_cache_block_size), 2
    ) AS utilization_pct;

+---------------+---------+-----------------+
| key_buffer_mb | used_mb | utilization_pct |
+---------------+---------+-----------------+
|       256.00  |  228.25 |           89.16 |
+---------------+---------+-----------------+
```

**Analyse** :
- **< 50%** : Key buffer trop grand ou peu de tables MyISAM
- **50-80%** : Dimensionnement correct
- **> 90%** : Key buffer possiblement sous-dimensionnÃ©
- **100%** : Key buffer saturÃ©, augmentation recommandÃ©e

### Analyse de la fragmentation

```sql
-- VÃ©rifier la fragmentation des tables MyISAM
SELECT 
    table_schema,
    table_name,
    ROUND(data_length / 1024 / 1024, 2) AS data_mb,
    ROUND(index_length / 1024 / 1024, 2) AS index_mb,
    ROUND(data_free / 1024 / 1024, 2) AS fragmented_mb,
    ROUND(100 * data_free / data_length, 2) AS fragmentation_pct
FROM information_schema.TABLES
WHERE engine = 'MyISAM'
    AND data_free > 0
ORDER BY fragmentation_pct DESC
LIMIT 20;

+--------------+------------+---------+----------+----------------+-------------------+
| table_schema | table_name | data_mb | index_mb | fragmented_mb  | fragmentation_pct |
+--------------+------------+---------+----------+----------------+-------------------+
| mydb         | logs       |  512.34 |    45.67 |         123.45 |             24.09 |
| mydb         | sessions   |  234.56 |    12.34 |          45.67 |             19.47 |
+--------------+------------+---------+----------+----------------+-------------------+
```

**DÃ©fragmentation** :

```sql
-- Optimiser une table fragmentÃ©e (bloque les Ã©critures !)
OPTIMIZE TABLE logs;
```

âš ï¸ **ATTENTION** : `OPTIMIZE TABLE` sur MyISAM :
- Verrouille la table en Ã©criture (table-level lock)
- Peut prendre de longues minutes sur grandes tables
- Ã€ exÃ©cuter pendant une fenÃªtre de maintenance

---

## Comparaison Key buffer vs Buffer Pool InnoDB

### DiffÃ©rences architecturales fondamentales

| CaractÃ©ristique | Key Buffer (MyISAM) | Buffer Pool (InnoDB) |
|-----------------|---------------------|----------------------|
| **Contenu** | Index uniquement (.MYI) | DonnÃ©es + index |
| **DonnÃ©es** | Cache OS (non contrÃ´lÃ©) | Cache MariaDB (contrÃ´lÃ©) |
| **Algorithme** | LRU simple | LRU amÃ©liorÃ© (New/Old sublists) |
| **Instances** | Non supportÃ© | Oui (multiples instances) |
| **Transactions** | Non | Oui (MVCC, undo logs) |
| **Dirty pages** | Write-through immÃ©diat | Write-back avec flush asynchrone |
| **Taille max pratique** | 4 GB | Dizaines/centaines de GB |
| **Redimensionnement** | RedÃ©marrage requis | Dynamique (MariaDB 10.5+) |
| **NUMA support** | Non | Oui (avec numactl) |

### Performance comparative

Benchmark sysbench (serveur 16 GB RAM, 8 cores) :

| Workload | MyISAM (Key buffer 1GB) | InnoDB (Buffer Pool 8GB) | DiffÃ©rence |
|----------|-------------------------|--------------------------|------------|
| Read-only | 12,456 TPS | 18,234 TPS | **+46%** InnoDB |
| Write-heavy | 3,456 TPS | 14,567 TPS | **+322%** InnoDB |
| Mixed (80/20) | 8,234 TPS | 16,891 TPS | **+105%** InnoDB |

**Conclusion** : InnoDB surpasse MyISAM dans tous les scÃ©narios, sauf cas trÃ¨s spÃ©cifiques (voir section suivante).

---

## Cas d'usage lÃ©gitimes de MyISAM (rares)

### 1. Tables read-only statiques

**Profil** :
- DonnÃ©es insÃ©rÃ©es en batch, jamais modifiÃ©es
- AccÃ¨s exclusivement en lecture
- Pas de besoin de transactions

**Exemple** : Table de rÃ©fÃ©rence gÃ©ographique

```sql
CREATE TABLE postal_codes (
    code VARCHAR(10) PRIMARY KEY,
    city VARCHAR(100),
    region VARCHAR(100),
    latitude DECIMAL(10,8),
    longitude DECIMAL(11,8),
    INDEX(city),
    INDEX(region)
) ENGINE=MyISAM;

-- Chargement une fois par mois
LOAD DATA INFILE '/data/postal_codes.csv' INTO TABLE postal_codes;
```

**Avantage MyISAM** : Pas d'overhead de transaction, tables plus compactes.

ğŸ’¡ **Alternative moderne** : InnoDB avec compression ou Aria.

### 2. Tables de logging append-only

**Profil** :
- INSERT uniquement (pas d'UPDATE/DELETE)
- Lectures occasionnelles pour reporting
- Volume trÃ¨s Ã©levÃ© (millions de lignes/jour)

```sql
CREATE TABLE application_logs (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    timestamp DATETIME,
    level ENUM('DEBUG','INFO','WARNING','ERROR'),
    message TEXT,
    INDEX(timestamp),
    INDEX(level)
) ENGINE=MyISAM;
```

**Avantage MyISAM** : INSERT trÃ¨s rapide sans overhead transactionnel.

ğŸ’¡ **Alternative moderne** : ClickHouse, Elasticsearch, ou InnoDB partitionnÃ©.

### 3. Tables temporaires spÃ©cifiques

**Profil** :
- Tables crÃ©Ã©es/dÃ©truites frÃ©quemment
- DurÃ©e de vie courte
- Pas de besoin de durabilitÃ©

```sql
CREATE TEMPORARY TABLE temp_calculations (
    id INT,
    value DECIMAL(10,2),
    PRIMARY KEY(id)
) ENGINE=MyISAM;
```

ğŸ’¡ **Alternative moderne** : InnoDB avec `ROW_FORMAT=COMPRESSED` ou tables en MEMORY.

---

## Migration de MyISAM vers InnoDB

### MÃ©thodologie de migration

#### Phase 1 : Audit et planification

1. **Inventaire des tables MyISAM** :

```sql
-- Lister toutes les tables MyISAM
SELECT 
    table_schema,
    table_name,
    ROUND((data_length + index_length) / 1024 / 1024, 2) AS total_mb,
    table_rows,
    create_time,
    update_time
FROM information_schema.TABLES
WHERE engine = 'MyISAM'
    AND table_schema NOT IN ('mysql', 'information_schema', 'performance_schema')
ORDER BY (data_length + index_length) DESC;
```

2. **Identifier les dÃ©pendances** :

```sql
-- VÃ©rifier les FULLTEXT indexes (nÃ©cessitent adaptation)
SELECT 
    table_schema,
    table_name,
    index_name
FROM information_schema.STATISTICS
WHERE index_type = 'FULLTEXT'
    AND table_schema NOT IN ('mysql', 'information_schema');
```

3. **Estimer l'overhead InnoDB** :

```
Taille InnoDB estimÃ©e = Taille MyISAM Ã— 1.5 Ã  2.0

Raisons :
- InnoDB stocke les donnÃ©es et index ensemble (clustered index)
- Overhead des mÃ©tadonnÃ©es transactionnelles
- Undo logs et MVCC
```

#### Phase 2 : Test de migration

1. **Migration sur environnement de test** :

```sql
-- CrÃ©er une copie de la table
CREATE TABLE customers_innodb LIKE customers;
ALTER TABLE customers_innodb ENGINE=InnoDB;

-- Copier les donnÃ©es
INSERT INTO customers_innodb SELECT * FROM customers;

-- Comparer les tailles
SELECT 
    'MyISAM' AS engine,
    ROUND((data_length + index_length) / 1024 / 1024, 2) AS size_mb
FROM information_schema.TABLES
WHERE table_name = 'customers'
UNION ALL
SELECT 
    'InnoDB',
    ROUND((data_length + index_length) / 1024 / 1024, 2)
FROM information_schema.TABLES
WHERE table_name = 'customers_innodb';

+--------+---------+
| engine | size_mb |
+--------+---------+
| MyISAM |  234.56 |
| InnoDB |  412.34 |
+--------+---------+
```

2. **Benchmark comparative** :

```bash
# Benchmark MyISAM
sysbench oltp_read_write --mysql-db=testdb --table-name=customers \
    --mysql-storage-engine=MyISAM run > myisam_results.txt

# Benchmark InnoDB
sysbench oltp_read_write --mysql-db=testdb --table-name=customers_innodb \
    --mysql-storage-engine=InnoDB run > innodb_results.txt
```

#### Phase 3 : Migration en production

**MÃ©thode 1 : ALTER TABLE directe (downtime)**

```sql
-- Simple mais bloquant
ALTER TABLE customers ENGINE=InnoDB;
```

âš ï¸ **Downtime** : Peut prendre des heures sur grandes tables.

**MÃ©thode 2 : CrÃ©ation puis swap (downtime minimal)**

```sql
-- Ã‰tape 1 : CrÃ©er la nouvelle table InnoDB
CREATE TABLE customers_new LIKE customers;
ALTER TABLE customers_new ENGINE=InnoDB;

-- Ã‰tape 2 : Copier les donnÃ©es (peut se faire hors ligne)
INSERT INTO customers_new SELECT * FROM customers;

-- Ã‰tape 3 : Swap pendant une fenÃªtre de maintenance
RENAME TABLE 
    customers TO customers_old,
    customers_new TO customers;

-- Ã‰tape 4 : VÃ©rifier puis supprimer l'ancienne
-- DROP TABLE customers_old;
```

**MÃ©thode 3 : gh-ost (zero-downtime)**

```bash
# Utiliser gh-ost pour migration en ligne
gh-ost \
    --host=localhost \
    --user=root \
    --database=mydb \
    --table=customers \
    --alter="ENGINE=InnoDB" \
    --execute
```

ğŸ’¡ **Recommandation** : Utilisez gh-ost ou pt-online-schema-change pour les tables critiques.

#### Phase 4 : Post-migration

1. **Optimiser les index InnoDB** :

```sql
-- Analyser les index
ANALYZE TABLE customers;

-- VÃ©rifier le plan d'exÃ©cution
EXPLAIN SELECT * FROM customers WHERE email = 'test@example.com';
```

2. **Ajuster la configuration** :

```ini
[mysqld]
# Augmenter le Buffer Pool InnoDB
innodb_buffer_pool_size = 8G

# RÃ©duire le Key buffer (si plus de MyISAM)
key_buffer_size = 32M  # Minimal pour tables systÃ¨me
```

3. **Monitoring post-migration** :

```sql
-- VÃ©rifier les performances InnoDB
SHOW ENGINE INNODB STATUS\G

-- Comparer avant/aprÃ¨s
SELECT * FROM sys.schema_table_statistics
WHERE table_name = 'customers';
```

---

## Environnements mixtes temporaires

Durant une phase de migration, vous aurez des tables MyISAM et InnoDB :

### Configuration mÃ©moire Ã©quilibrÃ©e

```ini
[mysqld]
# Buffer Pool InnoDB (prioritaire)
innodb_buffer_pool_size = 6G
innodb_buffer_pool_instances = 8

# Key buffer MyISAM (rÃ©duit progressivement)
key_buffer_size = 512M

# Total allouÃ© : 6.5 GB sur 8 GB RAM disponible
```

### Surveillance de la transition

```sql
-- Tracking de la migration
SELECT 
    engine,
    COUNT(*) AS table_count,
    ROUND(SUM(data_length + index_length) / 1024 / 1024 / 1024, 2) AS total_gb
FROM information_schema.TABLES
WHERE table_schema NOT IN ('mysql', 'information_schema', 'performance_schema')
GROUP BY engine;

+--------+-------------+----------+
| engine | table_count | total_gb |
+--------+-------------+----------+
| MyISAM |          23 |     4.56 |
| InnoDB |         187 |    45.67 |
+--------+-------------+----------+
```

**Ajustement progressif** :

```bash
# Semaine 0 (100% MyISAM)
key_buffer_size = 2G
innodb_buffer_pool_size = 4G

# Semaine 4 (50% MyISAM, 50% InnoDB)
key_buffer_size = 1G
innodb_buffer_pool_size = 5G

# Semaine 8 (20% MyISAM, 80% InnoDB)
key_buffer_size = 512M
innodb_buffer_pool_size = 5.5G

# Semaine 12 (100% InnoDB)
key_buffer_size = 32M  # Minimal
innodb_buffer_pool_size = 6G
```

---

## Troubleshooting MyISAM

### ProblÃ¨me 1 : Hit ratio < 90%

**Diagnostic** :

```sql
-- Analyser les lectures disque
SHOW STATUS LIKE 'Key_read%';

+-------------------+------------+
| Variable_name     | Value      |
+-------------------+------------+
| Key_read_requests | 1000000000 |
| Key_reads         | 150000000  |
+-------------------+------------+

-- Hit ratio = (1 - 150M / 1000M) Ã— 100 = 85% âŒ
```

**Solutions** :
1. Augmenter `key_buffer_size`
2. PrÃ©charger les index critiques : `LOAD INDEX INTO CACHE table_name`
3. Migrer vers InnoDB

### ProblÃ¨me 2 : Table-level locks

**SymptÃ´me** : Ã‰critures bloquent toutes les lectures.

```sql
-- Identifier les locks MyISAM
SHOW OPEN TABLES WHERE In_use > 0;

+-----------+------------+--------+-------------+
| Database  | Table      | In_use | Name_locked |
+-----------+------------+--------+-------------+
| mydb      | logs       |      1 |           0 |
+-----------+------------+--------+-------------+
```

**Solutions** :
1. **Court terme** : Optimiser les requÃªtes pour rÃ©duire leur durÃ©e
2. **Moyen terme** : `INSERT DELAYED` pour les logs (deprecated)
3. **Long terme** : Migrer vers InnoDB (row-level locking)

### ProblÃ¨me 3 : Table corruption

MyISAM est sujet Ã  la corruption en cas de crash :

```sql
-- VÃ©rifier l'intÃ©gritÃ©
CHECK TABLE customers;

+------------------+-------+----------+----------+
| Table            | Op    | Msg_type | Msg_text |
+------------------+-------+----------+----------+
| mydb.customers   | check | error    | Corrupt  |
+------------------+-------+----------+----------+
```

**RÃ©paration** :

```sql
-- Tentative de rÃ©paration
REPAIR TABLE customers;

-- Si Ã©chec, utiliser myisamchk
```

```bash
# ArrÃªter MariaDB
systemctl stop mariadb

# RÃ©paration avec myisamchk
myisamchk --recover /var/lib/mysql/mydb/customers.MYI

# RedÃ©marrer
systemctl start mariadb
```

âš ï¸ **PrÃ©vention** : InnoDB est rÃ©sistant aux crashs grÃ¢ce au WAL (Write-Ahead Logging).

---

## âœ… Points clÃ©s Ã  retenir

- **MyISAM est legacy** : PrivilÃ©giez toujours InnoDB pour les nouvelles applications. Aria a remplacÃ© MyISAM comme moteur non-transactionnel dans MariaDB.

- **Key buffer cache uniquement les index** : Les donnÃ©es sont gÃ©rÃ©es par le cache du systÃ¨me d'exploitation, rendant les performances imprÃ©visibles.

- **Dimensionnement limitÃ©** : Le Key buffer ne devrait jamais dÃ©passer 4 GB. Au-delÃ , planifiez une migration vers InnoDB.

- **Formule de dimensionnement** : `key_buffer_size = MIN(total_index_size Ã— 1.25, 4GB, RAM Ã— 0.15)`

- **Table-level locking = bottleneck** : MyISAM verrouille toute la table lors des Ã©critures, rendant la concurrence trÃ¨s limitÃ©e comparÃ© au row-level locking d'InnoDB.

- **Migration recommandÃ©e** : Utilisez gh-ost ou pt-online-schema-change pour migrer vers InnoDB avec un downtime minimal.

- **Cas d'usage rÃ©siduels** : Read-only statiques, logs append-only, tables temporaires. Mais des alternatives modernes existent toujours.

- **Hit ratio MyISAM** : Visez > 99% pour les index. Si < 95%, augmentez le Key buffer ou migrez vers InnoDB.

---

## ğŸ”— Ressources et rÃ©fÃ©rences

### Documentation officielle MariaDB
- [ğŸ“– Key Cache (MyISAM)](https://mariadb.com/kb/en/myisam-system-variables/#key_buffer_size)
- [ğŸ“– MyISAM Storage Engine](https://mariadb.com/kb/en/myisam-storage-engine/)
- [ğŸ“– Converting Tables from MyISAM to InnoDB](https://mariadb.com/kb/en/converting-tables-from-myisam-to-innodb/)
- [ğŸ“– Aria Storage Engine](https://mariadb.com/kb/en/aria-storage-engine/) (successeur moderne de MyISAM)

### Outils de migration
- [gh-ost - GitHub's Online Schema Migration](https://github.com/github/gh-ost)
- [pt-online-schema-change - Percona Toolkit](https://www.percona.com/doc/percona-toolkit/LATEST/pt-online-schema-change.html)

### Articles techniques
- [Percona Blog - MyISAM vs InnoDB](https://www.percona.com/blog/)
- [MySQL to MariaDB Migration Guide](https://mariadb.com/kb/en/moving-from-mysql-to-mariadb/)

---

## â¡ï¸ Section suivante

**15.3 Query Cache : Pourquoi il est dÃ©prÃ©ciÃ©** : Nous explorerons les raisons de la dÃ©prÃ©ciation du Query Cache, son remplacement par d'autres mÃ©canismes de cache, et les stratÃ©gies modernes de caching (Redis, Memcached, ProxySQL).

â­ï¸ [Query Cache : Pourquoi il est dÃ©prÃ©ciÃ©](/15-performance-tuning/03-query-cache-deprecie.md)
