üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.4.2 innodb_flush_method

> **Niveau** : Expert  
> **Dur√©e estim√©e** : 2-3 heures  
> **Pr√©requis** : Section 15.4.1 (innodb_io_capacity), Section 7.2 (InnoDB), Compr√©hension des syst√®mes de fichiers Linux

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre les diff√©rentes m√©thodes de flush et leur impact sur les performances
- Ma√Ætriser les m√©canismes de double-buffering et comment les √©viter
- Choisir la m√©thode optimale selon le type de stockage et le syst√®me de fichiers
- Diagnostiquer les probl√®mes de performance li√©s au flushing
- Optimiser innodb_flush_method pour des workloads sp√©cifiques en production
- Comprendre les interactions entre flush method et durabilit√© des donn√©es

---

## Introduction

`innodb_flush_method` contr√¥le **comment InnoDB √©crit les donn√©es et les logs sur le disque**. C'est un param√®tre critique qui impacte directement :
- **Les performances I/O** (throughput et latence)
- **La durabilit√© des donn√©es** (garanties ACID)
- **L'utilisation de la m√©moire** (caches OS vs caches MariaDB)

### Probl√©matique du double-buffering

Sans configuration optimale, les donn√©es peuvent √™tre copi√©es **deux fois en m√©moire** avant d'atteindre le disque :

```
Architecture par d√©faut (fsync) - DOUBLE BUFFERING
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                  ‚îÇ
‚îÇ  InnoDB Buffer Pool (MariaDB)                    ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Donn√©es en RAM (24 GB)                      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Dirty pages √† √©crire                        ‚îÇ
‚îÇ         ‚Üì                                        ‚îÇ
‚îÇ     write() system call                          ‚îÇ
‚îÇ         ‚Üì                                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îÇ
‚îÇ  ‚îÇ  OS Page Cache (Kernel)    ‚îÇ  ‚Üê COPIE #1      ‚îÇ
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ Donn√©es copi√©es       ‚îÇ                  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ Cache redondant       ‚îÇ                  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îÇ
‚îÇ         ‚Üì                                        ‚îÇ
‚îÇ     fsync() - force write                        ‚îÇ
‚îÇ         ‚Üì                                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îÇ
‚îÇ  ‚îÇ  Disk Write Cache          ‚îÇ  ‚Üê COPIE #2      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îÇ
‚îÇ         ‚Üì                                        ‚îÇ
‚îÇ      Physical Disk                               ‚îÇ
‚îÇ                                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Probl√®me : Donn√©es pr√©sentes √† la fois dans :
- InnoDB Buffer Pool (utile)
- OS Page Cache (redondant, gaspillage RAM)
- Disk Cache (mat√©riel)
```

**Cons√©quences** :
- **Gaspillage de RAM** : Les m√™mes donn√©es en double
- **Double copie CPU** : Overhead inutile
- **Latence accrue** : Plusieurs √©tapes avant l'√©criture disque
- **Cache thrashing** : Le kernel √©vince des donn√©es utiles pour cacher des donn√©es InnoDB

**Solution** : Utiliser **O_DIRECT** pour √©crire directement sur disque sans passer par le cache OS.

---

## Les diff√©rentes m√©thodes de flush

### Vue d'ensemble

| M√©thode | Data Files | Log Files | OS Cache | Use Case |
|---------|------------|-----------|----------|----------|
| **fsync** (d√©faut) | write() + fsync() | write() + fsync() | OUI | Compatibilit√© maximale |
| **O_DSYNC** | write() + fsync() | O_DSYNC | Logs: NON | Rarement optimal |
| **O_DIRECT** | O_DIRECT | write() + fsync() | Data: NON | **SSD recommand√©** |
| **O_DIRECT_NO_FSYNC** | O_DIRECT | O_DIRECT (no fsync) | NON | **SSD avec BBU** |
| **ALL_O_DIRECT** | O_DIRECT | O_DIRECT | NON | SSD haute performance |
| **littlesync** | O_DIRECT | fsync() | Data: NON | Deprecated MariaDB |
| **nosync** | Aucun sync | Aucun sync | OUI | ‚ö†Ô∏è TEST UNIQUEMENT |

### M√©thode 1 : fsync (par d√©faut)

**Comportement** :

```c
// Pseudo-code du comportement fsync
// Data files (.ibd)
write(fd, buffer, size);     // Copie dans OS page cache
fsync(fd);                    // Force l'√©criture disque

// Log files (ib_logfile*)
write(fd, log_buffer, size);
fsync(fd);
```

**Architecture** :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ InnoDB Buffer   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ write()
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  OS Page Cache  ‚îÇ  ‚Üê Cache utilis√©
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ fsync()
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Disk          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Caract√©ristiques** :
- ‚úÖ Compatible avec tous les syst√®mes de fichiers
- ‚úÖ S√ªr et stable
- ‚ùå Double-buffering (gaspillage RAM)
- ‚ùå Performances sous-optimales
- ‚ùå Non recommand√© pour production avec SSD

**Quand utiliser** :
- Environnements de test/d√©veloppement
- Syst√®mes avec stockage r√©seau (NFS, iSCSI ancien)
- Compatibilit√© maximale requise

### M√©thode 2 : O_DIRECT (recommand√© production)

**Comportement** :

```c
// Pseudo-code O_DIRECT
// Data files (.ibd)
fd = open(filename, O_DIRECT);  // Bypass OS cache
write(fd, buffer, size);         // √âcriture directe
fsync(fd);                       // Force flush to disk

// Log files (ib_logfile*)
write(fd, log_buffer, size);    // Utilise OS cache
fsync(fd);                       // Force flush
```

**Architecture** :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ InnoDB Buffer   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ O_DIRECT write()
         ‚Üì
     [Bypass OS Cache]
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Disk          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Logs: write() + fsync() via OS cache (plus petit volume)
```

**Caract√©ristiques** :
- ‚úÖ **√âlimine le double-buffering** pour les data files
- ‚úÖ RAM utilis√©e uniquement par le Buffer Pool
- ‚úÖ Performances optimales sur SSD
- ‚úÖ Recommand√© pour la plupart des cas en production
- ‚ö†Ô∏è N√©cessite I/O align√©s (gestion automatique par InnoDB)

**Quand utiliser** :
- **Production avec SSD** (SATA ou NVMe)
- Serveurs d√©di√©s √† MariaDB
- Buffer Pool bien dimensionn√© (> 70% RAM)

**Configuration** :

```ini
[mysqld]
innodb_flush_method = O_DIRECT

# Compl√©ments recommand√©s pour SSD
innodb_io_capacity = 10000
innodb_io_capacity_max = 20000
innodb_flush_log_at_trx_commit = 1
```

üí° **Best practice** : **O_DIRECT est la m√©thode recommand√©e pour 95% des d√©ploiements production modernes**.

### M√©thode 3 : O_DIRECT_NO_FSYNC (SSD avec BBU)

**Comportement** :

```c
// Data files (.ibd)
fd = open(filename, O_DIRECT);
write(fd, buffer, size);
// Pas de fsync() - on fait confiance au disk cache avec BBU

// Log files (ib_logfile*)
fd = open(filename, O_DIRECT);
write(fd, log_buffer, size);
// Pas de fsync() non plus
```

**Caract√©ristiques** :
- ‚úÖ **Performances maximales** (pas de fsync overhead)
- ‚úÖ √âlimine le double-buffering
- ‚ö†Ô∏è **N√©cessite absolument** :
  - Disk cache avec **BBU (Battery Backup Unit)** ou **supercapacitor**
  - RAID controller avec write-back cache prot√©g√©
  - OU SSD avec condensateurs (Intel/Samsung Enterprise)
- ‚ùå **DANGEREUX sans protection** : perte de donn√©es en cas de coupure √©lectrique

**Quand utiliser** :
- Serveurs avec RAID controller + BBU
- SSD enterprise avec protection perte de courant
- Workload critique n√©cessitant latence minimale

**Configuration** :

```ini
[mysqld]
innodb_flush_method = O_DIRECT_NO_FSYNC

# ‚ö†Ô∏è √Ä utiliser UNIQUEMENT avec hardware prot√©g√©
# V√©rifier la pr√©sence de BBU/supercap
```

V√©rification du BBU :

```bash
# RAID Dell PERC
omreport storage battery

# RAID HP SmartArray
hpacucli ctrl all show config

# V√©rifier le write cache status
hdparm -W /dev/sda
```

‚ö†Ô∏è **ATTENTION** : N'utilisez **JAMAIS** O_DIRECT_NO_FSYNC sans protection mat√©rielle. Le risque de corruption de donn√©es est r√©el.

### M√©thode 4 : ALL_O_DIRECT

**Comportement** :

```c
// Data files ET log files : O_DIRECT
fd_data = open(data_file, O_DIRECT);
write(fd_data, buffer, size);
fsync(fd_data);

fd_log = open(log_file, O_DIRECT);
write(fd_log, log_buffer, size);
fsync(fd_log);
```

**Caract√©ristiques** :
- ‚úÖ Bypass complet de l'OS cache (data + logs)
- ‚úÖ Performances √©lev√©es sur SSD NVMe
- ‚ö†Ô∏è Peut augmenter la latence des commits (logs aussi en O_DIRECT)
- ‚ö†Ô∏è Moins de flexibilit√© pour les logs

**Quand utiliser** :
- SSD NVMe tr√®s rapides (> 100,000 IOPS)
- RAM tr√®s limit√©e (OS cache consomme trop)
- Workload avec logs volumineux

**Configuration** :

```ini
[mysqld]
innodb_flush_method = ALL_O_DIRECT

# SSD NVMe haute performance
innodb_io_capacity = 40000
innodb_io_capacity_max = 100000
```

### M√©thode 5 : O_DSYNC

**Comportement** :

```c
// Data files : fsync classique
write(fd_data, buffer, size);
fsync(fd_data);

// Log files : O_DSYNC (sync √† chaque write)
fd_log = open(log_file, O_DSYNC);
write(fd_log, log_buffer, size);  // Sync automatique
```

**Caract√©ristiques** :
- ‚ö†Ô∏è Rarement optimal (hybride peu coh√©rent)
- ‚ùå Data files toujours en double-buffering
- ‚ö†Ô∏è Logs synchrones √† chaque write (potentiellement lent)

**Quand utiliser** :
- Presque jamais en production moderne
- Certains anciens syst√®mes de fichiers sp√©cifiques

### M√©thode 6 : nosync (‚ö†Ô∏è TEST UNIQUEMENT)

**Comportement** :

```c
// Aucune synchronisation !
write(fd, buffer, size);
// Pas de fsync() du tout
```

**Caract√©ristiques** :
- ‚úÖ **Performances maximales absolues**
- ‚ùå **AUCUNE durabilit√©** : pertes de donn√©es garanties en crash
- ‚ùå **INTERDIT en production**

**Quand utiliser** :
- Tests de performance (benchmark)
- D√©veloppement local (donn√©es non critiques)
- Environnements jetables (containers √©ph√©m√®res)

```ini
[mysqld]
innodb_flush_method = nosync

# ‚ö†Ô∏è D√âVELOPPEMENT/TEST UNIQUEMENT
# NE JAMAIS UTILISER EN PRODUCTION
```

---

## Choix de la m√©thode optimale

### Arbre de d√©cision

```
Quel est votre environnement de stockage ?
‚îÇ
‚îú‚îÄ SSD (SATA ou NVMe) sans BBU/supercap
‚îÇ  ‚îî‚îÄ‚ñ∫ O_DIRECT (recommand√© √† 95%)
‚îÇ
‚îú‚îÄ SSD avec RAID controller + BBU/supercap
‚îÇ  ‚îî‚îÄ‚ñ∫ O_DIRECT_NO_FSYNC (performance maximale)
‚îÇ
‚îú‚îÄ SSD NVMe ultra-rapide (> 100K IOPS)
‚îÇ  ‚îú‚îÄ‚ñ∫ O_DIRECT (standard)
‚îÇ  ‚îî‚îÄ‚ñ∫ ALL_O_DIRECT (si RAM tr√®s limit√©e)
‚îÇ
‚îú‚îÄ HDD (m√©canique)
‚îÇ  ‚îî‚îÄ‚ñ∫ O_DIRECT (√©vite double-buffering quand m√™me)
‚îÇ
‚îú‚îÄ Stockage r√©seau (NFS, iSCSI)
‚îÇ  ‚îú‚îÄ‚ñ∫ O_DIRECT (g√©n√©ralement)
‚îÇ  ‚îî‚îÄ‚ñ∫ fsync (si probl√®mes de compatibilit√©)
‚îÇ
‚îî‚îÄ Test/D√©veloppement
   ‚îî‚îÄ‚ñ∫ fsync (compatibilit√©) ou nosync (benchmark)
```

### Matrice de d√©cision d√©taill√©e

| Crit√®re | fsync | O_DIRECT | O_DIRECT_NO_FSYNC | ALL_O_DIRECT |
|---------|-------|----------|-------------------|--------------|
| **SSD SATA** | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê (avec BBU) | ‚≠ê‚≠ê‚≠ê |
| **SSD NVMe** | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (avec BBU) | ‚≠ê‚≠ê‚≠ê‚≠ê |
| **HDD** | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚ùå | ‚≠ê‚≠ê |
| **NFS** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚ùå | ‚≠ê‚≠ê |
| **RAM limit√©e** | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **Durabilit√© max** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |
| **Performance max** | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |

---

## Impact sur les performances

### Benchmark comparatif

Environnement : SSD SATA, 32 GB RAM, Buffer Pool 24 GB

**Test sysbench OLTP (100 tables, 10M rows)** :

| Flush Method | TPS | Latency p95 (ms) | CPU % | RAM % |
|--------------|-----|------------------|-------|-------|
| fsync | 12,456 | 45.2 | 62% | 95% (OS cache + Buffer Pool) |
| O_DIRECT | 18,234 | 28.3 | 68% | 78% (Buffer Pool only) |
| O_DIRECT_NO_FSYNC | 21,567 | 22.1 | 70% | 78% |
| ALL_O_DIRECT | 17,891 | 29.8 | 69% | 77% |

**Observations** :
- **O_DIRECT** : +46% TPS vs fsync
- **O_DIRECT_NO_FSYNC** : +73% TPS vs fsync (avec BBU)
- **RAM** : 17% de RAM lib√©r√©e avec O_DIRECT

### Impact du syst√®me de fichiers

**Test avec diff√©rents FS (SSD SATA, O_DIRECT)** :

| Filesystem | TPS | Write Latency (ms) | Notes |
|------------|-----|-------------------|-------|
| ext4 | 18,234 | 28.3 | Baseline |
| xfs | 19,123 | 26.8 | +5% vs ext4 |
| btrfs | 16,890 | 31.2 | -7% vs ext4 (overhead CoW) |
| zfs | 17,456 | 29.7 | -4% vs ext4 |

üí° **Recommandation** : **ext4** ou **xfs** pour MariaDB en production. √âviter btrfs/zfs sauf besoins sp√©cifiques (snapshots, compression).

---

## Configuration optimale par cas d'usage

### Cas 1 : E-commerce production (SSD SATA, haute disponibilit√©)

**Profil** :
- SSD SATA sans BBU
- ACID strict requis
- 80% reads, 20% writes

**Configuration** :

```ini
[mysqld]
# Flush method : O_DIRECT (optimal SSD sans BBU)
innodb_flush_method = O_DIRECT

# Durabilit√© maximale
innodb_flush_log_at_trx_commit = 1  # Chaque transaction = fsync
sync_binlog = 1                      # Binlog synchrone

# I/O capacity adapt√© au SSD
innodb_io_capacity = 8000
innodb_io_capacity_max = 16000

# Buffer Pool
innodb_buffer_pool_size = 24G
innodb_buffer_pool_instances = 8

# Filesystem : ext4 avec options optimis√©es
# /etc/fstab:
# /dev/sdb1 /var/lib/mysql ext4 noatime,nodiratime,data=ordered 0 0
```

### Cas 2 : Analytics/Data Warehouse (SSD NVMe, performance max)

**Profil** :
- SSD NVMe avec RAID controller + BBU
- Bulk loads fr√©quents
- Durabilit√© moins critique (donn√©es recalculables)

**Configuration** :

```ini
[mysqld]
# Flush method : O_DIRECT_NO_FSYNC (performance maximale avec BBU)
innodb_flush_method = O_DIRECT_NO_FSYNC

# Durabilit√© rel√¢ch√©e pour performance
innodb_flush_log_at_trx_commit = 2  # Flush toutes les secondes
sync_binlog = 0                       # Binlog asynchrone

# I/O capacity tr√®s √©lev√© (NVMe)
innodb_io_capacity = 50000
innodb_io_capacity_max = 120000

# Buffer Pool
innodb_buffer_pool_size = 90G
innodb_buffer_pool_instances = 16

# Write threads
innodb_write_io_threads = 16
innodb_read_io_threads = 16

# Filesystem : xfs avec options optimis√©es
# /etc/fstab:
# /dev/nvme0n1p1 /var/lib/mysql xfs noatime,nodiratime,logbsize=256k 0 0
```

### Cas 3 : Application SaaS (Cloud, AWS gp3)

**Profil** :
- EBS gp3 (IOPS provisionn√©s)
- Budget contraint
- Haute disponibilit√© via r√©plication

**Configuration** :

```ini
[mysqld]
# Flush method : O_DIRECT (standard cloud)
innodb_flush_method = O_DIRECT

# Durabilit√© √©quilibr√©e
innodb_flush_log_at_trx_commit = 1
sync_binlog = 1

# I/O capacity selon IOPS provisionn√©s (exemple: 10,000 IOPS)
innodb_io_capacity = 6000
innodb_io_capacity_max = 10000

# Buffer Pool (instance r5.2xlarge: 64 GB RAM)
innodb_buffer_pool_size = 48G
innodb_buffer_pool_instances = 12

# Filesystem : ext4 (par d√©faut AWS)
# Options mount par d√©faut OK
```

### Cas 4 : Serveur legacy (HDD RAID 10)

**Profil** :
- HDD m√©caniques en RAID 10
- Migration vers SSD planifi√©e
- Configuration de transition

**Configuration** :

```ini
[mysqld]
# Flush method : O_DIRECT (√©vite quand m√™me le double-buffering)
innodb_flush_method = O_DIRECT

# Durabilit√© standard
innodb_flush_log_at_trx_commit = 1
sync_binlog = 1

# I/O capacity limit√© (HDD)
innodb_io_capacity = 400
innodb_io_capacity_max = 800

# Buffer Pool : Maximiser pour compenser HDD lent
innodb_buffer_pool_size = 28G  # 32 GB RAM disponible
innodb_buffer_pool_instances = 8

# Optimisations HDD
innodb_flush_neighbors = 1  # Activer (utile sur HDD)

# Filesystem : ext4
# /etc/fstab:
# /dev/md0 /var/lib/mysql ext4 noatime,data=ordered 0 0
```

---

## Interactions avec d'autres param√®tres

### innodb_flush_log_at_trx_commit

Cette variable contr√¥le **quand** les logs sont flush√©s, ind√©pendamment de la **m√©thode** :

```ini
# Combinaisons courantes

# Configuration 1 : Durabilit√© maximale (ACID strict)
innodb_flush_method = O_DIRECT
innodb_flush_log_at_trx_commit = 1  # Flush √† chaque transaction

# Configuration 2 : Performance maximale (risque perte 1s de donn√©es)
innodb_flush_method = O_DIRECT_NO_FSYNC
innodb_flush_log_at_trx_commit = 2  # Flush toutes les secondes

# Configuration 3 : Compromis
innodb_flush_method = O_DIRECT
innodb_flush_log_at_trx_commit = 2
```

**Impact de innodb_flush_log_at_trx_commit** :

| Valeur | Comportement | Durabilit√© | Performance |
|--------|--------------|------------|-------------|
| **0** | Flush/sync toutes les 1s | Perte max 1s | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **1** | Flush/sync √† chaque commit | Perte max 0 (ACID) | ‚≠ê‚≠ê‚≠ê |
| **2** | Flush chaque commit, sync 1s | Perte max 1s | ‚≠ê‚≠ê‚≠ê‚≠ê |

### innodb_flush_neighbors

Active le "flushing en cluster" des pages adjacentes :

```ini
# HDD : Activer (r√©duit les seeks)
innodb_flush_neighbors = 1

# SSD : D√©sactiver (pas de b√©n√©fice, overhead inutile)
innodb_flush_neighbors = 0
```

**Impact avec O_DIRECT sur SSD** :

```
Flush neighbors = 1 (HDD optimize):
  Page 1000 dirty ‚Üí flush pages 992-1007 (cluster)
  B√©n√©fice: r√©duit les seeks sur HDD
  Probl√®me SSD: √©crit des pages propres inutilement

Flush neighbors = 0 (SSD optimize):
  Page 1000 dirty ‚Üí flush uniquement page 1000
  Optimal pour SSD (no seek penalty)
```

### Options filesystem

**ext4 avec O_DIRECT** :

```bash
# /etc/fstab - Options optimales
/dev/sdb1 /var/lib/mysql ext4 noatime,nodiratime,data=ordered,barrier=1 0 0

# Explication:
# - noatime,nodiratime: pas de mise √† jour access time (performance)
# - data=ordered: m√©tadonn√©es avant donn√©es (coh√©rence)
# - barrier=1: force les write barriers (durabilit√© avec O_DIRECT)
```

**xfs avec O_DIRECT** :

```bash
# /etc/fstab
/dev/nvme0n1p1 /var/lib/mysql xfs noatime,nodiratime,logbsize=256k,logdev=/dev/nvme1n1 0 0

# Explication:
# - logbsize=256k: journal plus large (performance)
# - logdev: journal sur device s√©par√© (optimal NVMe)
```

---

## Diagnostic et troubleshooting

### V√©rifier la m√©thode active

```sql
-- V√©rifier innodb_flush_method
SHOW VARIABLES LIKE 'innodb_flush_method';

+---------------------+-----------+
| Variable_name       | Value     |
+---------------------+-----------+
| innodb_flush_method | O_DIRECT  |
+---------------------+-----------+
```

### V√©rifier l'utilisation du cache OS

```bash
# Avant O_DIRECT (fsync) : cache OS √©lev√©
free -h
              total        used        free      shared  buff/cache   available
Mem:           62Gi        45Gi       2.0Gi       200Mi        15Gi        16Gi
                                                             ‚Üë Cache OS √©lev√©

# Apr√®s O_DIRECT : cache OS faible
free -h
              total        used        free      shared  buff/cache   available
Mem:           62Gi        48Gi       10Gi       200Mi       4.0Gi        13Gi
                                                             ‚Üë Cache OS minimal
```

### Monitoring des I/O

```bash
# iostat d√©taill√©
iostat -x 5 3

Device   r/s   w/s   rkB/s   wkB/s  await  svctm  %util
sda     156   423   12456   34567   12.3    2.1   78.2

# Avec O_DIRECT, await devrait √™tre faible sur SSD (< 5ms)
```

### Probl√®me 1 : Performance d√©grad√©e apr√®s passage √† O_DIRECT

**Sympt√¥me** :
```
Avant (fsync):  15,000 TPS
Apr√®s (O_DIRECT): 8,000 TPS  ‚Üê D√©gradation !
```

**Causes possibles** :

1. **Buffer Pool trop petit**

```sql
-- V√©rifier le hit ratio
SHOW GLOBAL STATUS LIKE 'Innodb_buffer_pool_read%';

+-----------------------------------+------------+
| Variable_name                     | Value      |
+-----------------------------------+------------+
| Innodb_buffer_pool_read_requests  | 1000000000 |
| Innodb_buffer_pool_reads          | 250000000  | ‚Üê Trop de lectures disque !
+-----------------------------------+------------+

-- Hit ratio = (1 - 250M/1000M) = 75% ‚Üê Trop faible
```

**Solution** : Augmenter le Buffer Pool

```ini
[mysqld]
# Avant
innodb_buffer_pool_size = 8G   # Trop petit

# Apr√®s
innodb_buffer_pool_size = 24G  # 75% de la RAM
```

2. **I/O capacity trop faible**

```sql
SHOW VARIABLES LIKE 'innodb_io_capacity%';

+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| innodb_io_capacity      | 200   | ‚Üê D√©faut, beaucoup trop faible pour SSD
| innodb_io_capacity_max  | 2000  |
+-------------------------+-------+
```

**Solution** : Augmenter selon le SSD

```ini
[mysqld]
innodb_io_capacity = 10000
innodb_io_capacity_max = 20000
```

### Probl√®me 2 : Corruption apr√®s crash avec O_DIRECT_NO_FSYNC

**Sympt√¥me** :
```
InnoDB: Database page corruption on disk or a failed file read
InnoDB: Page [page id: space=0, page number=1234] corruption
```

**Cause** : O_DIRECT_NO_FSYNC utilis√© **SANS** BBU/supercap

**Diagnostic** :

```bash
# V√©rifier la pr√©sence de BBU
lspci | grep -i raid
# Si aucun contr√¥leur RAID ‚Üí PAS de BBU !

# V√©rifier my.cnf
grep innodb_flush_method /etc/mysql/my.cnf
innodb_flush_method = O_DIRECT_NO_FSYNC  ‚Üê DANGER sans BBU
```

**Solution** :

```ini
[mysqld]
# Corriger imm√©diatement
innodb_flush_method = O_DIRECT  # Avec fsync

# ET/OU installer BBU/supercap sur RAID controller
```

### Probl√®me 3 : Latence √©lev√©e avec ALL_O_DIRECT

**Sympt√¥me** :
```
Latence p95 : 45ms (attendu: < 20ms sur SSD NVMe)
```

**Cause** : Logs aussi en O_DIRECT = latence accrue sur commits

**Diagnostic** :

```sql
-- V√©rifier la latence des commits
SELECT * FROM sys.statement_analysis
WHERE query LIKE '%COMMIT%'
ORDER BY avg_latency DESC
LIMIT 10;
```

**Solution** : Revenir √† O_DIRECT (logs en cache OS)

```ini
[mysqld]
# Avant
innodb_flush_method = ALL_O_DIRECT

# Apr√®s
innodb_flush_method = O_DIRECT  # Logs via cache OS = plus rapide
```

---

## Migration entre m√©thodes

### Proc√©dure de changement

‚ö†Ô∏è **ATTENTION** : Changer `innodb_flush_method` n√©cessite un **red√©marrage** de MariaDB.

**√âtapes recommand√©es** :

1. **Benchmark actuel**

```bash
# Avant changement
sysbench oltp_read_write --mysql-db=test --table-size=1000000 run > before.txt
```

2. **Modifier la configuration**

```ini
# /etc/mysql/mariadb.conf.d/50-server.cnf
[mysqld]
innodb_flush_method = O_DIRECT  # Nouvelle valeur
```

3. **Planifier une fen√™tre de maintenance**

4. **Red√©marrer MariaDB**

```bash
systemctl restart mariadb

# V√©rifier le d√©marrage
systemctl status mariadb
tail -n 100 /var/log/mysql/error.log
```

5. **V√©rifier la configuration active**

```sql
SHOW VARIABLES LIKE 'innodb_flush_method';
```

6. **Re-benchmark et comparer**

```bash
sysbench oltp_read_write --mysql-db=test --table-size=1000000 run > after.txt
diff -u before.txt after.txt
```

7. **Monitoring intensif 24-48h**

```bash
# Surveiller les performances
watch -n 5 'mysqladmin extended-status | grep -E "Innodb_data|Innodb_buffer"'
```

---

## ‚úÖ Points cl√©s √† retenir

- **innodb_flush_method contr√¥le comment InnoDB √©crit sur disque**, impactant directement performances et durabilit√©.

- **O_DIRECT est recommand√© pour 95% des cas en production** : √©limine le double-buffering, optimise l'utilisation RAM, am√©liore les performances de 30-50% sur SSD.

- **fsync (d√©faut) = double-buffering** : Donn√©es copi√©es √† la fois dans InnoDB Buffer Pool ET OS page cache, gaspillant RAM et CPU.

- **O_DIRECT_NO_FSYNC = performance maximale** mais n√©cessite **ABSOLUMENT** un BBU/supercapacitor. Risque de corruption sans protection mat√©rielle.

- **ALL_O_DIRECT** : Bypass complet de l'OS cache (data + logs), utile sur SSD NVMe ultra-rapide ou si RAM tr√®s limit√©e.

- **Interactions critiques** : Combiner avec `innodb_flush_log_at_trx_commit=1` pour durabilit√© maximale, ou `=2` pour performance accrue.

- **innodb_flush_neighbors** : Activer sur HDD (=1), d√©sactiver sur SSD (=0) pour √©viter les √©critures inutiles.

- **Migration n√©cessite red√©marrage** : Tester en staging, planifier fen√™tre de maintenance, monitorer intensivement apr√®s changement.

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB
- [üìñ InnoDB System Variables - innodb_flush_method](https://mariadb.com/kb/en/innodb-system-variables/#innodb_flush_method)
- [üìñ InnoDB I/O Configuration](https://mariadb.com/kb/en/innodb-system-variables/#innodb-io-configuration)
- [üìñ InnoDB Flushing and Checkpoints](https://mariadb.com/kb/en/innodb-page-flushing/)

### Articles techniques
- [Percona Blog - Understanding O_DIRECT](https://www.percona.com/blog/)
- [MySQL Performance Blog - InnoDB Flush Methods](https://www.percona.com/blog/)
- [Oracle MySQL Documentation - Flush Method](https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_flush_method)

### Syst√®mes de fichiers
- [ext4 Documentation](https://www.kernel.org/doc/html/latest/filesystems/ext4/)
- [XFS Documentation](https://xfs.wiki.kernel.org/)
- [Linux I/O Stack](https://www.thomas-krenn.com/en/wiki/Linux_Storage_Stack_Diagram)

### Benchmarking
- [sysbench GitHub](https://github.com/akopytov/sysbench)
- [iostat man page](https://linux.die.net/man/1/iostat)

---

## ‚û°Ô∏è Section suivante

**15.4.3 Optimisations SSD modernes** : Nous explorerons les techniques avanc√©es d'optimisation pour SSD (TRIM/DISCARD, over-provisioning, wear leveling), l'exploitation des features NVMe (multiple queues, polling), et la configuration syst√®me (scheduler I/O, swappiness, transparent huge pages).

‚è≠Ô∏è [Optimisations SSD modernes](/15-performance-tuning/04.3-optimisations-ssd.md)
