ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 15.4.1 innodb_io_capacity

> **Niveau** : Expert  
> **DurÃ©e estimÃ©e** : 2-3 heures  
> **PrÃ©requis** : Section 7.2 (InnoDB), Section 15.2 (Configuration mÃ©moire), ComprÃ©hension des architectures de stockage

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre le rÃ´le de `innodb_io_capacity` dans l'architecture InnoDB
- Mesurer les capacitÃ©s I/O rÃ©elles de votre infrastructure de stockage
- Dimensionner optimalement `innodb_io_capacity` et `innodb_io_capacity_max`
- Adapter la configuration aux diffÃ©rents types de stockage (HDD, SSD SATA, SSD NVMe)
- Diagnostiquer et rÃ©soudre les problÃ¨mes de performance liÃ©s aux I/O
- Optimiser le flushing des dirty pages pour des workloads spÃ©cifiques

---

## Introduction

`innodb_io_capacity` est l'un des paramÃ¨tres les plus critiques mais mal compris de la configuration InnoDB. Il contrÃ´le le **rythme auquel InnoDB Ã©crit les dirty pages du Buffer Pool vers le disque** (processus appelÃ© **flushing**).

### ProblÃ©matique : Le compromis flush vs performance

InnoDB maintient en permanence deux objectifs contradictoires :

1. **Minimiser les I/O disque** : Garder les donnÃ©es en RAM le plus longtemps possible
2. **Assurer la durabilitÃ©** : Ã‰crire rÃ©guliÃ¨rement sur disque pour Ã©viter la perte de donnÃ©es

```
Buffer Pool (RAM)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                     â”‚
â”‚  Clean Pages: 60%                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ Safe, already on disk   â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                     â”‚
â”‚  Dirty Pages: 40%                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ Modified, need flushing â”‚â—„â”€â”€â”€â”€ innodb_io_capacity
â”‚  â”‚ to disk                 â”‚       controls this rate
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“ Flush writes
    Disk Storage
```

Un `innodb_io_capacity` **trop faible** :
- Accumulation excessive de dirty pages (> 75% du Buffer Pool)
- Risque de "checkpoint storm" oÃ¹ InnoDB doit flusher massivement
- Ralentissements sÃ©vÃ¨res lors des pics d'Ã©criture
- Temps de rÃ©cupÃ©ration aprÃ¨s crash prolongÃ©s

Un `innodb_io_capacity` **trop Ã©levÃ©** :
- Gaspillage d'I/O disque inutiles
- Sollicitation excessive du disque
- RÃ©duction de la durÃ©e de vie des SSD (wear leveling)
- Contention sur les I/O au dÃ©triment d'autres opÃ©rations

---

## Architecture du Background Flushing

### Threads de flushing

InnoDB utilise plusieurs types de threads pour gÃ©rer les Ã©critures :

```
InnoDB I/O Architecture
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                              â”‚
â”‚  Master Thread                               â”‚
â”‚  â”œâ”€â”€ Background flush (innodb_io_capacity)   â”‚
â”‚  â”‚   â†’ Flush graduel et rÃ©gulier             â”‚
â”‚  â”‚                                           â”‚
â”‚  Page Cleaner Threads                        â”‚
â”‚  â”œâ”€â”€ Adaptive flushing                       â”‚
â”‚  â”‚   â†’ Flush agressif si nÃ©cessaire          â”‚
â”‚  â”‚   â†’ ContrÃ´lÃ© par innodb_io_capacity_max   â”‚
â”‚  â”‚                                           â”‚
â”‚  â””â”€â”€ Checkpoint flush                        â”‚
â”‚      â†’ Flush forcÃ© pour libÃ©rer redo log     â”‚
â”‚                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Algorithme de flushing adaptatif

InnoDB ajuste dynamiquement le taux de flush selon :

1. **Pourcentage de dirty pages** (`innodb_max_dirty_pages_pct`)
2. **Taux de gÃ©nÃ©ration des redo logs**
3. **DisponibilitÃ© I/O** (`innodb_io_capacity` et `innodb_io_capacity_max`)

```
Flush Rate Calculation (simplifiÃ©):

IF dirty_pages_pct < innodb_max_dirty_pages_pct:
    flush_rate = innodb_io_capacity Ã— (dirty_pages_pct / target_pct)
ELSE:
    flush_rate = innodb_io_capacity_max (mode agressif)
```

---

## Mesure de la capacitÃ© I/O rÃ©elle

### Avant toute configuration : Benchmark votre stockage

âš ï¸ **ATTENTION** : Ne **jamais** deviner `innodb_io_capacity`. Mesurez-le !

### MÃ©thode 1 : fio (Flexible I/O Tester)

**Installation** :

```bash
# Ubuntu/Debian
apt-get install fio

# RHEL/CentOS
yum install fio
```

**Test d'IOPS en Ã©criture alÃ©atoire 16K (similaire Ã  InnoDB)** :

```bash
# Test sur le volume de donnÃ©es MariaDB
# âš ï¸ Ã€ exÃ©cuter sur un serveur de TEST ou avec MariaDB arrÃªtÃ©
fio --name=random-write \
    --ioengine=libaio \
    --iodepth=64 \
    --rw=randwrite \
    --bs=16k \
    --direct=1 \
    --size=4G \
    --numjobs=4 \
    --runtime=60 \
    --group_reporting \
    --filename=/var/lib/mysql/fio-test-file

# RÃ©sultat typique SSD SATA:
# IOPS: 15000-20000
```

**InterprÃ©tation** :

```
Type de stockage          IOPS (16K random write)    innodb_io_capacity    innodb_io_capacity_max
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HDD 7200 RPM              100-200                    100                   200
HDD RAID 10 (4 disks)     400-800                    400                   800
SSD SATA                  15,000-25,000              5,000-10,000          15,000-20,000
SSD NVMe                  50,000-200,000             20,000-40,000         80,000-100,000
NVMe RAID 0 (2 disks)     100,000-400,000            40,000-80,000         150,000-200,000
Cloud (AWS gp3)           3,000-16,000 (configurable) 1,000-8,000          6,000-12,000
```

### MÃ©thode 2 : ioping

Test de latence I/O :

```bash
# Installation
apt-get install ioping

# Test latence alÃ©atoire
ioping -c 100 -s 16k /var/lib/mysql

# RÃ©sultat typique SSD:
# min/avg/max/mdev = 0.1/0.3/2.1/0.4 ms
```

**CorrÃ©lation latence â†” IOPS** :

```
IOPS thÃ©orique max = 1000 ms / latency_avg_ms

Exemple SSD (0.3 ms latency):
IOPS = 1000 / 0.3 â‰ˆ 3333 IOPS par thread
Avec 64 threads: 3333 Ã— 64 = ~213,000 IOPS
```

### MÃ©thode 3 : sysbench (I/O spÃ©cifique)

```bash
# PrÃ©paration
sysbench fileio --file-total-size=4G prepare

# Test Ã©criture alÃ©atoire
sysbench fileio \
    --file-total-size=4G \
    --file-test-mode=rndwr \
    --file-extra-flags=direct \
    --file-fsync-freq=0 \
    --file-block-size=16384 \
    --max-time=60 \
    --max-requests=0 \
    run

# Nettoyage
sysbench fileio --file-total-size=4G cleanup
```

---

## Configuration de innodb_io_capacity

### Variables principales

```ini
[mysqld]
# CapacitÃ© I/O normale (flux rÃ©gulier)
innodb_io_capacity = 10000

# CapacitÃ© I/O maximale (flux agressif lors de pics)
innodb_io_capacity_max = 20000

# Nombre de threads de flushing (MariaDB 10.2+)
innodb_page_cleaners = 4
```

### RÃ¨gles de dimensionnement

**RÃ¨gle gÃ©nÃ©rale** :

```
innodb_io_capacity = 50-75% des IOPS mesurÃ©s en Ã©criture alÃ©atoire
innodb_io_capacity_max = 2Ã— innodb_io_capacity (ou IOPS max mesurÃ©s)
```

**Exemples concrets** :

```ini
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Configuration 1 : SSD SATA (18,000 IOPS mesurÃ©s)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[mysqld]
innodb_io_capacity = 10000        # 55% de 18,000
innodb_io_capacity_max = 20000    # 2Ã— innodb_io_capacity
innodb_page_cleaners = 4          # 1 par 4-8 GB de Buffer Pool

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Configuration 2 : NVMe (120,000 IOPS mesurÃ©s)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[mysqld]
innodb_io_capacity = 60000        # 50% de 120,000
innodb_io_capacity_max = 120000   # 100% des IOPS mesurÃ©s
innodb_page_cleaners = 8

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Configuration 3 : HDD RAID 10 (600 IOPS mesurÃ©s)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[mysqld]
innodb_io_capacity = 400          # 66% de 600
innodb_io_capacity_max = 800      # 133% (burst possible)
innodb_page_cleaners = 2

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Configuration 4 : AWS gp3 (10,000 IOPS provisionnÃ©s)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[mysqld]
innodb_io_capacity = 6000         # 60% de 10,000
innodb_io_capacity_max = 10000    # 100% des IOPS provisionnÃ©s
innodb_page_cleaners = 4
```

### Page Cleaners : ParallÃ©lisation du flushing

`innodb_page_cleaners` contrÃ´le le nombre de threads dÃ©diÃ©s au flushing.

**RÃ¨gle de dimensionnement** :

```
innodb_page_cleaners = MIN(
    innodb_buffer_pool_instances,
    nombre_cores / 2,
    8  # Maximum recommandÃ©
)
```

**Exemples** :

```bash
# Serveur 1: 32 GB Buffer Pool, 8 instances, 16 cores
innodb_page_cleaners = MIN(8, 8, 8) = 8

# Serveur 2: 64 GB Buffer Pool, 16 instances, 32 cores
innodb_page_cleaners = MIN(16, 16, 8) = 8

# Serveur 3: 8 GB Buffer Pool, 4 instances, 8 cores
innodb_page_cleaners = MIN(4, 4, 8) = 4
```

ğŸ’¡ **Conseil** : Alignez `innodb_page_cleaners` avec `innodb_buffer_pool_instances` pour un flushing optimal.

---

## Optimisations pour SSD modernes

### CaractÃ©ristiques des SSD Ã  exploiter

Les SSD modernes ont des propriÃ©tÃ©s trÃ¨s diffÃ©rentes des HDD :

| CaractÃ©ristique | HDD | SSD SATA | SSD NVMe |
|-----------------|-----|----------|----------|
| **Latence** | 5-10 ms | 0.1-0.5 ms | 0.02-0.1 ms |
| **IOPS (4K random)** | 100-200 | 20,000-90,000 | 100,000-1,000,000 |
| **Throughput sÃ©quentiel** | 100-200 MB/s | 500-600 MB/s | 2,000-7,000 MB/s |
| **SensibilitÃ© seek** | TrÃ¨s Ã©levÃ©e | Nulle | Nulle |
| **Queue depth optimal** | 1-4 | 32-128 | 64-256 |

### Configuration optimisÃ©e pour SSD

```ini
[mysqld]
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Optimisations I/O pour SSD NVMe
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# I/O Capacity : Exploiter la capacitÃ© Ã©levÃ©e
innodb_io_capacity = 40000
innodb_io_capacity_max = 100000

# Page Cleaners : Plus de parallÃ©lisme
innodb_page_cleaners = 8

# Flush Method : Direct I/O pour Ã©viter double-buffering
innodb_flush_method = O_DIRECT

# Flush Log : Plus agressif (SSD peut suivre)
innodb_flush_log_at_trx_commit = 1  # DurabilitÃ© maximale
innodb_flush_log_at_timeout = 1

# Write I/O Threads : Plus de parallÃ©lisme
innodb_write_io_threads = 16  # Au lieu de 4 par dÃ©faut

# Read I/O Threads
innodb_read_io_threads = 16

# Purge Threads : ParallÃ©lisation du nettoyage MVCC
innodb_purge_threads = 4

# Adaptive Flushing : ActivÃ© (essentiel sur SSD)
innodb_adaptive_flushing = ON
innodb_adaptive_flushing_lwm = 10  # Low water mark (%)

# Dirty Pages : Permettre un peu plus de dirty pages
innodb_max_dirty_pages_pct = 80  # Au lieu de 90 par dÃ©faut
innodb_max_dirty_pages_pct_lwm = 0  # Flush commence dÃ¨s qu'il y a des dirty pages
```

### ğŸ†• NouveautÃ© MariaDB 11.8 : Cost-based optimizer amÃ©liorÃ© pour SSD

MariaDB 11.8 introduit des amÃ©liorations dans le cost-based optimizer qui prennent mieux en compte les caractÃ©ristiques des SSD :

```sql
-- VÃ©rifier les nouvelles variables de coÃ»t (MariaDB 11.8+)
SHOW VARIABLES LIKE '%cost%';

+----------------------------------+----------+
| Variable_name                    | Value    |
+----------------------------------+----------+
| optimizer_disk_read_cost         | 1.0      | â† AjustÃ© pour SSD
| optimizer_index_block_copy_cost  | 0.05     | â† RÃ©duit pour SSD
| optimizer_row_copy_cost          | 0.01     |
+----------------------------------+----------+
```

**Configuration pour SSD NVMe** :

```sql
-- RÃ©duire les coÃ»ts de lecture disque (SSD = presque aussi rapide que RAM)
SET GLOBAL optimizer_disk_read_cost = 0.5;  -- Au lieu de 1.0

-- RÃ©duire les coÃ»ts de copie de blocs d'index
SET GLOBAL optimizer_index_block_copy_cost = 0.02;  -- Au lieu de 0.05
```

Ajout dans `my.cnf` :

```ini
[mysqld]
# Cost-based optimizer optimisÃ© pour SSD NVMe (MariaDB 11.8+)
optimizer_disk_read_cost = 0.5
optimizer_index_block_copy_cost = 0.02
optimizer_row_copy_cost = 0.01
```

ğŸ’¡ **Impact** : L'optimizer favorisera davantage les index scans et les opÃ©rations disque quand il sait qu'elles sont bon marchÃ© sur SSD.

---

## Monitoring et diagnostic

### MÃ©triques essentielles Ã  surveiller

```sql
-- Ã‰tat du flushing InnoDB
SHOW ENGINE INNODB STATUS\G

# Extrait pertinent:
# ----------------------
# BUFFER POOL AND MEMORY
# ----------------------
# Total large memory allocated 34359738368
# Dictionary memory allocated 1048576
# Buffer pool size   2097152        â† Pages totales
# Free buffers       1024
# Database pages     2089456
# Old database pages 770234
# Modified db pages  167893         â† Dirty pages (Ã  surveiller !)
# Pending reads      0
# Pending writes: LRU 0, flush list 0, single page 0
# Pages made young 45678, not young 123456
# Pages read 234567, created 345678, written 456789
# 12.34 reads/s, 23.45 creates/s, 34.56 writes/s  â† Flush rate
# Buffer pool hit rate 999 / 1000   â† Hit ratio
```

### Calcul du pourcentage de dirty pages

```sql
-- Dirty pages en pourcentage
SELECT 
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty') AS dirty_pages,
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total') AS total_pages,
    ROUND(100 * 
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty') /
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total'), 2
    ) AS dirty_pct,
    @@innodb_max_dirty_pages_pct AS max_allowed_pct;

+-------------+-------------+-----------+-----------------+
| dirty_pages | total_pages | dirty_pct | max_allowed_pct |
+-------------+-------------+-----------+-----------------+
|      167893 |     2097152 |      8.00 |              80 |
+-------------+-------------+-----------+-----------------+
```

**InterprÃ©tation** :

| Dirty % | Ã‰tat | Action |
|---------|------|--------|
| < 10% | Excellent | Flushing efficace |
| 10-30% | Bon | Normal pour workload d'Ã©criture |
| 30-50% | Moyen | Surveiller, possiblement augmenter io_capacity |
| 50-75% | ProblÃ©matique | Augmenter io_capacity urgement |
| > 75% | Critique | Risque de checkpoint storm |

### Taux de flushing en temps rÃ©el

```sql
-- CrÃ©er une vue pour le monitoring
CREATE OR REPLACE VIEW v_innodb_flush_rate AS
SELECT 
    'Current' AS snapshot,
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_flushed') AS pages_flushed,
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Innodb_data_writes') AS total_writes,
    NOW() AS timestamp;

-- Surveiller le taux de flush
SELECT 
    v2.timestamp,
    (v2.pages_flushed - v1.pages_flushed) AS pages_flushed_delta,
    (v2.total_writes - v1.total_writes) AS writes_delta,
    TIMESTAMPDIFF(SECOND, v1.timestamp, v2.timestamp) AS seconds_elapsed,
    ROUND((v2.pages_flushed - v1.pages_flushed) / 
          TIMESTAMPDIFF(SECOND, v1.timestamp, v2.timestamp), 2) AS flush_rate_per_sec
FROM v_innodb_flush_rate v1
CROSS JOIN (SELECT * FROM v_innodb_flush_rate) v2
WHERE v2.timestamp > v1.timestamp
LIMIT 1;
```

### Alerting sur dirty pages

```sql
-- Event pour alerting automatique
DELIMITER $$

CREATE EVENT monitor_dirty_pages
ON SCHEDULE EVERY 5 MINUTE
DO
BEGIN
    DECLARE dirty_pct DECIMAL(5,2);
    
    SELECT ROUND(100 * 
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty') /
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total'), 2
    ) INTO dirty_pct;
    
    IF dirty_pct > 60 THEN
        -- Logging de l'alerte
        INSERT INTO monitoring.innodb_alerts (alert_time, metric, value, threshold)
        VALUES (NOW(), 'dirty_pages_pct', dirty_pct, 60);
    END IF;
END$$

DELIMITER ;
```

---

## StratÃ©gies d'optimisation par workload

### Workload 1 : OLTP haute concurrence (lecture/Ã©criture Ã©quilibrÃ©es)

**Profil** :
- 80% reads, 20% writes
- Transactions courtes (< 100ms)
- Pics de trafic prÃ©visibles

**Configuration optimisÃ©e** (SSD SATA) :

```ini
[mysqld]
# I/O modÃ©rÃ© mais rÃ©gulier
innodb_io_capacity = 8000
innodb_io_capacity_max = 16000

# Dirty pages : Flush plus tÃ´t pour Ã©viter les pics
innodb_max_dirty_pages_pct = 70
innodb_max_dirty_pages_pct_lwm = 10

# Adaptive flushing : ActivÃ©
innodb_adaptive_flushing = ON
innodb_adaptive_flushing_lwm = 10

# Flushing agressif lors des pics
innodb_flushing_avg_loops = 30
```

### Workload 2 : Write-Heavy (logging, analytics)

**Profil** :
- 30% reads, 70% writes
- Bulk inserts frÃ©quents
- Dirty pages s'accumulent rapidement

**Configuration optimisÃ©e** (SSD NVMe) :

```ini
[mysqld]
# I/O trÃ¨s agressif
innodb_io_capacity = 50000
innodb_io_capacity_max = 120000

# Dirty pages : TolÃ©rance plus Ã©levÃ©e
innodb_max_dirty_pages_pct = 85
innodb_max_dirty_pages_pct_lwm = 0  # Flush constant

# Page cleaners : Maximum de parallÃ©lisme
innodb_page_cleaners = 8

# Write threads : Plus nombreux
innodb_write_io_threads = 16

# Adaptive flushing : TrÃ¨s agressif
innodb_adaptive_flushing = ON
innodb_adaptive_flushing_lwm = 5
innodb_flushing_avg_loops = 10  # RÃ©action rapide
```

### Workload 3 : Read-Heavy (reporting, analytics)

**Profil** :
- 95% reads, 5% writes
- Dirty pages peu nombreuses
- PrioritÃ© Ã  la latence de lecture

**Configuration optimisÃ©e** (SSD SATA) :

```ini
[mysqld]
# I/O modeste (peu de writes)
innodb_io_capacity = 4000
innodb_io_capacity_max = 8000

# Dirty pages : Flush prÃ©coce
innodb_max_dirty_pages_pct = 50
innodb_max_dirty_pages_pct_lwm = 5

# Read threads : PrioritÃ©
innodb_read_io_threads = 16
innodb_write_io_threads = 4

# Adaptive flushing : ModÃ©rÃ©
innodb_adaptive_flushing = ON
innodb_adaptive_flushing_lwm = 10
```

---

## Tuning dynamique (sans redÃ©marrage)

La plupart des variables I/O peuvent Ãªtre modifiÃ©es Ã  chaud :

```sql
-- Augmenter la capacitÃ© I/O (serveur SSD sous-utilisÃ©)
SET GLOBAL innodb_io_capacity = 20000;
SET GLOBAL innodb_io_capacity_max = 40000;

-- VÃ©rifier l'impact immÃ©diat
SHOW ENGINE INNODB STATUS\G

-- Ajuster le seuil de dirty pages
SET GLOBAL innodb_max_dirty_pages_pct = 70;

-- Observer pendant 30 minutes, puis valider dans my.cnf
```

ğŸ’¡ **MÃ©thodologie de tuning itÃ©ratif** :

1. **Mesurer** : Benchmarker le stockage (fio, ioping)
2. **Configurer** : Appliquer les valeurs calculÃ©es
3. **Tester** : Modifier Ã  chaud et observer 1-2 heures
4. **Valider** : Si OK, persister dans my.cnf
5. **Monitorer** : Surveiller les mÃ©triques en production
6. **ItÃ©rer** : Ajuster selon le comportement rÃ©el

---

## Troubleshooting avancÃ©

### ProblÃ¨me 1 : Dirty pages > 75% en permanence

**SymptÃ´mes** :
- Ralentissements pÃ©riodiques sÃ©vÃ¨res
- Checkpoint storms (flush massif soudain)
- Latence Ã©levÃ©e sur les Ã©critures

**Diagnostic** :

```sql
-- VÃ©rifier les dirty pages
SELECT 
    ROUND(100 * 
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty') /
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total'), 2
    ) AS dirty_pct;

+------------+
| dirty_pct  |
+------------+
|      82.34 |  â† ProblÃ©matique !
+------------+

-- VÃ©rifier si innodb_io_capacity est trop faible
SHOW VARIABLES LIKE 'innodb_io_capacity%';

+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| innodb_io_capacity      | 200   |  â† Beaucoup trop faible pour SSD !
| innodb_io_capacity_max  | 2000  |
+-------------------------+-------+
```

**Solution** :

```sql
-- Augmenter drastiquement (SSD dÃ©tectÃ©)
SET GLOBAL innodb_io_capacity = 10000;
SET GLOBAL innodb_io_capacity_max = 20000;

-- VÃ©rifier aprÃ¨s 15-30 minutes
```

### ProblÃ¨me 2 : I/O Utilization trÃ¨s faible malgrÃ© dirty pages

**SymptÃ´mes** :
- Dirty pages Ã©levÃ©es (> 50%)
- Mais `iostat` montre seulement 10-20% d'utilisation
- SSD capable de beaucoup plus

**Diagnostic** :

```bash
# VÃ©rifier l'utilisation I/O rÃ©elle
iostat -x 5 3

Device   r/s   w/s   rkB/s   wkB/s  %util
sda      45    123   1234    5678   18.2   â† TrÃ¨s sous-utilisÃ© !

# VÃ©rifier la configuration
mysql -e "SHOW VARIABLES LIKE 'innodb_%io%';"
```

**Causes possibles** :
1. `innodb_io_capacity` trop faible
2. Pas assez de `innodb_page_cleaners`
3. Pas assez de `innodb_write_io_threads`

**Solution** :

```ini
[mysqld]
# Augmenter massivement
innodb_io_capacity = 20000
innodb_io_capacity_max = 40000

# Plus de parallÃ©lisme
innodb_page_cleaners = 8
innodb_write_io_threads = 16
```

### ProblÃ¨me 3 : Checkpoint storms rÃ©pÃ©tÃ©s

**SymptÃ´mes** :
- Pauses pÃ©riodiques de 10-30 secondes
- Logs montrent "InnoDB: Page cleaner took XXXms to flush"
- Performance en dents de scie

**Diagnostic dans SHOW ENGINE INNODB STATUS** :

```
Log sequence number          123456789012
Log flushed up to            123456780000
Pages flushed up to          123456770000
Last checkpoint at           123456750000
0 pending log flushes, 0 pending chkp writes
```

Si `Log sequence number - Last checkpoint` > 80% de `innodb_log_file_size` â†’ ProblÃ¨me !

**Solution** :

```ini
[mysqld]
# Augmenter l'agressivitÃ© du flushing
innodb_io_capacity = 15000
innodb_io_capacity_max = 30000

# RÃ©duire le seuil de dirty pages
innodb_max_dirty_pages_pct = 60

# Activer l'adaptive flushing agressif
innodb_adaptive_flushing = ON
innodb_adaptive_flushing_lwm = 5
innodb_flushing_avg_loops = 10

# ET/OU augmenter la taille des redo logs
innodb_log_file_size = 2G  # Au lieu de 512M par exemple
```

---

## IntÃ©gration avec le monitoring

### MÃ©triques Prometheus/Grafana

```yaml
# mysqld_exporter collecte ces mÃ©triques
- mysql_global_status_innodb_buffer_pool_pages_dirty
- mysql_global_status_innodb_buffer_pool_pages_total
- mysql_global_status_innodb_buffer_pool_pages_flushed
- mysql_global_status_innodb_data_writes
- mysql_global_status_innodb_data_pending_writes
```

### RequÃªtes PromQL utiles

```promql
# Dirty pages en pourcentage
100 * (
  mysql_global_status_innodb_buffer_pool_pages_dirty /
  mysql_global_status_innodb_buffer_pool_pages_total
)

# Taux de flush (pages/seconde)
rate(mysql_global_status_innodb_buffer_pool_pages_flushed[5m])

# Writes pending (alerte si > 100)
mysql_global_status_innodb_data_pending_writes
```

### Alertes recommandÃ©es

```yaml
groups:
  - name: innodb_io
    rules:
      - alert: DirtyPagesHigh
        expr: |
          100 * (
            mysql_global_status_innodb_buffer_pool_pages_dirty /
            mysql_global_status_innodb_buffer_pool_pages_total
          ) > 70
        for: 15m
        labels:
          severity: warning
        annotations:
          summary: "InnoDB dirty pages > 70%"
          description: "Consider increasing innodb_io_capacity"
      
      - alert: DirtyPagesCritical
        expr: |
          100 * (
            mysql_global_status_innodb_buffer_pool_pages_dirty /
            mysql_global_status_innodb_buffer_pool_pages_total
          ) > 85
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "InnoDB dirty pages > 85% - checkpoint storm risk"
          description: "Immediate action required"
```

---

## âœ… Points clÃ©s Ã  retenir

- **innodb_io_capacity contrÃ´le le rythme de flush** des dirty pages du Buffer Pool vers le disque. C'est l'un des paramÃ¨tres les plus critiques pour les performances I/O.

- **Mesurez, ne devinez pas** : Utilisez fio, ioping ou sysbench pour mesurer les IOPS rÃ©els de votre stockage avant de configurer innodb_io_capacity.

- **RÃ¨gle de dimensionnement** : `innodb_io_capacity = 50-75% des IOPS mesurÃ©s` et `innodb_io_capacity_max = 2Ã— innodb_io_capacity`.

- **SSD vs HDD** : Les SSD nÃ©cessitent des valeurs 20-100x plus Ã©levÃ©es que les HDD. Un SSD SATA typique justifie 10,000-20,000, un NVMe peut aller jusqu'Ã  40,000-100,000.

- **Surveillez les dirty pages** : Si > 70% en permanence, augmentez innodb_io_capacity. Si > 85%, risque imminent de checkpoint storm.

- **Page cleaners et write threads** : Augmentez `innodb_page_cleaners` (jusqu'Ã  8) et `innodb_write_io_threads` (jusqu'Ã  16) sur SSD pour exploiter le parallÃ©lisme.

- **ğŸ†• MariaDB 11.8** : Le cost-based optimizer amÃ©liorÃ© pour SSD permet de rÃ©duire `optimizer_disk_read_cost` pour favoriser les opÃ©rations disque quand elles sont bon marchÃ©.

- **Tuning dynamique** : Toutes les variables clÃ©s peuvent Ãªtre modifiÃ©es sans redÃ©marrage. Testez en production, puis persistez dans my.cnf.

---

## ğŸ”— Ressources et rÃ©fÃ©rences

### Documentation officielle MariaDB
- [ğŸ“– InnoDB System Variables - innodb_io_capacity](https://mariadb.com/kb/en/innodb-system-variables/#innodb_io_capacity)
- [ğŸ“– InnoDB Page Flushing](https://mariadb.com/kb/en/innodb-page-flushing/)
- [ğŸ“– InnoDB Adaptive Flushing](https://mariadb.com/kb/en/innodb-adaptive-flushing/)

### Outils de benchmarking
- [fio - Flexible I/O Tester](https://fio.readthedocs.io/)
- [ioping - Disk latency monitor](https://github.com/koct9i/ioping)
- [sysbench - Benchmark tool](https://github.com/akopytov/sysbench)

### Articles techniques avancÃ©s
- [Percona Blog - InnoDB Flushing and Checkpoints](https://www.percona.com/blog/)
- [MySQL Performance Blog - Understanding InnoDB I/O](https://www.percona.com/blog/)
- [Facebook Engineering - MySQL at Scale](https://engineering.fb.com/)

### SSD et stockage moderne
- [Understanding SSD Performance](https://www.anandtech.com/show/2738/8)
- [NVMe Performance Guide](https://nvmexpress.org/)

---

## â¡ï¸ Section suivante

**15.4.2 innodb_flush_method** : Nous explorerons les diffÃ©rentes mÃ©thodes de flush (O_DIRECT, O_DSYNC, fsync), leur impact sur les performances selon les systÃ¨mes de fichiers, et comment choisir la mÃ©thode optimale pour votre infrastructure.

â­ï¸ [innodb_flush_method](/15-performance-tuning/04.2-innodb-flush-method.md)
