ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 15.2.1 InnoDB Buffer Pool : Dimensionnement

> **Niveau** : Expert  
> **DurÃ©e estimÃ©e** : 2-3 heures  
> **PrÃ©requis** : Section 15.1 (MÃ©thodologie d'optimisation), Section 7.2 (InnoDB), ComprÃ©hension de l'architecture mÃ©moire Linux

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre le rÃ´le critique du Buffer Pool dans les performances InnoDB
- Dimensionner le Buffer Pool de maniÃ¨re optimale selon les ressources disponibles
- Configurer et monitorer efficacement l'utilisation du Buffer Pool
- Diagnostiquer les problÃ¨mes de performance liÃ©s Ã  un Buffer Pool mal dimensionnÃ©
- Optimiser le Buffer Pool pour des workloads spÃ©cifiques en production

---

## Introduction

Le **Buffer Pool** est le composant mÃ©moire le plus critique d'InnoDB. Il s'agit d'une zone de cache qui stocke en RAM les pages de donnÃ©es et d'index frÃ©quemment accÃ©dÃ©es, rÃ©duisant drastiquement les I/O disque. Un dimensionnement inadÃ©quat du Buffer Pool est la cause la plus frÃ©quente de problÃ¨mes de performance sur des serveurs MariaDB en production.

### Pourquoi le Buffer Pool est-il si important ?

Les disques, mÃªme les SSD NVMe modernes, sont plusieurs ordres de grandeur plus lents que la RAM :
- **RAM** : latence ~100 nanosecondes
- **SSD NVMe** : latence ~100 microsecondes (1000x plus lent)
- **SSD SATA** : latence ~500 microsecondes (5000x plus lent)
- **HDD** : latence ~10 millisecondes (100 000x plus lent)

Un Buffer Pool correctement dimensionnÃ© peut permettre Ã  MariaDB de servir 95-99% des requÃªtes directement depuis la RAM, transformant un systÃ¨me limitÃ© par les I/O en un systÃ¨me limitÃ© par le CPU.

---

## Architecture du Buffer Pool

### Structure interne

Le Buffer Pool est organisÃ© en **pages** de 16 Ko par dÃ©faut (configurable avec `innodb_page_size`). Chaque page peut contenir :
- Des donnÃ©es de tables
- Des entrÃ©es d'index
- Des mÃ©tadonnÃ©es InnoDB
- Des donnÃ©es de l'Adaptive Hash Index
- Des structures de verrouillage

### Algorithme de gestion : LRU amÃ©liorÃ©

InnoDB utilise une liste LRU (Least Recently Used) modifiÃ©e, divisÃ©e en deux segments :
- **New sublist** (37% par dÃ©faut) : pages rÃ©cemment accÃ©dÃ©es
- **Old sublist** (63%) : pages anciennes candidates Ã  l'Ã©viction

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          InnoDB Buffer Pool                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ New Sublist  â”‚  â”‚  Old Sublist     â”‚     â”‚
â”‚  â”‚    (37%)     â”‚  â”‚     (63%)        â”‚     â”‚
â”‚  â”‚              â”‚  â”‚                  â”‚     â”‚
â”‚  â”‚ Hot pages    â”‚  â”‚  Cold pages      â”‚     â”‚
â”‚  â”‚ frequently   â”‚  â”‚  candidates for  â”‚     â”‚
â”‚  â”‚ accessed     â”‚  â”‚  eviction        â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Cette architecture protÃ¨ge contre les **full table scans** qui Ã©vinceraient les donnÃ©es chaudes avec un LRU classique.

---

## Dimensionnement du Buffer Pool

### RÃ¨gle de base : 70-80% de la RAM disponible

Pour un serveur **dÃ©diÃ©** Ã  MariaDB, la recommandation standard est :

```ini
[mysqld]
# Serveur avec 32 GB RAM dÃ©diÃ© Ã  MariaDB
innodb_buffer_pool_size = 24G  # 75% de 32 GB
```

âš ï¸ **Attention** : Cette rÃ¨gle suppose un serveur dÃ©diÃ©. Ne jamais allouer plus de RAM que disponible, sous peine de swapping catastrophique.

### Calcul dÃ©taillÃ© pour environnements partagÃ©s

Pour un serveur **hÃ©bergeant d'autres services**, calculez la RAM disponible pour MariaDB :

```
RAM_disponible = RAM_totale - (OS + autres_services + marge_sÃ©curitÃ©)

Exemple pour serveur 64 GB avec applications web :
- RAM totale : 64 GB
- OS (Linux) : 2 GB
- Applications web : 8 GB
- Marge de sÃ©curitÃ© : 4 GB (10%)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RAM disponible = 50 GB

innodb_buffer_pool_size = 40 GB (80% de 50 GB)
```

### MÃ©thodologie de dimensionnement itÃ©ratif

#### 1. Analyse de la taille du working set

Le **working set** est l'ensemble des donnÃ©es frÃ©quemment accÃ©dÃ©es. Pour l'estimer :

```sql
-- Taille totale des bases de donnÃ©es InnoDB
SELECT 
    ROUND(SUM(data_length + index_length) / 1024 / 1024 / 1024, 2) AS total_gb
FROM information_schema.TABLES
WHERE engine = 'InnoDB';
```

```sql
-- Taille par base de donnÃ©es
SELECT 
    table_schema,
    ROUND(SUM(data_length + index_length) / 1024 / 1024 / 1024, 2) AS size_gb,
    COUNT(*) AS table_count
FROM information_schema.TABLES
WHERE engine = 'InnoDB'
GROUP BY table_schema
ORDER BY size_gb DESC;
```

**ScÃ©narios typiques** :

| Working Set | Buffer Pool recommandÃ© | StratÃ©gie |
|-------------|------------------------|-----------|
| < RAM disponible | 100% du working set + 20% | Cache total possible |
| = RAM disponible | 80-90% de la RAM | Cache quasi-total |
| 2x RAM | 70-80% de la RAM | Cache partiel optimisÃ© |
| > 3x RAM | 70-80% de la RAM | Optimisation index + partitionnement |

#### 2. Analyse du hit ratio actuel

Le **Buffer Pool hit ratio** indique le pourcentage de lectures servies depuis le cache :

```sql
-- Hit ratio du Buffer Pool
SELECT 
    ROUND(100 * (1 - (
        VARIABLE_VALUE / 
        (SELECT VARIABLE_VALUE 
         FROM information_schema.GLOBAL_STATUS 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
    )), 2) AS buffer_pool_hit_ratio
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads';
```

**InterprÃ©tation** :
- **> 99%** : Excellent, Buffer Pool bien dimensionnÃ©
- **95-99%** : Bon, possibilitÃ© d'optimisation
- **90-95%** : Moyen, augmentation du Buffer Pool recommandÃ©e
- **< 90%** : ProblÃ©matique, augmentation urgente nÃ©cessaire

ğŸ’¡ **Conseil** : Mesurez le hit ratio aprÃ¨s au moins 24-48h de fonctionnement pour obtenir des statistiques reprÃ©sentatives.

#### 3. Monitoring de l'utilisation rÃ©elle

VÃ©rifiez comment le Buffer Pool est utilisÃ© :

```sql
-- Ã‰tat dÃ©taillÃ© du Buffer Pool
SHOW ENGINE INNODB STATUS\G
```

Extrait pertinent :
```
----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 25787392000
Dictionary memory allocated 389770
Buffer pool size   1572864        -- Pages totales (1572864 * 16KB = 24 GB)
Free buffers       1024           -- Pages libres
Database pages     1548123        -- Pages utilisÃ©es pour les donnÃ©es
Old database pages 571234         -- Pages dans l'old sublist
Modified db pages  42156          -- Dirty pages en attente d'Ã©criture
```

Calcul du taux d'utilisation :
```
Utilisation = (Database pages / Buffer pool size) * 100
            = (1548123 / 1572864) * 100
            = 98.4%
```

Si l'utilisation est constamment > 95%, le Buffer Pool est probablement sous-dimensionnÃ©.

---

## Configuration avancÃ©e du Buffer Pool

### Buffer Pool Instances (innodb_buffer_pool_instances)

Pour amÃ©liorer la concurrence sur les serveurs multi-cÅ“urs, InnoDB permet de diviser le Buffer Pool en plusieurs instances :

```ini
[mysqld]
innodb_buffer_pool_size = 32G
innodb_buffer_pool_instances = 8  # 1 instance par 4 GB recommandÃ©
```

**RÃ¨gles de dimensionnement** :

| Buffer Pool Size | Instances recommandÃ©es | Justification |
|------------------|------------------------|---------------|
| < 1 GB | 1 | Overhead pas justifiÃ© |
| 1-8 GB | 2-4 | RÃ©duction de la contention |
| 8-16 GB | 4-8 | Ã‰quilibre optimal |
| 16-64 GB | 8-16 | Maximum de parallÃ©lisme |
| > 64 GB | 16 | Limite MariaDB (max 64 instances thÃ©orique, 16 pratique) |

ğŸ’¡ **Conseil** : Utilisez `innodb_buffer_pool_instances = innodb_buffer_pool_size_in_GB / 4` comme point de dÃ©part.

âš ï¸ **Attention** : Chaque instance nÃ©cessite ses propres mutex et structures. Trop d'instances peut augmenter l'overhead mÃ©moire.

### Buffer Pool Chunk Size (MariaDB 10.5+)

Depuis MariaDB 10.5, le Buffer Pool est divisÃ© en **chunks** pour permettre le redimensionnement dynamique :

```ini
[mysqld]
innodb_buffer_pool_chunk_size = 128M  # DÃ©faut, gÃ©nÃ©ralement optimal
```

La taille totale du Buffer Pool doit Ãªtre un multiple de :
```
innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances
```

MariaDB ajuste automatiquement si ce n'est pas le cas, mais il vaut mieux le calculer explicitement :

```bash
# Exemple : 32 GB avec 8 instances et chunks de 128M
# 32 GB = 32768 MB
# Chunk total = 128M * 8 = 1024M = 1 GB
# 32768 / 1024 = 32 chunks par instance âœ“
```

### Redimensionnement dynamique (sans redÃ©marrage)

ğŸ†• **MariaDB 11.8** : Le redimensionnement dynamique du Buffer Pool est stable et performant.

```sql
-- VÃ©rifier la taille actuelle
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';

-- Augmenter Ã  48 GB (serveur en production)
SET GLOBAL innodb_buffer_pool_size = 51539607552;  -- 48 * 1024^3
```

Monitoring du redimensionnement :

```sql
-- Observer la progression
SHOW STATUS LIKE 'Innodb_buffer_pool_resize_status';
```

RÃ©sultat typique :
```
+----------------------------------+----------------------------------------------------------+
| Variable_name                    | Value                                                    |
+----------------------------------+----------------------------------------------------------+
| Innodb_buffer_pool_resize_status | Resizing buffer pool from 25769803776 to 51539607552.    |
+----------------------------------+----------------------------------------------------------+
```

âš ï¸ **Attention** : 
- Le redimensionnement peut prendre plusieurs minutes sur des gros Buffer Pools
- Des ralentissements temporaires peuvent survenir pendant le processus
- Planifiez cette opÃ©ration pendant une fenÃªtre de maintenance ou en heures creuses

---

## Optimisations spÃ©cifiques au Buffer Pool

### PrÃ©chargement du Buffer Pool au dÃ©marrage

Pour rÃ©duire le temps de "warm-up" aprÃ¨s un redÃ©marrage :

```ini
[mysqld]
# Sauvegarder l'Ã©tat du Buffer Pool Ã  l'arrÃªt
innodb_buffer_pool_dump_at_shutdown = ON

# Restaurer le Buffer Pool au dÃ©marrage
innodb_buffer_pool_load_at_startup = ON

# Pourcentage de pages les plus chaudes Ã  sauvegarder
innodb_buffer_pool_dump_pct = 25  # 25% par dÃ©faut, suffisant gÃ©nÃ©ralement
```

Sauvegarde manuelle :
```sql
-- DÃ©clencher une sauvegarde immÃ©diate
SET GLOBAL innodb_buffer_pool_dump_now = ON;

-- Monitoring
SHOW STATUS LIKE 'Innodb_buffer_pool_dump_status';
```

Restauration manuelle :
```sql
-- Charger les donnÃ©es sauvegardÃ©es
SET GLOBAL innodb_buffer_pool_load_now = ON;

-- Annuler un chargement en cours
SET GLOBAL innodb_buffer_pool_load_abort = ON;
```

Le fichier de dump est stockÃ© dans le datadir :
```bash
ls -lh /var/lib/mysql/ib_buffer_pool
-rw-r----- 1 mysql mysql 45M Dec 14 10:30 /var/lib/mysql/ib_buffer_pool
```

### Scan Resistant Buffer Pool

Configuration pour protÃ©ger contre les full table scans :

```ini
[mysqld]
# Pourcentage de l'old sublist (dÃ©faut: 37, optimal pour la plupart)
innodb_old_blocks_pct = 37

# DÃ©lai avant qu'une page de l'old sublist ne migre vers la new (ms)
innodb_old_blocks_time = 1000  # 1 seconde par dÃ©faut
```

**Cas d'usage** :
- **Workload OLTP pur** : `innodb_old_blocks_time = 0` (migration immÃ©diate)
- **Workload mixte OLTP + Analytics** : `innodb_old_blocks_time = 1000` (dÃ©faut)
- **Analytics avec scans frÃ©quents** : `innodb_old_blocks_time = 2000-5000` (protection forte)

---

## Monitoring et diagnostic

### MÃ©triques essentielles Ã  surveiller

```sql
-- Vue complÃ¨te du Buffer Pool
SELECT 
    @@innodb_buffer_pool_size / 1024 / 1024 / 1024 AS buffer_pool_gb,
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total') AS total_pages,
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_data') AS data_pages,
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_free') AS free_pages,
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty') AS dirty_pages,
    ROUND(100 * (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
                 WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_data') /
          (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
           WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total'), 2) AS utilization_pct;
```

### RequÃªtes de diagnostic avancÃ©es

**1. Calcul du hit ratio avec dÃ©tails**

```sql
SELECT 
    'Buffer Pool Read Requests' AS metric,
    VARIABLE_VALUE AS value
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests'
UNION ALL
SELECT 
    'Buffer Pool Reads (Disk)',
    VARIABLE_VALUE
FROM information_schema.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads'
UNION ALL
SELECT
    'Hit Ratio (%)',
    ROUND(100 * (1 - (
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
    )), 4);
```

**2. Ã‰volution du Buffer Pool dans le temps**

CrÃ©ez une table de monitoring :

```sql
CREATE TABLE buffer_pool_metrics (
    ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    buffer_pool_size_gb DECIMAL(10,2),
    pages_total BIGINT,
    pages_data BIGINT,
    pages_free BIGINT,
    pages_dirty BIGINT,
    hit_ratio DECIMAL(5,2),
    read_requests BIGINT,
    disk_reads BIGINT,
    INDEX(ts)
) ENGINE=InnoDB;
```

Event pour collecter automatiquement :

```sql
CREATE EVENT collect_buffer_pool_metrics
ON SCHEDULE EVERY 5 MINUTE
DO
INSERT INTO buffer_pool_metrics (
    buffer_pool_size_gb,
    pages_total,
    pages_data,
    pages_free,
    pages_dirty,
    hit_ratio,
    read_requests,
    disk_reads
)
SELECT 
    @@innodb_buffer_pool_size / 1024 / 1024 / 1024,
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total'),
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_data'),
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_free'),
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty'),
    ROUND(100 * (1 - (
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
    )), 2),
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests'),
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads');
```

---

## Cas pratiques de dimensionnement

### Cas 1 : E-commerce OLTP (32 GB RAM, 50 GB de donnÃ©es)

**Analyse** :
- Working set : ~30 GB (donnÃ©es chaudes : produits, commandes rÃ©centes, clients actifs)
- RAM disponible : 32 GB
- Workload : 95% lectures, 5% Ã©critures

**Configuration optimale** :

```ini
[mysqld]
# Buffer Pool : 75% de la RAM
innodb_buffer_pool_size = 24G
innodb_buffer_pool_instances = 8

# Optimisations OLTP
innodb_old_blocks_time = 500  # Migration rapide
innodb_buffer_pool_dump_pct = 40  # Plus de donnÃ©es chaudes

# PrÃ©chargement
innodb_buffer_pool_dump_at_shutdown = ON
innodb_buffer_pool_load_at_startup = ON
```

**RÃ©sultat attendu** :
- Hit ratio : > 99%
- Warm-up aprÃ¨s redÃ©marrage : < 2 minutes
- I/O disque : < 100 IOPS en moyenne

### Cas 2 : Analytics/Data Warehouse (128 GB RAM, 2 TB de donnÃ©es)

**Analyse** :
- Working set : > 500 GB (impossibilitÃ© de tout mettre en cache)
- RAM disponible : 128 GB
- Workload : Scans importants, agrÃ©gations lourdes

**Configuration optimale** :

```ini
[mysqld]
# Buffer Pool : 70% de la RAM (OS et applications nÃ©cessitent plus de mÃ©moire)
innodb_buffer_pool_size = 90G
innodb_buffer_pool_instances = 16

# Protection contre les scans
innodb_old_blocks_time = 3000  # 3 secondes
innodb_old_blocks_pct = 30     # Old sublist plus petite

# PrÃ©chargement limitÃ© (scans variÃ©s)
innodb_buffer_pool_dump_pct = 10
```

**ComplÃ©ments** :
- Utiliser le partitionnement pour limiter les scans
- Envisager ColumnStore pour les requÃªtes analytiques pures
- Indexes covering pour rÃ©duire les accÃ¨s aux donnÃ©es

### Cas 3 : SaaS Multi-tenant (64 GB RAM, 100 GB donnÃ©es, pics de trafic)

**Analyse** :
- Working set variable : 40-80 GB selon l'heure
- Pics de trafic : 9h-18h
- AccÃ¨s inÃ©gaux entre tenants (20/80)

**Configuration optimale** :

```ini
[mysqld]
# Buffer Pool : 80% de la RAM (serveur dÃ©diÃ©)
innodb_buffer_pool_size = 51G
innodb_buffer_pool_instances = 12

# Ã‰quilibre OLTP/scans
innodb_old_blocks_time = 1000
innodb_buffer_pool_dump_pct = 30

# Redimensionnement dynamique pendant les creux
# (via scripts automatisÃ©s)
```

Script de redimensionnement automatique :

```bash
#!/bin/bash
# resize_buffer_pool.sh
HOUR=$(date +%H)

if [ $HOUR -ge 19 ] || [ $HOUR -le 6 ]; then
    # Heures creuses : rÃ©duire le Buffer Pool
    mysql -e "SET GLOBAL innodb_buffer_pool_size = 34359738368"  # 32G
else
    # Heures de pointe : maximiser le Buffer Pool
    mysql -e "SET GLOBAL innodb_buffer_pool_size = 54760833024"  # 51G
fi
```

---

## Diagnostic de problÃ¨mes courants

### SymptÃ´me 1 : Hit ratio < 90%

**Causes possibles** :
1. Buffer Pool trop petit
2. Working set en croissance
3. Full table scans frÃ©quents

**Diagnostic** :

```sql
-- Identifier les tables les plus lues depuis le disque
SELECT 
    t.table_schema,
    t.table_name,
    t.engine,
    ROUND((t.data_length + t.index_length) / 1024 / 1024, 2) AS size_mb,
    s.rows_read,
    s.rows_changed
FROM information_schema.TABLES t
LEFT JOIN sys.schema_table_statistics s 
    ON t.table_schema = s.table_schema 
    AND t.table_name = s.table_name
WHERE t.engine = 'InnoDB'
    AND s.rows_read > 1000000
ORDER BY s.rows_read DESC
LIMIT 20;
```

**Solutions** :
- Augmenter `innodb_buffer_pool_size`
- Optimiser les requÃªtes avec EXPLAIN
- CrÃ©er des index appropriÃ©s
- Partitionner les grandes tables

### SymptÃ´me 2 : Pages dirty > 10% du Buffer Pool

**Causes possibles** :
1. Flush trop lent (I/O insuffisants)
2. Charge d'Ã©criture trop importante
3. `innodb_max_dirty_pages_pct` trop Ã©levÃ©

**Diagnostic** :

```sql
SELECT 
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty') AS dirty_pages,
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total') AS total_pages,
    ROUND(100 * 
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty') /
        (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total'), 2
    ) AS dirty_pct,
    @@innodb_max_dirty_pages_pct AS max_dirty_pct_setting;
```

**Solutions** :

```ini
[mysqld]
# RÃ©duire le seuil de dirty pages
innodb_max_dirty_pages_pct = 75  # Au lieu de 90 par dÃ©faut

# Augmenter la capacitÃ© de flush (voir section 15.4)
innodb_io_capacity = 2000
innodb_io_capacity_max = 4000
```

### SymptÃ´me 3 : Warm-up trÃ¨s lent aprÃ¨s redÃ©marrage

**Causes possibles** :
1. `innodb_buffer_pool_dump_pct` trop faible
2. Fichier ib_buffer_pool absent ou corrompu
3. I/O disque lents

**Diagnostic** :

```bash
# VÃ©rifier la prÃ©sence et la taille du dump
ls -lh /var/lib/mysql/ib_buffer_pool

# Logs du chargement
grep "ib_buffer_pool" /var/log/mysql/error.log
```

**Solutions** :

```ini
[mysqld]
# Augmenter le pourcentage de dump
innodb_buffer_pool_dump_pct = 50  # 50% au lieu de 25%

# Assurer le chargement au dÃ©marrage
innodb_buffer_pool_load_at_startup = ON
```

---

## IntÃ©gration avec le monitoring systÃ¨me

### Alerting Prometheus/Grafana

MÃ©triques Ã  monitorer via `mysqld_exporter` :

```yaml
# prometheus_alerts.yml
groups:
  - name: mariadb_buffer_pool
    rules:
      - alert: BufferPoolHitRatioLow
        expr: |
          100 * (1 - (
            rate(mysql_global_status_innodb_buffer_pool_reads[5m]) /
            rate(mysql_global_status_innodb_buffer_pool_read_requests[5m])
          )) < 95
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "Buffer Pool hit ratio below 95%"
          description: "Hit ratio is {{ $value }}% on {{ $labels.instance }}"
      
      - alert: BufferPoolUtilizationHigh
        expr: |
          100 * (
            mysql_global_status_innodb_buffer_pool_pages_data /
            mysql_global_status_innodb_buffer_pool_pages_total
          ) > 95
        for: 30m
        labels:
          severity: warning
        annotations:
          summary: "Buffer Pool utilization above 95%"
          description: "Consider increasing innodb_buffer_pool_size"
```

### Dashboard Grafana

RequÃªtes PromQL utiles :

```promql
# Hit ratio
100 * (1 - (
  rate(mysql_global_status_innodb_buffer_pool_reads[5m]) /
  rate(mysql_global_status_innodb_buffer_pool_read_requests[5m])
))

# Utilization
100 * (
  mysql_global_status_innodb_buffer_pool_pages_data /
  mysql_global_status_innodb_buffer_pool_pages_total
)

# Dirty pages percentage
100 * (
  mysql_global_status_innodb_buffer_pool_pages_dirty /
  mysql_global_status_innodb_buffer_pool_pages_total
)
```

---

## âœ… Points clÃ©s Ã  retenir

- **Le Buffer Pool est le paramÃ¨tre le plus critique** pour les performances InnoDB. Un dimensionnement inadÃ©quat peut dÃ©grader les performances de 10x Ã  100x.

- **RÃ¨gle des 70-80%** : Sur un serveur dÃ©diÃ©, allouez 70-80% de la RAM au Buffer Pool. Ajustez selon les autres services hÃ©bergÃ©s.

- **Hit ratio > 99%** : Visez un hit ratio supÃ©rieur Ã  99% pour des performances optimales. Un hit ratio < 95% indique un problÃ¨me.

- **Buffer Pool Instances** : Divisez le Buffer Pool en instances (1 par 4-8 GB) pour amÃ©liorer la concurrence sur les serveurs multi-cÅ“urs.

- **Redimensionnement dynamique** : MariaDB 11.8 permet de modifier `innodb_buffer_pool_size` sans redÃ©marrage, mais planifiez l'opÃ©ration en heures creuses.

- **PrÃ©chargement au dÃ©marrage** : Activez `innodb_buffer_pool_dump_at_shutdown` et `innodb_buffer_pool_load_at_startup` pour rÃ©duire drastiquement le temps de warm-up.

- **Monitoring continu** : Surveillez le hit ratio, le taux d'utilisation et le pourcentage de dirty pages. Alertez si ces mÃ©triques dÃ©gradent.

- **Protection contre les scans** : Ajustez `innodb_old_blocks_time` selon votre workload pour protÃ©ger les donnÃ©es chaudes des full table scans.

---

## ğŸ”— Ressources et rÃ©fÃ©rences

### Documentation officielle MariaDB
- [ğŸ“– InnoDB Buffer Pool](https://mariadb.com/kb/en/innodb-buffer-pool/)
- [ğŸ“– InnoDB System Variables](https://mariadb.com/kb/en/innodb-system-variables/)
- [ğŸ“– InnoDB Status Variables](https://mariadb.com/kb/en/innodb-status-variables/)

### Articles et guides avancÃ©s
- [Percona Blog - InnoDB Buffer Pool in Depth](https://www.percona.com/blog/)
- [MySQL High Performance (Baron Schwartz) - Chapter 8: Optimizing Server Settings](https://www.oreilly.com/library/view/high-performance-mysql/9781492080503/)
- [MariaDB Server Documentation - Buffer Pool Configuration](https://mariadb.com/kb/en/configuring-innodb/)

### Outils de monitoring
- [mysqld_exporter for Prometheus](https://github.com/prometheus/mysqld_exporter)
- [PMM (Percona Monitoring and Management)](https://www.percona.com/software/database-tools/percona-monitoring-and-management)

---

## â¡ï¸ Section suivante

**15.2.2 Buffer Pool instances** : Nous approfondirons la configuration multi-instances, les stratÃ©gies d'allocation mÃ©moire par instance, et l'optimisation pour les architectures NUMA.

â­ï¸ [Buffer Pool instances](/15-performance-tuning/02.2-buffer-pool-instances.md)
