üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.9.4 Partition Pruning

> **Niveau** : Expert  
> **Dur√©e estim√©e** : 2-3 heures  
> **Pr√©requis** : Sections 15.9.1-15.9.3 (RANGE, LIST, HASH), Compr√©hension de l'optimiseur SQL

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre le m√©canisme du partition pruning (√©lagage de partitions)
- Identifier quand le pruning est actif ou absent
- √âcrire des requ√™tes optimis√©es pour exploiter le pruning
- Utiliser EXPLAIN PARTITIONS pour v√©rifier le pruning
- Diagnostiquer les probl√®mes de performance li√©s au pruning
- Optimiser l'optimiseur pour un meilleur pruning
- √âviter les anti-patterns qui cassent le pruning
- Mesurer l'impact du pruning sur les performances

---

## Introduction

Le **partition pruning** (√©lagage de partitions) est l'optimisation la plus importante du partitionnement. Il permet √† MariaDB d'**√©liminer automatiquement** les partitions non pertinentes lors de l'ex√©cution d'une requ√™te, r√©duisant drastiquement les I/O et am√©liorant les performances.

### Le probl√®me sans partition pruning

```
Table partitionn√©e : orders (12 partitions mensuelles, 100M lignes)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Jan 24 ‚îÇ Feb 24 ‚îÇ Mar 24 ‚îÇ   ...   ‚îÇ Dec 25 ‚îÇ
‚îÇ 8.3M   ‚îÇ 8.3M   ‚îÇ 8.3M   ‚îÇ         ‚îÇ 8.3M   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Requ√™te SANS pruning:
SELECT * FROM orders WHERE customer_id = 12345;
       ‚Üì
Scan: TOUTES les 12 partitions (100M lignes)
I/O: 100M lignes examin√©es
Temps: 45 secondes ‚ùå
```

### La solution avec partition pruning

```
Requ√™te AVEC pruning:
SELECT * FROM orders 
WHERE order_date >= '2025-11-01' 
  AND order_date < '2025-12-01';
       ‚Üì
Pruning: Seule partition Nov 2025 (8.3M lignes)
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Nov 25 ‚îÇ  ‚Üê Partition unique acc√©d√©e
‚îÇ 8.3M   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì
I/O: 8.3M lignes examin√©es (92% de r√©duction)
Temps: 3.2 secondes (14x plus rapide) ‚úì
```

**Impact typique du pruning** :
- ‚úÖ **R√©duction I/O** : 50-99% selon granularit√©
- ‚úÖ **Gain performance** : 5-100x selon cas
- ‚úÖ **Moins de RAM** : Buffer Pool plus efficace
- ‚úÖ **Moins de CPU** : Moins de lignes √† filtrer

---

## M√©canisme du partition pruning

### Phase d'analyse de l'optimiseur

```
√âtapes de l'optimiseur MariaDB:

1. Parse SQL
   ‚Üì
2. Analyse WHERE clause
   ‚Üì
3. Identification colonnes de partitionnement
   ‚Üì
4. Calcul des partitions pertinentes
   ‚îÇ
   ‚îú‚îÄ RANGE: Comparaison plages
   ‚îú‚îÄ LIST: Recherche valeurs
   ‚îî‚îÄ HASH: Calcul hash MOD N
   ‚Üì
5. √âlimination des partitions non pertinentes
   ‚Üì
6. G√©n√©ration plan d'ex√©cution optimis√©
   ‚Üì
7. Ex√©cution sur partitions retenues uniquement
```

### Algorithmes de pruning par type

**RANGE Partitioning** :

```sql
-- Partition d√©finition
PARTITION BY RANGE (YEAR(order_date) * 100 + MONTH(order_date)) (
    PARTITION p2025_01 VALUES LESS THAN (202502),
    PARTITION p2025_02 VALUES LESS THAN (202503),
    PARTITION p2025_03 VALUES LESS THAN (202504)
);

-- Requ√™te
WHERE order_date = '2025-02-15'
       ‚Üì
-- Calcul: YEAR(2025-02-15) * 100 + MONTH(2025-02-15) = 202502
-- Comparaison:
--   202502 >= 202502 (limite p2025_01) ‚Üí Non
--   202502 >= 202503 (limite p2025_02) ‚Üí Oui ‚Üí p2025_02 !
--   202502 >= 202504 (limite p2025_03) ‚Üí Non
       ‚Üì
-- Pruning: Partition p2025_02 uniquement
```

**LIST Partitioning** :

```sql
-- Partition d√©finition
PARTITION BY LIST (country) (
    PARTITION p_france VALUES IN ('FR'),
    PARTITION p_germany VALUES IN ('DE'),
    PARTITION p_uk VALUES IN ('GB')
);

-- Requ√™te
WHERE country = 'FR'
       ‚Üì
-- Recherche directe: 'FR' dans VALUES IN de quelle partition ?
-- 'FR' dans p_france ‚Üí Oui !
       ‚Üì
-- Pruning: Partition p_france uniquement
```

**HASH Partitioning** :

```sql
-- Partition d√©finition
PARTITION BY HASH(user_id) PARTITIONS 8;

-- Requ√™te
WHERE user_id = 12345
       ‚Üì
-- Calcul: HASH(12345) MOD 8 = 5
       ‚Üì
-- Pruning: Partition p5 uniquement
```

---

## Conditions pour le partition pruning

### R√®gle fondamentale

üí° **Le WHERE doit filtrer sur la colonne de partitionnement (ou expression √©quivalente)**

```sql
-- ‚úÖ Pruning ACTIF
SELECT * FROM orders WHERE order_date = '2025-11-15';
-- Filtre sur order_date (colonne de partitionnement)

-- ‚ùå Pruning INACTIF
SELECT * FROM orders WHERE customer_id = 12345;
-- Aucun filtre sur order_date ‚Üí Toutes partitions scann√©es
```

### Conditions par type de partitionnement

**RANGE Pruning** :

```sql
-- ‚úÖ √âgalit√©
WHERE order_date = '2025-11-15'

-- ‚úÖ Plage
WHERE order_date BETWEEN '2025-11-01' AND '2025-11-30'

-- ‚úÖ Comparaisons
WHERE order_date >= '2025-11-01'
WHERE order_date < '2025-12-01'

-- ‚úÖ Combinaisons
WHERE order_date >= '2025-10-01' AND order_date <= '2025-12-31'

-- ‚úÖ IN avec valeurs
WHERE order_date IN ('2025-11-01', '2025-11-15', '2025-11-30')
```

**LIST Pruning** :

```sql
-- ‚úÖ √âgalit√©
WHERE country = 'FR'

-- ‚úÖ IN avec valeurs de m√™me partition
WHERE country IN ('FR')

-- ‚úÖ IN avec valeurs de plusieurs partitions
WHERE country IN ('FR', 'DE', 'GB')
-- Pruning: 3 partitions (p_france, p_germany, p_uk)

-- ‚ùå NOT IN (pruning impossible)
WHERE country NOT IN ('FR')
-- Doit scanner toutes partitions sauf p_france
```

**HASH Pruning** :

```sql
-- ‚úÖ √âgalit√© stricte
WHERE user_id = 12345

-- ‚úÖ IN avec liste
WHERE user_id IN (100, 200, 300)
-- Calcule HASH pour chaque valeur

-- ‚ùå Plage (pruning impossible)
WHERE user_id BETWEEN 1000 AND 2000
-- Doit scanner toutes partitions
```

---

## Utilisation d'EXPLAIN PARTITIONS

### Syntaxe de base

```sql
EXPLAIN PARTITIONS
SELECT * FROM orders 
WHERE order_date = '2025-11-15';

+----+-------------+--------+------------+------+---------------+
| id | select_type | table  | partitions | type | possible_keys |
+----+-------------+--------+------------+------+---------------+
|  1 | SIMPLE      | orders | p2025_11   | ref  | idx_date      |
+----+-------------+--------+------------+------+---------------+
                      ‚Üë
                 1 partition = Pruning OK ‚úì
```

### Interpr√©tation de la colonne "partitions"

| Valeur | Signification | Performance |
|--------|---------------|-------------|
| `p2025_11` | 1 partition acc√©d√©e | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent |
| `p2025_11,p2025_12` | 2 partitions | ‚≠ê‚≠ê‚≠ê‚≠ê Tr√®s bon |
| `p2025_10,...,p2025_12` | Plusieurs partitions | ‚≠ê‚≠ê‚≠ê Acceptable |
| `p2025_01,...,p2025_12` | Toutes partitions | ‚≠ê Mauvais (pas de pruning) |

### Exemples d√©taill√©s

**Exemple 1 : Pruning optimal (RANGE)** :

```sql
-- Table: 12 partitions mensuelles (Jan-Dec 2025)
EXPLAIN PARTITIONS
SELECT COUNT(*) FROM orders 
WHERE order_date BETWEEN '2025-11-01' AND '2025-11-30';

+----+-------------+--------+------------+-------+
| id | select_type | table  | partitions | rows  |
+----+-------------+--------+------------+-------+
|  1 | SIMPLE      | orders | p2025_11   | 8.3M  |  ‚Üê 1 partition
+----+-------------+--------+------------+-------+

Analyse:
- Pruning: ‚úì Actif (1 seule partition)
- Rows: 8.3M (au lieu de 100M)
- Gain: 92% de r√©duction
```

**Exemple 2 : Pruning partiel (RANGE)** :

```sql
EXPLAIN PARTITIONS
SELECT * FROM orders 
WHERE order_date >= '2025-10-01';

+----+-------------+--------+-------------------------+-------+
| id | select_type | table  | partitions              | rows  |
+----+-------------+--------+-------------------------+-------+
|  1 | SIMPLE      | orders | p2025_10,p2025_11,p2025_12 | 25M |  ‚Üê 3 partitions
+----+-------------+--------+-------------------------+-------+

Analyse:
- Pruning: ‚úì Partiel (3 partitions au lieu de 12)
- Rows: 25M (au lieu de 100M)
- Gain: 75% de r√©duction
```

**Exemple 3 : Absence de pruning** :

```sql
EXPLAIN PARTITIONS
SELECT * FROM orders 
WHERE customer_id = 12345;

+----+-------------+--------+-------------------------------+-------+
| id | select_type | table  | partitions                    | rows  |
+----+-------------+--------+-------------------------------+-------+
|  1 | SIMPLE      | orders | p2025_01,p2025_02,...,p2025_12| 100M  |  ‚Üê TOUTES
+----+-------------+--------+-------------------------------+-------+

Analyse:
- Pruning: ‚ùå Absent (12 partitions = toutes)
- Rows: 100M
- Gain: 0% (aucune r√©duction)
- Probl√®me: Pas de filtre sur order_date
```

**Exemple 4 : Pruning LIST** :

```sql
-- Table partitionn√©e par pays
EXPLAIN PARTITIONS
SELECT * FROM users WHERE country IN ('FR', 'DE');

+----+-------------+-------+--------------------+-------+
| id | select_type | table | partitions         | rows  |
+----+-------------+-------+--------------------+-------+
|  1 | SIMPLE      | users | p_france,p_germany | 27M   |  ‚Üê 2 partitions
+----+-------------+-------+--------------------+-------+

Analyse:
- Pruning: ‚úì Actif (2 partitions sur 6 total)
- Gain: 67% de r√©duction
```

**Exemple 5 : Pruning HASH limit√©** :

```sql
-- Table HASH sur user_id
EXPLAIN PARTITIONS
SELECT * FROM sessions WHERE user_id = 12345;

+----+-------------+----------+------------+-------+
| id | select_type | table    | partitions | rows  |
+----+-------------+----------+------------+-------+
|  1 | SIMPLE      | sessions | p5         | 1.2M  |  ‚Üê 1 partition
+----+-------------+----------+------------+-------+

Analyse:
- Pruning: ‚úì Actif (HASH(12345) MOD 8 = 5)
- 1 partition acc√©d√©e sur 8

-- MAIS requ√™te avec plage:
EXPLAIN PARTITIONS
SELECT * FROM sessions WHERE user_id BETWEEN 1000 AND 2000;

+----+-------------+----------+------------------------+-------+
| id | select_type | table    | partitions             | rows  |
+----+-------------+----------+------------------------+-------+
|  1 | SIMPLE      | sessions | p0,p1,p2,p3,p4,p5,p6,p7| 10M   |  ‚Üê TOUTES
+----+-------------+----------+------------------------+-------+

Analyse:
- Pruning: ‚ùå Absent (plage incompatible avec HASH)
```

---

## Anti-patterns qui cassent le pruning

### 1. Fonction sur colonne de partitionnement

```sql
-- ‚ùå MAUVAIS - Fonction emp√™che pruning
SELECT * FROM orders 
WHERE YEAR(order_date) = 2025;

EXPLAIN PARTITIONS:
partitions: p2025_01,p2025_02,...,p2025_12  ‚Üê Toutes partitions

-- ‚úÖ BON - R√©√©crite sans fonction
SELECT * FROM orders 
WHERE order_date >= '2025-01-01' 
  AND order_date < '2026-01-01';

EXPLAIN PARTITIONS:
partitions: p2025_01,p2025_02,...,p2025_12  ‚Üê Toutes partitions (mais prunable si RANGE par mois)
```

**Pourquoi ?** L'optimiseur ne peut pas calculer √† l'avance quelles partitions satisfont `YEAR(order_date) = 2025`.

### 2. Colonne transform√©e dans WHERE

```sql
-- ‚ùå MAUVAIS
SELECT * FROM users 
WHERE UPPER(country) = 'FR';

-- ‚úÖ BON
SELECT * FROM users 
WHERE country = 'FR';

-- ‚ùå MAUVAIS
SELECT * FROM orders 
WHERE DATE_FORMAT(order_date, '%Y-%m') = '2025-11';

-- ‚úÖ BON
SELECT * FROM orders 
WHERE order_date >= '2025-11-01' 
  AND order_date < '2025-12-01';
```

### 3. OR avec colonnes non-partitionn√©es

```sql
-- ‚ùå MAUVAIS - OR casse le pruning
SELECT * FROM orders 
WHERE order_date = '2025-11-15' 
   OR customer_id = 12345;

EXPLAIN PARTITIONS:
partitions: p2025_01,...,p2025_12  ‚Üê Toutes partitions

-- ‚úÖ BON - R√©√©crire avec UNION
SELECT * FROM orders WHERE order_date = '2025-11-15'
UNION
SELECT * FROM orders WHERE customer_id = 12345 AND order_date >= '2025-01-01';
-- Premi√®re partie: pruning sur p2025_11
-- Deuxi√®me partie: pruning sur toutes partitions 2025
```

### 4. IS NULL sur colonne de partitionnement

```sql
-- ‚ö†Ô∏è Comportement sp√©cial
SELECT * FROM orders WHERE order_date IS NULL;

-- RANGE: NULL va dans premi√®re partition
-- LIST: NULL doit √™tre explicitement list√©
-- HASH: Comportement impr√©visible

-- Mieux: √âviter NULL dans colonne de partitionnement
-- Utiliser NOT NULL + valeur par d√©faut
```

### 5. Sous-requ√™tes complexes

```sql
-- ‚ùå MAUVAIS - Sous-requ√™te emp√™che pruning
SELECT * FROM orders 
WHERE order_date = (
    SELECT MAX(order_date) FROM orders WHERE customer_id = 12345
);

-- ‚úÖ BON - Mat√©rialiser la sous-requ√™te
SET @max_date = (SELECT MAX(order_date) FROM orders WHERE customer_id = 12345);
SELECT * FROM orders WHERE order_date = @max_date;
```

---

## Optimisation des requ√™tes pour le pruning

### Pattern 1 : Ajouter filtre sur colonne de partitionnement

```sql
-- ‚ùå Original (pas de pruning)
SELECT * FROM orders WHERE customer_id = 12345;
-- Scan: Toutes partitions

-- ‚úÖ Optimis√© (avec contexte applicatif)
SELECT * FROM orders 
WHERE customer_id = 12345 
  AND order_date >= DATE_SUB(NOW(), INTERVAL 6 MONTH);
-- Scan: Seulement 6 derni√®res partitions
-- Gain: 50% (si 12 partitions mensuelles)
```

**Justification** : Si l'application cherche g√©n√©ralement des commandes r√©centes, ajouter un filtre temporel am√©liore le pruning.

### Pattern 2 : Utiliser index composite

```sql
-- Table partitionn√©e par order_date
CREATE INDEX idx_customer_date ON orders(customer_id, order_date);

-- Requ√™te avec les deux colonnes
SELECT * FROM orders 
WHERE customer_id = 12345 
  AND order_date >= '2025-11-01';

-- B√©n√©fices:
-- 1. Pruning: Partition Nov 2025 uniquement
-- 2. Index: Recherche efficace sur customer_id
-- 3. Covering index possible si colonnes SELECT dans index
```

### Pattern 3 : D√©composer requ√™tes complexes

```sql
-- ‚ùå Complexe (pruning difficile)
SELECT o.order_id, o.total, c.customer_name
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE c.country = 'FR' 
  AND o.status = 'delivered';
-- orders pas prunable (pas de filtre sur order_date)

-- ‚úÖ D√©compos√©
-- √âtape 1: Identifier date range
SET @min_date = DATE_SUB(NOW(), INTERVAL 3 MONTH);

-- √âtape 2: Requ√™te avec pruning
SELECT o.order_id, o.total, c.customer_name
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE c.country = 'FR' 
  AND o.status = 'delivered'
  AND o.order_date >= @min_date;  -- Ajoute pruning
```

### Pattern 4 : Requ√™tes par partition (batch processing)

```sql
-- Traitement batch : Parcourir partition par partition
-- Au lieu de:
UPDATE orders SET processed = 1 WHERE status = 'pending';

-- Utiliser:
DECLARE @partition VARCHAR(20);
DECLARE partition_cursor CURSOR FOR 
    SELECT PARTITION_NAME 
    FROM INFORMATION_SCHEMA.PARTITIONS
    WHERE TABLE_NAME = 'orders';

OPEN partition_cursor;
FETCH NEXT FROM partition_cursor INTO @partition;

WHILE @@FETCH_STATUS = 0
BEGIN
    SET @sql = 'UPDATE orders PARTITION (' + @partition + ') 
                SET processed = 1 WHERE status = ''pending''';
    EXEC sp_executesql @sql;
    
    FETCH NEXT FROM partition_cursor INTO @partition;
END;

CLOSE partition_cursor;
DEALLOCATE partition_cursor;
```

**Avantages** :
- Contr√¥le granulaire
- Moins de locks (partition par partition)
- Monitoring pr√©cis

---

## Mesure de l'impact du pruning

### M√©thode 1 : EXPLAIN PARTITIONS

```sql
-- Requ√™te sans pruning
EXPLAIN PARTITIONS
SELECT COUNT(*) FROM orders WHERE customer_id = 12345;
-- partitions: p2025_01,...,p2025_12 (12 partitions)
-- rows: 100,000,000

-- Requ√™te avec pruning
EXPLAIN PARTITIONS
SELECT COUNT(*) FROM orders 
WHERE customer_id = 12345 
  AND order_date >= '2025-11-01';
-- partitions: p2025_11,p2025_12 (2 partitions)
-- rows: 16,666,666

-- Calcul gain:
-- R√©duction partitions: 83% (2 vs 12)
-- R√©duction rows: 83% (16.6M vs 100M)
```

### M√©thode 2 : Handler statistics

```sql
-- Reset compteurs
FLUSH STATUS;

-- Ex√©cuter requ√™te
SELECT COUNT(*) FROM orders 
WHERE order_date = '2025-11-15';

-- V√©rifier statistiques
SHOW SESSION STATUS LIKE 'Handler%';

+----------------------------+----------+
| Variable_name              | Value    |
+----------------------------+----------+
| Handler_read_first         | 1        |
| Handler_read_key           | 8345678  |
| Handler_read_next          | 8345678  |
| Handler_read_rnd           | 0        |
| Handler_read_rnd_next      | 0        |
+----------------------------+----------+

-- Comparer avec requ√™te sans pruning:
-- Handler_read_next serait 10x plus √©lev√©
```

### M√©thode 3 : Profiling

```sql
-- Activer profiling
SET profiling = 1;

-- Requ√™te sans pruning
SELECT COUNT(*) FROM orders WHERE customer_id = 12345;

-- Requ√™te avec pruning
SELECT COUNT(*) FROM orders 
WHERE customer_id = 12345 
  AND order_date >= '2025-11-01';

-- Comparer profils
SHOW PROFILES;

+----------+----------+---------------------------------------------+
| Query_ID | Duration | Query                                       |
+----------+----------+---------------------------------------------+
|        1 | 12.4567  | SELECT COUNT(*) ... customer_id = 12345     |
|        2 |  1.8923  | SELECT COUNT(*) ... AND order_date >= ...   |
+----------+----------+---------------------------------------------+

-- Gain: 6.6x plus rapide avec pruning

-- D√©tail du profil
SHOW PROFILE FOR QUERY 2;

+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| starting             | 0.000123 |
| checking permissions | 0.000012 |
| Opening tables       | 0.000234 |  ‚Üê Plus rapide (moins de partitions)
| init                 | 0.000045 |
| System lock          | 0.000023 |
| optimizing           | 0.000067 |
| statistics           | 0.000089 |  ‚Üê Plus rapide
| preparing            | 0.000034 |
| executing            | 0.000012 |
| Sending data         | 1.8912   |  ‚Üê Gain principal (moins de donn√©es)
| end                  | 0.000023 |
| query end            | 0.000012 |
| closing tables       | 0.000034 |
| freeing items        | 0.000023 |
| cleaning up          | 0.000012 |
+----------------------+----------+
```

### M√©thode 4 : Monitoring I/O

```bash
# Avant requ√™te
iostat -x 1

# Pendant requ√™te sans pruning
Device   r/s   w/s   rkB/s   wkB/s  %util
sda     4567   123  456789   12345   98.5  ‚Üê Tr√®s √©lev√©

# Pendant requ√™te avec pruning
Device   r/s   w/s   rkB/s   wkB/s  %util
sda      567    45   56789    4567   15.2  ‚Üê 6x moins d'I/O
```

---

## Cas d'usage avanc√©s

### Cas 1 : Pruning avec JOIN

```sql
-- Table orders partitionn√©e par order_date
-- Table customers non-partitionn√©e

-- ‚ùå Pruning impossible (join complex)
SELECT o.*, c.customer_name
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE c.country = 'FR';
-- orders: Toutes partitions scann√©es

-- ‚úÖ Pruning possible (filtre explicite)
SELECT o.*, c.customer_name
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE c.country = 'FR'
  AND o.order_date >= '2025-11-01';  -- Ajoute pruning
-- orders: Partitions Nov-Dec seulement
```

### Cas 2 : Pruning avec subquery

```sql
-- ‚ùå Subquery emp√™che pruning
SELECT * FROM orders
WHERE customer_id IN (
    SELECT customer_id FROM customers WHERE country = 'FR'
)
-- AND order_date >= '2025-11-01';  -- Manquant !

-- ‚úÖ Ajouter filtre temporel
SELECT * FROM orders
WHERE customer_id IN (
    SELECT customer_id FROM customers WHERE country = 'FR'
)
AND order_date >= '2025-11-01';  -- Pruning actif
```

### Cas 3 : Pruning dynamique

```sql
-- Fonction pour calculer plage de dates dynamique
DELIMITER $$

CREATE FUNCTION get_date_range(period VARCHAR(20))
RETURNS DATE
DETERMINISTIC
BEGIN
    CASE period
        WHEN 'last_month' THEN
            RETURN DATE_SUB(CURDATE(), INTERVAL 1 MONTH);
        WHEN 'last_quarter' THEN
            RETURN DATE_SUB(CURDATE(), INTERVAL 3 MONTH);
        WHEN 'last_year' THEN
            RETURN DATE_SUB(CURDATE(), INTERVAL 1 YEAR);
    END CASE;
END$$

DELIMITER ;

-- Utilisation (pruning dynamique)
SELECT * FROM orders 
WHERE order_date >= get_date_range('last_quarter');
-- Pruning: 3 derni√®res partitions mensuelles
```

### Cas 4 : Pruning avec UNION

```sql
-- Requ√™te complexe n√©cessitant plusieurs plages
-- Optimiser avec UNION pour pruning sp√©cifique

SELECT * FROM orders 
WHERE order_date BETWEEN '2025-01-01' AND '2025-01-31'  -- Jan
UNION ALL
SELECT * FROM orders 
WHERE order_date BETWEEN '2025-06-01' AND '2025-06-30'  -- Jun
UNION ALL
SELECT * FROM orders 
WHERE order_date BETWEEN '2025-12-01' AND '2025-12-31'; -- Dec

-- Pruning: Seulement partitions Jan, Jun, Dec
-- vs WHERE order_date IN (...) qui scannerait toutes
```

---

## Configuration et tuning de l'optimiseur

### Variables affectant le pruning

```sql
-- V√©rifier param√®tres optimiseur
SHOW VARIABLES LIKE 'optimizer%';

+----------------------------------+---------+
| Variable_name                    | Value   |
+----------------------------------+---------+
| optimizer_prune_level            | 1       |  ‚Üê Active pruning
| optimizer_search_depth           | 62      |
| optimizer_switch                 | ...     |
+----------------------------------+---------+

-- optimizer_prune_level:
-- 0 = D√©sactiver pruning (debug uniquement)
-- 1 = Activer pruning (d√©faut, recommand√©)
```

### Hints pour forcer/√©viter pruning

```sql
-- Forcer scan d'une partition sp√©cifique
SELECT * FROM orders PARTITION (p2025_11)
WHERE customer_id = 12345;
-- Bypass pruning automatique, acc√®s direct p2025_11

-- Scanner plusieurs partitions explicitement
SELECT * FROM orders PARTITION (p2025_11, p2025_12)
WHERE customer_id = 12345;

-- Forcer scan de toutes partitions (debug)
SELECT * FROM orders IGNORE INDEX (idx_date)
WHERE order_date = '2025-11-15';
-- Ignore index, force scan complet
```

---

## Debugging et troubleshooting

### Probl√®me 1 : Pruning attendu mais absent

**Sympt√¥mes** :
```sql
EXPLAIN PARTITIONS
SELECT * FROM orders WHERE order_date = '2025-11-15';

partitions: p2025_01,p2025_02,...,p2025_12  ‚Üê Toutes partitions !
```

**Diagnostic** :

```sql
-- V√©rifier type de colonne
SHOW CREATE TABLE orders\G

-- Si order_date est VARCHAR au lieu de DATE:
order_date VARCHAR(10)  ‚Üê Probl√®me !

-- Requ√™te fait comparaison string vs date
-- Conversion implicite emp√™che pruning

-- Solution: Convertir colonne en DATE
ALTER TABLE orders MODIFY order_date DATE NOT NULL;
```

### Probl√®me 2 : Pruning partiel inattendu

**Sympt√¥mes** :
```sql
EXPLAIN PARTITIONS
SELECT * FROM orders 
WHERE order_date BETWEEN '2025-11-01' AND '2025-11-30';

partitions: p2025_10,p2025_11,p2025_12  ‚Üê 3 au lieu de 1 ?
```

**Cause** : Expression de partitionnement diff√©rente de la comparaison :

```sql
-- Partition expression
PARTITION BY RANGE (TO_DAYS(order_date)) (...)

-- Requ√™te compare DATE
WHERE order_date BETWEEN '2025-11-01' AND '2025-11-30'

-- Optimiseur ne peut pas mapper pr√©cis√©ment
-- ‚Üí Pruning conservateur (inclut partitions adjacentes)
```

**Solution** : Utiliser m√™me expression :

```sql
WHERE TO_DAYS(order_date) BETWEEN TO_DAYS('2025-11-01') AND TO_DAYS('2025-11-30')
-- OU mieux, r√©organiser partitioning:
PARTITION BY RANGE (YEAR(order_date) * 100 + MONTH(order_date))
```

### Probl√®me 3 : Performance d√©grad√©e malgr√© pruning

**Sympt√¥mes** :
```sql
-- Pruning actif
EXPLAIN PARTITIONS: partitions: p2025_11  ‚úì

-- Mais requ√™te lente
Query time: 15 seconds
```

**Diagnostics possibles** :

1. **Index manquant** :
```sql
-- Pruning OK mais pas d'index sur autres colonnes
EXPLAIN SELECT * FROM orders PARTITION (p2025_11)
WHERE customer_id = 12345;

type: ALL  ‚Üê Full scan de la partition !

-- Solution: Cr√©er index
CREATE INDEX idx_customer ON orders(customer_id);
```

2. **Partition trop volumineuse** :
```sql
-- V√©rifier taille partition
SELECT 
    PARTITION_NAME,
    TABLE_ROWS,
    ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) AS size_mb
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_NAME = 'orders';

p2025_11: 45M rows, 15GB  ‚Üê Trop gros !

-- Solution: Subdiviser (mensuel ‚Üí journalier)
```

---

## Monitoring du pruning en production

### Requ√™tes de monitoring

```sql
-- Vue pour tracker partitions acc√©d√©es
CREATE OR REPLACE VIEW v_partition_access AS
SELECT 
    p.TABLE_SCHEMA,
    p.TABLE_NAME,
    p.PARTITION_NAME,
    p.TABLE_ROWS,
    ROUND((p.DATA_LENGTH + p.INDEX_LENGTH) / 1024 / 1024, 2) AS size_mb,
    -- Estimation de l'acc√®s (via InnoDB stats)
    ROUND(p.TABLE_ROWS / NULLIF(
        (SELECT SUM(TABLE_ROWS) 
         FROM INFORMATION_SCHEMA.PARTITIONS p2
         WHERE p2.TABLE_SCHEMA = p.TABLE_SCHEMA 
           AND p2.TABLE_NAME = p.TABLE_NAME), 0
    ) * 100, 2) AS rows_pct
FROM INFORMATION_SCHEMA.PARTITIONS p
WHERE p.TABLE_SCHEMA NOT IN ('information_schema', 'performance_schema', 'mysql')
  AND p.PARTITION_NAME IS NOT NULL
ORDER BY p.TABLE_SCHEMA, p.TABLE_NAME, p.PARTITION_ORDINAL_POSITION;
```

### Alerting sur absence de pruning

```sql
-- Event pour d√©tecter requ√™tes sans pruning
-- (N√©cessite Performance Schema activ√©)

SELECT 
    DIGEST_TEXT,
    COUNT_STAR AS executions,
    ROUND(SUM_TIMER_WAIT / 1000000000000, 2) AS total_sec,
    ROUND(AVG_TIMER_WAIT / 1000000000000, 4) AS avg_sec,
    ROUND(SUM_ROWS_EXAMINED / COUNT_STAR, 0) AS avg_rows_examined
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE '%orders%'  -- Table partitionn√©e
  AND DIGEST_TEXT NOT LIKE '%order_date%'  -- Pas de filtre sur colonne partitionnement
  AND COUNT_STAR > 100  -- Ex√©cut√© fr√©quemment
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 20;

-- Identifier requ√™tes candidates pour optimisation pruning
```

---

## ‚úÖ Points cl√©s √† retenir

- **Partition pruning = optimisation critique** qui √©limine les partitions non pertinentes. Peut r√©duire I/O de 50-99% et acc√©l√©rer requ√™tes de 5-100x.

- **R√®gle fondamentale** : Le WHERE doit filtrer sur la colonne de partitionnement. Sans filtre, MariaDB scanne toutes les partitions.

- **EXPLAIN PARTITIONS** est l'outil essentiel pour v√©rifier le pruning. Colonne "partitions" montre quelles partitions sont acc√©d√©es. 1 partition = excellent, toutes = aucun pruning.

- **Pruning par type** : RANGE (plages, √©galit√©, IN), LIST (√©galit√©, IN), HASH (√©galit√© stricte uniquement, pas de plages).

- **Anti-patterns qui cassent le pruning** : Fonctions sur colonne (`YEAR(date)`), transformations (`UPPER(country)`), OR avec colonnes non-partitionn√©es, sous-requ√™tes complexes.

- **Optimisation** : Ajouter filtres temporels m√™me si non requis fonctionnellement, utiliser index composites, d√©composer requ√™tes complexes.

- **Mesure d'impact** : EXPLAIN PARTITIONS (r√©duction partitions), Handler statistics (I/O), Profiling (temps), iostat (disque).

- **Monitoring production** : Cr√©er vues sur INFORMATION_SCHEMA.PARTITIONS, utiliser Performance Schema pour identifier requ√™tes sans pruning fr√©quentes.

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB
- [üìñ Partition Pruning](https://mariadb.com/kb/en/partition-pruning-and-selection/)
- [üìñ EXPLAIN PARTITIONS](https://mariadb.com/kb/en/explain/#partitions-column)
- [üìñ Optimizer Hints](https://mariadb.com/kb/en/optimizer-hints/)

### Performance Schema
- [üìñ Performance Schema Overview](https://mariadb.com/kb/en/performance-schema-overview/)
- [üìñ Statement Analysis](https://mariadb.com/kb/en/performance-schema-statement-tables/)

### Articles techniques
- [Percona Blog - Partition Pruning Best Practices](https://www.percona.com/blog/)
- [MySQL Performance Blog - Understanding Partition Pruning](https://www.percona.com/blog/)

### Outils d'analyse
- [pt-query-digest](https://www.percona.com/doc/percona-toolkit/LATEST/pt-query-digest.html)
- [mysqldumpslow](https://dev.mysql.com/doc/refman/8.0/en/mysqldumpslow.html)

---

## ‚û°Ô∏è Section suivante

**15.8 Performance Schema et sys schema** : Nous explorerons le monitoring temps r√©el avec Performance Schema, l'instrumentation avanc√©e, les vues du sys schema, et l'analyse d√©taill√©e des requ√™tes et ressources en production.

‚è≠Ô∏è [Gestion avanc√©e des partitions (conversion partition‚Üîtable)](/15-performance-tuning/10-gestion-avancee-partitions.md)
