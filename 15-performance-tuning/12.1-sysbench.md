ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 15.12.1 sysbench

> **Niveau** : Expert  
> **DurÃ©e estimÃ©e** : 3-4 heures  
> **PrÃ©requis** : Chapitres 15.1-15.11, ComprÃ©hension des mÃ©triques de performance

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Installer et configurer sysbench pour des tests professionnels
- Concevoir et exÃ©cuter des benchmarks OLTP rÃ©alistes
- InterprÃ©ter les mÃ©triques de performance (TPS, latence, throughput)
- Comparer les performances avant/aprÃ¨s optimisation
- Dimensionner l'infrastructure selon les rÃ©sultats de benchmark
- Identifier les goulots d'Ã©tranglement (CPU, I/O, rÃ©seau)
- CrÃ©er des scÃ©narios de test personnalisÃ©s
- Automatiser les tests de rÃ©gression de performance
- Ã‰viter les piÃ¨ges classiques du benchmarking

---

## Introduction

**sysbench** est l'outil de benchmark de rÃ©fÃ©rence pour Ã©valuer les performances des bases de donnÃ©es MySQL et MariaDB. DÃ©veloppÃ© initialement par Alexey Kopytov (Percona), il permet de tester de maniÃ¨re fiable et reproductible les performances CPU, I/O, mÃ©moire et base de donnÃ©es.

### Pourquoi sysbench est essentiel

```
ProblÃ©matiques en production sans benchmark:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ "Le serveur est lent"                       â”‚
â”‚ "On ne sait pas si on peut gÃ©rer 2x de load"â”‚
â”‚ "L'optimisation a-t-elle amÃ©liorÃ© ?"        â”‚
â”‚ "Quel serveur choisir : A ou B ?"           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
    Questions sans rÃ©ponses quantitatives

Avec sysbench:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Serveur actuel : 15,000 TPS                 â”‚
â”‚ CapacitÃ© maximale : 28,000 TPS              â”‚
â”‚ Latence p95 : 25ms                          â”‚
â”‚ AprÃ¨s optimisation : +45% TPS (21,750)      â”‚
â”‚ Serveur A vs B : B = +30% performance       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“
    DÃ©cisions basÃ©es sur donnÃ©es mesurÃ©es
```

**Cas d'usage de sysbench** :
- âœ… **Benchmark initial** : Ã‰tablir baseline de performance
- âœ… **Validation optimisation** : Mesurer l'impact des changements
- âœ… **Dimensionnement** : DÃ©terminer besoins matÃ©riels
- âœ… **Tests de charge** : VÃ©rifier comportement sous stress
- âœ… **Comparaison matÃ©rielle** : Ã‰valuer diffÃ©rentes configurations
- âœ… **Tests de rÃ©gression** : DÃ©tecter dÃ©gradations de performance
- âœ… **Planification capacitÃ©** : Estimer croissance supportable

---

## Installation

### Installation depuis les sources (version rÃ©cente)

```bash
# DÃ©pendances
sudo apt-get update
sudo apt-get install -y \
    make \
    automake \
    libtool \
    pkg-config \
    libaio-dev \
    libmysqlclient-dev \
    libssl-dev

# TÃ©lÃ©charger sysbench (derniÃ¨re version)
cd /tmp
git clone https://github.com/akopytov/sysbench.git
cd sysbench

# Compiler et installer
./autogen.sh
./configure --with-mysql
make -j$(nproc)
sudo make install

# VÃ©rifier installation
sysbench --version
sysbench 1.0.20
```

### Installation via package manager

```bash
# Ubuntu/Debian
curl -s https://packagecloud.io/install/repositories/akopytov/sysbench/script.deb.sh | sudo bash
sudo apt-get install sysbench

# RHEL/CentOS
curl -s https://packagecloud.io/install/repositories/akopytov/sysbench/script.rpm.sh | sudo bash
sudo yum install sysbench

# VÃ©rification
sysbench --version
which sysbench
```

### Configuration de l'environnement

```bash
# CrÃ©er base de donnÃ©es de test
mysql -u root -p << 'EOF'
CREATE DATABASE sbtest;
CREATE USER 'sbtest'@'localhost' IDENTIFIED BY 'sbtest_password';
GRANT ALL PRIVILEGES ON sbtest.* TO 'sbtest'@'localhost';
FLUSH PRIVILEGES;
EOF

# Variables d'environnement (optionnel)
export MYSQL_HOST=localhost
export MYSQL_USER=sbtest
export MYSQL_PASSWORD=sbtest_password
export MYSQL_DB=sbtest
```

---

## Tests de base de donnÃ©es OLTP

### PrÃ©paration des donnÃ©es

```bash
# PrÃ©parer 10 tables de 100,000 lignes chacune
sysbench /usr/share/sysbench/oltp_read_write.lua \
    --mysql-host=localhost \
    --mysql-port=3306 \
    --mysql-user=sbtest \
    --mysql-password=sbtest_password \
    --mysql-db=sbtest \
    --tables=10 \
    --table-size=100000 \
    prepare

# Progression:
# Creating table 'sbtest1'...
# Inserting 100000 records into 'sbtest1'
# Creating a secondary index on 'sbtest1'...
# Creating table 'sbtest2'...
# ...
```

**Structure des tables crÃ©Ã©es** :

```sql
-- Structure table sbtest (gÃ©nÃ©rique)
CREATE TABLE sbtest1 (
    id INT NOT NULL AUTO_INCREMENT,
    k INT NOT NULL DEFAULT 0,
    c CHAR(120) NOT NULL DEFAULT '',
    pad CHAR(60) NOT NULL DEFAULT '',
    PRIMARY KEY (id),
    KEY k_1 (k)
) ENGINE=InnoDB;

-- Taille approximative:
-- 10 tables Ã— 100K rows Ã— ~200 bytes = ~200 MB
-- Ajuster table-size et tables selon capacitÃ© serveur
```

### Test OLTP Read-Write (mixte)

```bash
# Test read-write (le plus rÃ©aliste)
sysbench /usr/share/sysbench/oltp_read_write.lua \
    --mysql-host=localhost \
    --mysql-user=sbtest \
    --mysql-password=sbtest_password \
    --mysql-db=sbtest \
    --tables=10 \
    --table-size=100000 \
    --threads=16 \
    --time=300 \
    --report-interval=10 \
    run

# ParamÃ¨tres clÃ©s:
# --threads=16        : 16 connexions concurrentes
# --time=300          : Test de 5 minutes
# --report-interval=10: Rapport toutes les 10 secondes
```

**Sortie typique** :

```
[ 10s ] thds: 16 tps: 2145.32 qps: 42906.47 (r/w/o: 30034.43/8581.27/4290.77) lat (ms,95%): 14.73 err/s: 0.00 reconn/s: 0.00
[ 20s ] thds: 16 tps: 2167.89 qps: 43357.81 (r/w/o: 30350.48/8671.56/4335.77) lat (ms,95%): 14.46 err/s: 0.00 reconn/s: 0.00
[ 30s ] thds: 16 tps: 2189.45 qps: 43788.93 (r/w/o: 30652.05/8758.05/4378.83) lat (ms,95%): 14.21 err/s: 0.00 reconn/s: 0.00
...
[ 300s ] thds: 16 tps: 2156.23 qps: 43124.65 (r/w/o: 30187.26/8625.07/4312.32) lat (ms,95%): 14.82 err/s: 0.00 reconn/s: 0.00

SQL statistics:
    queries performed:
        read:                            9035742
        write:                           2581640
        other:                           1290820
        total:                           12908202
    transactions:                        645410 (2151.33 per sec.)
    queries:                             12908202 (43026.63 per sec.)
    ignored errors:                      0      (0.00 per sec.)
    reconnects:                          0      (0.00 per sec.)

General statistics:
    total time:                          300.0123s
    total number of events:              645410

Latency (ms):
         min:                                    2.14
         avg:                                    7.43
         max:                                  156.78
         95th percentile:                       14.73
         sum:                              4797234.56

Threads fairness:
    events (avg/stddev):           40338.1250/123.45
    execution time (avg/stddev):   299.8272/0.05
```

### InterprÃ©tation des mÃ©triques

| MÃ©trique | Valeur exemple | Signification |
|----------|----------------|---------------|
| **tps** | 2151.33 | Transactions par seconde (objectif principal) |
| **qps** | 43026.63 | Queries par seconde (1 transaction = ~20 queries) |
| **r/w/o** | 30187/8625/4312 | Read/Write/Other queries |
| **lat 95th** | 14.73 ms | 95% des transactions < 14.73ms |
| **lat avg** | 7.43 ms | Latence moyenne |
| **lat max** | 156.78 ms | Pire latence (outlier) |

**Objectifs de performance typiques** :

| Niveau | TPS | Latence p95 | Use Case |
|--------|-----|-------------|----------|
| Faible | < 1,000 | > 100ms | Serveur sous-dimensionnÃ© |
| Acceptable | 1,000-5,000 | 20-50ms | Application web standard |
| Bon | 5,000-15,000 | 10-20ms | E-commerce, SaaS |
| Excellent | 15,000-30,000 | 5-10ms | Haute performance |
| Exceptionnel | > 30,000 | < 5ms | Ultra haute performance |

### Tests OLTP spÃ©cialisÃ©s

**Read-Only (lecture seule)** :

```bash
# Test lecture pure (SELECT)
sysbench /usr/share/sysbench/oltp_read_only.lua \
    --mysql-host=localhost \
    --mysql-user=sbtest \
    --mysql-password=sbtest_password \
    --mysql-db=sbtest \
    --tables=10 \
    --table-size=100000 \
    --threads=32 \
    --time=60 \
    run

# RÃ©sultat typique: 40,000-80,000 TPS
# Latence p95: 3-8ms
```

**Write-Only (Ã©criture seule)** :

```bash
# Test Ã©criture pure (INSERT/UPDATE/DELETE)
sysbench /usr/share/sysbench/oltp_write_only.lua \
    --mysql-host=localhost \
    --mysql-user=sbtest \
    --mysql-password=sbtest_password \
    --mysql-db=sbtest \
    --tables=10 \
    --table-size=100000 \
    --threads=16 \
    --time=60 \
    run

# RÃ©sultat typique: 5,000-15,000 TPS
# Latence p95: 15-30ms (plus Ã©levÃ©e, normal)
```

**Point Select (recherche par clÃ© primaire)** :

```bash
# Test SELECT par PK uniquement
sysbench /usr/share/sysbench/oltp_point_select.lua \
    --mysql-host=localhost \
    --mysql-user=sbtest \
    --mysql-password=sbtest_password \
    --mysql-db=sbtest \
    --tables=10 \
    --table-size=100000 \
    --threads=64 \
    --time=60 \
    run

# RÃ©sultat typique: 100,000-200,000 TPS
# Latence p95: 1-3ms
```

---

## MÃ©thodologie de benchmark

### 1. Ã‰tablir une baseline

```bash
#!/bin/bash
# baseline-benchmark.sh

MYSQL_HOST=localhost
MYSQL_USER=sbtest
MYSQL_PASSWORD=sbtest_password
MYSQL_DB=sbtest
RESULTS_DIR=./benchmark-results
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

mkdir -p $RESULTS_DIR

# Configuration serveur actuelle
mysql -h $MYSQL_HOST -u $MYSQL_USER -p$MYSQL_PASSWORD -e "
    SELECT @@innodb_buffer_pool_size, 
           @@innodb_io_capacity, 
           @@innodb_flush_method
" > $RESULTS_DIR/baseline_config_$TIMESTAMP.txt

# Benchmark read-write
echo "Running OLTP read-write benchmark..."
sysbench /usr/share/sysbench/oltp_read_write.lua \
    --mysql-host=$MYSQL_HOST \
    --mysql-user=$MYSQL_USER \
    --mysql-password=$MYSQL_PASSWORD \
    --mysql-db=$MYSQL_DB \
    --tables=10 \
    --table-size=1000000 \
    --threads=16 \
    --time=300 \
    --report-interval=10 \
    run > $RESULTS_DIR/baseline_oltp_rw_$TIMESTAMP.txt

# Extraire TPS
TPS=$(grep "transactions:" $RESULTS_DIR/baseline_oltp_rw_$TIMESTAMP.txt | \
      awk '{print $3}' | sed 's/(//')

echo "Baseline TPS: $TPS" | tee $RESULTS_DIR/baseline_summary_$TIMESTAMP.txt
```

### 2. Tests progressifs de charge

```bash
#!/bin/bash
# load-test.sh - Test avec charge croissante

for THREADS in 1 2 4 8 16 32 64 128; do
    echo "Testing with $THREADS threads..."
    
    sysbench /usr/share/sysbench/oltp_read_write.lua \
        --mysql-host=localhost \
        --mysql-user=sbtest \
        --mysql-password=sbtest_password \
        --mysql-db=sbtest \
        --tables=10 \
        --table-size=100000 \
        --threads=$THREADS \
        --time=60 \
        run > results_threads_${THREADS}.txt
    
    # Pause entre tests
    sleep 30
done

# Analyser rÃ©sultats
echo "Threads,TPS,Latency_p95" > load_test_summary.csv
for file in results_threads_*.txt; do
    THREADS=$(echo $file | grep -oP '\d+')
    TPS=$(grep "transactions:" $file | awk '{print $3}' | sed 's/(//')
    LAT=$(grep "95th percentile:" $file | awk '{print $3}')
    echo "$THREADS,$TPS,$LAT" >> load_test_summary.csv
done

# Visualiser (gnuplot, Excel, etc.)
```

**Analyse typique** :

```
Threads    TPS        Latency p95
1          1,234      0.95ms     
2          2,456      1.02ms     
4          4,789      1.15ms     
8          9,234      1.34ms     
16         17,456     2.12ms     â† Optimal
32         23,567     3.89ms     
64         26,234     8.45ms     â† Saturation
128        27,123     18.67ms    â† DÃ©gradation
```

**Courbe de performance** :

```
TPS
30K |                    â•­â”€â”€â”€â”€â”€â”€â”€â”€  Plateau (saturation)
    |                 â•­â”€â”€â•¯
25K |              â•­â”€â”€â•¯
    |           â•­â”€â”€â•¯
20K |        â•­â”€â”€â•¯
    |     â•­â”€â”€â•¯
15K |  â•­â”€â”€â•¯               â† Zone optimale
    |â•­â”€â•¯
10K |â•¯
    |
 5K |
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     1   2   4   8  16  32  64 128  Threads
```

### 3. Comparaison avant/aprÃ¨s optimisation

```bash
#!/bin/bash
# compare-optimization.sh

# Baseline AVANT optimisation
echo "=== BEFORE optimization ==="
sysbench /usr/share/sysbench/oltp_read_write.lua \
    --mysql-host=localhost \
    --mysql-user=sbtest \
    --mysql-password=sbtest_password \
    --mysql-db=sbtest \
    --tables=10 \
    --table-size=1000000 \
    --threads=16 \
    --time=300 \
    run > before.txt

TPS_BEFORE=$(grep "transactions:" before.txt | awk '{print $3}' | sed 's/(//')
LAT_BEFORE=$(grep "95th percentile:" before.txt | awk '{print $3}')

# Appliquer optimisations
mysql -u root -p << 'EOF'
SET GLOBAL innodb_buffer_pool_size = 8G;
SET GLOBAL innodb_io_capacity = 10000;
SET GLOBAL innodb_io_capacity_max = 20000;
EOF

# Attendre stabilisation
sleep 60

# Benchmark APRÃˆS optimisation
echo "=== AFTER optimization ==="
sysbench /usr/share/sysbench/oltp_read_write.lua \
    --mysql-host=localhost \
    --mysql-user=sbtest \
    --mysql-password=sbtest_password \
    --mysql-db=sbtest \
    --tables=10 \
    --table-size=1000000 \
    --threads=16 \
    --time=300 \
    run > after.txt

TPS_AFTER=$(grep "transactions:" after.txt | awk '{print $3}' | sed 's/(//')
LAT_AFTER=$(grep "95th percentile:" after.txt | awk '{print $3}')

# Calculer amÃ©lioration
IMPROVEMENT=$(echo "scale=2; ($TPS_AFTER - $TPS_BEFORE) / $TPS_BEFORE * 100" | bc)

echo "=== RESULTS ==="
echo "TPS Before:  $TPS_BEFORE"
echo "TPS After:   $TPS_AFTER"
echo "Improvement: +${IMPROVEMENT}%"
echo "Latency Before: $LAT_BEFORE ms"
echo "Latency After:  $LAT_AFTER ms"
```

---

## Tests I/O et systÃ¨me

### Test I/O disque (fileio)

```bash
# PrÃ©paration fichiers de test (16 fichiers de 1GB chacun)
sysbench fileio \
    --file-total-size=16G \
    --file-num=16 \
    prepare

# Test lecture sÃ©quentielle
sysbench fileio \
    --file-total-size=16G \
    --file-num=16 \
    --file-test-mode=seqrd \
    --file-extra-flags=direct \
    --threads=4 \
    --time=60 \
    run

# Test Ã©criture sÃ©quentielle
sysbench fileio \
    --file-total-size=16G \
    --file-num=16 \
    --file-test-mode=seqwr \
    --file-extra-flags=direct \
    --threads=4 \
    --time=60 \
    run

# Test lecture alÃ©atoire (le plus important pour DB)
sysbench fileio \
    --file-total-size=16G \
    --file-num=16 \
    --file-test-mode=rndrd \
    --file-extra-flags=direct \
    --file-block-size=16K \
    --threads=16 \
    --time=60 \
    run

# RÃ©sultats typiques:
# HDD:      100-200 IOPS random read
# SSD SATA: 15,000-25,000 IOPS random read
# SSD NVMe: 100,000-500,000 IOPS random read

# Nettoyage
sysbench fileio --file-total-size=16G cleanup
```

### Test CPU

```bash
# Test calcul nombres premiers (charge CPU)
sysbench cpu \
    --cpu-max-prime=20000 \
    --threads=$(nproc) \
    --time=60 \
    run

# RÃ©sultats:
# events per second: 1234.56  â† Plus Ã©levÃ© = CPU plus rapide
# total time: 60.0123s
# total number of events: 74073
```

### Test mÃ©moire

```bash
# Test bande passante mÃ©moire
sysbench memory \
    --memory-block-size=1K \
    --memory-total-size=10G \
    --memory-oper=read \
    --threads=4 \
    run

# Test latence mÃ©moire
sysbench memory \
    --memory-block-size=1K \
    --memory-total-size=1G \
    --memory-oper=read \
    --threads=1 \
    run
```

---

## Dimensionnement infrastructure

### Calculer la capacitÃ© nÃ©cessaire

```bash
#!/bin/bash
# capacity-planning.sh

# Charge actuelle en production (mesurÃ©)
CURRENT_TPS=8000
CURRENT_THREADS=50

# Croissance prÃ©vue
GROWTH_FACTOR=2.5  # 2.5x dans 12 mois

# Marge de sÃ©curitÃ©
SAFETY_MARGIN=1.3  # 30% de marge

# CapacitÃ© cible
TARGET_TPS=$(echo "$CURRENT_TPS * $GROWTH_FACTOR * $SAFETY_MARGIN" | bc)

echo "Current load: $CURRENT_TPS TPS"
echo "Target capacity: $TARGET_TPS TPS"

# Tester diffÃ©rentes configurations
for CONFIG in "4cores_16gb" "8cores_32gb" "16cores_64gb"; do
    echo "Testing configuration: $CONFIG"
    
    # Simuler charge cible
    sysbench /usr/share/sysbench/oltp_read_write.lua \
        --mysql-host=$CONFIG.test.local \
        --mysql-user=sbtest \
        --mysql-password=sbtest_password \
        --mysql-db=sbtest \
        --tables=20 \
        --table-size=1000000 \
        --threads=100 \
        --time=300 \
        run > results_$CONFIG.txt
    
    ACHIEVED_TPS=$(grep "transactions:" results_$CONFIG.txt | awk '{print $3}' | sed 's/(//')
    
    if (( $(echo "$ACHIEVED_TPS > $TARGET_TPS" | bc -l) )); then
        echo "âœ“ $CONFIG meets requirements: $ACHIEVED_TPS TPS"
    else
        echo "âœ— $CONFIG insufficient: $ACHIEVED_TPS TPS"
    fi
done
```

### Estimation coÃ»ts vs performance

```
Configuration          TPS      Latency p95    CoÃ»t/mois    $/TPS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
2 cores, 8 GB RAM      5,000    25ms           $50          $0.010
4 cores, 16 GB RAM     12,000   12ms           $100         $0.008
8 cores, 32 GB RAM     28,000   8ms            $200         $0.007  â† Optimal
16 cores, 64 GB RAM    42,000   6ms            $400         $0.009
32 cores, 128 GB RAM   51,000   5ms            $800         $0.016  â† Rendement dÃ©croissant
```

---

## Tests avancÃ©s et personnalisÃ©s

### Script Lua personnalisÃ©

```lua
-- custom_workload.lua
-- Workload personnalisÃ© simulant application spÃ©cifique

function thread_init()
    drv = sysbench.sql.driver()
    con = drv:connect()
end

function event()
    -- Simulation requÃªte 1: Recherche utilisateur
    con:query("SELECT * FROM users WHERE email = 'user@example.com'")
    
    -- Simulation requÃªte 2: Liste commandes rÃ©centes
    con:query([[
        SELECT o.*, p.product_name 
        FROM orders o 
        JOIN order_items oi ON o.order_id = oi.order_id
        JOIN products p ON oi.product_id = p.product_id
        WHERE o.user_id = 12345 
          AND o.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
        ORDER BY o.created_at DESC 
        LIMIT 20
    ]])
    
    -- Simulation requÃªte 3: Mise Ã  jour statistiques
    con:query("UPDATE user_stats SET page_views = page_views + 1 WHERE user_id = 12345")
end

function thread_done()
    con:disconnect()
end
```

**ExÃ©cution** :

```bash
sysbench custom_workload.lua \
    --mysql-host=localhost \
    --mysql-user=sbtest \
    --mysql-password=sbtest_password \
    --mysql-db=myapp \
    --threads=32 \
    --time=300 \
    --report-interval=10 \
    run
```

### Test de montÃ©e en charge progressive

```bash
#!/bin/bash
# ramp-up-test.sh

MAX_THREADS=128
STEP=8
DURATION_PER_STEP=60

for ((THREADS=1; THREADS<=MAX_THREADS; THREADS+=STEP)); do
    echo "=== Testing with $THREADS threads ==="
    
    sysbench /usr/share/sysbench/oltp_read_write.lua \
        --mysql-host=localhost \
        --mysql-user=sbtest \
        --mysql-password=sbtest_password \
        --mysql-db=sbtest \
        --tables=10 \
        --table-size=1000000 \
        --threads=$THREADS \
        --time=$DURATION_PER_STEP \
        --report-interval=10 \
        run | tee ramp_${THREADS}.txt
    
    # Pause courte entre paliers
    sleep 10
done

# Analyser le point de saturation
echo "Analyzing saturation point..."
python3 << 'EOF'
import re
import glob

results = []
for file in sorted(glob.glob("ramp_*.txt"), key=lambda x: int(re.search(r'\d+', x).group())):
    with open(file) as f:
        content = f.read()
        threads = int(re.search(r'ramp_(\d+)', file).group(1))
        tps_match = re.search(r'transactions:\s+\d+\s+\((\d+\.\d+)', content)
        if tps_match:
            tps = float(tps_match.group(1))
            results.append((threads, tps))

# Trouver pic de performance
max_tps = max(results, key=lambda x: x[1])
print(f"Peak performance: {max_tps[1]:.2f} TPS at {max_tps[0]} threads")

# DÃ©tecter saturation (quand TPS cesse d'augmenter)
for i in range(1, len(results)):
    if results[i][1] < results[i-1][1] * 0.95:
        print(f"Saturation detected at {results[i][0]} threads")
        break
EOF
```

---

## Bonnes pratiques et piÃ¨ges Ã  Ã©viter

### âœ… Bonnes pratiques

1. **Warm-up** : Toujours prÃ©chauffer avant mesure

```bash
# Warm-up de 60 secondes avant vrai test
sysbench /usr/share/sysbench/oltp_read_write.lua \
    --mysql-host=localhost \
    --mysql-user=sbtest \
    --mysql-password=sbtest_password \
    --mysql-db=sbtest \
    --tables=10 \
    --table-size=100000 \
    --threads=16 \
    --time=60 \
    run > /dev/null  # Warm-up, rÃ©sultats ignorÃ©s

# Vrai test aprÃ¨s warm-up
sysbench /usr/share/sysbench/oltp_read_write.lua \
    --mysql-host=localhost \
    --mysql-user=sbtest \
    --mysql-password=sbtest_password \
    --mysql-db=sbtest \
    --tables=10 \
    --table-size=100000 \
    --threads=16 \
    --time=300 \
    run  # Mesure rÃ©elle
```

2. **Tests rÃ©pÃ©tÃ©s** : 3-5 runs minimum, prendre la mÃ©diane

```bash
for run in {1..5}; do
    echo "Run $run/5"
    sysbench /usr/share/sysbench/oltp_read_write.lua \
        --mysql-host=localhost \
        --mysql-user=sbtest \
        --mysql-password=sbtest_password \
        --mysql-db=sbtest \
        --tables=10 \
        --table-size=100000 \
        --threads=16 \
        --time=300 \
        run > run_${run}.txt
    sleep 60  # Pause entre runs
done
```

3. **Dataset rÃ©aliste** : Taille proche de production

```bash
# Si DB production = 50 GB, utiliser:
sysbench oltp_read_write.lua \
    --tables=50 \
    --table-size=1000000 \  # 50 tables Ã— 1M rows â‰ˆ 50 GB
    prepare
```

4. **Monitoring systÃ¨me parallÃ¨le**

```bash
# Terminal 1: sysbench
sysbench ... run

# Terminal 2: monitoring
vmstat 1 > vmstat.log &
iostat -x 1 > iostat.log &
sar -u 1 > cpu.log &

# Terminal 3: MariaDB status
while true; do
    mysql -e "SHOW ENGINE INNODB STATUS\G" >> innodb_status.log
    sleep 10
done
```

### âŒ PiÃ¨ges Ã  Ã©viter

1. **Ne PAS tester sur production directement**
   - Utiliser serveur dÃ©diÃ© ou staging
   - Risque de saturation et impact utilisateurs

2. **Ne PAS comparer rÃ©sultats diffÃ©rents environnements sans contexte**
   ```
   âŒ "Serveur A: 15K TPS, Serveur B: 12K TPS â†’ A est meilleur"
   âœ“  VÃ©rifier: hardware, rÃ©seau, dataset, configuration
   ```

3. **Ne PAS ignorer le rÃ©seau**
   ```bash
   # Test local (sysbench sur mÃªme machine que MariaDB)
   sysbench ... --mysql-host=localhost
   # TPS: 25,000
   
   # Test rÃ©seau (sysbench distant)
   sysbench ... --mysql-host=db.example.com
   # TPS: 8,000  â† RÃ©seau est le goulot !
   ```

4. **Ne PAS utiliser dataset trop petit**
   ```bash
   # âŒ Dataset 100 MB, Buffer Pool 8 GB
   # Toutes donnÃ©es en RAM â†’ RÃ©sultats non reprÃ©sentatifs
   
   # âœ“ Dataset > Buffer Pool
   # Force lecture disque â†’ RÃ©sultats rÃ©alistes
   ```

---

## Automatisation et intÃ©gration CI/CD

### Script de test de rÃ©gression

```bash
#!/bin/bash
# performance-regression-test.sh

BASELINE_FILE="baseline_tps.txt"
THRESHOLD_DEGRADATION=5  # Alerte si dÃ©gradation > 5%

# Baseline (si n'existe pas)
if [ ! -f "$BASELINE_FILE" ]; then
    echo "Creating baseline..."
    sysbench /usr/share/sysbench/oltp_read_write.lua \
        --mysql-host=localhost \
        --mysql-user=sbtest \
        --mysql-password=sbtest_password \
        --mysql-db=sbtest \
        --tables=10 \
        --table-size=100000 \
        --threads=16 \
        --time=300 \
        run > baseline_full.txt
    
    grep "transactions:" baseline_full.txt | awk '{print $3}' | sed 's/(//' > $BASELINE_FILE
fi

BASELINE_TPS=$(cat $BASELINE_FILE)

# Test actuel
sysbench /usr/share/sysbench/oltp_read_write.lua \
    --mysql-host=localhost \
    --mysql-user=sbtest \
    --mysql-password=sbtest_password \
    --mysql-db=sbtest \
    --tables=10 \
    --table-size=100000 \
    --threads=16 \
    --time=300 \
    run > current_full.txt

CURRENT_TPS=$(grep "transactions:" current_full.txt | awk '{print $3}' | sed 's/(//')

# Calculer diffÃ©rence
DIFF=$(echo "scale=2; ($BASELINE_TPS - $CURRENT_TPS) / $BASELINE_TPS * 100" | bc)

echo "Baseline TPS: $BASELINE_TPS"
echo "Current TPS:  $CURRENT_TPS"
echo "Difference:   $DIFF%"

# VÃ©rifier dÃ©gradation
if (( $(echo "$DIFF > $THRESHOLD_DEGRADATION" | bc -l) )); then
    echo "âŒ PERFORMANCE REGRESSION DETECTED: -${DIFF}%"
    exit 1
elif (( $(echo "$DIFF < -$THRESHOLD_DEGRADATION" | bc -l) )); then
    echo "âœ“ Performance improvement: +${DIFF#-}%"
    exit 0
else
    echo "âœ“ Performance stable"
    exit 0
fi
```

### IntÃ©gration GitLab CI

```yaml
# .gitlab-ci.yml
performance_test:
  stage: test
  script:
    # DÃ©marrer MariaDB de test
    - docker run -d --name mariadb-test -e MYSQL_ROOT_PASSWORD=root mariadb:11.8
    - sleep 30
    
    # PrÃ©parer donnÃ©es
    - sysbench /usr/share/sysbench/oltp_read_write.lua \
        --mysql-host=mariadb-test \
        --mysql-user=root \
        --mysql-password=root \
        --mysql-db=sbtest \
        --tables=5 \
        --table-size=10000 \
        prepare
    
    # Test performance
    - sysbench /usr/share/sysbench/oltp_read_write.lua \
        --mysql-host=mariadb-test \
        --mysql-user=root \
        --mysql-password=root \
        --mysql-db=sbtest \
        --tables=5 \
        --table-size=10000 \
        --threads=8 \
        --time=60 \
        run > perf_results.txt
    
    # VÃ©rifier seuil minimum
    - TPS=$(grep "transactions:" perf_results.txt | awk '{print $3}' | sed 's/(//')
    - |
      if [ $(echo "$TPS < 1000" | bc) -eq 1 ]; then
        echo "Performance below threshold: $TPS TPS"
        exit 1
      fi
  artifacts:
    paths:
      - perf_results.txt
    expire_in: 30 days
```

---

## âœ… Points clÃ©s Ã  retenir

- **sysbench est l'outil de rÃ©fÃ©rence** pour benchmarker MariaDB de maniÃ¨re reproductible et fiable. Support OLTP, I/O, CPU, mÃ©moire.

- **Tests OLTP principaux** : oltp_read_write (mixte rÃ©aliste), oltp_read_only (lecture), oltp_write_only (Ã©criture). Choisir selon workload cible.

- **MÃ©triques clÃ©s** : TPS (transactions/sec), latence p95 (95th percentile), QPS (queries/sec). TPS = mÃ©trique principale pour comparer performances.

- **MÃ©thodologie rigoureuse** : Warm-up obligatoire, tests rÃ©pÃ©tÃ©s (3-5x), dataset rÃ©aliste (> Buffer Pool), monitoring systÃ¨me parallÃ¨le.

- **Tests progressifs** : Augmenter charge graduellement (1, 2, 4, 8, 16, 32... threads) pour identifier point de saturation et capacitÃ© maximale.

- **Dimensionnement** : Benchmark avec charge cible Ã— marge sÃ©curitÃ© (1.3-1.5x). Comparer configurations pour choix optimal coÃ»t/performance.

- **Ã‰viter piÃ¨ges** : Ne pas tester en production, dataset trop petit, ignorer rÃ©seau, comparer environnements diffÃ©rents sans contexte.

- **Automatisation** : IntÃ©grer dans CI/CD pour dÃ©tecter rÃ©gressions. Ã‰tablir baseline, comparer Ã  chaque commit, alerter si dÃ©gradation > seuil.

---

## ğŸ”— Ressources et rÃ©fÃ©rences

### Documentation officielle
- [ğŸ“– sysbench GitHub](https://github.com/akopytov/sysbench)
- [ğŸ“– sysbench Documentation](https://github.com/akopytov/sysbench/blob/master/README.md)
- [ğŸ“– Lua Scripting Guide](https://github.com/akopytov/sysbench/blob/master/src/scripting.txt)

### Articles et guides
- [Percona Blog - sysbench Best Practices](https://www.percona.com/blog/)
- [MariaDB Blog - Benchmarking](https://mariadb.com/resources/blog/)

### Outils complÃ©mentaires
- [mysqlslap](https://mariadb.com/kb/en/mysqlslap/) - Outil de charge inclus avec MariaDB
- [HammerDB](https://www.hammerdb.com/) - Alternative avec GUI
- [tpcc-mysql](https://github.com/Percona-Lab/tpcc-mysql) - Benchmark TPC-C

---

## â¡ï¸ Section suivante

La prochaine section explorera d'autres outils de monitoring et d'analyse de performance pour complÃ©ter l'arsenal d'optimisation de MariaDB en production.

â­ï¸ [mysqlslap](/15-performance-tuning/12.2-mysqlslap.md)
