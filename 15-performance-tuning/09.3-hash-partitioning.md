üîù Retour au [Sommaire](/SOMMAIRE.md)

# 15.9.3 HASH Partitioning

> **Niveau** : Expert  
> **Dur√©e estim√©e** : 2-3 heures  
> **Pr√©requis** : Section 15.9.1 (RANGE), Section 15.9.2 (LIST), Compr√©hension des algorithmes de hachage

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre le partitionnement HASH et ses algorithmes (HASH vs LINEAR HASH)
- Ma√Ætriser KEY partitioning comme variante de HASH
- Impl√©menter une distribution uniforme automatique des donn√©es
- Choisir le nombre optimal de partitions
- G√©rer l'ajout et la suppression de partitions (COALESCE)
- Comprendre les impacts de la redistribution des donn√©es
- Diagnostiquer les probl√®mes de distribution
- Choisir entre HASH, RANGE et LIST selon le cas d'usage
- Optimiser les performances avec le partitionnement HASH

---

## Introduction

Le **partitionnement HASH** distribue automatiquement les donn√©es entre les partitions en appliquant une **fonction de hachage** sur la colonne de partitionnement. Contrairement √† RANGE et LIST o√π vous d√©finissez explicitement les crit√®res, HASH r√©partit les donn√©es de mani√®re **uniforme et automatique**.

### Concept de base

```
Partitionnement HASH:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ INSERT INTO users (user_id, name, email)       ‚îÇ
‚îÇ VALUES (12345, 'Alice', 'alice@example.com')   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì
    HASH(12345) = 43762
         ‚Üì
    43762 MOD 8 = 2  (8 partitions)
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Ligne stock√©e dans partition p2                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Distribution automatique sur 8 partitions:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ p0  ‚îÇ p1  ‚îÇ p2  ‚îÇ p3  ‚îÇ p4  ‚îÇ p5  ‚îÇ p6  ‚îÇ p7  ‚îÇ
‚îÇ 12% ‚îÇ 13% ‚îÇ 12% ‚îÇ 13% ‚îÇ 12% ‚îÇ 13% ‚îÇ 12% ‚îÇ 13% ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       Distribution quasi-uniforme
```

### Comparaison avec RANGE et LIST

| Crit√®re | RANGE | LIST | HASH |
|---------|-------|------|------|
| **Distribution** | Manuelle par plages | Manuelle par valeurs | **Automatique et uniforme** |
| **Logique m√©tier** | Temporelle, s√©quentielle | Cat√©gorielle | **Aucune** |
| **Partition pruning** | Oui (sur ranges) | Oui (sur valeurs exactes) | **Non** (sauf √©galit√© stricte) |
| **√âquilibrage** | D√©pend des donn√©es | D√©pend des donn√©es | **Garanti** |
| **Ajout partition** | REORGANIZE | ADD PARTITION | **ADD PARTITION (redistribution)** |
| **Use case** | Archivage temporel | Isolation cat√©gorielle | **Load balancing, distribution** |
| **Complexit√© gestion** | Moyenne | Moyenne | **Faible** |

**Quand utiliser HASH** :
- ‚úÖ Pas de logique m√©tier √©vidente pour partitionner
- ‚úÖ Besoin de **distribution uniforme** automatique
- ‚úÖ Requ√™tes **sans filtre sp√©cifique** r√©current
- ‚úÖ Objectif : **Diviser la charge** (load balancing)
- ‚úÖ √âviter la gestion manuelle des partitions

**Quand NE PAS utiliser HASH** :
- ‚ùå Requ√™tes filtrent toujours sur une dimension logique (date, r√©gion)
- ‚ùå Besoin d'archivage/purge s√©lectif
- ‚ùå Partition pruning essentiel pour performance

---

## HASH vs LINEAR HASH

MariaDB offre deux algorithmes de hachage : **HASH** et **LINEAR HASH**.

### Algorithme HASH standard

```
Formule: HASH(column_value) MOD num_partitions

Exemple avec 4 partitions:
HASH(10) MOD 4 = 2 ‚Üí partition p2
HASH(11) MOD 4 = 3 ‚Üí partition p3
HASH(12) MOD 4 = 0 ‚Üí partition p0
HASH(13) MOD 4 = 1 ‚Üí partition p1
```

**Caract√©ristiques** :
- ‚úÖ **Distribution tr√®s uniforme**
- ‚ùå **Co√ªt √©lev√©** lors d'ajout/suppression de partitions (redistribution massive)

**Ajout de partition (4 ‚Üí 5)** :

```
Avant (4 partitions):
HASH(10) MOD 4 = 2 ‚Üí p2
HASH(14) MOD 4 = 2 ‚Üí p2

Apr√®s (5 partitions):
HASH(10) MOD 5 = 0 ‚Üí p0  ‚Üê D√©plac√© !
HASH(14) MOD 5 = 4 ‚Üí p4  ‚Üê D√©plac√© !

R√©sultat: ~80% des donn√©es redistribu√©es !
```

### Algorithme LINEAR HASH

```
Formule: Bas√© sur power-of-two (2^n)

LINEAR HASH utilise:
partition = column_value & (2^n - 1)

Exemple avec 4 partitions (2^2):
10 & (4-1) = 10 & 3 = 2 ‚Üí partition p2
11 & 3 = 3 ‚Üí partition p3
12 & 3 = 0 ‚Üí partition p0
```

**Caract√©ristiques** :
- ‚úÖ **Ajout/suppression rapide** (redistribution minimale)
- ‚ö†Ô∏è **Distribution moins uniforme** que HASH standard

**Ajout de partition (4 ‚Üí 5)** :

```
LINEAR HASH optimise pour powers of two:
4 partitions ‚Üí 8 partitions (saute √† 2^3)

Redistribution: Seulement ~50% des donn√©es au lieu de ~80%
```

### Comparaison HASH vs LINEAR HASH

```sql
-- Test de distribution (100,000 insertions)

-- HASH standard (4 partitions)
p0: 25,023 rows (25.02%)  ‚Üê Tr√®s uniforme
p1: 24,987 rows (24.99%)
p2: 25,012 rows (25.01%)
p3: 24,978 rows (24.98%)
√âcart-type: 0.015%

-- LINEAR HASH (4 partitions)
p0: 26,234 rows (26.23%)  ‚Üê Moins uniforme
p1: 23,891 rows (23.89%)
p2: 25,456 rows (25.46%)
p3: 24,419 rows (24.42%)
√âcart-type: 0.94%
```

üí° **Recommandation** :
- **HASH standard** : Si nombre de partitions stable, distribution critique
- **LINEAR HASH** : Si ajout/suppression fr√©quent de partitions

---

## Syntaxe et cr√©ation

### HASH partitioning basique

```sql
CREATE TABLE users (
    user_id BIGINT AUTO_INCREMENT,
    username VARCHAR(50),
    email VARCHAR(100),
    created_at TIMESTAMP,
    PRIMARY KEY (user_id)
) PARTITION BY HASH(user_id)
PARTITIONS 8;  -- 8 partitions nomm√©es p0, p1, ..., p7
```

**Partitions automatiquement nomm√©es** : p0, p1, p2, ..., p7

### LINEAR HASH

```sql
CREATE TABLE sessions (
    session_id CHAR(36),
    user_id BIGINT,
    created_at TIMESTAMP,
    data JSON,
    PRIMARY KEY (session_id)
) PARTITION BY LINEAR HASH(CRC32(session_id))
PARTITIONS 16;
```

### HASH sur expression

```sql
-- Partitionnement par ann√©e (sans logique RANGE)
CREATE TABLE events (
    event_id BIGINT AUTO_INCREMENT,
    event_date DATE,
    event_type VARCHAR(50),
    PRIMARY KEY (event_id, event_date)
) PARTITION BY HASH(YEAR(event_date))
PARTITIONS 4;  -- Distribue sur 4 partitions

-- Partitionnement par mois (modulo 12)
CREATE TABLE logs (
    log_id BIGINT AUTO_INCREMENT,
    log_timestamp DATETIME,
    message TEXT,
    PRIMARY KEY (log_id, log_timestamp)
) PARTITION BY HASH(MONTH(log_timestamp))
PARTITIONS 12;  -- Une partition "logique" par mois
```

‚ö†Ô∏è **Attention** : `HASH(YEAR(date))` n'est PAS la m√™me chose que `RANGE BY YEAR(date)` :
- HASH : Distribue uniform√©ment les ann√©es sur N partitions
- RANGE : Chaque ann√©e dans sa propre partition

### Noms de partitions personnalis√©s

```sql
-- Nommer explicitement les partitions
CREATE TABLE data (
    id BIGINT,
    value VARCHAR(100),
    PRIMARY KEY (id)
) PARTITION BY HASH(id) (
    PARTITION p_shard_0,
    PARTITION p_shard_1,
    PARTITION p_shard_2,
    PARTITION p_shard_3
);
```

---

## KEY Partitioning (variante de HASH)

**KEY partitioning** est similaire √† HASH mais utilise la **fonction de hachage interne de MariaDB** au lieu d'une fonction d√©finie par l'utilisateur.

### Syntaxe KEY

```sql
CREATE TABLE users (
    user_id BIGINT AUTO_INCREMENT,
    username VARCHAR(50),
    email VARCHAR(100),
    PRIMARY KEY (user_id)
) PARTITION BY KEY()  -- Sans sp√©cifier colonne
PARTITIONS 8;

-- MariaDB utilise automatiquement la PRIMARY KEY pour hachage
```

### KEY avec colonne explicite

```sql
CREATE TABLE sessions (
    session_id CHAR(36),
    user_id BIGINT,
    created_at TIMESTAMP,
    PRIMARY KEY (session_id)
) PARTITION BY KEY(user_id)  -- Hash sur user_id, pas session_id
PARTITIONS 16;
```

### LINEAR KEY

```sql
CREATE TABLE data (
    id BIGINT,
    value TEXT,
    PRIMARY KEY (id)
) PARTITION BY LINEAR KEY(id)
PARTITIONS 32;
```

### Diff√©rences HASH vs KEY

| Crit√®re | HASH | KEY |
|---------|------|-----|
| **Fonction hash** | MD5, CRC32 (d√©finie par utilisateur) | Fonction interne MariaDB |
| **Colonne** | Doit sp√©cifier expression | Peut √™tre vide (utilise PK) |
| **Compatibilit√©** | Portable entre moteurs | Sp√©cifique MariaDB |
| **Performance** | L√©g√®rement plus lent | L√©g√®rement plus rapide |
| **Distribution** | Identique | Identique |

üí° **Recommandation** : **KEY()** pour simplicit√© si la PRIMARY KEY convient.

---

## Gestion des partitions HASH

### Ajout de partitions

```sql
-- Ajouter 4 partitions (8 ‚Üí 12)
ALTER TABLE users ADD PARTITION PARTITIONS 4;

-- Redistribution automatique:
-- MariaDB recalcule HASH(user_id) MOD 12 pour TOUTES les lignes
-- D√©place les donn√©es n√©cessaires
```

**Impact de l'ajout** :

```
Avant: 8 partitions
p0: 12.5% des donn√©es
p1: 12.5%
...
p7: 12.5%

Apr√®s: 12 partitions (ADD PARTITION PARTITIONS 4)
Redistribution: ~33% des donn√©es d√©plac√©es
Temps: Proportionnel √† la taille de la table
Blocage: ALTER TABLE = table verrouill√©e (sauf pt-online-schema-change)
```

‚ö†Ô∏è **Attention** : Ajout de partitions HASH = **op√©ration tr√®s co√ªteuse** sur grandes tables.

### R√©duction du nombre de partitions (COALESCE)

```sql
-- R√©duire de 12 √† 8 partitions (supprime 4 partitions)
ALTER TABLE users COALESCE PARTITION 4;

-- Redistribution automatique vers partitions restantes
```

**Impact de COALESCE** :

```
Avant: 12 partitions (p0...p11)
Apr√®s: 8 partitions (p0...p7)

Donn√©es de p8, p9, p10, p11 redistribu√©es vers p0-p7
Redistribution: ~33% des donn√©es d√©plac√©es
```

### Impossible avec HASH : DROP PARTITION

```sql
-- ‚ùå ERREUR
ALTER TABLE users DROP PARTITION p3;
-- ERROR 1512: DROP PARTITION can only be used on RANGE/LIST partitions

-- ‚úÖ Utiliser COALESCE √† la place
ALTER TABLE users COALESCE PARTITION 1;  -- R√©duit de N √† N-1
```

### R√©organisation compl√®te

```sql
-- Changer le nombre total de partitions
ALTER TABLE users PARTITION BY HASH(user_id) PARTITIONS 16;

-- √âquivalent √†:
-- 1. Recr√©er table avec 16 partitions
-- 2. Copier toutes les donn√©es
-- 3. Redistribuer selon nouveau nombre
```

---

## Cas d'usage et exemples

### Cas 1 : Sessions utilisateur (distribution uniforme)

**Contexte** : Application web avec sessions, pas de logique m√©tier √©vidente.

```sql
CREATE TABLE user_sessions (
    session_id CHAR(36) NOT NULL,
    user_id BIGINT,
    ip_address VARCHAR(45),
    user_agent TEXT,
    created_at TIMESTAMP,
    last_activity TIMESTAMP,
    session_data JSON,
    PRIMARY KEY (session_id)
) PARTITION BY KEY(session_id)
PARTITIONS 16;
```

**Avantages** :
- ‚úÖ Distribution uniforme automatique
- ‚úÖ Pas de hot partition (toutes les partitions √©galement sollicit√©es)
- ‚úÖ I/O r√©partis sur plusieurs fichiers .ibd

**Requ√™tes** :

```sql
-- Acc√®s par session_id (partition pruning possible)
SELECT * FROM user_sessions WHERE session_id = 'abc-123-def-456';
-- MariaDB calcule HASH(session_id) et acc√®de partition sp√©cifique

-- Scan complet (toutes partitions)
SELECT COUNT(*) FROM user_sessions 
WHERE last_activity < DATE_SUB(NOW(), INTERVAL 1 HOUR);
-- Pas de pruning, mais I/O distribu√©s
```

### Cas 2 : Cache distribu√©

**Contexte** : Table de cache, cl√©s arbitraires.

```sql
CREATE TABLE cache_entries (
    cache_key VARCHAR(255) NOT NULL,
    cache_value MEDIUMBLOB,
    expires_at TIMESTAMP,
    created_at TIMESTAMP,
    PRIMARY KEY (cache_key)
) PARTITION BY LINEAR HASH(CRC32(cache_key))
PARTITIONS 32;
```

**Avantages** :
- ‚úÖ Distribution parfaite pour cl√©s al√©atoires (UUID, hash)
- ‚úÖ LINEAR HASH permet ajout facile de partitions si cache grandit
- ‚úÖ Purge par partition (expiration)

**Purge par partition** :

```sql
-- Purger partition sp√©cifique
ALTER TABLE cache_entries TRUNCATE PARTITION p0;
-- Vide p0, beaucoup plus rapide que DELETE

-- Ou purger toutes les partitions en rotation
-- Script bash qui TRUNCATE une partition par jour
```

### Cas 3 : Sharding applicatif

**Contexte** : Application multi-tenant, distribution √©quitable.

```sql
CREATE TABLE tenant_data (
    id BIGINT AUTO_INCREMENT,
    tenant_id INT NOT NULL,
    data_type VARCHAR(50),
    payload JSON,
    created_at TIMESTAMP,
    PRIMARY KEY (id, tenant_id),
    INDEX idx_tenant (tenant_id, created_at)
) PARTITION BY HASH(tenant_id)
PARTITIONS 8;
```

**Strat√©gie** :

```sql
-- Chaque tenant distribu√© automatiquement
-- Tenant 1001 ‚Üí partition p1
-- Tenant 1002 ‚Üí partition p2
-- Tenant 1003 ‚Üí partition p3
-- etc.

-- Requ√™te tenant sp√©cifique (partition pruning)
SELECT * FROM tenant_data 
WHERE tenant_id = 1001 
  AND created_at >= '2025-01-01';
-- Acc√®s partition calcul√©e: HASH(1001) MOD 8
```

### Cas 4 : Log rotation automatique

**Contexte** : Logs applicatifs, rotation par partition.

```sql
CREATE TABLE application_logs (
    log_id BIGINT AUTO_INCREMENT,
    log_timestamp DATETIME,
    severity ENUM('DEBUG','INFO','WARNING','ERROR'),
    message TEXT,
    PRIMARY KEY (log_id, log_timestamp)
) PARTITION BY HASH(TO_DAYS(log_timestamp))
PARTITIONS 30;  -- ~30 jours de rotation
```

**Rotation** :

```sql
-- Chaque jour correspond √† une partition (modulo 30)
-- Jour 1 ‚Üí partition p1
-- Jour 2 ‚Üí partition p2
-- ...
-- Jour 31 ‚Üí partition p1 (√©crase jour 1)

-- TRUNCATE la partition du jour pour lib√©rer espace
-- Calcul: TO_DAYS('2025-12-15') MOD 30 = X
ALTER TABLE application_logs TRUNCATE PARTITION pX;
```

‚ö†Ô∏è **Alternative meilleure** : RANGE partitioning par date avec DROP PARTITION pour archivage propre.

---

## Nombre optimal de partitions

### R√®gles de dimensionnement

```
R√®gles empiriques:

Petit dataset (< 10 GB):
  Partitions = 4-8
  Objectif: I/O parall√®le

Medium dataset (10-100 GB):
  Partitions = 8-16
  Objectif: Distribution + parall√©lisme

Large dataset (> 100 GB):
  Partitions = 16-64
  Objectif: Sharding, maintenance cibl√©e

Tr√®s large dataset (> 1 TB):
  Partitions = 64-256
  Objectif: Sharding massif
  Attention: Overhead filesystem
```

### Formule de calcul

```
num_partitions = MIN(
    total_size_gb / target_partition_size_gb,
    num_cpu_cores * 2,
    256  # Maximum pratique
)

Exemples:

Table 80 GB, 16 cores, cible 5 GB/partition:
  = MIN(80/5, 16*2, 256)
  = MIN(16, 32, 256)
  = 16 partitions ‚úì

Table 500 GB, 32 cores, cible 10 GB/partition:
  = MIN(500/10, 32*2, 256)
  = MIN(50, 64, 256)
  = 50 partitions ‚úì
```

### Impacts du nombre de partitions

| Nb partitions | Avantages | Inconv√©nients |
|---------------|-----------|---------------|
| **4-8** | Simple, peu d'overhead | Distribution limit√©e |
| **8-16** | Bon √©quilibre | Optimal pour la plupart |
| **16-32** | Parall√©lisme √©lev√© | Gestion plus complexe |
| **32-64** | Sharding massif | Overhead filesystem |
| **> 64** | Tr√®s haute granularit√© | Performance peut se d√©grader |

üí° **Recommandation** : **8-16 partitions** pour la plupart des cas. Ajuster selon taille et charge.

---

## Performance et partition pruning

### Partition pruning limit√© avec HASH

```sql
-- ‚úÖ Partition pruning possible (√©galit√© stricte)
SELECT * FROM users WHERE user_id = 12345;
-- MariaDB calcule HASH(12345) MOD 8 ‚Üí partition p2 directement

EXPLAIN PARTITIONS
SELECT * FROM users WHERE user_id = 12345;
+----+-------------+-------+------------+------+
| id | select_type | table | partitions | type |
+----+-------------+-------+------------+------+
|  1 | SIMPLE      | users | p2         | ref  |
+----+-------------+-------+------------+------+

-- ‚úÖ Partition pruning avec IN (liste de valeurs)
SELECT * FROM users WHERE user_id IN (100, 200, 300);
-- Calcule HASH pour chaque valeur, acc√®de 3 partitions max

-- ‚ùå Pas de partition pruning (plage)
SELECT * FROM users WHERE user_id BETWEEN 1000 AND 2000;
-- Doit scanner TOUTES les partitions

EXPLAIN PARTITIONS
SELECT * FROM users WHERE user_id BETWEEN 1000 AND 2000;
+----+-------------+-------+------------------------+------+
| id | select_type | table | partitions             | type |
+----+-------------+-------+------------------------+------+
|  1 | SIMPLE      | users | p0,p1,p2,p3,p4,p5,p6,p7| range|
+----+-------------+-------+------------------------+------+
```

### Optimisations malgr√© absence de pruning

```
Avantages m√™me sans partition pruning:

1. I/O parall√®le:
   - Scan de 8 partitions en parall√®le
   - Meilleur que 1 grosse table s√©quentielle

2. Index plus petits:
   - Index par partition = plus compact
   - Meilleur cache hit ratio

3. Maintenance cibl√©e:
   - OPTIMIZE PARTITION p3
   - ANALYZE PARTITION p5

4. Fichiers plus petits:
   - 8 fichiers .ibd de 10 GB
   - vs 1 fichier .ibd de 80 GB
   - Meilleure gestion filesystem
```

---

## Monitoring et diagnostic

### Informations sur partitions HASH

```sql
-- Vue d√©taill√©e
SELECT 
    PARTITION_NAME,
    PARTITION_METHOD,
    PARTITION_EXPRESSION,
    TABLE_ROWS,
    ROUND(DATA_LENGTH / 1024 / 1024, 2) AS data_mb,
    ROUND(INDEX_LENGTH / 1024 / 1024, 2) AS index_mb,
    ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) AS total_mb,
    ROUND(TABLE_ROWS * 100.0 / SUM(TABLE_ROWS) OVER (), 2) AS rows_pct
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_SCHEMA = 'mydb'
  AND TABLE_NAME = 'users'
ORDER BY PARTITION_ORDINAL_POSITION;

+----------------+------------------+----------------------+------------+---------+----------+----------+----------+
| PARTITION_NAME | PARTITION_METHOD | PARTITION_EXPRESSION | TABLE_ROWS | data_mb | index_mb | total_mb | rows_pct |
+----------------+------------------+----------------------+------------+---------+----------+----------+----------+
| p0             | HASH             | user_id              |   1256789  | 456.78  |  123.45  |  580.23  |   12.48  |
| p1             | HASH             | user_id              |   1267890  | 461.23  |  124.56  |  585.79  |   12.59  |
| p2             | HASH             | user_id              |   1245678  | 452.34  |  122.34  |  574.68  |   12.37  |
| p3             | HASH             | user_id              |   1278901  | 465.67  |  125.67  |  591.34  |   12.70  |
| p4             | HASH             | user_id              |   1234567  | 448.90  |  121.23  |  570.13  |   12.26  |
| p5             | HASH             | user_id              |   1289012  | 468.12  |  126.78  |  594.90  |   12.80  |
| p6             | HASH             | user_id              |   1223456  | 445.56  |  120.12  |  565.68  |   12.15  |
| p7             | HASH             | user_id              |   1273890  | 463.45  |  125.01  |  588.46  |   12.65  |
+----------------+------------------+----------------------+------------+---------+----------+----------+----------+
```

### V√©rification de l'uniformit√©

```sql
-- Calculer √©cart-type de distribution
WITH partition_stats AS (
    SELECT 
        PARTITION_NAME,
        TABLE_ROWS
    FROM INFORMATION_SCHEMA.PARTITIONS
    WHERE TABLE_SCHEMA = 'mydb'
      AND TABLE_NAME = 'users'
      AND PARTITION_NAME IS NOT NULL
),
stats AS (
    SELECT 
        AVG(TABLE_ROWS) AS avg_rows,
        STDDEV(TABLE_ROWS) AS stddev_rows
    FROM partition_stats
)
SELECT 
    ps.PARTITION_NAME,
    ps.TABLE_ROWS,
    s.avg_rows,
    ROUND((ps.TABLE_ROWS - s.avg_rows) * 100.0 / s.avg_rows, 2) AS deviation_pct,
    s.stddev_rows,
    ROUND(s.stddev_rows * 100.0 / s.avg_rows, 2) AS coefficient_variation_pct
FROM partition_stats ps
CROSS JOIN stats s
ORDER BY ps.PARTITION_NAME;

+----------------+------------+----------+---------------+-------------+---------------------------+
| PARTITION_NAME | TABLE_ROWS | avg_rows | deviation_pct | stddev_rows | coefficient_variation_pct |
+----------------+------------+----------+---------------+-------------+---------------------------+
| p0             |   1256789  | 1260023  |     -0.26     |   18234     |           1.45            |
| p1             |   1267890  | 1260023  |      0.62     |   18234     |           1.45            |
| p2             |   1245678  | 1260023  |     -1.14     |   18234     |           1.45            |
| p3             |   1278901  | 1260023  |      1.50     |   18234     |           1.45            |
| p4             |   1234567  | 1260023  |     -2.02     |   18234     |           1.45            |
| p5             |   1289012  | 1260023  |      2.30     |   18234     |           1.45            |
| p6             |   1223456  | 1260023  |     -2.90     |   18234     |           1.45            |
| p7             |   1273890  | 1260023  |      1.10     |   18234     |           1.45            |
+----------------+------------+----------+---------------+-------------+---------------------------+

Coefficient de variation: 1.45% ‚Üí Excellente distribution ‚úì
```

**Interpr√©tation** :
- Coefficient < 5% : Distribution excellente
- Coefficient 5-10% : Distribution acceptable
- Coefficient > 10% : Distribution probl√©matique (revoir strat√©gie)

---

## Limitations et consid√©rations

### Limitations du HASH partitioning

1. **Pas de partition pruning sur plages**
   ```sql
   -- ‚ùå Inefficace
   WHERE user_id BETWEEN 1000 AND 2000  -- Toutes partitions
   WHERE created_at >= '2025-01-01'     -- Toutes partitions
   ```

2. **Pas d'archivage s√©lectif**
   ```sql
   -- ‚ùå Impossible de DROP partition pour archiver
   -- Donn√©es de toutes p√©riodes m√©lang√©es dans chaque partition
   ```

3. **Redistribution co√ªteuse**
   ```sql
   -- Ajouter 4 partitions (8‚Üí12) = redistribution massive
   ALTER TABLE users ADD PARTITION PARTITIONS 4;
   -- Peut prendre des heures sur tr√®s grande table
   ```

4. **Pas de DEFAULT partition**
   ```sql
   -- Contrairement √† LIST, toutes les valeurs vont dans une partition
   -- Pas de catch-all
   ```

### Quand NE PAS utiliser HASH

‚ùå **Ne pas utiliser si** :
- Requ√™tes filtrent **syst√©matiquement** sur dimension logique (date, r√©gion)
- Besoin d'**archivage/purge** par p√©riode ou cat√©gorie
- **Partition pruning essentiel** pour performance
- Donn√©es ont une **structure temporelle** claire

‚úÖ **√Ä la place, utiliser** :
- **RANGE** : Pour donn√©es temporelles, archivage
- **LIST** : Pour cat√©gories, r√©gions, statuts

### Hybride : HASH + index

Si besoin √† la fois de distribution ET de pruning :

```sql
-- HASH pour distribution
CREATE TABLE orders (
    order_id BIGINT,
    order_date DATE,
    customer_id INT,
    PRIMARY KEY (order_id),
    INDEX idx_date (order_date),      -- Index pour pruning temporel
    INDEX idx_customer (customer_id)  -- Index pour pruning client
) PARTITION BY HASH(order_id)
PARTITIONS 16;

-- Requ√™te avec index (compensation de l'absence de pruning)
SELECT * FROM orders 
WHERE order_date >= '2025-01-01';  -- Utilise idx_date
-- Scan 16 partitions mais avec index efficace
```

---

## Migration et conversion

### Convertir RANGE ‚Üí HASH

**Sc√©nario** : Table RANGE par date devient ing√©rable (trop de partitions), migration vers HASH.

```sql
-- Table RANGE initiale (365 partitions = 1 par jour)
CREATE TABLE events_range (
    event_id BIGINT,
    event_date DATE,
    PRIMARY KEY (event_id, event_date)
) PARTITION BY RANGE (TO_DAYS(event_date)) (...);  -- 365 partitions

-- Migration vers HASH (16 partitions)
CREATE TABLE events_hash (
    event_id BIGINT,
    event_date DATE,
    PRIMARY KEY (event_id)  -- Suppression event_date de PK
) PARTITION BY HASH(event_id)
PARTITIONS 16;

-- Copier donn√©es
INSERT INTO events_hash SELECT event_id, event_date FROM events_range;

-- Basculer
RENAME TABLE events_range TO events_old, events_hash TO events;
```

**Trade-off** :
- ‚ùå Perte du partition pruning temporel
- ‚úÖ Gestion simplifi√©e (16 vs 365 partitions)
- ‚úÖ Distribution uniforme

### Convertir non-partitionn√© ‚Üí HASH

```sql
-- Table non-partitionn√©e
CREATE TABLE users (
    user_id BIGINT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100)
);

-- Partitionner en HASH (online avec pt-online-schema-change)
pt-online-schema-change \
  --alter "PARTITION BY HASH(user_id) PARTITIONS 8" \
  D=mydb,t=users \
  --execute

-- Ou directement (bloquant)
ALTER TABLE users PARTITION BY HASH(user_id) PARTITIONS 8;
```

---

## ‚úÖ Points cl√©s √† retenir

- **HASH partitioning distribue automatiquement** les donn√©es de mani√®re uniforme via fonction de hachage. Id√©al quand pas de logique m√©tier √©vidente.

- **HASH vs LINEAR HASH** : HASH standard = distribution plus uniforme mais redistribution co√ªteuse. LINEAR HASH = ajout/suppression rapide mais distribution l√©g√®rement moins uniforme.

- **KEY partitioning = variante de HASH** utilisant fonction interne MariaDB. Syntaxe `PARTITION BY KEY()` sans colonne utilise automatiquement la PRIMARY KEY.

- **Partition pruning limit√©** : Fonctionne sur √©galit√© stricte (`WHERE id = X`) ou IN, mais PAS sur plages. Toutes requ√™tes avec BETWEEN scannent toutes les partitions.

- **Ajout partition = redistribution massive** : ALTER TABLE ADD PARTITION redistribue ~50-80% des donn√©es. Op√©ration tr√®s co√ªteuse sur grandes tables, planifier soigneusement.

- **COALESCE PARTITION** pour r√©duire nombre de partitions. DROP PARTITION impossible avec HASH (contrairement √† RANGE/LIST).

- **Nombre optimal : 8-16 partitions** pour la plupart des cas. Formule : `MIN(size_gb / target_partition_gb, cores √ó 2, 256)`.

- **Cas d'usage** : Sessions, cache, sharding sans logique m√©tier, distribution uniforme pour load balancing. NE PAS utiliser pour archivage temporel ou cat√©goriel.

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB
- [üìñ HASH Partitioning](https://mariadb.com/kb/en/partitioning-types/#hash-partitioning)
- [üìñ LINEAR HASH](https://mariadb.com/kb/en/partitioning-types/#linear-hash)
- [üìñ KEY Partitioning](https://mariadb.com/kb/en/partitioning-types/#key-partitioning)
- [üìñ Partition Management](https://mariadb.com/kb/en/partition-maintenance/)

### Articles techniques
- [Percona Blog - HASH vs RANGE Partitioning](https://www.percona.com/blog/)
- [MySQL Performance Blog - Choosing Partitioning Type](https://www.percona.com/blog/)

### Algorithmes de hachage
- [MD5 Hash Function](https://en.wikipedia.org/wiki/MD5)
- [CRC32 Checksum](https://en.wikipedia.org/wiki/Cyclic_redundancy_check)
- [Consistent Hashing](https://en.wikipedia.org/wiki/Consistent_hashing)

---

## ‚û°Ô∏è Conclusion du module Partitionnement

Vous ma√Ætrisez maintenant les **3 types de partitionnement** :

- **RANGE** (15.9.1) : Plages continues, archivage temporel
- **LIST** (15.9.2) : Valeurs discr√®tes, isolation cat√©gorielle  
- **HASH** (15.9.3) : Distribution uniforme, load balancing

**Tableau d√©cisionnel final** :

| Crit√®re | RANGE | LIST | HASH |
|---------|-------|------|------|
| **Donn√©es temporelles** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê | ‚≠ê‚≠ê |
| **Donn√©es cat√©gorielles** | ‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |
| **Distribution uniforme** | ‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **Partition pruning** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |
| **Archivage/purge** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê |
| **Simplicit√© gestion** | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |

La section suivante explorera **Performance Schema et sys schema** pour le monitoring temps r√©el.

‚è≠Ô∏è [Partition pruning](/15-performance-tuning/09.4-partition-pruning.md)
