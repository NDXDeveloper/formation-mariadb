üîù Retour au [Sommaire](/SOMMAIRE.md)

# 10.8.2 Audit de connexions et requ√™tes

> **Niveau** : Avanc√©
> **Dur√©e estim√©e** : 2.5 heures
> **Pr√©requis** : Section 10.8.1 (Server Audit Plugin), connaissance analyse de logs

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Analyser les connexions et identifier les tentatives d'intrusion
- D√©tecter les requ√™tes suspectes et les patterns d'attaque
- Investiguer les incidents de s√©curit√© avec les logs d'audit
- Mettre en place des alertes automatiques pour les √©v√©nements critiques
- Cr√©er des tableaux de bord de monitoring de s√©curit√©
- Effectuer des analyses forensiques post-incident

---

## Introduction

L'audit des **connexions** et des **requ√™tes** est crucial pour :

- ‚úÖ **D√©tecter les intrusions** : Tentatives d'authentification multiples, acc√®s non autoris√©s
- ‚úÖ **Identifier les menaces internes** : Utilisateurs l√©gitimes avec comportement anormal
- ‚úÖ **Pr√©venir les fuites de donn√©es** : Extraction massive, acc√®s √† des donn√©es sensibles
- ‚úÖ **Conformit√©** : Preuves d'acc√®s pour audits r√©glementaires
- ‚úÖ **Investigation forensique** : Reconstitution d'incidents de s√©curit√©

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           Analyse d'Audit : Connexions et Requ√™tes          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                             ‚îÇ
‚îÇ  1. Collecte                                                ‚îÇ
‚îÇ     ‚Ä¢ Logs d'audit (Server Audit Plugin)                    ‚îÇ
‚îÇ     ‚Ä¢ Logs syst√®me (auth.log, secure)                       ‚îÇ
‚îÇ     ‚Ä¢ Logs applicatifs                                      ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  2. Parsing et Normalisation                                ‚îÇ
‚îÇ     ‚Ä¢ Extraction des champs cl√©s                            ‚îÇ
‚îÇ     ‚Ä¢ Enrichissement (g√©olocalisation IP, etc.)             ‚îÇ
‚îÇ     ‚Ä¢ Agr√©gation temporelle                                 ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  3. Analyse et D√©tection                                    ‚îÇ
‚îÇ     ‚Ä¢ Patterns d'attaque (brute-force, SQL injection)       ‚îÇ
‚îÇ     ‚Ä¢ Comportements anormaux (horaires, volumes)            ‚îÇ
‚îÇ     ‚Ä¢ Corr√©lation multi-sources                             ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  4. Alerting et R√©ponse                                     ‚îÇ
‚îÇ     ‚Ä¢ Alertes temps r√©el (Slack, email, PagerDuty)          ‚îÇ
‚îÇ     ‚Ä¢ Blocage automatique (fail2ban, WAF)                   ‚îÇ
‚îÇ     ‚Ä¢ Escalade incidents                                    ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  5. Investigation et Forensique                             ‚îÇ
‚îÇ     ‚Ä¢ Timeline de l'incident                                ‚îÇ
‚îÇ     ‚Ä¢ Identification de l'attaquant                         ‚îÇ
‚îÇ     ‚Ä¢ √âvaluation de l'impact                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Audit des connexions

### Analyser les authentifications r√©ussies

```bash
#!/bin/bash
# analyze-successful-logins.sh
# Analyse des connexions r√©ussies

AUDIT_LOG="/var/log/mysql/audit.log"

echo "=== Connexions R√©ussies (status=0) ==="
echo ""

# Top 10 utilisateurs par nombre de connexions
echo "1. Top 10 utilisateurs (connexions)"
awk -F',' '$6 == "CONNECT" && $9 == "0" {print $3}' "$AUDIT_LOG" \
    | sort | uniq -c | sort -rn | head -10 \
    | awk '{printf "%-20s %d connexions\n", $2, $1}'

echo ""

# Connexions par tranche horaire
echo "2. Connexions par heure"
awk -F',' '$6 == "CONNECT" && $9 == "0" {
    split($1, dt, " ");
    split(dt[2], tm, ":");
    printf "%02d:00\n", tm[1]
}' "$AUDIT_LOG" | sort | uniq -c | sort -k2

echo ""

# Connexions par source IP
echo "3. Top 10 IP sources"
awk -F',' '$6 == "CONNECT" && $9 == "0" {print $4}' "$AUDIT_LOG" \
    | sort | uniq -c | sort -rn | head -10 \
    | awk '{printf "%-20s %d connexions\n", $2, $1}'

echo ""

# Connexions en dehors des heures de bureau (20h-8h)
echo "4. Connexions hors heures de bureau (20h-8h)"
awk -F',' '$6 == "CONNECT" && $9 == "0" {
    split($1, dt, " ");
    split(dt[2], tm, ":");
    hour = tm[1] + 0;
    if (hour >= 20 || hour < 8) {
        print $1, $3, $4
    }
}' "$AUDIT_LOG" | tail -20
```

### Analyser les √©checs d'authentification

```bash
#!/bin/bash
# analyze-failed-logins.sh
# D√©tection de tentatives d'intrusion

AUDIT_LOG="/var/log/mysql/audit.log"
THRESHOLD=5  # Seuil d'alerte

echo "=== Connexions √âchou√©es (status != 0) ==="
echo ""

# Utilisateurs avec √©checs multiples
echo "1. Utilisateurs avec √©checs r√©p√©t√©s (> $THRESHOLD)"
awk -F',' '$6 == "CONNECT" && $9 != "0" {print $3}' "$AUDIT_LOG" \
    | sort | uniq -c | sort -rn \
    | awk -v thresh="$THRESHOLD" '$1 > thresh {printf "%-20s %d √©checs ‚ö†Ô∏è\n", $2, $1}'

echo ""

# IP sources avec tentatives multiples (brute-force)
echo "2. IP sources suspectes (> $THRESHOLD √©checs)"
awk -F',' '$6 == "CONNECT" && $9 != "0" {print $4}' "$AUDIT_LOG" \
    | sort | uniq -c | sort -rn \
    | awk -v thresh="$THRESHOLD" '$1 > thresh {printf "%-20s %d √©checs üö®\n", $2, $1}'

echo ""

# Timeline des √©checs (derni√®res 24h)
echo "3. Timeline des √©checs (derni√®res 50 tentatives)"
awk -F',' '$6 == "CONNECT" && $9 != "0" {
    print $1, $3, $4, "status:" $9
}' "$AUDIT_LOG" | tail -50

echo ""

# Pattern de brute-force : m√™me IP, utilisateurs diff√©rents
echo "4. Brute-force potentiel : M√™me IP, utilisateurs multiples"
awk -F',' '$6 == "CONNECT" && $9 != "0" {
    print $4, $3
}' "$AUDIT_LOG" | awk '{
    users[$1] = users[$1] " " $2
    count[$1]++
}
END {
    for (ip in count) {
        if (count[ip] > 3) {
            printf "IP: %-20s Tentatives: %d Utilisateurs: %s\n", ip, count[ip], users[ip]
        }
    }
}'
```

### D√©tection d'anomalies de connexion

```sql
-- Requ√™tes SQL pour analyse des connexions
-- (n√©cessite import des logs dans une table)

-- Cr√©er une table pour parser les logs
CREATE TABLE IF NOT EXISTS audit_logs (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    timestamp DATETIME,
    server VARCHAR(100),
    user VARCHAR(100),
    host VARCHAR(100),
    connection_id INT,
    event VARCHAR(50),
    database_name VARCHAR(100),
    query TEXT,
    status INT,
    INDEX idx_timestamp (timestamp),
    INDEX idx_user (user),
    INDEX idx_host (host),
    INDEX idx_event (event)
);

-- Utilisateurs se connectant depuis de nouvelles IP (anomalie)
SELECT
    user,
    host,
    COUNT(*) AS new_ip_connections,
    MIN(timestamp) AS first_seen
FROM audit_logs
WHERE event = 'CONNECT'
  AND status = 0
  AND timestamp > DATE_SUB(NOW(), INTERVAL 24 HOUR)
  AND host NOT IN (
      SELECT DISTINCT host
      FROM audit_logs
      WHERE event = 'CONNECT'
        AND status = 0
        AND timestamp < DATE_SUB(NOW(), INTERVAL 7 DAY)
  )
GROUP BY user, host
HAVING new_ip_connections > 1
ORDER BY new_ip_connections DESC;

-- Connexions en dehors des horaires habituels
WITH user_normal_hours AS (
    SELECT
        user,
        HOUR(timestamp) AS hour,
        COUNT(*) AS hour_count
    FROM audit_logs
    WHERE event = 'CONNECT'
      AND status = 0
      AND timestamp BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND DATE_SUB(NOW(), INTERVAL 7 DAY)
    GROUP BY user, hour
    HAVING hour_count > 5  -- Au moins 5 connexions pour √©tablir une baseline
)
SELECT
    al.timestamp,
    al.user,
    al.host,
    HOUR(al.timestamp) AS connection_hour,
    'Unusual hour' AS anomaly_type
FROM audit_logs al
WHERE al.event = 'CONNECT'
  AND al.status = 0
  AND al.timestamp > DATE_SUB(NOW(), INTERVAL 24 HOUR)
  AND NOT EXISTS (
      SELECT 1
      FROM user_normal_hours unh
      WHERE unh.user = al.user
        AND unh.hour = HOUR(al.timestamp)
  )
ORDER BY al.timestamp DESC;

-- V√©locit√© de connexions anormale (trop rapide = script/bot)
SELECT
    user,
    host,
    COUNT(*) AS connections,
    MIN(timestamp) AS first_conn,
    MAX(timestamp) AS last_conn,
    TIMESTAMPDIFF(SECOND, MIN(timestamp), MAX(timestamp)) AS duration_seconds,
    COUNT(*) / GREATEST(TIMESTAMPDIFF(SECOND, MIN(timestamp), MAX(timestamp)), 1) AS conn_per_second
FROM audit_logs
WHERE event = 'CONNECT'
  AND status = 0
  AND timestamp > DATE_SUB(NOW(), INTERVAL 1 HOUR)
GROUP BY user, host
HAVING connections > 10
   AND duration_seconds < 60  -- Plus de 10 connexions en moins de 60 secondes
ORDER BY conn_per_second DESC;
```

---

## Audit des requ√™tes

### D√©tecter les requ√™tes suspectes

```bash
#!/bin/bash
# analyze-suspicious-queries.sh
# D√©tection de requ√™tes potentiellement malveillantes

AUDIT_LOG="/var/log/mysql/audit.log"

echo "=== Analyse des Requ√™tes Suspectes ==="
echo ""

# 1. Tentatives d'injection SQL
echo "1. Tentatives d'injection SQL potentielles"
grep -i "QUERY" "$AUDIT_LOG" | grep -iE "(UNION|SELECT.*FROM.*WHERE.*OR|--|/\*|;.*DROP|;.*DELETE)" | head -20

echo ""

# 2. Requ√™tes avec commentaires SQL (bypass WAF)
echo "2. Requ√™tes avec commentaires (--,/*,#)"
grep -i "QUERY" "$AUDIT_LOG" | grep -E "(--|/\*|\#)" | head -20

echo ""

# 3. Acc√®s √† mysql.user (tentative de vol de hash)
echo "3. Acc√®s √† mysql.user (tentative de vol de credentials)"
grep -i "mysql.user" "$AUDIT_LOG" | grep -i "SELECT"

echo ""

# 4. DROP DATABASE / DROP TABLE
echo "4. Requ√™tes destructives (DROP)"
grep -iE "DROP\s+(DATABASE|TABLE|USER)" "$AUDIT_LOG"

echo ""

# 5. Requ√™tes GRANT/REVOKE (√©l√©vation de privil√®ges)
echo "5. Modifications de privil√®ges (GRANT/REVOKE)"
grep -iE "(GRANT|REVOKE)" "$AUDIT_LOG" | tail -20

echo ""

# 6. Requ√™tes avec UNION (dump de base)
echo "6. UNION-based SQL injection"
grep -i "UNION" "$AUDIT_LOG" | grep -i "SELECT" | head -10

echo ""

# 7. Extraction massive de donn√©es (LIMIT √©lev√©)
echo "7. Extraction massive (LIMIT > 10000)"
grep -i "LIMIT" "$AUDIT_LOG" | awk -F'LIMIT' '{print $2}' | awk '{print $1}' | sort -n | tail -20
```

### D√©tecter les patterns d'attaque

```sql
-- D√©tection d'attaques SQL injection

-- Pattern 1 : UNION-based SQL injection
SELECT
    timestamp,
    user,
    host,
    database_name,
    SUBSTRING(query, 1, 200) AS query_preview
FROM audit_logs
WHERE event LIKE 'QUERY%'
  AND query REGEXP 'UNION.*SELECT'
  AND timestamp > DATE_SUB(NOW(), INTERVAL 24 HOUR)
ORDER BY timestamp DESC;

-- Pattern 2 : Boolean-based blind SQL injection
SELECT
    timestamp,
    user,
    host,
    database_name,
    SUBSTRING(query, 1, 200) AS query_preview
FROM audit_logs
WHERE event LIKE 'QUERY%'
  AND (
      query REGEXP 'OR.*=.*'  -- OR 1=1
      OR query REGEXP 'AND.*=.*'  -- AND 1=1
  )
  AND query REGEXP 'WHERE'
  AND timestamp > DATE_SUB(NOW(), INTERVAL 24 HOUR)
ORDER BY timestamp DESC;

-- Pattern 3 : Time-based blind SQL injection
SELECT
    timestamp,
    user,
    host,
    database_name,
    SUBSTRING(query, 1, 200) AS query_preview
FROM audit_logs
WHERE event LIKE 'QUERY%'
  AND query REGEXP 'SLEEP|BENCHMARK|WAIT FOR DELAY'
  AND timestamp > DATE_SUB(NOW(), INTERVAL 24 HOUR)
ORDER BY timestamp DESC;

-- Pattern 4 : Tentatives d'acc√®s √† information_schema (reconnaissance)
SELECT
    user,
    host,
    COUNT(*) AS access_count,
    GROUP_CONCAT(DISTINCT table_name) AS tables_accessed
FROM (
    SELECT
        user,
        host,
        SUBSTRING_INDEX(SUBSTRING_INDEX(query, 'FROM', -1), ' ', 2) AS table_name
    FROM audit_logs
    WHERE event LIKE 'QUERY%'
      AND database_name = 'information_schema'
      AND timestamp > DATE_SUB(NOW(), INTERVAL 24 HOUR)
) subq
GROUP BY user, host
HAVING access_count > 10  -- Plus de 10 requ√™tes = reconnaissance
ORDER BY access_count DESC;
```

### Audit des requ√™tes sensibles

```sql
-- Requ√™tes DDL (modifications de sch√©ma)
SELECT
    timestamp,
    user,
    host,
    database_name,
    CASE
        WHEN query REGEXP '^CREATE' THEN 'CREATE'
        WHEN query REGEXP '^ALTER' THEN 'ALTER'
        WHEN query REGEXP '^DROP' THEN 'DROP'
        WHEN query REGEXP '^RENAME' THEN 'RENAME'
        WHEN query REGEXP '^TRUNCATE' THEN 'TRUNCATE'
    END AS ddl_type,
    SUBSTRING(query, 1, 200) AS query_preview
FROM audit_logs
WHERE event = 'QUERY_DDL'
  AND timestamp > DATE_SUB(NOW(), INTERVAL 7 DAY)
ORDER BY timestamp DESC
LIMIT 100;

-- Requ√™tes sur tables sensibles (donn√©es personnelles RGPD)
SELECT
    timestamp,
    user,
    host,
    database_name,
    SUBSTRING(query, 1, 150) AS query_preview,
    CASE
        WHEN query REGEXP '^SELECT' THEN 'READ'
        WHEN query REGEXP '^(INSERT|UPDATE|DELETE)' THEN 'MODIFY'
    END AS operation_type
FROM audit_logs
WHERE event LIKE 'QUERY%'
  AND (
      query REGEXP 'users|customers|personal_data|credit_cards|health_records'
  )
  AND timestamp > DATE_SUB(NOW(), INTERVAL 24 HOUR)
ORDER BY timestamp DESC
LIMIT 100;

-- Extractions massives de donn√©es (LIMIT √©lev√© ou sans WHERE)
SELECT
    timestamp,
    user,
    host,
    database_name,
    SUBSTRING(query, 1, 200) AS query_preview,
    CASE
        WHEN query NOT REGEXP 'WHERE' THEN 'NO_WHERE_CLAUSE'
        WHEN query REGEXP 'LIMIT [0-9]{5,}' THEN 'LARGE_LIMIT'
    END AS risk_type
FROM audit_logs
WHERE event LIKE 'QUERY%'
  AND query REGEXP '^SELECT'
  AND (
      query NOT REGEXP 'WHERE'
      OR query REGEXP 'LIMIT [0-9]{5,}'  -- LIMIT > 9999
  )
  AND timestamp > DATE_SUB(NOW(), INTERVAL 24 HOUR)
ORDER BY timestamp DESC
LIMIT 50;

-- Modifications de privil√®ges (GRANT/REVOKE)
SELECT
    timestamp,
    user,
    host,
    database_name,
    query
FROM audit_logs
WHERE event = 'QUERY_DCL'
  AND query REGEXP '^(GRANT|REVOKE)'
  AND timestamp > DATE_SUB(NOW(), INTERVAL 30 DAY)
ORDER BY timestamp DESC;
```

---

## Corr√©lation et enrichissement

### Corr√©lation avec les logs syst√®me

```bash
#!/bin/bash
# correlate-logs.sh
# Corr√©lation entre logs MariaDB et logs syst√®me

AUDIT_LOG="/var/log/mysql/audit.log"
AUTH_LOG="/var/log/auth.log"
SUSPECT_IP="192.168.1.100"

echo "=== Corr√©lation de Logs : IP $SUSPECT_IP ==="
echo ""

# 1. Activit√© dans les logs MariaDB
echo "1. Activit√© MariaDB depuis $SUSPECT_IP"
grep "$SUSPECT_IP" "$AUDIT_LOG" | awk -F',' '{print $1, $3, $6}' | head -20

echo ""

# 2. Tentatives SSH depuis la m√™me IP
echo "2. Tentatives SSH depuis $SUSPECT_IP"
grep "$SUSPECT_IP" "$AUTH_LOG" | grep -i "ssh" | tail -20

echo ""

# 3. Autres services acc√©d√©s
echo "3. Autres services acc√©d√©s depuis $SUSPECT_IP"
sudo grep "$SUSPECT_IP" /var/log/syslog | grep -v "mariadb\|mysql" | tail -20

echo ""

# 4. R√©solution DNS inverse (g√©olocalisation approximative)
echo "4. Informations IP"
host "$SUSPECT_IP"
whois "$SUSPECT_IP" | grep -iE "(country|netname|descr)" | head -5
```

### Enrichissement avec g√©olocalisation

```python
#!/usr/bin/env python3
# geolocate-audit-logs.py
# Enrichir les logs d'audit avec g√©olocalisation

import csv
import geoip2.database
from datetime import datetime

# Charger la base GeoIP2
reader = geoip2.database.Reader('/usr/share/GeoIP/GeoLite2-City.mmdb')

# Parser les logs d'audit
with open('/var/log/mysql/audit.log', 'r') as f:
    for line in f:
        parts = line.strip().split(',')
        if len(parts) >= 9 and parts[5] == 'CONNECT':
            timestamp = parts[0]
            user = parts[2]
            ip = parts[3]
            status = parts[8]

            try:
                # G√©olocaliser l'IP
                response = reader.city(ip)
                country = response.country.name
                city = response.city.name
                lat = response.location.latitude
                lon = response.location.longitude

                # Alerter si connexion depuis pays inhabituel
                if country not in ['France', 'United States', 'Germany']:
                    print(f"‚ö†Ô∏è  UNUSUAL LOCATION: {timestamp} | User: {user} | IP: {ip} | Location: {city}, {country}")

            except Exception as e:
                pass  # IP priv√©e ou non trouv√©e

reader.close()
```

### D√©tection d'anomalies comportementales

```sql
-- Baseline : Volume de requ√™tes normal par utilisateur
CREATE TABLE user_baseline AS
SELECT
    user,
    AVG(daily_queries) AS avg_queries_per_day,
    STDDEV(daily_queries) AS stddev_queries
FROM (
    SELECT
        user,
        DATE(timestamp) AS date,
        COUNT(*) AS daily_queries
    FROM audit_logs
    WHERE event LIKE 'QUERY%'
      AND timestamp BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND DATE_SUB(NOW(), INTERVAL 7 DAY)
    GROUP BY user, DATE(timestamp)
) daily_stats
GROUP BY user;

-- D√©tection : Utilisateurs avec volume anormal (> 3 √©carts-types)
SELECT
    al.user,
    DATE(al.timestamp) AS date,
    COUNT(*) AS queries_today,
    ub.avg_queries_per_day AS expected_avg,
    ub.stddev_queries AS expected_stddev,
    (COUNT(*) - ub.avg_queries_per_day) / NULLIF(ub.stddev_queries, 0) AS z_score
FROM audit_logs al
JOIN user_baseline ub ON al.user = ub.user
WHERE al.event LIKE 'QUERY%'
  AND al.timestamp > DATE_SUB(NOW(), INTERVAL 24 HOUR)
GROUP BY al.user, DATE(al.timestamp), ub.avg_queries_per_day, ub.stddev_queries
HAVING z_score > 3  -- Anomalie : plus de 3 √©carts-types
ORDER BY z_score DESC;
```

---

## Alerting automatique

### Alertes par email

```bash
#!/bin/bash
# alert-suspicious-activity.sh
# Alertes email pour activit√© suspecte

AUDIT_LOG="/var/log/mysql/audit.log"
EMAIL="security@example.com"
THRESHOLD=5

# V√©rifier les √©checs de connexion
FAILED_ATTEMPTS=$(grep -c "CONNECT.*,0$" "$AUDIT_LOG")

if [ "$FAILED_ATTEMPTS" -gt "$THRESHOLD" ]; then
    SUBJECT="‚ö†Ô∏è MariaDB Security Alert: Failed Login Attempts"
    BODY="$FAILED_ATTEMPTS failed login attempts detected in the last hour.

Top offending IPs:
$(awk -F',' '$6 == "CONNECT" && $9 != "0" {print $4}' "$AUDIT_LOG" | sort | uniq -c | sort -rn | head -5)

Review logs: $AUDIT_LOG"

    echo "$BODY" | mail -s "$SUBJECT" "$EMAIL"
fi

# V√©rifier les requ√™tes DROP
DROP_QUERIES=$(grep -c "DROP" "$AUDIT_LOG")

if [ "$DROP_QUERIES" -gt 0 ]; then
    SUBJECT="üö® MariaDB Alert: DROP Statement Detected"
    BODY="DROP statement(s) detected:

$(grep "DROP" "$AUDIT_LOG" | tail -5)

Immediate review required."

    echo "$BODY" | mail -s "$SUBJECT" "$EMAIL"
fi
```

### Alertes Slack

```python
#!/usr/bin/env python3
# slack-alert.py
# Envoyer des alertes Slack pour √©v√©nements critiques

import requests
import json
import sys

SLACK_WEBHOOK = "https://hooks.slack.com/services/YOUR/WEBHOOK/URL"

def send_slack_alert(message, severity="warning"):
    """
    Envoyer une alerte Slack
    severity: info, warning, danger
    """
    color_map = {
        "info": "#36a64f",
        "warning": "#ff9900",
        "danger": "#ff0000"
    }

    payload = {
        "attachments": [
            {
                "color": color_map.get(severity, "#808080"),
                "title": "MariaDB Security Alert",
                "text": message,
                "footer": "MariaDB Audit System",
                "ts": int(time.time())
            }
        ]
    }

    response = requests.post(SLACK_WEBHOOK, json=payload)
    return response.status_code == 200

# Exemple d'utilisation
if __name__ == "__main__":
    if len(sys.argv) > 1:
        message = sys.argv[1]
        severity = sys.argv[2] if len(sys.argv) > 2 else "warning"
        send_slack_alert(message, severity)
```

### Int√©gration avec fail2ban

```ini
# /etc/fail2ban/filter.d/mariadb-auth.conf
# Filtre fail2ban pour MariaDB

[Definition]
failregex = ^.*,CONNECT,.*,<HOST>,.*,(\d+)$
            # Correspond aux √©checs de connexion (status != 0)
ignoreregex =

# /etc/fail2ban/jail.d/mariadb.conf
[mariadb-auth]
enabled = true
port = 3306
filter = mariadb-auth
logpath = /var/log/mysql/audit.log
maxretry = 5
findtime = 600
bantime = 3600
action = iptables-multiport[name=mariadb, port="3306", protocol=tcp]
```

---

## Tableaux de bord et visualisation

### Dashboard Grafana (exemple)

```yaml
# Grafana Dashboard JSON (simplifi√©)
{
  "dashboard": {
    "title": "MariaDB Security Audit",
    "panels": [
      {
        "title": "Connexions par heure",
        "type": "graph",
        "targets": [
          {
            "query": "SELECT timestamp, COUNT(*) FROM audit_logs WHERE event='CONNECT' GROUP BY timestamp"
          }
        ]
      },
      {
        "title": "√âchecs d'authentification",
        "type": "stat",
        "targets": [
          {
            "query": "SELECT COUNT(*) FROM audit_logs WHERE event='CONNECT' AND status != 0"
          }
        ]
      },
      {
        "title": "Top 10 utilisateurs actifs",
        "type": "table",
        "targets": [
          {
            "query": "SELECT user, COUNT(*) as queries FROM audit_logs WHERE event LIKE 'QUERY%' GROUP BY user ORDER BY queries DESC LIMIT 10"
          }
        ]
      },
      {
        "title": "Requ√™tes sensibles (DROP, GRANT)",
        "type": "logs",
        "targets": [
          {
            "query": "SELECT * FROM audit_logs WHERE query REGEXP '^(DROP|GRANT)' ORDER BY timestamp DESC LIMIT 20"
          }
        ]
      }
    ]
  }
}
```

### M√©triques cl√©s √† monitorer

| M√©trique | Seuil | Action |
|----------|-------|--------|
| **√âchecs de connexion** | > 10 en 5 min | Alerte + IP ban (fail2ban) |
| **Connexions depuis nouvelle IP** | Premi√®re fois | Notification |
| **Requ√™tes DROP/TRUNCATE** | Toute occurrence | Alerte imm√©diate |
| **Modifications GRANT** | Toute occurrence | Alerte + investigation |
| **Volume de requ√™tes** | > 3œÉ de la baseline | Alerte anomalie |
| **Acc√®s mysql.user** | Toute lecture | Alerte + blocage potentiel |
| **Requ√™tes avec UNION** | Toute occurrence | Alerte SQL injection |

---

## Investigation forensique

### Sc√©nario : Incident de s√©curit√©

**Contexte** : Alerte pour extraction massive de donn√©es depuis une IP inconnue.

#### √âtape 1 : Identification de l'incident

```bash
#!/bin/bash
# incident-investigation.sh
# Investigation d'un incident de s√©curit√©

AUDIT_LOG="/var/log/mysql/audit.log"
INCIDENT_IP="203.0.113.50"  # IP suspecte
START_TIME="20251213 14:00:00"
END_TIME="20251213 16:00:00"

echo "=== Investigation Forensique ==="
echo "IP suspecte : $INCIDENT_IP"
echo "P√©riode : $START_TIME - $END_TIME"
echo ""

# 1. Timeline compl√®te de l'activit√©
echo "1. Timeline de l'activit√©"
awk -F',' -v ip="$INCIDENT_IP" -v start="$START_TIME" -v end="$END_TIME" '
    $4 == ip && $1 >= start && $1 <= end {
        print $1, $3, $6, substr($8, 1, 100)
    }
' "$AUDIT_LOG" | sort

echo ""

# 2. Utilisateur(s) utilis√©(s)
echo "2. Utilisateur(s) compromis"
awk -F',' -v ip="$INCIDENT_IP" '$4 == ip {print $3}' "$AUDIT_LOG" | sort -u

echo ""

# 3. Bases de donn√©es acc√©d√©es
echo "3. Bases de donn√©es acc√©d√©es"
awk -F',' -v ip="$INCIDENT_IP" '$4 == ip && $7 != "" {print $7}' "$AUDIT_LOG" | sort -u

echo ""

# 4. Requ√™tes SELECT (extraction de donn√©es)
echo "4. Requ√™tes SELECT (extraction)"
awk -F',' -v ip="$INCIDENT_IP" '
    $4 == ip && $8 ~ /^SELECT/ {
        print $1, substr($8, 1, 200)
    }
' "$AUDIT_LOG"

echo ""

# 5. Requ√™tes destructives
echo "5. Requ√™tes destructives (DROP, DELETE, TRUNCATE)"
awk -F',' -v ip="$INCIDENT_IP" '
    $4 == ip && $8 ~ /(DROP|DELETE|TRUNCATE)/ {
        print $1, $8
    }
' "$AUDIT_LOG"

echo ""

# 6. Premi√®re et derni√®re activit√©
echo "6. Dur√©e de l'incident"
awk -F',' -v ip="$INCIDENT_IP" '$4 == ip {print $1}' "$AUDIT_LOG" | sort | awk '
    NR == 1 {first = $0}
    {last = $0}
    END {
        print "Premi√®re activit√© : " first
        print "Derni√®re activit√©  : " last
    }
'
```

#### √âtape 2 : √âvaluation de l'impact

```sql
-- √âvaluation de l'impact de l'incident

-- 1. Nombre de lignes potentiellement extraites
SELECT
    COUNT(*) AS queries_executed,
    SUM(
        CASE
            WHEN query REGEXP 'LIMIT ([0-9]+)'
            THEN CAST(REGEXP_SUBSTR(query, 'LIMIT ([0-9]+)', 1, 1, NULL, 1) AS UNSIGNED)
            ELSE 0
        END
    ) AS estimated_rows_extracted
FROM audit_logs
WHERE host = '203.0.113.50'
  AND event LIKE 'QUERY%'
  AND query REGEXP '^SELECT'
  AND timestamp BETWEEN '2025-12-13 14:00:00' AND '2025-12-13 16:00:00';

-- 2. Tables affect√©es
SELECT
    SUBSTRING_INDEX(SUBSTRING_INDEX(query, 'FROM', -1), ' ', 2) AS table_accessed,
    COUNT(*) AS access_count
FROM audit_logs
WHERE host = '203.0.113.50'
  AND event LIKE 'QUERY%'
  AND query REGEXP '^SELECT'
  AND timestamp BETWEEN '2025-12-13 14:00:00' AND '2025-12-13 16:00:00'
GROUP BY table_accessed
ORDER BY access_count DESC;

-- 3. Modifications de donn√©es (INSERT, UPDATE, DELETE)
SELECT
    timestamp,
    user,
    database_name,
    SUBSTRING(query, 1, 200) AS query_preview,
    CASE
        WHEN query REGEXP '^INSERT' THEN 'INSERT'
        WHEN query REGEXP '^UPDATE' THEN 'UPDATE'
        WHEN query REGEXP '^DELETE' THEN 'DELETE'
    END AS modification_type
FROM audit_logs
WHERE host = '203.0.113.50'
  AND event LIKE 'QUERY%'
  AND query REGEXP '^(INSERT|UPDATE|DELETE)'
  AND timestamp BETWEEN '2025-12-13 14:00:00' AND '2025-12-13 16:00:00'
ORDER BY timestamp;
```

#### √âtape 3 : Rapport d'incident

```bash
#!/bin/bash
# generate-incident-report.sh
# G√©n√©rer un rapport d'incident d√©taill√©

INCIDENT_IP="203.0.113.50"
REPORT_FILE="incident_report_$(date +%Y%m%d_%H%M%S).md"

cat > "$REPORT_FILE" <<EOF
# Rapport d'Incident de S√©curit√© MariaDB

## Informations G√©n√©rales

- **Date de d√©tection** : $(date)
- **IP source** : $INCIDENT_IP
- **Niveau de s√©v√©rit√©** : √âLEV√â
- **Statut** : En investigation

## R√©sum√© de l'Incident

$(whois "$INCIDENT_IP" | grep -iE "(country|netname|descr)" | head -5)

## Timeline

\`\`\`
$(awk -F',' -v ip="$INCIDENT_IP" '$4 == ip {print $1, $3, $6}' /var/log/mysql/audit.log | head -50)
\`\`\`

## Utilisateurs Compromis

$(awk -F',' -v ip="$INCIDENT_IP" '$4 == ip {print $3}' /var/log/mysql/audit.log | sort -u)

## Bases de Donn√©es Acc√©d√©es

$(awk -F',' -v ip="$INCIDENT_IP" '$4 == ip && $7 != "" {print $7}' /var/log/mysql/audit.log | sort -u)

## Requ√™tes Suspectes

\`\`\`sql
$(awk -F',' -v ip="$INCIDENT_IP" '$4 == ip && $8 ~ /(DROP|DELETE|GRANT|UNION)/ {print $8}' /var/log/mysql/audit.log | head -20)
\`\`\`

## Actions Recommand√©es

1. ‚úÖ Bloquer l'IP source imm√©diatement (iptables/fail2ban)
2. ‚úÖ Changer les mots de passe des utilisateurs compromis
3. ‚úÖ R√©voquer les sessions actives
4. ‚ö†Ô∏è Analyser les donn√©es extraites (impact RGPD)
5. ‚ö†Ô∏è Notifier l'√©quipe s√©curit√© et la direction
6. ‚ö†Ô∏è Consid√©rer notification CNIL si donn√©es personnelles

## Signatures d'Investigation

- **Analyste** : _________________________
- **Date** : _________________________
- **Approuv√© par** : _________________________

EOF

echo "Rapport g√©n√©r√© : $REPORT_FILE"
```

---

## R√©ponse automatique aux incidents

### Blocage automatique

```bash
#!/bin/bash
# auto-block-ip.sh
# Blocage automatique des IP suspectes

AUDIT_LOG="/var/log/mysql/audit.log"
THRESHOLD=10
TIMEFRAME=300  # 5 minutes

# D√©tecter les IP avec trop d'√©checs
awk -F',' -v threshold="$THRESHOLD" '
    $6 == "CONNECT" && $9 != "0" {
        ip[$4]++
        if (ip[$4] == threshold) {
            print $4
        }
    }
' "$AUDIT_LOG" | tail -10 | while read IP; do

    # V√©rifier si l'IP n'est pas d√©j√† bloqu√©e
    if ! iptables -L INPUT -n | grep -q "$IP"; then
        echo "$(date): Blocking IP $IP (failed login attempts > $THRESHOLD)"

        # Bloquer avec iptables
        iptables -A INPUT -s "$IP" -p tcp --dport 3306 -j DROP

        # Alerter
        echo "IP $IP blocked due to excessive failed login attempts" | \
            mail -s "üö® MariaDB Auto-Block Alert" security@example.com
    fi
done
```

### R√©vocation de session

```sql
-- Identifier et terminer les sessions suspectes

-- Lister les sessions actives d'une IP suspecte
SELECT
    id,
    user,
    host,
    db,
    command,
    time,
    state,
    info
FROM information_schema.processlist
WHERE host LIKE '203.0.113.50%';

-- Terminer toutes les sessions d'une IP
-- (n√©cessite SUPER privilege)
SELECT
    CONCAT('KILL ', id, ';') AS kill_command
FROM information_schema.processlist
WHERE host LIKE '203.0.113.50%';

-- Ex√©cuter manuellement ou via script
-- KILL 123;
-- KILL 124;
```

---

## Bonnes pratiques d'audit

### 1. R√©tention appropri√©e des logs

```bash
# Politique de r√©tention recommand√©e

# Logs actifs : 7-30 jours (acc√®s rapide)
/var/log/mysql/audit.log

# Archives : 1-7 ans (selon r√©glementation)
/backup/mysql-audit/2025/
  ‚îú‚îÄ‚îÄ audit.log.2025-01.tar.gz.gpg
  ‚îú‚îÄ‚îÄ audit.log.2025-02.tar.gz.gpg
  ‚îî‚îÄ‚îÄ ...

# R√©glementation :
# - PCI-DSS : 1 an minimum, 3 ans recommand√©
# - HIPAA : 6 ans minimum
# - SOX : 7 ans
# - RGPD : Selon n√©cessit√© (documenter)
```

### 2. S√©paration des environnements

```ini
# Production : Audit maximal
[mysqld]
server_audit_events = CONNECT,QUERY,TABLE
server_audit_incl_users = ''  # Tous

# Staging : Audit mod√©r√©
[mysqld]
server_audit_events = CONNECT,QUERY_DDL
server_audit_excl_users = 'test_user'

# D√©veloppement : Audit minimal
[mysqld]
server_audit_events = CONNECT
```

### 3. Tests r√©guliers de d√©tection

```bash
#!/bin/bash
# test-detection.sh
# Tester les r√®gles de d√©tection (simulation d'attaque)

echo "=== Test de D√©tection d'Intrusion ==="
echo ""

# Test 1 : Tentatives de connexion multiples (brute-force)
echo "Test 1 : Brute-force simulation"
for i in {1..10}; do
    mysql -u fake_user -p'wrong_password' -h localhost 2>/dev/null
done
echo "‚úì 10 tentatives √©chou√©es g√©n√©r√©es"

# Test 2 : Requ√™te avec UNION (SQL injection)
echo "Test 2 : SQL injection simulation"
mysql -u test_user -p'test_password' -e "SELECT * FROM test.users WHERE id=1 UNION SELECT 1,2,3" 2>/dev/null
echo "‚úì Requ√™te UNION g√©n√©r√©e"

# Test 3 : Acc√®s mysql.user
echo "Test 3 : Credential theft simulation"
mysql -u test_user -p'test_password' -e "SELECT user, host FROM mysql.user" 2>/dev/null
echo "‚úì Acc√®s mysql.user g√©n√©r√©"

echo ""
echo "V√©rifier les alertes dans les 5 minutes..."
```

---

## ‚úÖ Points cl√©s √† retenir

- **Audit connexions** : D√©tecter brute-force, IP suspectes, horaires anormaux
- **Audit requ√™tes** : Identifier SQL injection, extraction massive, requ√™tes destructives
- **Corr√©lation** : Croiser logs MariaDB, syst√®me, application pour vue compl√®te
- **Alerting** : Email, Slack, PagerDuty pour √©v√©nements critiques temps r√©el
- **Forensique** : Timeline, impact, rapport structur√© pour incidents
- **R√©ponse automatique** : Blocage IP (fail2ban/iptables), r√©vocation sessions
- **M√©triques cl√©s** : √âchecs connexion, volume requ√™tes, acc√®s tables sensibles
- **SIEM** : Splunk, ELK, Graylog pour centralisation et analyse avanc√©e
- **R√©tention** : 1-7 ans selon r√©glementation (PCI-DSS, HIPAA, SOX, RGPD)
- **Tests r√©guliers** : Simulation d'attaques pour valider d√©tection

---

## üîó Ressources et r√©f√©rences

- [üìñ MariaDB Audit Plugin](https://mariadb.com/kb/en/mariadb-audit-plugin/)
- [üìñ OWASP SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection)
- [üìñ NIST Incident Response Guide](https://csrc.nist.gov/publications/detail/sp/800-61/rev-2/final)
- [üìñ fail2ban Documentation](https://www.fail2ban.org/wiki/index.php/Main_Page)
- [Blog : Database Forensics Best Practices](https://mariadb.org/database-forensics-best-practices/)

---


‚è≠Ô∏è [S√©curit√© au niveau application](/10-securite-gestion-utilisateurs/09-securite-niveau-application.md)
