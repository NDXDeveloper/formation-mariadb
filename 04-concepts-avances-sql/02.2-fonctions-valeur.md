ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 4.2.2 Fonctions de valeur (LAG, LEAD, FIRST_VALUE, LAST_VALUE)

> **Niveau** : AvancÃ©
> **DurÃ©e estimÃ©e** : 3-4 heures
> **PrÃ©requis** : MaÃ®trise des Window Functions (section 4.2), fonctions de rang (section 4.2.1)

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- AccÃ©der aux valeurs des lignes prÃ©cÃ©dentes et suivantes avec LAG et LEAD
- RÃ©cupÃ©rer la premiÃ¨re et derniÃ¨re valeur d'une fenÃªtre avec FIRST_VALUE et LAST_VALUE
- Utiliser NTH_VALUE pour accÃ©der Ã  une position spÃ©cifique
- Calculer des variations, croissances et tendances temporelles
- DÃ©tecter des patterns et anomalies dans les sÃ©ries temporelles
- MaÃ®triser les subtilitÃ©s des frames de fenÃªtre avec ces fonctions
- Optimiser les requÃªtes d'analyse comparative

---

## Introduction

Les **fonctions de valeur** (value functions) permettent d'accÃ©der aux **valeurs d'autres lignes** dans la mÃªme fenÃªtre, sans avoir besoin de jointures ou sous-requÃªtes. Elles sont essentielles pour :

- **Analyses temporelles** : Comparer une pÃ©riode avec la prÃ©cÃ©dente/suivante
- **Calculs de variations** : Croissance, dÃ©croissance, taux de variation
- **DÃ©tection de tendances** : Changements de direction, sÃ©ries croissantes
- **Comparaisons** : Ã‰cart par rapport au meilleur/pire de la pÃ©riode
- **Fill forward/backward** : Remplir les valeurs manquantes

### Les cinq fonctions principales

| Fonction | Description | Cas d'usage typique |
|----------|-------------|---------------------|
| **LAG(col, n)** | Valeur n lignes **avant** | Comparer avec pÃ©riode prÃ©cÃ©dente |
| **LEAD(col, n)** | Valeur n lignes **aprÃ¨s** | PrÃ©voir la prochaine valeur |
| **FIRST_VALUE(col)** | **PremiÃ¨re** valeur de la fenÃªtre | Comparer au dÃ©but de pÃ©riode |
| **LAST_VALUE(col)** | **DerniÃ¨re** valeur de la fenÃªtre | Comparer Ã  la fin (âš ï¸ frame!) |
| **NTH_VALUE(col, n)** | **n-iÃ¨me** valeur de la fenÃªtre | MÃ©diane, percentiles |

ğŸ’¡ **Avantage clÃ©** : Ces fonctions Ã©vitent les self-joins complexes et coÃ»teux, amÃ©liorant lisibilitÃ© et performances.

---

## LAG() : AccÃ©der aux valeurs prÃ©cÃ©dentes

### DÃ©finition

`LAG(expression [, offset [, default]])` retourne la valeur de l'expression **n lignes avant** la ligne courante dans la partition, selon l'ordre dÃ©fini par ORDER BY.

### Syntaxe

```sql
LAG(expression [, offset [, default]]) OVER (
    [PARTITION BY partition_expression]
    ORDER BY sort_expression [ASC|DESC]
)
```

**ParamÃ¨tres :**
- `expression` : Colonne ou expression dont on veut rÃ©cupÃ©rer la valeur
- `offset` : Nombre de lignes en arriÃ¨re (dÃ©faut = 1)
- `default` : Valeur retournÃ©e si hors limites (dÃ©faut = NULL)

### Exemple 1 : Variation mensuelle des ventes

```sql
-- Comparer les ventes mensuelles avec le mois prÃ©cÃ©dent
SELECT
    DATE_FORMAT(date_vente, '%Y-%m') AS mois,
    SUM(montant) AS ventes_mois,
    LAG(SUM(montant), 1) OVER (ORDER BY DATE_FORMAT(date_vente, '%Y-%m')) AS ventes_mois_prec,
    -- Variation absolue
    SUM(montant) - LAG(SUM(montant), 1) OVER (ORDER BY DATE_FORMAT(date_vente, '%Y-%m')) AS variation_absolue,
    -- Variation en pourcentage
    ROUND(
        (SUM(montant) - LAG(SUM(montant), 1) OVER (ORDER BY DATE_FORMAT(date_vente, '%Y-%m'))) /
        LAG(SUM(montant), 1) OVER (ORDER BY DATE_FORMAT(date_vente, '%Y-%m')) * 100,
        2
    ) AS variation_pct
FROM ventes
GROUP BY DATE_FORMAT(date_vente, '%Y-%m')
ORDER BY mois;
```

**RÃ©sultat :**
```
| mois    | ventes_mois | ventes_mois_prec | variation_absolue | variation_pct |
|---------|-------------|------------------|-------------------|---------------|
| 2024-01 | 150000      | NULL             | NULL              | NULL          |
| 2024-02 | 165000      | 150000           | 15000             | 10.00         |
| 2024-03 | 158000      | 165000           | -7000             | -4.24         |
| 2024-04 | 180000      | 158000           | 22000             | 13.92         |
| 2024-05 | 195000      | 180000           | 15000             | 8.33          |
```

ğŸ’¡ **Note** : Le premier mois n'a pas de prÃ©cÃ©dent, donc LAG retourne NULL.

### Exemple 2 : LAG avec offset et valeur par dÃ©faut

```sql
-- Comparer avec plusieurs pÃ©riodes prÃ©cÃ©dentes
SELECT
    date_vente,
    produit_id,
    quantite_vendue,
    -- 1 jour avant
    LAG(quantite_vendue, 1, 0) OVER (
        PARTITION BY produit_id
        ORDER BY date_vente
    ) AS ventes_j_moins_1,
    -- 7 jours avant (semaine prÃ©cÃ©dente)
    LAG(quantite_vendue, 7, 0) OVER (
        PARTITION BY produit_id
        ORDER BY date_vente
    ) AS ventes_j_moins_7,
    -- 30 jours avant (mois prÃ©cÃ©dent)
    LAG(quantite_vendue, 30, 0) OVER (
        PARTITION BY produit_id
        ORDER BY date_vente
    ) AS ventes_j_moins_30
FROM ventes_quotidiennes
WHERE produit_id = 42
ORDER BY date_vente DESC
LIMIT 10;
```

ğŸ’¡ **Utilisation du default** : `0` au lieu de NULL facilite les calculs sans avoir Ã  gÃ©rer IFNULL.

### Exemple 3 : DÃ©tection de changements

```sql
-- Identifier les changements de prix d'un produit
SELECT
    produit_id,
    date_modification,
    prix_nouveau,
    LAG(prix_nouveau, 1) OVER (
        PARTITION BY produit_id
        ORDER BY date_modification
    ) AS prix_precedent,
    prix_nouveau - LAG(prix_nouveau, 1) OVER (
        PARTITION BY produit_id
        ORDER BY date_modification
    ) AS variation_prix,
    CASE
        WHEN prix_nouveau > LAG(prix_nouveau, 1) OVER (
            PARTITION BY produit_id ORDER BY date_modification
        ) THEN 'ğŸ“ˆ Augmentation'
        WHEN prix_nouveau < LAG(prix_nouveau, 1) OVER (
            PARTITION BY produit_id ORDER BY date_modification
        ) THEN 'ğŸ“‰ RÃ©duction'
        ELSE 'â¡ï¸ Stable'
    END AS tendance
FROM historique_prix
ORDER BY produit_id, date_modification;
```

### Cas d'usage : Streak (sÃ©ries consÃ©cutives)

```sql
-- Compter le nombre de jours consÃ©cutifs avec ventes > 1000â‚¬
WITH ventes_jour AS (
    SELECT
        date_vente,
        SUM(montant) AS total_jour,
        CASE
            WHEN SUM(montant) > 1000 THEN 1
            ELSE 0
        END AS objectif_atteint
    FROM ventes
    GROUP BY date_vente
),
ventes_avec_lag AS (
    SELECT
        date_vente,
        total_jour,
        objectif_atteint,
        LAG(objectif_atteint, 1, 0) OVER (ORDER BY date_vente) AS objectif_hier,
        -- Nouvelle sÃ©rie si objectif atteint aujourd'hui mais pas hier
        CASE
            WHEN objectif_atteint = 1 AND LAG(objectif_atteint, 1, 0) OVER (ORDER BY date_vente) = 0
            THEN 1
            ELSE 0
        END AS nouvelle_serie
    FROM ventes_jour
),
series_numerotees AS (
    SELECT
        date_vente,
        total_jour,
        objectif_atteint,
        SUM(nouvelle_serie) OVER (ORDER BY date_vente) AS numero_serie
    FROM ventes_avec_lag
)
SELECT
    numero_serie,
    MIN(date_vente) AS debut_serie,
    MAX(date_vente) AS fin_serie,
    COUNT(*) AS duree_jours,
    AVG(total_jour) AS ventes_moyenne_serie
FROM series_numerotees
WHERE objectif_atteint = 1
GROUP BY numero_serie
ORDER BY duree_jours DESC;
```

---

## LEAD() : AccÃ©der aux valeurs suivantes

### DÃ©finition

`LEAD(expression [, offset [, default]])` retourne la valeur de l'expression **n lignes aprÃ¨s** la ligne courante, selon l'ordre dÃ©fini par ORDER BY. C'est le miroir de LAG().

### Syntaxe

```sql
LEAD(expression [, offset [, default]]) OVER (
    [PARTITION BY partition_expression]
    ORDER BY sort_expression [ASC|DESC]
)
```

### Exemple 4 : PrÃ©vision et rÃ©alitÃ©

```sql
-- Comparer les prÃ©visions avec les ventes rÃ©elles du mois suivant
SELECT
    mois,
    prevision_ventes,
    ventes_reelles,
    LEAD(ventes_reelles, 1) OVER (ORDER BY mois) AS ventes_mois_suivant,
    -- Ã‰cart entre prÃ©vision et rÃ©alitÃ©
    ventes_reelles - prevision_ventes AS ecart_prevision,
    -- Exactitude de la prÃ©vision (%)
    ROUND(
        (1 - ABS(ventes_reelles - prevision_ventes) / ventes_reelles) * 100,
        2
    ) AS exactitude_pct
FROM previsions_mensuelles
ORDER BY mois;
```

### Exemple 5 : FenÃªtre d'observation (LAG + LEAD)

```sql
-- Analyser une valeur dans son contexte (avant et aprÃ¨s)
SELECT
    date_mesure,
    temperature,
    -- Contexte temporel
    LAG(temperature, 1) OVER (ORDER BY date_mesure) AS temp_avant,
    LEAD(temperature, 1) OVER (ORDER BY date_mesure) AS temp_apres,
    -- Variation par rapport au contexte
    temperature - LAG(temperature, 1) OVER (ORDER BY date_mesure) AS variation_depuis_avant,
    LEAD(temperature, 1) OVER (ORDER BY date_mesure) - temperature AS variation_vers_apres,
    -- DÃ©tection de pic
    CASE
        WHEN temperature > LAG(temperature, 1) OVER (ORDER BY date_mesure)
         AND temperature > LEAD(temperature, 1) OVER (ORDER BY date_mesure)
        THEN 'ğŸ”º Pic local'
        WHEN temperature < LAG(temperature, 1) OVER (ORDER BY date_mesure)
         AND temperature < LEAD(temperature, 1) OVER (ORDER BY date_mesure)
        THEN 'ğŸ”» Creux local'
        ELSE 'â¡ï¸ Transition'
    END AS pattern
FROM mesures_meteo
ORDER BY date_mesure;
```

### Exemple 6 : Calcul de durÃ©e entre Ã©vÃ©nements

```sql
-- Temps Ã©coulÃ© entre chaque commande d'un client
SELECT
    client_id,
    commande_id,
    date_commande,
    LEAD(date_commande, 1) OVER (
        PARTITION BY client_id
        ORDER BY date_commande
    ) AS date_commande_suivante,
    DATEDIFF(
        LEAD(date_commande, 1) OVER (
            PARTITION BY client_id
            ORDER BY date_commande
        ),
        date_commande
    ) AS jours_avant_prochaine_commande,
    -- Segmentation du client selon frÃ©quence
    CASE
        WHEN DATEDIFF(
            LEAD(date_commande, 1) OVER (PARTITION BY client_id ORDER BY date_commande),
            date_commande
        ) <= 30 THEN 'ğŸŸ¢ TrÃ¨s actif'
        WHEN DATEDIFF(
            LEAD(date_commande, 1) OVER (PARTITION BY client_id ORDER BY date_commande),
            date_commande
        ) <= 90 THEN 'ğŸŸ¡ Actif'
        WHEN DATEDIFF(
            LEAD(date_commande, 1) OVER (PARTITION BY client_id ORDER BY date_commande),
            date_commande
        ) <= 180 THEN 'ğŸŸ  Inactif'
        ELSE 'ğŸ”´ Perdu'
    END AS statut_engagement
FROM commandes
ORDER BY client_id, date_commande;
```

### Cas d'usage : DÃ©tection de churn

```sql
-- Identifier les clients qui n'ont pas commandÃ© depuis longtemps
WITH derniere_activite AS (
    SELECT
        client_id,
        MAX(date_commande) AS derniere_commande,
        LEAD(MAX(date_commande), 1, CURRENT_DATE) OVER (
            PARTITION BY client_id
            ORDER BY MAX(date_commande)
        ) AS date_reference
    FROM commandes
    GROUP BY client_id
)
SELECT
    client_id,
    derniere_commande,
    DATEDIFF(CURRENT_DATE, derniere_commande) AS jours_inactivite,
    CASE
        WHEN DATEDIFF(CURRENT_DATE, derniere_commande) > 365
            THEN 'â›” Churned'
        WHEN DATEDIFF(CURRENT_DATE, derniere_commande) > 180
            THEN 'âš ï¸ Ã€ risque Ã©levÃ©'
        WHEN DATEDIFF(CURRENT_DATE, derniere_commande) > 90
            THEN 'âš¡ Ã€ risque'
        ELSE 'âœ… Actif'
    END AS statut_churn
FROM derniere_activite
WHERE DATEDIFF(CURRENT_DATE, derniere_commande) > 90
ORDER BY jours_inactivite DESC;
```

---

## FIRST_VALUE() : PremiÃ¨re valeur de la fenÃªtre

### DÃ©finition

`FIRST_VALUE(expression)` retourne la **premiÃ¨re valeur** de l'expression dans la fenÃªtre, selon l'ordre dÃ©fini par ORDER BY.

### Syntaxe

```sql
FIRST_VALUE(expression) OVER (
    [PARTITION BY partition_expression]
    ORDER BY sort_expression [ASC|DESC]
    [frame_clause]
)
```

### Exemple 7 : Comparaison au meilleur/premier

```sql
-- Comparer chaque employÃ© au meilleur salaire de son dÃ©partement
SELECT
    departement_id,
    nom,
    salaire,
    FIRST_VALUE(salaire) OVER (
        PARTITION BY departement_id
        ORDER BY salaire DESC
    ) AS salaire_max_dept,
    FIRST_VALUE(nom) OVER (
        PARTITION BY departement_id
        ORDER BY salaire DESC
    ) AS nom_meilleur_salaire,
    -- Ã‰cart par rapport au maximum
    salaire - FIRST_VALUE(salaire) OVER (
        PARTITION BY departement_id
        ORDER BY salaire DESC
    ) AS ecart_vs_max,
    -- Ratio par rapport au maximum
    ROUND(
        salaire / FIRST_VALUE(salaire) OVER (
            PARTITION BY departement_id
            ORDER BY salaire DESC
        ) * 100,
        2
    ) AS pct_du_max
FROM employes
ORDER BY departement_id, salaire DESC;
```

**RÃ©sultat :**
```
| departement_id | nom    | salaire | salaire_max_dept | nom_meilleur_salaire | ecart_vs_max | pct_du_max |
|----------------|--------|---------|------------------|----------------------|--------------|------------|
| 1              | Alice  | 120000  | 120000           | Alice                | 0            | 100.00     |
| 1              | Bob    | 95000   | 120000           | Alice                | -25000       | 79.17      |
| 1              | Claire | 85000   | 120000           | Alice                | -35000       | 70.83      |
| 2              | David  | 110000  | 110000           | David                | 0            | 100.00     |
| 2              | Eve    | 90000   | 110000           | David                | -20000       | 81.82      |
```

### Exemple 8 : Ã‰volution par rapport au dÃ©but de pÃ©riode

```sql
-- Croissance par rapport au premier jour du mois
SELECT
    date_vente,
    montant_cumule,
    FIRST_VALUE(montant_cumule) OVER (
        PARTITION BY DATE_FORMAT(date_vente, '%Y-%m')
        ORDER BY date_vente
    ) AS montant_debut_mois,
    -- Croissance depuis le dÃ©but du mois
    montant_cumule - FIRST_VALUE(montant_cumule) OVER (
        PARTITION BY DATE_FORMAT(date_vente, '%Y-%m')
        ORDER BY date_vente
    ) AS croissance_mois,
    -- Pourcentage de croissance
    ROUND(
        (montant_cumule - FIRST_VALUE(montant_cumule) OVER (
            PARTITION BY DATE_FORMAT(date_vente, '%Y-%m')
            ORDER BY date_vente
        )) / FIRST_VALUE(montant_cumule) OVER (
            PARTITION BY DATE_FORMAT(date_vente, '%Y-%m')
            ORDER BY date_vente
        ) * 100,
        2
    ) AS pct_croissance_mois
FROM (
    SELECT
        date_vente,
        SUM(montant) OVER (
            PARTITION BY DATE_FORMAT(date_vente, '%Y-%m')
            ORDER BY date_vente
        ) AS montant_cumule
    FROM ventes
) cumuls
ORDER BY date_vente;
```

### Cas d'usage : Normalisation par rapport Ã  la baseline

```sql
-- Index de prix par rapport au prix de base (premier prix connu)
SELECT
    produit_id,
    date_prix,
    prix,
    FIRST_VALUE(prix) OVER (
        PARTITION BY produit_id
        ORDER BY date_prix
    ) AS prix_base,
    FIRST_VALUE(date_prix) OVER (
        PARTITION BY produit_id
        ORDER BY date_prix
    ) AS date_prix_base,
    -- Index (base 100)
    ROUND(
        (prix / FIRST_VALUE(prix) OVER (
            PARTITION BY produit_id
            ORDER BY date_prix
        )) * 100,
        2
    ) AS indice_prix_base_100
FROM historique_prix
ORDER BY produit_id, date_prix;
```

---

## LAST_VALUE() : DerniÃ¨re valeur de la fenÃªtre

### DÃ©finition

`LAST_VALUE(expression)` retourne la **derniÃ¨re valeur** de l'expression dans la fenÃªtre. âš ï¸ **PIÃˆGE MAJEUR** : Par dÃ©faut, la fenÃªtre s'arrÃªte Ã  la ligne courante, pas Ã  la fin de la partition !

### Syntaxe et frame important

```sql
LAST_VALUE(expression) OVER (
    [PARTITION BY partition_expression]
    ORDER BY sort_expression [ASC|DESC]
    [ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING]  -- âš ï¸ CRUCIAL !
)
```

### âš ï¸ PIÃˆGE : Frame par dÃ©faut de LAST_VALUE

```sql
-- âŒ MAUVAIS : Frame par dÃ©faut (RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
SELECT
    nom,
    salaire,
    LAST_VALUE(salaire) OVER (
        PARTITION BY departement_id
        ORDER BY salaire
    ) AS salaire_max  -- âŒ Retourne le salaire ACTUEL, pas le max !
FROM employes;

-- âœ… BON : SpÃ©cifier le frame explicitement
SELECT
    nom,
    salaire,
    LAST_VALUE(salaire) OVER (
        PARTITION BY departement_id
        ORDER BY salaire
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS salaire_max  -- âœ… Retourne bien le salaire max de la partition
FROM employes;

-- ğŸ¯ ALTERNATIVE : Utiliser FIRST_VALUE avec ORDER BY inversÃ©
SELECT
    nom,
    salaire,
    FIRST_VALUE(salaire) OVER (
        PARTITION BY departement_id
        ORDER BY salaire DESC  -- Ordre inversÃ©
    ) AS salaire_max  -- âœ… Plus simple et sans piÃ¨ge
FROM employes;
```

ğŸ’¡ **Recommandation** : PrivilÃ©giez FIRST_VALUE avec ORDER BY inversÃ© pour Ã©viter les erreurs.

### Exemple 9 : Comparaison dÃ©but/fin de pÃ©riode

```sql
-- Comparer le prix actuel au dernier prix connu
SELECT
    produit_id,
    date_prix,
    prix,
    FIRST_VALUE(prix) OVER (
        PARTITION BY produit_id
        ORDER BY date_prix
    ) AS premier_prix,
    LAST_VALUE(prix) OVER (
        PARTITION BY produit_id
        ORDER BY date_prix
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS dernier_prix,
    -- Variation totale sur la pÃ©riode
    LAST_VALUE(prix) OVER (
        PARTITION BY produit_id
        ORDER BY date_prix
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) - FIRST_VALUE(prix) OVER (
        PARTITION BY produit_id
        ORDER BY date_prix
    ) AS variation_totale
FROM historique_prix
ORDER BY produit_id, date_prix;
```

### Exemple 10 : Objectif de fin de pÃ©riode

```sql
-- Progression vers l'objectif mensuel
SELECT
    DATE_FORMAT(date_vente, '%Y-%m') AS mois,
    date_vente,
    SUM(montant) OVER (
        PARTITION BY DATE_FORMAT(date_vente, '%Y-%m')
        ORDER BY date_vente
    ) AS ventes_cumulees,
    -- Objectif du mois (derniÃ¨re valeur = total du mois)
    LAST_VALUE(SUM(montant)) OVER (
        PARTITION BY DATE_FORMAT(date_vente, '%Y-%m')
        ORDER BY date_vente
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS objectif_mois,
    -- Taux de rÃ©alisation
    ROUND(
        SUM(montant) OVER (
            PARTITION BY DATE_FORMAT(date_vente, '%Y-%m')
            ORDER BY date_vente
        ) / LAST_VALUE(SUM(montant)) OVER (
            PARTITION BY DATE_FORMAT(date_vente, '%Y-%m')
            ORDER BY date_vente
            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) * 100,
        2
    ) AS taux_realisation_pct
FROM ventes
GROUP BY DATE_FORMAT(date_vente, '%Y-%m'), date_vente
ORDER BY mois, date_vente;
```

---

## NTH_VALUE() : N-iÃ¨me valeur de la fenÃªtre

### DÃ©finition

`NTH_VALUE(expression, n)` retourne la **n-iÃ¨me valeur** de l'expression dans la fenÃªtre (1-indexed).

### Syntaxe

```sql
NTH_VALUE(expression, n) OVER (
    [PARTITION BY partition_expression]
    ORDER BY sort_expression [ASC|DESC]
    [frame_clause]
)
```

### Exemple 11 : AccÃ¨s Ã  des positions spÃ©cifiques

```sql
-- Top 3 des salaires par dÃ©partement + mÃ©diane
SELECT DISTINCT
    departement_id,
    -- Top 3
    FIRST_VALUE(salaire) OVER w AS salaire_1er,
    NTH_VALUE(salaire, 2) OVER w AS salaire_2eme,
    NTH_VALUE(salaire, 3) OVER w AS salaire_3eme,
    -- MÃ©diane (position centrale)
    NTH_VALUE(salaire, CAST(COUNT(*) OVER (PARTITION BY departement_id) / 2 AS UNSIGNED)) OVER w AS salaire_median_approx
FROM employes
WINDOW w AS (
    PARTITION BY departement_id
    ORDER BY salaire DESC
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
)
ORDER BY departement_id;
```

### Exemple 12 : Quartiles avec NTH_VALUE

```sql
-- Calculer les quartiles pour chaque dÃ©partement
WITH employes_ordonnes AS (
    SELECT
        departement_id,
        salaire,
        ROW_NUMBER() OVER (PARTITION BY departement_id ORDER BY salaire) AS position,
        COUNT(*) OVER (PARTITION BY departement_id) AS nb_total
    FROM employes
)
SELECT DISTINCT
    departement_id,
    -- Q1 (25%)
    NTH_VALUE(salaire, GREATEST(1, CAST(nb_total * 0.25 AS UNSIGNED))) OVER w AS q1,
    -- Q2 (50% = mÃ©diane)
    NTH_VALUE(salaire, GREATEST(1, CAST(nb_total * 0.50 AS UNSIGNED))) OVER w AS q2_mediane,
    -- Q3 (75%)
    NTH_VALUE(salaire, GREATEST(1, CAST(nb_total * 0.75 AS UNSIGNED))) OVER w AS q3
FROM employes_ordonnes
WINDOW w AS (
    PARTITION BY departement_id
    ORDER BY salaire
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
);
```

---

## Combinaisons et patterns avancÃ©s

### Pattern 1 : Fill Forward (propagation de la derniÃ¨re valeur connue)

```sql
-- Remplir les valeurs manquantes avec la derniÃ¨re valeur connue
WITH donnees_complete AS (
    SELECT
        date_mesure,
        temperature,
        LAST_VALUE(temperature IGNORE NULLS) OVER (
            ORDER BY date_mesure
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) AS temperature_remplie
    FROM mesures_meteo
)
SELECT
    date_mesure,
    COALESCE(temperature, temperature_remplie) AS temperature_finale
FROM donnees_complete
ORDER BY date_mesure;
```

ğŸ’¡ **Note** : MariaDB supporte `IGNORE NULLS` pour LAG, LEAD, FIRST_VALUE, LAST_VALUE et NTH_VALUE depuis la version 10.2.2.

### Pattern 2 : Running comparison (comparaison glissante)

```sql
-- Comparer chaque jour avec les 3 jours prÃ©cÃ©dents et suivants
SELECT
    date_vente,
    montant,
    -- Comparaisons prÃ©cÃ©dentes
    LAG(montant, 1) OVER w AS j_moins_1,
    LAG(montant, 2) OVER w AS j_moins_2,
    LAG(montant, 3) OVER w AS j_moins_3,
    -- Comparaisons suivantes
    LEAD(montant, 1) OVER w AS j_plus_1,
    LEAD(montant, 2) OVER w AS j_plus_2,
    LEAD(montant, 3) OVER w AS j_plus_3,
    -- Moyenne de la fenÃªtre (j-3 Ã  j+3)
    AVG(montant) OVER (
        ORDER BY date_vente
        ROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING
    ) AS moyenne_fenetre_7j
FROM ventes_quotidiennes
WINDOW w AS (ORDER BY date_vente)
ORDER BY date_vente;
```

### Pattern 3 : DÃ©tection de tendances complexes

```sql
-- Identifier les tendances haussiÃ¨res continues (3+ jours)
WITH tendances AS (
    SELECT
        date_vente,
        montant,
        LAG(montant, 1) OVER w AS montant_j_moins_1,
        LAG(montant, 2) OVER w AS montant_j_moins_2,
        LEAD(montant, 1) OVER w AS montant_j_plus_1,
        -- DÃ©tection de tendance
        CASE
            WHEN montant > LAG(montant, 1) OVER w
             AND LAG(montant, 1) OVER w > LAG(montant, 2) OVER w
            THEN 'ğŸ“ˆ Hausse continue (3j)'
            WHEN montant < LAG(montant, 1) OVER w
             AND LAG(montant, 1) OVER w < LAG(montant, 2) OVER w
            THEN 'ğŸ“‰ Baisse continue (3j)'
            WHEN montant > LAG(montant, 1) OVER w
             AND montant > LEAD(montant, 1) OVER w
            THEN 'ğŸ”º Pic local'
            WHEN montant < LAG(montant, 1) OVER w
             AND montant < LEAD(montant, 1) OVER w
            THEN 'ğŸ”» Creux local'
            ELSE 'â¡ï¸ Autre'
        END AS pattern
    FROM ventes_quotidiennes
    WINDOW w AS (ORDER BY date_vente)
)
SELECT *
FROM tendances
WHERE pattern LIKE '%continue%' OR pattern LIKE '%local%'
ORDER BY date_vente DESC;
```

### Pattern 4 : Calcul de CAGR (Compound Annual Growth Rate)

```sql
-- Taux de croissance annuel composÃ©
WITH premieres_dernieres_valeurs AS (
    SELECT
        produit_id,
        FIRST_VALUE(prix) OVER w AS prix_initial,
        FIRST_VALUE(YEAR(date_prix)) OVER w AS annee_initiale,
        LAST_VALUE(prix) OVER w AS prix_final,
        LAST_VALUE(YEAR(date_prix)) OVER w AS annee_finale
    FROM historique_prix
    WINDOW w AS (
        PARTITION BY produit_id
        ORDER BY date_prix
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    )
)
SELECT DISTINCT
    produit_id,
    prix_initial,
    prix_final,
    annee_finale - annee_initiale AS nb_annees,
    -- CAGR = (valeur_finale / valeur_initiale)^(1/nb_annÃ©es) - 1
    ROUND(
        (POW(prix_final / prix_initial, 1.0 / (annee_finale - annee_initiale)) - 1) * 100,
        2
    ) AS cagr_pct
FROM premieres_dernieres_valeurs
WHERE annee_finale > annee_initiale
ORDER BY cagr_pct DESC;
```

---

## Optimisation et performances

### 1. RÃ©utilisation des dÃ©finitions de fenÃªtre (WINDOW clause)

```sql
-- âŒ RÃ‰PÃ‰TITIF : MÃªme fenÃªtre dÃ©finie 4 fois
SELECT
    nom,
    salaire,
    LAG(salaire, 1) OVER (PARTITION BY departement_id ORDER BY date_embauche) AS salaire_prec,
    LEAD(salaire, 1) OVER (PARTITION BY departement_id ORDER BY date_embauche) AS salaire_suiv,
    FIRST_VALUE(salaire) OVER (PARTITION BY departement_id ORDER BY date_embauche) AS premier_salaire,
    LAST_VALUE(salaire) OVER (
        PARTITION BY departement_id
        ORDER BY date_embauche
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS dernier_salaire
FROM employes;

-- âœ… OPTIMISÃ‰ : Une seule dÃ©finition rÃ©utilisÃ©e
SELECT
    nom,
    salaire,
    LAG(salaire, 1) OVER w AS salaire_prec,
    LEAD(salaire, 1) OVER w AS salaire_suiv,
    FIRST_VALUE(salaire) OVER w AS premier_salaire,
    LAST_VALUE(salaire) OVER w_full AS dernier_salaire
FROM employes
WINDOW
    w AS (PARTITION BY departement_id ORDER BY date_embauche),
    w_full AS (w ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING);
```

### 2. Limitation du scope

```sql
-- Filtrer AVANT d'appliquer les fonctions de valeur
SELECT
    date_vente,
    montant,
    LAG(montant, 1) OVER (ORDER BY date_vente) AS montant_precedent
FROM ventes
WHERE date_vente >= CURRENT_DATE - INTERVAL 1 YEAR  -- RÃ©duit le dataset
  AND magasin_id = 42
ORDER BY date_vente;
```

### 3. Indexation appropriÃ©e

```sql
-- Index pour optimiser PARTITION BY et ORDER BY
CREATE INDEX idx_ventes_date ON ventes(produit_id, date_vente);

-- RequÃªte optimisÃ©e par l'index
SELECT
    produit_id,
    date_vente,
    prix,
    LAG(prix, 1) OVER (PARTITION BY produit_id ORDER BY date_vente) AS prix_precedent
FROM ventes
WHERE produit_id IN (10, 20, 30);
```

### 4. Ã‰viter les calculs redondants avec CTE

```sql
-- âœ… Calculer une seule fois, rÃ©utiliser plusieurs fois
WITH ventes_avec_lag AS (
    SELECT
        date_vente,
        montant,
        LAG(montant, 1) OVER (ORDER BY date_vente) AS montant_prec
    FROM ventes_quotidiennes
)
SELECT
    date_vente,
    montant,
    montant_prec,
    montant - montant_prec AS variation,
    CASE
        WHEN montant > montant_prec THEN 'ğŸ“ˆ'
        WHEN montant < montant_prec THEN 'ğŸ“‰'
        ELSE 'â¡ï¸'
    END AS tendance,
    ROUND((montant - montant_prec) / montant_prec * 100, 2) AS variation_pct
FROM ventes_avec_lag
WHERE montant_prec IS NOT NULL
ORDER BY date_vente;
```

---

## PiÃ¨ges et erreurs courantes

### 1. Oublier ORDER BY

```sql
-- âŒ ERREUR : Pas de ORDER BY
SELECT
    nom,
    salaire,
    LAG(salaire, 1) OVER (PARTITION BY departement_id) AS salaire_prec
FROM employes;
-- RÃ©sultat : Ordre imprÃ©visible, LAG retourne n'importe quelle valeur !

-- âœ… CORRECT : Toujours spÃ©cifier ORDER BY
SELECT
    nom,
    salaire,
    LAG(salaire, 1) OVER (
        PARTITION BY departement_id
        ORDER BY date_embauche  -- Ordre explicite
    ) AS salaire_prec
FROM employes;
```

### 2. Confusion avec le frame de LAST_VALUE

```sql
-- âŒ PIÃˆGE : LAST_VALUE retourne la valeur courante
SELECT
    date_vente,
    montant,
    LAST_VALUE(montant) OVER (ORDER BY date_vente) AS dernier_montant
FROM ventes;
-- RÃ©sultat : dernier_montant = montant (valeur courante)

-- âœ… SOLUTION 1 : Frame explicite
SELECT
    date_vente,
    montant,
    LAST_VALUE(montant) OVER (
        ORDER BY date_vente
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS dernier_montant
FROM ventes;

-- âœ… SOLUTION 2 : FIRST_VALUE inversÃ© (plus simple)
SELECT
    date_vente,
    montant,
    FIRST_VALUE(montant) OVER (ORDER BY date_vente DESC) AS dernier_montant
FROM ventes;
```

### 3. NULL dans les calculs de variation

```sql
-- âš ï¸ ATTENTION : LAG retourne NULL pour la premiÃ¨re ligne
SELECT
    date_vente,
    montant,
    LAG(montant, 1) OVER (ORDER BY date_vente) AS montant_prec,
    montant - LAG(montant, 1) OVER (ORDER BY date_vente) AS variation  -- NULL pour 1Ã¨re ligne
FROM ventes;

-- âœ… SOLUTIONS :
-- Option 1 : Utiliser COALESCE
SELECT
    date_vente,
    montant,
    COALESCE(montant - LAG(montant, 1) OVER (ORDER BY date_vente), 0) AS variation
FROM ventes;

-- Option 2 : SpÃ©cifier une valeur par dÃ©faut dans LAG
SELECT
    date_vente,
    montant,
    montant - LAG(montant, 1, montant) OVER (ORDER BY date_vente) AS variation  -- dÃ©faut = montant
FROM ventes;

-- Option 3 : Filtrer les NULL
SELECT
    date_vente,
    montant,
    variation
FROM (
    SELECT
        date_vente,
        montant,
        montant - LAG(montant, 1) OVER (ORDER BY date_vente) AS variation
    FROM ventes
) t
WHERE variation IS NOT NULL;
```

### 4. Offset hors limites

```sql
-- âš ï¸ LAG/LEAD avec offset > taille de la partition
SELECT
    produit_id,
    date_vente,
    montant,
    LAG(montant, 365) OVER (PARTITION BY produit_id ORDER BY date_vente) AS montant_annee_prec
FROM ventes
WHERE produit_id = 42;
-- Si le produit n'existe que depuis 6 mois, retourne NULL

-- âœ… SOLUTION : VÃ©rifier la disponibilitÃ© des donnÃ©es ou utiliser default
SELECT
    produit_id,
    date_vente,
    montant,
    LAG(montant, 365, 0) OVER (
        PARTITION BY produit_id
        ORDER BY date_vente
    ) AS montant_annee_prec,
    -- Indicateur de disponibilitÃ©
    CASE
        WHEN LAG(date_vente, 365) OVER (PARTITION BY produit_id ORDER BY date_vente) IS NOT NULL
        THEN 'âœ… DonnÃ©es complÃ¨tes'
        ELSE 'âš ï¸ DonnÃ©es partielles'
    END AS statut_donnees
FROM ventes
WHERE produit_id = 42;
```

---

## âœ… Points clÃ©s Ã  retenir

- **LAG(col, n)** accÃ¨de aux valeurs **n lignes avant** â†’ calculs de variations, comparaisons pÃ©riodiques
- **LEAD(col, n)** accÃ¨de aux valeurs **n lignes aprÃ¨s** â†’ prÃ©visions, analyse de transitions
- **FIRST_VALUE(col)** retourne la **premiÃ¨re valeur** de la fenÃªtre â†’ comparaison au dÃ©but, baseline
- **LAST_VALUE(col)** retourne la **derniÃ¨re valeur** âš ï¸ **PIÃˆGE** : Frame par dÃ©faut = ligne courante, pas fin de partition !
- **NTH_VALUE(col, n)** retourne la **n-iÃ¨me valeur** â†’ accÃ¨s Ã  positions spÃ©cifiques, quartiles
- **ORDER BY est obligatoire** pour un rÃ©sultat dÃ©terministe avec ces fonctions
- Toujours spÃ©cifier le **frame explicitement** pour LAST_VALUE : `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`
- Utiliser **IGNORE NULLS** pour sauter les valeurs NULL (disponible depuis MariaDB 10.2.2)
- **Valeur par dÃ©faut** dans LAG/LEAD Ã©vite les NULL : `LAG(col, 1, 0)`
- Combiner LAG et LEAD permet des **analyses contextuelles** (avant, actuel, aprÃ¨s)
- Utiliser la clause **WINDOW** pour rÃ©utiliser les dÃ©finitions et optimiser les performances
- Ces fonctions **Ã©vitent les self-joins** coÃ»teux et amÃ©liorent la lisibilitÃ©
- Pour LAST_VALUE, prÃ©fÃ©rer **FIRST_VALUE avec ORDER BY DESC** (plus simple, moins d'erreurs)

---

## ğŸ”— Ressources et rÃ©fÃ©rences

- [ğŸ“– Documentation officielle MariaDB - Window Functions](https://mariadb.com/kb/en/window-functions/)
- [ğŸ“– LAG()](https://mariadb.com/kb/en/lag/)
- [ğŸ“– LEAD()](https://mariadb.com/kb/en/lead/)
- [ğŸ“– FIRST_VALUE()](https://mariadb.com/kb/en/first_value/)
- [ğŸ“– LAST_VALUE()](https://mariadb.com/kb/en/last_value/)
- [ğŸ“– NTH_VALUE()](https://mariadb.com/kb/en/nth_value/)
- [ğŸ“– IGNORE NULLS](https://mariadb.com/kb/en/ignore-nulls/)

**Lectures complÃ©mentaires :**
- [Modern SQL - LAG and LEAD](https://modern-sql.com/feature/lag-and-lead)
- [Window Functions Deep Dive](https://use-the-index-luke.com/sql/partial-results/window-functions)

---

## â¡ï¸ Section suivante

**[4.2.3 Frames de fenÃªtre (ROWS, RANGE, GROUPS)](/04-concepts-avances-sql/02.3-frames-fenetre.md)** : Approfondir les frames de fenÃªtre pour les moyennes mobiles, cumuls, et calculs sur des plages personnalisÃ©es.

---

**Note pratique** : Les fonctions LAG et LEAD sont parmi les plus utilisÃ©es en production pour l'analyse de sÃ©ries temporelles. MaÃ®triser la gestion des NULL et des frames est essentiel pour Ã©viter les bugs subtils. Testez toujours vos requÃªtes avec les cas limites (premiÃ¨re/derniÃ¨re ligne, valeurs NULL, partitions de petite taille) ! ğŸ“Š

â­ï¸ [Frames de fenÃªtre (ROWS, RANGE, GROUPS)](/04-concepts-avances-sql/02.3-frames-fenetre.md)
