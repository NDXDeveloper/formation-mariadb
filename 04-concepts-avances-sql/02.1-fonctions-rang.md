üîù Retour au [Sommaire](/SOMMAIRE.md)

# 4.2.1 Fonctions de rang (ROW_NUMBER, RANK, DENSE_RANK, NTILE)

> **Niveau** : Avanc√©
> **Dur√©e estim√©e** : 2-3 heures
> **Pr√©requis** : Ma√Ætrise des Window Functions (section 4.2), PARTITION BY, ORDER BY

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Distinguer les quatre fonctions de rang et leurs comportements sp√©cifiques
- Choisir la fonction appropri√©e selon le cas d'usage
- Impl√©menter des requ√™tes Top N efficaces
- Utiliser NTILE pour cr√©er des quartiles, d√©ciles et percentiles
- D√©tecter et g√©rer les doublons avec les fonctions de rang
- Optimiser les performances des classements

---

## Introduction

Les **fonctions de rang** sont un sous-ensemble des Window Functions qui attribuent un **rang ou num√©ro** √† chaque ligne dans une partition, selon un ordre d√©fini. Elles sont essentielles pour :

- **Classements et Top N** : Identifier les meilleurs/pires √©l√©ments
- **Pagination** : Diviser les r√©sultats en pages
- **Analyse de distribution** : Quartiles, d√©ciles, percentiles
- **D√©tection de doublons** : Identifier les occurrences multiples
- **Segmentation** : Diviser les donn√©es en groupes √©quitables

MariaDB supporte quatre fonctions de rang principales :

| Fonction | Comportement avec √©galit√©s | Cas d'usage principal |
|----------|---------------------------|----------------------|
| **ROW_NUMBER()** | Num√©ro unique s√©quentiel | Pagination, num√©rotation unique |
| **RANK()** | Saute les rangs apr√®s √©galit√© | Classements sportifs, concours |
| **DENSE_RANK()** | Rangs cons√©cutifs sans saut | Cat√©gorisation, niveaux |
| **NTILE(n)** | D√©coupe en n groupes | Quartiles, d√©ciles, segmentation |

---

## ROW_NUMBER() : Num√©rotation s√©quentielle unique

### D√©finition

`ROW_NUMBER()` attribue un **num√©ro s√©quentiel unique** √† chaque ligne dans la partition, selon l'ordre d√©fini par ORDER BY. M√™me en cas d'√©galit√©, chaque ligne re√ßoit un num√©ro diff√©rent.

### Syntaxe

```sql
ROW_NUMBER() OVER (
    [PARTITION BY partition_expression]
    ORDER BY sort_expression [ASC|DESC]
)
```

### Exemple 1 : Num√©rotation simple

```sql
-- Num√©roter tous les employ√©s par ordre de salaire d√©croissant
SELECT
    nom,
    departement,
    salaire,
    ROW_NUMBER() OVER (ORDER BY salaire DESC) AS numero_ligne
FROM employes
ORDER BY numero_ligne;
```

**R√©sultat :**
```
| nom      | departement | salaire | numero_ligne |
|----------|-------------|---------|--------------|
| Alice    | Direction   | 120000  | 1            |
| Bob      | IT          | 95000   | 2            |
| Claire   | IT          | 95000   | 3            | -- M√™me salaire que Bob, mais num√©ro diff√©rent
| David    | Marketing   | 75000   | 4            |
| Eve      | RH          | 68000   | 5            |
```

üí° **Observation** : Bob et Claire ont le m√™me salaire, mais re√ßoivent des num√©ros diff√©rents (2 et 3). L'ordre entre eux est **non d√©terministe** si ORDER BY ne les distingue pas.

### Exemple 2 : Num√©rotation par partition

```sql
-- Num√©roter les employ√©s dans chaque d√©partement
SELECT
    departement,
    nom,
    salaire,
    ROW_NUMBER() OVER (
        PARTITION BY departement
        ORDER BY salaire DESC
    ) AS rang_departement
FROM employes
ORDER BY departement, rang_departement;
```

**R√©sultat :**
```
| departement | nom      | salaire | rang_departement |
|-------------|----------|---------|------------------|
| Direction   | Alice    | 120000  | 1                |
| IT          | Bob      | 95000   | 1                |
| IT          | Claire   | 95000   | 2                |
| IT          | Frank    | 72000   | 3                |
| Marketing   | David    | 75000   | 1                |
| Marketing   | Grace    | 68000   | 2                |
| RH          | Eve      | 68000   | 1                |
```

### Cas d'usage : Pagination efficace

ROW_NUMBER() est id√©al pour impl√©menter une pagination performante :

```sql
-- Page 2 (lignes 11 √† 20) des produits les plus vendus
WITH produits_numeros AS (
    SELECT
        produit_id,
        nom,
        quantite_vendue,
        ROW_NUMBER() OVER (ORDER BY quantite_vendue DESC) AS num_ligne
    FROM produits
)
SELECT produit_id, nom, quantite_vendue
FROM produits_numeros
WHERE num_ligne BETWEEN 11 AND 20;
```

üí° **Avantage** : Plus efficace que `OFFSET/LIMIT` pour les grandes pages, car le num√©ro de ligne est calcul√© une seule fois.

### Cas d'usage : Suppression de doublons

```sql
-- Supprimer les doublons en gardant la ligne la plus r√©cente
WITH doublons AS (
    SELECT
        id,
        email,
        date_creation,
        ROW_NUMBER() OVER (
            PARTITION BY email
            ORDER BY date_creation DESC
        ) AS rang
    FROM utilisateurs
)
DELETE FROM utilisateurs
WHERE id IN (
    SELECT id
    FROM doublons
    WHERE rang > 1  -- Garde uniquement la premi√®re occurrence (la plus r√©cente)
);
```

‚ö†Ô∏è **Attention** : L'ordre en cas d'√©galit√© est non d√©terministe. Pour un r√©sultat stable, ajoutez une colonne unique dans ORDER BY :

```sql
ROW_NUMBER() OVER (
    PARTITION BY email
    ORDER BY date_creation DESC, id DESC  -- id comme tie-breaker
) AS rang
```

---

## RANK() : Classement avec sauts

### D√©finition

`RANK()` attribue un **rang** √† chaque ligne, mais en cas d'√©galit√©, **plusieurs lignes peuvent avoir le m√™me rang**. Les rangs suivants sont alors **saut√©s** pour tenir compte du nombre de lignes ex-aequo.

### Syntaxe

```sql
RANK() OVER (
    [PARTITION BY partition_expression]
    ORDER BY sort_expression [ASC|DESC]
)
```

### Exemple 3 : Classement avec √©galit√©s

```sql
-- Classement des employ√©s par salaire
SELECT
    nom,
    salaire,
    RANK() OVER (ORDER BY salaire DESC) AS rang
FROM employes
ORDER BY rang;
```

**R√©sultat :**
```
| nom      | salaire | rang |
|----------|---------|------|
| Alice    | 120000  | 1    |
| Bob      | 95000   | 2    |
| Claire   | 95000   | 2    | -- Ex-aequo avec Bob
| Frank    | 90000   | 4    | -- Le rang 3 est saut√© !
| David    | 75000   | 5    |
| Eve      | 68000   | 6    |
| Grace    | 68000   | 6    | -- Ex-aequo avec Eve
| Hugo     | 55000   | 8    | -- Le rang 7 est saut√© !
```

üí° **Caract√©ristique cl√©** : Bob et Claire sont tous deux rang 2. Frank obtient le rang 4 (pas 3), car deux personnes occupent le rang 2.

### Cas d'usage : Classements sportifs

RANK() est parfait pour les classements sportifs o√π les ex-aequo sont possibles :

```sql
-- Classement d'une course avec temps ex-aequo
SELECT
    coureur,
    temps_secondes,
    RANK() OVER (ORDER BY temps_secondes ASC) AS position
FROM resultats_course
ORDER BY position;
```

**R√©sultat :**
```
| coureur   | temps_secondes | position |
|-----------|----------------|----------|
| Usain     | 9.58           | 1        |
| Tyson     | 9.69           | 2        |
| Asafa     | 9.72           | 3        |
| Justin    | 9.72           | 3        | -- Ex-aequo bronze
| Yohan     | 9.79           | 5        | -- 4√®me position saut√©e
```

### Cas d'usage : Top N avec √©galit√©s

```sql
-- Top 5 des produits les plus vendus (incluant les ex-aequo)
WITH classement AS (
    SELECT
        produit_id,
        nom,
        quantite_vendue,
        RANK() OVER (ORDER BY quantite_vendue DESC) AS rang
    FROM produits
)
SELECT produit_id, nom, quantite_vendue, rang
FROM classement
WHERE rang <= 5
ORDER BY rang;
```

üí° **R√©sultat** : Si les produits en 5√®me position sont ex-aequo, tous seront inclus (vous pourriez obtenir 6 ou 7 lignes).

---

## DENSE_RANK() : Classement sans sauts

### D√©finition

`DENSE_RANK()` attribue un **rang cons√©cutif** √† chaque ligne. En cas d'√©galit√©, plusieurs lignes ont le m√™me rang, mais **aucun rang n'est saut√©** dans la s√©quence.

### Syntaxe

```sql
DENSE_RANK() OVER (
    [PARTITION BY partition_expression]
    ORDER BY sort_expression [ASC|DESC]
)
```

### Exemple 4 : Comparaison RANK vs DENSE_RANK

```sql
-- Comparaison des trois fonctions de classement
SELECT
    nom,
    salaire,
    ROW_NUMBER() OVER (ORDER BY salaire DESC) AS row_num,
    RANK() OVER (ORDER BY salaire DESC) AS rank,
    DENSE_RANK() OVER (ORDER BY salaire DESC) AS dense_rank
FROM employes
ORDER BY salaire DESC;
```

**R√©sultat :**
```
| nom      | salaire | row_num | rank | dense_rank |
|----------|---------|---------|------|------------|
| Alice    | 120000  | 1       | 1    | 1          |
| Bob      | 95000   | 2       | 2    | 2          |
| Claire   | 95000   | 3       | 2    | 2          | -- M√™me rang
| Frank    | 90000   | 4       | 4    | 3          | -- RANK saute 3, DENSE_RANK non
| David    | 75000   | 5       | 5    | 4          |
| Eve      | 68000   | 6       | 6    | 5          |
| Grace    | 68000   | 7       | 6    | 5          | -- M√™me rang
| Hugo     | 55000   | 8       | 8    | 6          | -- RANK saute 7, DENSE_RANK non
```

üí° **Diff√©rence cl√©** :
- **RANK()** : 1, 2, 2, **4**, 5, 6, 6, **8** (sauts de rangs)
- **DENSE_RANK()** : 1, 2, 2, **3**, 4, 5, 5, **6** (aucun saut)

### Cas d'usage : Cat√©gorisation par niveaux

DENSE_RANK() est id√©al pour cr√©er des cat√©gories ou niveaux sans trous :

```sql
-- Attribuer un niveau de performance (1 = meilleur)
SELECT
    vendeur,
    ventes_totales,
    DENSE_RANK() OVER (ORDER BY ventes_totales DESC) AS niveau_performance,
    CASE
        WHEN DENSE_RANK() OVER (ORDER BY ventes_totales DESC) = 1 THEN 'ü•á Elite'
        WHEN DENSE_RANK() OVER (ORDER BY ventes_totales DESC) = 2 THEN 'ü•à Excellence'
        WHEN DENSE_RANK() OVER (ORDER BY ventes_totales DESC) = 3 THEN 'ü•â Tr√®s bien'
        WHEN DENSE_RANK() OVER (ORDER BY ventes_totales DESC) <= 5 THEN '‚≠ê Bien'
        ELSE '‚úì Standard'
    END AS badge
FROM vendeurs
ORDER BY niveau_performance;
```

### Cas d'usage : Top N strict (nombre de valeurs distinctes)

```sql
-- Top 3 des salaires distincts (pas des employ√©s)
WITH salaires_distincts AS (
    SELECT
        salaire,
        DENSE_RANK() OVER (ORDER BY salaire DESC) AS rang_salaire
    FROM employes
    GROUP BY salaire
)
SELECT DISTINCT
    e.nom,
    e.salaire,
    s.rang_salaire
FROM employes e
JOIN salaires_distincts s ON e.salaire = s.salaire
WHERE s.rang_salaire <= 3
ORDER BY s.rang_salaire, e.nom;
```

üí° **R√©sultat** : Exactement 3 niveaux de salaire, mais possiblement plus de 3 employ√©s si plusieurs ont le m√™me salaire.

---

## NTILE(n) : D√©coupage en groupes √©quitables

### D√©finition

`NTILE(n)` divise les lignes en **n groupes (buckets) de taille approximativement √©gale** et attribue un num√©ro de groupe (1 √† n) √† chaque ligne. Si le nombre de lignes n'est pas divisible par n, les premiers groupes auront une ligne de plus.

### Syntaxe

```sql
NTILE(nombre_groupes) OVER (
    [PARTITION BY partition_expression]
    ORDER BY sort_expression [ASC|DESC]
)
```

### Exemple 5 : Quartiles (4 groupes)

```sql
-- Diviser les employ√©s en 4 quartiles par salaire
SELECT
    nom,
    salaire,
    NTILE(4) OVER (ORDER BY salaire DESC) AS quartile
FROM employes
ORDER BY quartile, salaire DESC;
```

**R√©sultat avec 20 employ√©s :**
```
| nom      | salaire | quartile |
|----------|---------|----------|
| Alice    | 120000  | 1        | -- Q1 : 25% sup√©rieurs (5 employ√©s)
| Bob      | 115000  | 1        |
| Claire   | 110000  | 1        |
| David    | 105000  | 1        |
| Eve      | 100000  | 1        |
| Frank    | 95000   | 2        | -- Q2 (5 employ√©s)
| Grace    | 90000   | 2        |
| ...      | ...     | ...      |
| Tom      | 45000   | 4        | -- Q4 : 25% inf√©rieurs (5 employ√©s)
| Uma      | 40000   | 4        |
```

üí° **R√®gle de distribution** : Avec 20 lignes et NTILE(4), chaque quartile contient exactement 5 lignes (20/4).

### Exemple 6 : Distribution in√©gale

```sql
-- Diviser 23 employ√©s en 4 quartiles
SELECT
    nom,
    salaire,
    NTILE(4) OVER (ORDER BY salaire DESC) AS quartile,
    COUNT(*) OVER (PARTITION BY NTILE(4) OVER (ORDER BY salaire DESC)) AS taille_quartile
FROM employes
ORDER BY quartile, salaire DESC;
```

**R√©sultat avec 23 employ√©s :**
- **Q1** : 6 lignes (23/4 = 5.75, arrondi √† 6)
- **Q2** : 6 lignes
- **Q3** : 6 lignes
- **Q4** : 5 lignes (le dernier groupe a une ligne de moins)

‚ö†Ô∏è **Important** : NTILE distribue les lignes **physiquement**, pas par valeur. Des lignes avec la m√™me valeur peuvent se retrouver dans des groupes diff√©rents.

### Cas d'usage : Analyse ABC (Pareto)

```sql
-- Classification ABC des produits selon le chiffre d'affaires
WITH classification AS (
    SELECT
        produit_id,
        nom,
        chiffre_affaires,
        NTILE(10) OVER (ORDER BY chiffre_affaires DESC) AS decile
    FROM produits
)
SELECT
    produit_id,
    nom,
    chiffre_affaires,
    decile,
    CASE
        WHEN decile <= 2 THEN 'A (Top 20% - Produits strat√©giques)'
        WHEN decile <= 5 THEN 'B (30% - Produits importants)'
        ELSE 'C (50% - Produits standards)'
    END AS categorie_abc
FROM classification
ORDER BY chiffre_affaires DESC;
```

### Cas d'usage : Segmentation client (RFM)

```sql
-- Segmentation RFM (Recency, Frequency, Monetary)
WITH rfm_scores AS (
    SELECT
        client_id,
        nom,
        DATEDIFF(CURRENT_DATE, MAX(date_achat)) AS recency_jours,
        COUNT(*) AS frequency,
        SUM(montant) AS monetary,
        -- Scores sur 5 (1 = meilleur)
        NTILE(5) OVER (ORDER BY MAX(date_achat) DESC) AS score_recency,
        NTILE(5) OVER (ORDER BY COUNT(*) DESC) AS score_frequency,
        NTILE(5) OVER (ORDER BY SUM(montant) DESC) AS score_monetary
    FROM commandes
    GROUP BY client_id, nom
)
SELECT
    client_id,
    nom,
    recency_jours,
    frequency,
    monetary,
    CONCAT(score_recency, score_frequency, score_monetary) AS rfm_score,
    CASE
        WHEN score_recency <= 2 AND score_frequency <= 2 AND score_monetary <= 2
            THEN 'üëë Champions'
        WHEN score_recency <= 3 AND score_frequency <= 3 AND score_monetary <= 3
            THEN 'üíé Clients fid√®les'
        WHEN score_recency >= 4
            THEN '‚ö†Ô∏è √Ä risque'
        ELSE '‚úì Clients r√©guliers'
    END AS segment
FROM rfm_scores
ORDER BY rfm_score;
```

### Cas d'usage : Percentiles personnalis√©s

```sql
-- Calculer les percentiles 25, 50 (m√©diane), 75, 90, 95, 99
WITH percentiles AS (
    SELECT
        salaire,
        NTILE(100) OVER (ORDER BY salaire) AS percentile
    FROM employes
)
SELECT
    'P25' AS percentile,
    MIN(salaire) AS valeur
FROM percentiles WHERE percentile <= 25
UNION ALL
SELECT 'P50 (M√©diane)', MIN(salaire) FROM percentiles WHERE percentile <= 50
UNION ALL
SELECT 'P75', MIN(salaire) FROM percentiles WHERE percentile <= 75
UNION ALL
SELECT 'P90', MIN(salaire) FROM percentiles WHERE percentile <= 90
UNION ALL
SELECT 'P95', MIN(salaire) FROM percentiles WHERE percentile <= 95
UNION ALL
SELECT 'P99', MIN(salaire) FROM percentiles WHERE percentile <= 99;
```

---

## Comparaison d√©taill√©e des fonctions de rang

### Tableau r√©capitulatif

| Crit√®re | ROW_NUMBER() | RANK() | DENSE_RANK() | NTILE(n) |
|---------|-------------|--------|--------------|----------|
| **Num√©ros uniques** | ‚úÖ Oui | ‚ùå Non (ex-aequo) | ‚ùå Non (ex-aequo) | ‚ùå Non |
| **Ex-aequo possibles** | ‚ùå Non | ‚úÖ Oui | ‚úÖ Oui | ‚úÖ Oui |
| **Sauts de rangs** | N/A | ‚úÖ Oui | ‚ùå Non | N/A |
| **Groupes √©quitables** | ‚ùå Non | ‚ùå Non | ‚ùå Non | ‚úÖ Oui |
| **D√©terminisme** | ‚ö†Ô∏è Non (√©galit√©s) | ‚ö†Ô∏è Non (√©galit√©s) | ‚ö†Ô∏è Non (√©galit√©s) | ‚ö†Ô∏è Non (√©galit√©s) |
| **Cas d'usage principal** | Pagination, ID | Classements | Cat√©gories | Quartiles, segments |

### Exemple comparatif complet

```sql
-- Dataset : 10 employ√©s avec salaires vari√©s
WITH employes_test AS (
    SELECT 'Alice' AS nom, 100000 AS salaire UNION ALL
    SELECT 'Bob', 95000 UNION ALL
    SELECT 'Claire', 95000 UNION ALL  -- Ex-aequo avec Bob
    SELECT 'David', 90000 UNION ALL
    SELECT 'Eve', 85000 UNION ALL
    SELECT 'Frank', 85000 UNION ALL   -- Ex-aequo avec Eve
    SELECT 'Grace', 85000 UNION ALL   -- Ex-aequo avec Eve et Frank
    SELECT 'Hugo', 75000 UNION ALL
    SELECT 'Iris', 70000 UNION ALL
    SELECT 'Jack', 65000
)
SELECT
    nom,
    salaire,
    ROW_NUMBER() OVER (ORDER BY salaire DESC) AS row_number,
    RANK() OVER (ORDER BY salaire DESC) AS rank,
    DENSE_RANK() OVER (ORDER BY salaire DESC) AS dense_rank,
    NTILE(4) OVER (ORDER BY salaire DESC) AS ntile_4
FROM employes_test
ORDER BY salaire DESC, nom;
```

**R√©sultat :**
```
| nom    | salaire | row_number | rank | dense_rank | ntile_4 |
|--------|---------|------------|------|------------|---------|
| Alice  | 100000  | 1          | 1    | 1          | 1       |
| Bob    | 95000   | 2          | 2    | 2          | 1       |
| Claire | 95000   | 3          | 2    | 2          | 1       | -- NTILE : 3 lignes dans Q1
| David  | 90000   | 4          | 4    | 3          | 2       |
| Eve    | 85000   | 5          | 5    | 4          | 2       |
| Frank  | 85000   | 6          | 5    | 4          | 2       | -- NTILE : 3 lignes dans Q2
| Grace  | 85000   | 7          | 5    | 4          | 3       | -- 3 ex-aequo r√©partis diff√©remment
| Hugo   | 75000   | 8          | 8    | 5          | 3       |
| Iris   | 70000   | 9          | 9    | 6          | 4       |
| Jack   | 65000   | 10         | 10   | 7          | 4       |
```

üí° **Observations** :
- **ROW_NUMBER** : 1-10 s√©quentiellement, chaque ligne unique
- **RANK** : Sauts apr√®s ex-aequo (1, 2, 2, **4**, 5, 5, 5, **8**, 9, 10)
- **DENSE_RANK** : Pas de saut (1, 2, 2, **3**, 4, 4, 4, **5**, 6, 7)
- **NTILE(4)** : R√©partit en 4 groupes (3+3+2+2), m√™me valeur peut √™tre dans des groupes diff√©rents (Eve/Frank dans Q2, Grace dans Q3)

---

## Choix de la fonction selon le cas d'usage

### Arbre de d√©cision

```
Avez-vous besoin d'un num√©ro unique pour chaque ligne ?
‚îÇ
‚îú‚îÄ Oui ‚Üí ROW_NUMBER()
‚îÇ         Exemple : Pagination, suppression doublons
‚îÇ
‚îî‚îÄ Non ‚Üí Voulez-vous g√©rer les ex-aequo ?
          ‚îÇ
          ‚îú‚îÄ Non (groupes de taille √©gale) ‚Üí NTILE(n)
          ‚îÇ                                    Exemple : Quartiles, segments
          ‚îÇ
          ‚îî‚îÄ Oui ‚Üí Comment traiter les ex-aequo ?
                    ‚îÇ
                    ‚îú‚îÄ M√™me rang + sauter suivants ‚Üí RANK()
                    ‚îÇ                                 Exemple : Classement sportif
                    ‚îÇ
                    ‚îî‚îÄ M√™me rang + continuer ‚Üí DENSE_RANK()
                                                Exemple : Niveaux, cat√©gories
```

### Guide pratique

| Objectif | Fonction recommand√©e | Justification |
|----------|---------------------|---------------|
| **Pagination** | ROW_NUMBER() | Num√©ros uniques n√©cessaires |
| **Top 10 produits** | RANK() ou DENSE_RANK() | Inclure les ex-aequo en 10√®me position |
| **Classement olympique** | RANK() | Tradition : 1er, 2√ó2√®me, 4√®me (pas de 3√®me) |
| **Niveaux de fid√©lit√©** | DENSE_RANK() | Bronze, Argent, Or sans trous |
| **Quartiles de revenus** | NTILE(4) | Division √©quitable en 4 groupes |
| **D√©tection doublons** | ROW_NUMBER() | Garder une seule occurrence |
| **ABC (Pareto)** | NTILE(10) | Top 20% (2 d√©ciles), puis 30%, puis 50% |
| **Lead scoring** | NTILE(10) puis grouper | Chaud (9-10), Ti√®de (6-8), Froid (1-5) |

---

## Cas d'usage avanc√©s

### 1. Top N par cat√©gorie avec minimum

```sql
-- Top 3 produits par cat√©gorie, seulement si 3 produits ou plus existent
WITH top_produits AS (
    SELECT
        categorie,
        nom,
        prix,
        quantite_vendue,
        RANK() OVER (PARTITION BY categorie ORDER BY quantite_vendue DESC) AS rang,
        COUNT(*) OVER (PARTITION BY categorie) AS nb_produits_categorie
    FROM produits
)
SELECT
    categorie,
    nom,
    prix,
    quantite_vendue,
    rang
FROM top_produits
WHERE rang <= 3
  AND nb_produits_categorie >= 3  -- Exclure les cat√©gories avec moins de 3 produits
ORDER BY categorie, rang;
```

### 2. D√©tection de doublons avec priorit√© complexe

```sql
-- Identifier les doublons d'email en privil√©giant :
-- 1. Compte v√©rifi√© > non v√©rifi√©
-- 2. Plus r√©cent
-- 3. ID le plus √©lev√© (tie-breaker)
WITH doublons_priorises AS (
    SELECT
        id,
        email,
        email_verifie,
        date_creation,
        ROW_NUMBER() OVER (
            PARTITION BY LOWER(TRIM(email))  -- Normaliser l'email
            ORDER BY
                email_verifie DESC,  -- V√©rifi√© en premier
                date_creation DESC,  -- Plus r√©cent
                id DESC              -- ID le plus √©lev√©
        ) AS priorite
    FROM utilisateurs
)
SELECT
    id,
    email,
    email_verifie,
    date_creation,
    CASE
        WHEN priorite = 1 THEN '‚úÖ √Ä conserver'
        ELSE '‚ùå Doublon √† supprimer'
    END AS action
FROM doublons_priorises
WHERE priorite > 1  -- Afficher uniquement les doublons
ORDER BY email, priorite;
```

### 3. Pagination avec total de pages

```sql
-- Pagination avec m√©tadonn√©es (page 2, 10 r√©sultats par page)
WITH resultats_pagines AS (
    SELECT
        produit_id,
        nom,
        prix,
        ROW_NUMBER() OVER (ORDER BY prix DESC) AS numero_ligne,
        COUNT(*) OVER () AS total_resultats
    FROM produits
    WHERE categorie = 'Smartphones'
)
SELECT
    produit_id,
    nom,
    prix,
    numero_ligne,
    total_resultats,
    CEIL(total_resultats / 10.0) AS total_pages,
    CEIL(numero_ligne / 10.0) AS page_actuelle
FROM resultats_pagines
WHERE numero_ligne BETWEEN 11 AND 20  -- Page 2 (lignes 11-20)
ORDER BY numero_ligne;
```

### 4. Fen√™tre glissante avec rang

```sql
-- Top 3 des ventes sur les 30 derniers jours glissants
WITH ventes_30j AS (
    SELECT
        date_vente,
        produit_id,
        nom_produit,
        SUM(montant) OVER (
            PARTITION BY produit_id
            ORDER BY date_vente
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) AS ventes_30j_glissant,
        RANK() OVER (
            PARTITION BY date_vente
            ORDER BY SUM(montant) OVER (
                PARTITION BY produit_id
                ORDER BY date_vente
                ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
            ) DESC
        ) AS rang_jour
    FROM ventes
)
SELECT
    date_vente,
    produit_id,
    nom_produit,
    ventes_30j_glissant,
    rang_jour
FROM ventes_30j
WHERE rang_jour <= 3
ORDER BY date_vente DESC, rang_jour;
```

### 5. M√©dianes par groupe

```sql
-- Calculer la m√©diane des salaires par d√©partement
-- (MariaDB n'a pas de fonction MEDIAN() native)
WITH salaires_rangs AS (
    SELECT
        departement_id,
        nom,
        salaire,
        ROW_NUMBER() OVER (PARTITION BY departement_id ORDER BY salaire) AS rang_asc,
        COUNT(*) OVER (PARTITION BY departement_id) AS nb_employes
    FROM employes
)
SELECT
    departement_id,
    AVG(salaire) AS mediane_salaire
FROM salaires_rangs
WHERE rang_asc IN (
    FLOOR((nb_employes + 1) / 2.0),  -- M√©diane basse si nb pair
    CEIL((nb_employes + 1) / 2.0)    -- M√©diane haute si nb pair
)
GROUP BY departement_id;
```

---

## Optimisation et performances

### 1. Indexation

Les colonnes utilis√©es dans PARTITION BY et ORDER BY doivent √™tre index√©es :

```sql
-- Index composite optimal pour cette requ√™te
CREATE INDEX idx_produits_cat_ventes ON produits(categorie, quantite_vendue DESC);

-- Requ√™te optimis√©e
SELECT
    categorie,
    nom,
    quantite_vendue,
    RANK() OVER (PARTITION BY categorie ORDER BY quantite_vendue DESC) AS rang
FROM produits
WHERE categorie IN ('Smartphones', 'Ordinateurs')
ORDER BY categorie, rang;
```

üí° **Conseil** : L'index composite (categorie, quantite_vendue DESC) permet :
- Un filtre efficace sur categorie
- Un tri rapide dans chaque partition

### 2. Limiter le scope avec WHERE

Filtrez les donn√©es **avant** d'appliquer les fonctions de fen√™tre :

```sql
-- ‚ùå MAUVAIS : Fen√™tre sur toutes les donn√©es puis filtre
SELECT *
FROM (
    SELECT
        nom,
        salaire,
        RANK() OVER (ORDER BY salaire DESC) AS rang
    FROM employes
) t
WHERE rang <= 10;

-- ‚úÖ BON : Filtre d'abord (si possible)
SELECT
    nom,
    salaire,
    RANK() OVER (ORDER BY salaire DESC) AS rang
FROM employes
WHERE departement_id = 5  -- R√©duit le dataset
  AND date_embauche >= '2020-01-01'
HAVING rang <= 10;
```

### 3. √âviter les fonctions de rang imbriqu√©es

```sql
-- ‚ùå CO√õTEUX : Double passage
SELECT
    nom,
    salaire,
    RANK() OVER (ORDER BY salaire DESC) AS rang_global,
    RANK() OVER (
        ORDER BY RANK() OVER (PARTITION BY departement_id ORDER BY salaire DESC)
    ) AS rang_bizarre
FROM employes;

-- ‚úÖ PR√âF√âRABLE : Utiliser une CTE
WITH rangs_dept AS (
    SELECT
        nom,
        salaire,
        departement_id,
        RANK() OVER (PARTITION BY departement_id ORDER BY salaire DESC) AS rang_dept
    FROM employes
)
SELECT
    nom,
    salaire,
    rang_dept,
    RANK() OVER (ORDER BY rang_dept) AS rang_des_rangs
FROM rangs_dept;
```

### 4. NTILE vs calculs manuels

Pour de petits nombres de groupes, NTILE() est optimal. Pour des calculs complexes :

```sql
-- Alternative √† NTILE pour percentiles exacts
SELECT
    nom,
    salaire,
    PERCENT_RANK() OVER (ORDER BY salaire) * 100 AS percentile_exact
FROM employes;
```

---

## Pi√®ges courants et solutions

### 1. ORDER BY manquant ou ambigu

‚ùå **ERREUR** : Sans ORDER BY, l'ordre est non d√©terministe
```sql
-- R√©sultat impr√©visible !
SELECT
    nom,
    salaire,
    ROW_NUMBER() OVER (PARTITION BY departement_id) AS rang
FROM employes;
```

‚úÖ **SOLUTION** : Toujours sp√©cifier ORDER BY
```sql
SELECT
    nom,
    salaire,
    ROW_NUMBER() OVER (
        PARTITION BY departement_id
        ORDER BY salaire DESC, nom  -- nom comme tie-breaker
    ) AS rang
FROM employes;
```

### 2. Confusion entre RANK et DENSE_RANK

```sql
-- Si vous voulez exactement 3 niveaux distincts de salaire
-- ‚ùå RANK() peut donner 1, 2, 2, 4, 5... (plus de 3 valeurs)
-- ‚úÖ DENSE_RANK() donnera 1, 2, 2, 3, 3... (exactement 3 valeurs)

SELECT
    nom,
    salaire,
    DENSE_RANK() OVER (ORDER BY salaire DESC) AS niveau
FROM employes
WHERE DENSE_RANK() OVER (ORDER BY salaire DESC) <= 3;  -- ‚ùå Invalide !

-- ‚úÖ Solution avec CTE
WITH niveaux AS (
    SELECT
        nom,
        salaire,
        DENSE_RANK() OVER (ORDER BY salaire DESC) AS niveau
    FROM employes
)
SELECT nom, salaire, niveau
FROM niveaux
WHERE niveau <= 3;
```

### 3. NTILE avec ORDER BY insuffisant

```sql
-- ‚ùå PROBL√àME : Ex-aequo r√©partis arbitrairement
SELECT
    nom,
    score,
    NTILE(4) OVER (ORDER BY score) AS quartile
FROM etudiants;

-- Deux √©tudiants avec score=75 peuvent √™tre dans des quartiles diff√©rents !

-- ‚úÖ SOLUTION : Ajouter tie-breaker si d√©terminisme n√©cessaire
SELECT
    nom,
    score,
    NTILE(4) OVER (ORDER BY score, nom) AS quartile  -- nom pour stabilit√©
FROM etudiants;
```

### 4. Performance avec grandes partitions

```sql
-- ‚ùå LENT : Beaucoup de partitions et de tri
SELECT
    date_vente,
    heure,
    produit_id,
    RANK() OVER (
        PARTITION BY date_vente, heure, magasin_id, rayon  -- Trop de partitions
        ORDER BY montant DESC
    ) AS rang
FROM ventes;

-- ‚úÖ OPTIMISER : R√©duire les partitions ou pr√©-filtrer
SELECT
    date_vente,
    produit_id,
    RANK() OVER (
        PARTITION BY date_vente
        ORDER BY montant DESC
    ) AS rang
FROM ventes
WHERE date_vente >= CURRENT_DATE - INTERVAL 7 DAY
  AND magasin_id = 42;
```

---

## ‚úÖ Points cl√©s √† retenir

- **ROW_NUMBER()** attribue un **num√©ro unique** √† chaque ligne, m√™me en cas d'√©galit√© (ordre non d√©terministe pour les ex-aequo)
- **RANK()** permet des **ex-aequo** et **saute les rangs** suivants (1, 2, 2, 4...) ‚Üí id√©al pour les classements sportifs
- **DENSE_RANK()** permet des **ex-aequo sans sauter** de rangs (1, 2, 2, 3...) ‚Üí id√©al pour les cat√©gories et niveaux
- **NTILE(n)** divise les donn√©es en **n groupes de taille √©gale** ‚Üí id√©al pour quartiles, d√©ciles, segmentation
- Toujours ajouter un **tie-breaker** (colonne suppl√©mentaire) dans ORDER BY pour des r√©sultats d√©terministes
- Les fonctions de rang n√©cessitent **ORDER BY** dans la clause OVER (sinon ordre impr√©visible)
- **Indexer** les colonnes utilis√©es dans PARTITION BY et ORDER BY pour de meilleures performances
- Utiliser des **CTE** pour filtrer sur les r√©sultats de fonctions de rang (pas possible dans WHERE directement)
- NTILE r√©partit les **lignes physiquement**, pas par valeur ‚Üí lignes avec m√™me valeur peuvent √™tre dans des groupes diff√©rents
- Pour Top N avec ex-aequo : **RANK()** (nombre variable de r√©sultats) ou **ROW_NUMBER()** (nombre exact)

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation officielle MariaDB - Window Functions](https://mariadb.com/kb/en/window-functions/)
- [üìñ ROW_NUMBER()](https://mariadb.com/kb/en/row_number/)
- [üìñ RANK()](https://mariadb.com/kb/en/rank/)
- [üìñ DENSE_RANK()](https://mariadb.com/kb/en/dense_rank/)
- [üìñ NTILE()](https://mariadb.com/kb/en/ntile/)
- [üìñ Window Functions Overview](https://mariadb.com/kb/en/window-functions-overview/)

**Lectures compl√©mentaires :**
- [SQL:2003 Standard - Window Functions](https://en.wikipedia.org/wiki/SQL:2003)
- [PostgreSQL Window Functions Documentation](https://www.postgresql.org/docs/current/tutorial-window.html)

---

## ‚û°Ô∏è Section suivante

**[4.2.2 Fonctions de valeur (LAG, LEAD, FIRST_VALUE, LAST_VALUE)](/04-concepts-avances-sql/02.2-fonctions-valeur.md)** : Explorer les fonctions qui permettent d'acc√©der aux valeurs des lignes pr√©c√©dentes, suivantes, ou √† des positions sp√©cifiques dans la fen√™tre.

---

**Note pratique** : Les fonctions de rang sont parmi les plus utilis√©es en production pour l'analyse de donn√©es. Ma√Ætriser leurs subtilit√©s (ex-aequo, sauts de rangs, d√©terminisme) est essentiel pour √©viter les bugs difficiles √† d√©tecter. Testez toujours vos requ√™tes avec des jeux de donn√©es contenant des valeurs en double ! üéØ

‚è≠Ô∏è [Fonctions de valeur (LAG, LEAD, FIRST_VALUE, LAST_VALUE)](/04-concepts-avances-sql/02.2-fonctions-valeur.md)
