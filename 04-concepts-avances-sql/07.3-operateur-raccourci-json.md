üîù Retour au [Sommaire](/SOMMAIRE.md)

# 4.7.3 Op√©rateur raccourci (->>)

> **Niveau** : Avanc√©
> **Dur√©e estim√©e** : 1-2 heures
> **Pr√©requis** : Sections 4.7.1 et 4.7.2, ma√Ætrise de JSON_EXTRACT()

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Utiliser les op√©rateurs -> et ->> pour extraire des valeurs JSON
- Comprendre la diff√©rence entre -> (retourne JSON) et ->> (retourne texte)
- Choisir le bon op√©rateur selon le contexte
- Optimiser les requ√™tes avec ces op√©rateurs
- √âviter les pi√®ges li√©s aux conversions de type
- Ma√Ætriser les cas d'usage avanc√©s

---

## Introduction

Les op√©rateurs **->** et **->>** sont des **raccourcis syntaxiques** introduits dans MariaDB 10.4+ pour simplifier l'extraction de valeurs JSON. Ils offrent une syntaxe plus concise et lisible que `JSON_EXTRACT()` et `JSON_UNQUOTE()`.

### Pourquoi des op√©rateurs raccourcis ?

```sql
-- ‚ùå Syntaxe verbeuse avec fonctions
SELECT
    JSON_UNQUOTE(JSON_EXTRACT(data, '$.nom')) AS nom,
    JSON_UNQUOTE(JSON_EXTRACT(data, '$.email')) AS email,
    CAST(JSON_EXTRACT(data, '$.age') AS UNSIGNED) AS age
FROM utilisateurs;

-- ‚úÖ Syntaxe concise avec op√©rateurs
SELECT
    data->>'$.nom' AS nom,
    data->>'$.email' AS email,
    CAST(data->>'$.age' AS UNSIGNED) AS age
FROM utilisateurs;
```

üí° **Gain** : Code plus lisible, moins d'erreurs de parenth√®ses, plus proche du SQL standard (PostgreSQL).

---

## Op√©rateur -> : Extraction JSON brute

### D√©finition

L'op√©rateur **->** extrait une valeur JSON et **conserve son type JSON** avec les guillemets et la repr√©sentation JSON native.

```sql
-- Syntaxe : json_column->'$.path'
-- √âquivalent √† : JSON_EXTRACT(json_column, '$.path')
```

### Exemples de base

```sql
SET @json = '{"nom": "Alice", "age": 30, "ville": "Paris"}';

-- Extraction avec ->
SELECT @json->'$.nom' AS nom;
-- "Alice" (avec guillemets JSON)

SELECT @json->'$.age' AS age;
-- 30 (nombre JSON)

-- Comparaison avec JSON_EXTRACT
SELECT
    @json->'$.nom' AS operateur,
    JSON_EXTRACT(@json, '$.nom') AS fonction;
-- R√©sultats identiques
```

### Comportement avec diff√©rents types JSON

```sql
SET @json_types = '{
    "texte": "Hello",
    "nombre": 42,
    "decimal": 3.14,
    "booleen": true,
    "nul": null,
    "tableau": [1, 2, 3],
    "objet": {"x": 10}
}';

-- String : conserve les guillemets
SELECT @json_types->'$.texte' AS texte;
-- "Hello"

-- Number : conserve le type num√©rique
SELECT @json_types->'$.nombre' AS nombre;
-- 42

-- Boolean : conserve le bool√©en JSON
SELECT @json_types->'$.booleen' AS booleen;
-- true

-- Null : retourne null JSON
SELECT @json_types->'$.nul' AS nul;
-- null

-- Array : conserve la structure tableau
SELECT @json_types->'$.tableau' AS tableau;
-- [1, 2, 3]

-- Object : conserve la structure objet
SELECT @json_types->'$.objet' AS objet;
-- {"x": 10}
```

### Cha√Ænage d'extractions

```sql
SET @json_nested = '{
    "user": {
        "profile": {
            "contact": {
                "email": "alice@example.com",
                "phones": ["+33612345678", "+33698765432"]
            }
        }
    }
}';

-- Cha√Ænage avec ->
SELECT
    @json_nested->'$.user' AS user,
    @json_nested->'$.user.profile' AS profile,
    @json_nested->'$.user.profile.contact' AS contact,
    @json_nested->'$.user.profile.contact.email' AS email;

-- Navigation dans tableaux
SELECT @json_nested->'$.user.profile.contact.phones[0]' AS phone1;
-- "+33612345678"

SELECT @json_nested->'$.user.profile.contact.phones[1]' AS phone2;
-- "+33698765432"
```

---

## Op√©rateur ->> : Extraction texte d√©quot√©

### D√©finition

L'op√©rateur **->>** extrait une valeur JSON et **la convertit en texte brut** en retirant les guillemets JSON.

```sql
-- Syntaxe : json_column->>'$.path'
-- √âquivalent √† : JSON_UNQUOTE(JSON_EXTRACT(json_column, '$.path'))
```

### Exemples de base

```sql
SET @json = '{"nom": "Alice", "age": 30, "ville": "Paris"}';

-- Extraction avec ->>
SELECT @json->>'$.nom' AS nom;
-- Alice (sans guillemets)

SELECT @json->>'$.age' AS age;
-- 30 (texte, pas nombre JSON)

-- Comparaison -> vs ->>
SELECT
    @json->'$.nom' AS avec_guillemets,
    @json->>'$.nom' AS sans_guillemets;
-- avec_guillemets: "Alice"
-- sans_guillemets: Alice
```

### Comportement avec diff√©rents types

```sql
SET @json_types = '{
    "texte": "Hello World",
    "nombre": 42,
    "decimal": 3.14,
    "booleen": true,
    "nul": null,
    "tableau": [1, 2, 3],
    "objet": {"x": 10}
}';

-- String : retire les guillemets
SELECT @json_types->>'$.texte' AS texte;
-- Hello World (sans guillemets)

-- Number : convertit en texte
SELECT @json_types->>'$.nombre' AS nombre;
-- 42 (type VARCHAR/TEXT)

-- Boolean : convertit en texte
SELECT @json_types->>'$.booleen' AS booleen;
-- true (texte "true")

-- Null : retourne NULL SQL (pas "null" texte)
SELECT @json_types->>'$.nul' AS nul;
-- NULL

-- Array : convertit en texte JSON
SELECT @json_types->>'$.tableau' AS tableau;
-- [1, 2, 3] (texte)

-- Object : convertit en texte JSON
SELECT @json_types->>'$.objet' AS objet;
-- {"x": 10} (texte)
```

### Conversion de type n√©cessaire

```sql
-- ->> retourne toujours du texte, conversion n√©cessaire pour calculs
SET @json = '{"prix": 99.99, "quantite": 5}';

-- ‚ùå ERREUR : Op√©rations arithm√©tiques sur texte
SELECT @json->>'$.prix' + @json->>'$.quantite';
-- 104.99 (mais convertit implicitement, peut √™tre risqu√©)

-- ‚úÖ CORRECT : Conversion explicite
SELECT
    CAST(@json->>'$.prix' AS DECIMAL(10,2)) AS prix,
    CAST(@json->>'$.quantite' AS UNSIGNED) AS quantite,
    CAST(@json->>'$.prix' AS DECIMAL(10,2)) * CAST(@json->>'$.quantite' AS UNSIGNED) AS total;
-- prix: 99.99, quantite: 5, total: 499.95
```

---

## Comparaison : -> vs ->> vs JSON_EXTRACT()

### Tableau comparatif

| Aspect | -> | ->> | JSON_EXTRACT() | JSON_UNQUOTE(JSON_EXTRACT()) |
|--------|----|----|----------------|------------------------------|
| **Syntaxe** | Courte | Courte | Longue | Tr√®s longue |
| **Lisibilit√©** | ‚úÖ Excellente | ‚úÖ Excellente | üü° Moyenne | ‚ùå Verbeuse |
| **Type retour** | JSON | Texte | JSON | Texte |
| **Guillemets strings** | ‚úÖ Conserv√©s | ‚ùå Retir√©s | ‚úÖ Conserv√©s | ‚ùå Retir√©s |
| **Performance** | ‚ö° Identique | ‚ö° Identique | ‚ö° Identique | ‚ö° Identique |
| **Cas d'usage** | R√©utilisation JSON | Affichage, filtres | Compatible anciennes versions | Compatible anciennes versions |

### Exemples comparatifs

```sql
SET @json = '{"user": {"name": "Alice", "email": "alice@example.com"}}';

-- Les 4 approches pour extraire le nom
SELECT
    JSON_EXTRACT(@json, '$.user.name') AS json_extract,
    JSON_UNQUOTE(JSON_EXTRACT(@json, '$.user.name')) AS json_unquote_extract,
    @json->'$.user.name' AS operateur_fleche,
    @json->>'$.user.name' AS operateur_double_fleche;

-- R√©sultats :
-- json_extract:              "Alice"
-- json_unquote_extract:      Alice
-- operateur_fleche:          "Alice"
-- operateur_double_fleche:   Alice
```

### Quand utiliser chaque op√©rateur ?

```sql
-- ‚úÖ Utiliser -> quand :
-- 1. Vous voulez r√©utiliser le JSON extrait
SELECT
    id,
    data->'$.user' AS user_json,  -- Garde le JSON
    JSON_TYPE(data->'$.user') AS type  -- Fonctionne car c'est du JSON
FROM documents;

-- 2. Vous voulez conserver le type JSON natif
SELECT data->'$.actif' AS actif_json  -- true (bool√©en JSON)
FROM configs;

-- ‚úÖ Utiliser ->> quand :
-- 1. Vous affichez la valeur √† l'utilisateur
SELECT
    id,
    data->>'$.nom' AS nom,  -- Texte propre pour affichage
    data->>'$.email' AS email
FROM utilisateurs;

-- 2. Vous filtrez sur des valeurs texte
SELECT * FROM produits
WHERE data->>'$.categorie' = 'Electronique';

-- 3. Vous faites une jointure
SELECT p.*, c.nom_categorie
FROM produits p
JOIN categories c ON c.code = p.data->>'$.categorie_code';
```

---

## Cas d'usage pratiques

### 1. Requ√™tes de s√©lection

```sql
-- Liste de produits avec extraction JSON
SELECT
    id,
    data->>'$.nom' AS nom,
    CAST(data->>'$.prix' AS DECIMAL(10,2)) AS prix,
    data->>'$.marque' AS marque,
    data->>'$.categorie' AS categorie,
    CAST(data->>'$.stock' AS UNSIGNED) AS stock
FROM produits
WHERE data->>'$.actif' = 'true'
ORDER BY CAST(data->>'$.prix' AS DECIMAL(10,2)) DESC
LIMIT 10;
```

### 2. Filtrage complexe

```sql
-- Filtrer sur plusieurs crit√®res JSON
SELECT * FROM produits
WHERE data->>'$.categorie' = 'Electronique'
  AND CAST(data->>'$.prix' AS DECIMAL(10,2)) BETWEEN 100 AND 500
  AND CAST(data->>'$.stock' AS UNSIGNED) > 0
  AND data->>'$.marque' IN ('Apple', 'Samsung', 'Sony');
```

### 3. Jointures sur valeurs JSON

```sql
-- Jointure sur ID extrait du JSON
SELECT
    u.id,
    u.profile->>'$.nom' AS nom_utilisateur,
    c.date_commande,
    c.montant
FROM utilisateurs u
JOIN commandes c ON c.client_id = CAST(u.profile->>'$.client_id' AS UNSIGNED)
WHERE c.date_commande >= '2024-01-01';
```

### 4. Agr√©gations avec extraction JSON

```sql
-- Statistiques par cat√©gorie extraite du JSON
SELECT
    data->>'$.categorie' AS categorie,
    COUNT(*) AS nb_produits,
    AVG(CAST(data->>'$.prix' AS DECIMAL(10,2))) AS prix_moyen,
    SUM(CAST(data->>'$.stock' AS UNSIGNED)) AS stock_total,
    MIN(CAST(data->>'$.prix' AS DECIMAL(10,2))) AS prix_min,
    MAX(CAST(data->>'$.prix' AS DECIMAL(10,2))) AS prix_max
FROM produits
GROUP BY data->>'$.categorie'
ORDER BY nb_produits DESC;
```

### 5. Sous-requ√™tes avec op√©rateurs

```sql
-- Top 5 des marques par chiffre d'affaires
SELECT
    marque,
    chiffre_affaires
FROM (
    SELECT
        data->>'$.marque' AS marque,
        SUM(CAST(data->>'$.prix' AS DECIMAL(10,2)) * CAST(data->>'$.quantite_vendue' AS UNSIGNED)) AS chiffre_affaires
    FROM ventes
    WHERE YEAR(date_vente) = 2024
    GROUP BY data->>'$.marque'
) AS stats
ORDER BY chiffre_affaires DESC
LIMIT 5;
```

### 6. Construction de vues

```sql
-- Vue simplifiant l'acc√®s aux donn√©es JSON
CREATE OR REPLACE VIEW v_produits_simplifie AS
SELECT
    id,
    data->>'$.nom' AS nom,
    data->>'$.sku' AS sku,
    CAST(data->>'$.prix' AS DECIMAL(10,2)) AS prix,
    data->>'$.categorie' AS categorie,
    data->>'$.marque' AS marque,
    CAST(data->>'$.stock' AS UNSIGNED) AS stock,
    data->>'$.actif' = 'true' AS actif,
    data  -- JSON complet pour acc√®s aux autres champs
FROM produits;

-- Utilisation simplifi√©e
SELECT * FROM v_produits_simplifie
WHERE categorie = 'Electronique'
  AND prix < 500
  AND actif = TRUE;
```

---

## Optimisation avec colonnes virtuelles

### Probl√®me de performance

```sql
-- ‚ùå LENT : Extraction JSON √† chaque requ√™te
SELECT * FROM produits
WHERE data->>'$.categorie' = 'Electronique'
  AND CAST(data->>'$.prix' AS DECIMAL(10,2)) < 500;
-- Pas d'index possible sur data->>'$.categorie' directement
-- Full table scan √† chaque requ√™te
```

### Solution : Colonnes virtuelles index√©es

```sql
-- ‚úÖ RAPIDE : Colonnes virtuelles avec index
ALTER TABLE produits
ADD COLUMN categorie_extracted VARCHAR(50) AS (data->>'$.categorie') VIRTUAL,
ADD COLUMN prix_extracted DECIMAL(10,2) AS (CAST(data->>'$.prix' AS DECIMAL(10,2))) STORED,
ADD COLUMN stock_extracted INT AS (CAST(data->>'$.stock' AS UNSIGNED)) STORED,
ADD INDEX idx_categorie (categorie_extracted),
ADD INDEX idx_prix (prix_extracted),
ADD INDEX idx_stock (stock_extracted);

-- Requ√™te optimis√©e (utilise les index)
SELECT * FROM produits
WHERE categorie_extracted = 'Electronique'
  AND prix_extracted < 500
  AND stock_extracted > 0;

-- EXPLAIN montre l'utilisation des index
EXPLAIN SELECT * FROM produits
WHERE categorie_extracted = 'Electronique'\G
-- key: idx_categorie
-- rows: ~100 (au lieu de 100000 avec full scan)
```

### VIRTUAL vs STORED

```sql
-- VIRTUAL : Calcul√© √† chaque lecture (pas de stockage)
ALTER TABLE produits
ADD COLUMN nom_virtual VARCHAR(100) AS (data->>'$.nom') VIRTUAL;
-- Avantages : Pas d'espace disque, toujours √† jour
-- Inconv√©nients : Calcul√© √† chaque SELECT

-- STORED : Calcul√© une fois, stock√© physiquement
ALTER TABLE produits
ADD COLUMN nom_stored VARCHAR(100) AS (data->>'$.nom') STORED;
-- Avantages : Lecture rapide, indexable
-- Inconv√©nients : Espace disque, MAJ lors de UPDATE

-- Recommandation :
-- - VIRTUAL pour colonnes rarement lues
-- - STORED pour colonnes fr√©quemment filtr√©es/tri√©es
```

---

## Pi√®ges et erreurs courantes

### 1. Confusion de type avec ->>

```sql
-- ‚ö†Ô∏è PI√àGE : ->> retourne toujours du texte
SET @json = '{"prix": 99.99, "quantite": 5}';

-- Comparaison num√©rique incorrecte
SELECT @json->>'$.prix' > 100;
-- Peut donner des r√©sultats inattendus (comparaison de strings)

-- ‚úÖ CORRECT : Conversion explicite
SELECT CAST(@json->>'$.prix' AS DECIMAL(10,2)) > 100;
-- true/false correct
```

### 2. NULL vs "null"

```sql
SET @json = '{"valeur": null, "texte": "null"}';

-- Diff√©rence entre NULL JSON et NULL SQL
SELECT
    @json->'$.valeur' AS json_null,       -- null (JSON)
    @json->>'$.valeur' AS sql_null,       -- NULL (SQL)
    @json->>'$.texte' AS texte_null,      -- null (texte)
    @json->>'$.absent' AS vraiment_null;  -- NULL (SQL, cl√© absente)

-- Filtrage
SELECT * FROM data
WHERE json_col->>'$.field' IS NULL;  -- Inclut NULL et cl√©s absentes

SELECT * FROM data
WHERE json_col->>'$.field' = 'null';  -- Trouve uniquement "null" texte
```

### 3. Chemins inexistants

```sql
-- Chemin qui n'existe pas
SET @json = '{"a": 1}';

SELECT @json->>'$.b' AS resultat;
-- NULL (pas d'erreur)

-- Attention dans les calculs
SELECT CAST(@json->>'$.b' AS UNSIGNED) * 10;
-- 0 (NULL converti en 0, peut masquer l'absence de donn√©es)

-- ‚úÖ Meilleure pratique : V√©rifier l'existence
SELECT
    CASE
        WHEN JSON_CONTAINS_PATH(@json, 'one', '$.b')
        THEN CAST(@json->>'$.b' AS UNSIGNED)
        ELSE NULL
    END AS valeur_securisee;
```

### 4. Extraction de tableaux

```sql
SET @json = '{"items": [{"id": 1}, {"id": 2}, {"id": 3}]}';

-- ‚ùå ERREUR : ->> sur tableau retourne texte JSON (pas it√©rable directement)
SELECT @json->>'$.items[*]';
-- [{"id": 1}, {"id": 2}, {"id": 3}] (texte)

-- ‚úÖ CORRECT : Utiliser JSON_TABLE pour it√©rer
SELECT jt.*
FROM JSON_TABLE(
    @json,
    '$.items[*]' COLUMNS(
        id INT PATH '$.id'
    )
) AS jt;
-- id
-- 1
-- 2
-- 3
```

### 5. √âchappement et caract√®res sp√©ciaux

```sql
-- Cl√©s avec caract√®res sp√©ciaux
SET @json = '{"user-name": "Alice", "email@domain": "test@example.com"}';

-- ‚ùå ERREUR : Syntaxe invalide
-- SELECT @json->>'$.user-name';  -- Erreur de parsing

-- ‚úÖ CORRECT : √âchapper avec guillemets
SELECT @json->'$."user-name"' AS user_name;
-- "Alice"

-- Ou utiliser JSON_EXTRACT avec string litt√©ral
SELECT JSON_EXTRACT(@json, '$."email@domain"') AS email;
-- "test@example.com"
```

---

## Compatibilit√© et portabilit√©

### MariaDB vs PostgreSQL

```sql
-- PostgreSQL : Op√©rateurs identiques
-- -> : Retourne JSON
-- ->> : Retourne texte

-- Syntaxe compatible entre MariaDB et PostgreSQL
SELECT
    data->'user'->'profile'->>'name' AS nom,
    data->'user'->'contact'->>'email' AS email
FROM users;

-- Fonctionne sur les deux SGBD !
```

### MariaDB vs MySQL

```sql
-- MySQL 5.7+ : -> et ->> introduits en 8.0.13+
-- Syntaxe identique √† MariaDB

-- Diff√©rence : MySQL a un format binaire JSON
-- Performance : MySQL peut √™tre plus rapide (format binaire)
-- Syntaxe : Compatible entre les deux
```

### Migration de JSON_EXTRACT()

```sql
-- Code ancien (compatible tout MariaDB)
SELECT
    JSON_UNQUOTE(JSON_EXTRACT(data, '$.nom')) AS nom,
    JSON_EXTRACT(data, '$.age') AS age
FROM users;

-- Code moderne (MariaDB 10.4+)
SELECT
    data->>'$.nom' AS nom,
    data->'$.age' AS age
FROM users;

-- Recommandation : Utiliser -> et ->> pour nouveau code
-- Garder JSON_EXTRACT() si support versions anciennes n√©cessaire
```

---

## Bonnes pratiques

### 1. Pr√©f√©rer ->> pour l'affichage

```sql
-- ‚úÖ BON : Texte propre pour l'utilisateur
SELECT
    id,
    data->>'$.titre' AS titre,
    data->>'$.description' AS description
FROM articles;

-- ‚ùå MOINS BON : Guillemets JSON inutiles
SELECT
    id,
    data->'$.titre' AS titre,  -- Retourne "Mon Titre" avec guillemets
    data->'$.description' AS description
FROM articles;
```

### 2. Utiliser -> pour manipulations JSON ult√©rieures

```sql
-- ‚úÖ BON : Conserver le JSON pour traitement ult√©rieur
SELECT
    id,
    data->'$.user' AS user_json,  -- JSON complet
    JSON_TYPE(data->'$.user') AS type,
    JSON_KEYS(data->'$.user') AS cles
FROM documents;

-- ‚ùå ERREUR : ->> convertit en texte, plus de fonctions JSON
SELECT
    id,
    data->>'$.user' AS user_text,
    JSON_TYPE(data->>'$.user') AS type  -- NULL, pas du JSON !
FROM documents;
```

### 3. Toujours convertir explicitement pour calculs

```sql
-- ‚úÖ BON : Conversion explicite
SELECT
    CAST(data->>'$.prix' AS DECIMAL(10,2)) AS prix,
    CAST(data->>'$.quantite' AS UNSIGNED) AS quantite,
    CAST(data->>'$.prix' AS DECIMAL(10,2)) * CAST(data->>'$.quantite' AS UNSIGNED) AS total
FROM commandes;

-- ‚ö†Ô∏è RISQU√â : Conversion implicite
SELECT
    data->>'$.prix' * data->>'$.quantite' AS total
FROM commandes;
-- Peut fonctionner mais comportement non garanti
```

### 4. Documenter les chemins JSON

```sql
-- ‚úÖ BON : Commentaires pour documenter la structure
SELECT
    -- user.profile.personal_info
    data->>'$.user.profile.personal_info.name' AS nom,
    -- user.profile.contact
    data->>'$.user.profile.contact.email' AS email,
    -- user.preferences.ui
    data->>'$.user.preferences.ui.theme' AS theme
FROM users;
```

### 5. Cr√©er des vues pour simplifier l'acc√®s

```sql
-- Vue qui simplifie l'extraction r√©currente
CREATE OR REPLACE VIEW v_utilisateurs AS
SELECT
    id,
    data->>'$.nom' AS nom,
    data->>'$.prenom' AS prenom,
    data->>'$.email' AS email,
    CAST(data->>'$.age' AS UNSIGNED) AS age,
    data->>'$.ville' AS ville,
    data->>'$.pays' AS pays,
    STR_TO_DATE(data->>'$.date_inscription', '%Y-%m-%d') AS date_inscription,
    data  -- JSON complet pour acc√®s aux champs non extraits
FROM utilisateurs;

-- Utilisation simplifi√©e
SELECT * FROM v_utilisateurs
WHERE age >= 18 AND pays = 'France';
```

---

## ‚úÖ Points cl√©s √† retenir

- **-> (op√©rateur fl√®che)** : Extrait JSON brut, conserve type et guillemets
- **->> (op√©rateur double fl√®che)** : Extrait texte d√©quot√©, retire guillemets
- **√âquivalences** : `->` = JSON_EXTRACT(), `->>` = JSON_UNQUOTE(JSON_EXTRACT())
- **Lisibilit√©** : Op√©rateurs beaucoup plus concis et lisibles
- **Performance** : Identique √† JSON_EXTRACT() (alias syntaxique)
- **Conversion** : Toujours convertir explicitement ->> pour calculs num√©riques
- **NULL** : ->> retourne NULL SQL pour valeurs null JSON ou chemins absents
- **Compatibilit√©** : Syntaxe identique √† PostgreSQL, similaire √† MySQL 8.0.13+
- **Optimisation** : Cr√©er colonnes virtuelles index√©es pour valeurs fr√©quemment filtr√©es
- **Best practice** : Utiliser ->> pour affichage/filtrage, -> pour manipulations JSON ult√©rieures
- **Portabilit√©** : Code moderne, n√©cessite MariaDB 10.4+ (utiliser JSON_EXTRACT() pour versions ant√©rieures)

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation MariaDB - JSON Operators](https://mariadb.com/kb/en/json-operators/)
- [üìñ JSON_EXTRACT](https://mariadb.com/kb/en/json_extract/)
- [üìñ JSON_UNQUOTE](https://mariadb.com/kb/en/json_unquote/)
- [üìñ Generated Columns](https://mariadb.com/kb/en/generated-columns/)

**Comparaisons** :
- [PostgreSQL JSON Operators](https://www.postgresql.org/docs/current/functions-json.html)
- [MySQL JSON Path Syntax](https://dev.mysql.com/doc/refman/8.0/en/json-path-syntax.html)

---

## ‚û°Ô∏è Section suivante

**[4.8 JSON Path Expressions avanc√©es](/04-concepts-avances-sql/08-json-path-expressions.md)** üÜï : Explorer les nouvelles fonctionnalit√©s JSONPath de MariaDB 11.8 avec filtres, wildcards et op√©rateurs logiques.

---

**Note pratique** : Les op√©rateurs -> et ->> sont devenus le standard pour l'extraction JSON dans les SGBD modernes. Adoptez-les syst√©matiquement dans votre nouveau code pour am√©liorer la lisibilit√© et la maintenabilit√©. N'oubliez pas les colonnes virtuelles index√©es pour optimiser les performances des requ√™tes fr√©quentes ! üéØ

‚è≠Ô∏è [JSON Path Expressions avanc√©es](/04-concepts-avances-sql/08-json-path-expressions.md)
