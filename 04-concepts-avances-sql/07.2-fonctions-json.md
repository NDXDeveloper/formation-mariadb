üîù Retour au [Sommaire](/SOMMAIRE.md)

# 4.7.2 Fonctions JSON (JSON_EXTRACT, JSON_SET, JSON_ARRAY, etc.)

> **Niveau** : Avanc√©
> **Dur√©e estim√©e** : 4-5 heures
> **Pr√©requis** : Sections 4.7 et 4.7.1, connaissance du format JSON

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Cr√©er des documents JSON avec JSON_OBJECT et JSON_ARRAY
- Extraire des valeurs avec JSON_EXTRACT et les op√©rateurs raccourcis
- Modifier des documents JSON avec JSON_SET, JSON_INSERT, JSON_REPLACE
- Rechercher des valeurs avec JSON_CONTAINS et JSON_SEARCH
- Utiliser les fonctions d'agr√©gation JSON_ARRAYAGG et JSON_OBJECTAGG
- Transformer des donn√©es relationnelles en JSON et inversement
- Ma√Ætriser les fonctions utilitaires pour analyser les structures JSON

---

## Introduction

MariaDB offre plus de **40 fonctions JSON** r√©parties en plusieurs cat√©gories. Cette section explore les fonctions essentielles avec des exemples concrets pour chaque cas d'usage.

### Cat√©gories de fonctions

```
üì¶ Cr√©ation       : Construire des documents JSON
üîç Extraction     : Lire des valeurs JSON
‚úèÔ∏è  Modification   : Mettre √† jour des documents
üîé Recherche      : Trouver des valeurs sp√©cifiques
üìä Agr√©gation     : Construire JSON depuis des lignes SQL
üîß Utilitaires    : Analyser et valider des structures
```

---

## 1. Fonctions de cr√©ation

### JSON_ARRAY() : Cr√©er un tableau JSON

```sql
-- Syntaxe de base
SELECT JSON_ARRAY(1, 2, 3, 4, 5) AS tableau;
-- [1, 2, 3, 4, 5]

-- Avec diff√©rents types
SELECT JSON_ARRAY('texte', 123, 45.67, TRUE, NULL) AS mixte;
-- ["texte", 123, 45.67, true, null]

-- Tableau vide
SELECT JSON_ARRAY() AS vide;
-- []

-- Tableau imbriqu√©
SELECT JSON_ARRAY(
    JSON_ARRAY(1, 2),
    JSON_ARRAY(3, 4),
    JSON_ARRAY(5, 6)
) AS matrice;
-- [[1, 2], [3, 4], [5, 6]]
```

**Cas d'usage** : Cr√©er des listes de valeurs

```sql
-- Stocker les tags d'un article
INSERT INTO articles (titre, tags) VALUES
    ('Introduction √† SQL', JSON_ARRAY('sql', 'database', 'tutorial')),
    ('Window Functions', JSON_ARRAY('sql', 'advanced', 'analytics'));

-- Cr√©er une liste de permissions
UPDATE users
SET permissions = JSON_ARRAY('read', 'write', 'delete')
WHERE role = 'admin';
```

### JSON_OBJECT() : Cr√©er un objet JSON

```sql
-- Syntaxe : JSON_OBJECT(key1, value1, key2, value2, ...)
SELECT JSON_OBJECT('nom', 'Alice', 'age', 30, 'ville', 'Paris') AS utilisateur;
-- {"nom": "Alice", "age": 30, "ville": "Paris"}

-- Avec des valeurs NULL
SELECT JSON_OBJECT('nom', 'Bob', 'email', NULL) AS user;
-- {"nom": "Bob", "email": null}

-- Objets imbriqu√©s
SELECT JSON_OBJECT(
    'nom', 'Alice',
    'adresse', JSON_OBJECT(
        'rue', '123 Main St',
        'ville', 'Paris',
        'code_postal', '75001'
    )
) AS user_complet;
-- {"nom": "Alice", "adresse": {"rue": "123 Main St", "ville": "Paris", "code_postal": "75001"}}
```

**Cas d'usage** : Construire des documents √† partir de colonnes

```sql
-- Cr√©er un JSON depuis des colonnes relationnelles
SELECT
    id,
    JSON_OBJECT(
        'nom', nom,
        'email', email,
        'age', age,
        'date_inscription', date_inscription,
        'actif', actif
    ) AS profil_json
FROM utilisateurs;

-- Stocker une configuration
INSERT INTO configurations (module, settings) VALUES
    ('email', JSON_OBJECT(
        'smtp_host', 'smtp.example.com',
        'smtp_port', 587,
        'use_tls', TRUE,
        'from_address', 'noreply@example.com'
    ));
```

### JSON_QUOTE() : √âchapper une cha√Æne pour JSON

```sql
-- Convertir une cha√Æne en valeur JSON string valide
SELECT JSON_QUOTE('Hello "World"') AS echappee;
-- "Hello \"World\""

-- √âchapper des caract√®res sp√©ciaux
SELECT JSON_QUOTE('Line 1\nLine 2\tTabbed') AS special;
-- "Line 1\\nLine 2\\tTabbed"

-- Utilisation dans la construction
SELECT JSON_ARRAY(
    JSON_QUOTE('Texte avec "guillemets"'),
    JSON_QUOTE('Texte avec \n saut de ligne')
) AS array;
```

üí° **Note** : `JSON_QUOTE()` est rarement n√©cessaire car les autres fonctions √©chappent automatiquement.

### JSON_MERGE() et JSON_MERGE_PRESERVE() : Fusionner des documents

```sql
-- JSON_MERGE_PRESERVE : Conserve les doublons (tableaux)
SELECT JSON_MERGE_PRESERVE(
    '{"a": 1, "b": 2}',
    '{"b": 3, "c": 4}'
) AS fusionne;
-- {"a": 1, "b": [2, 3], "c": 4}
-- Cl√© dupliqu√©e "b" devient un tableau

-- JSON_MERGE : Alias de JSON_MERGE_PRESERVE
SELECT JSON_MERGE(
    '["x", "y"]',
    '["y", "z"]'
) AS array_merge;
-- ["x", "y", "y", "z"]

-- Fusion de plusieurs documents
SELECT JSON_MERGE_PRESERVE(
    '{"user": "alice"}',
    '{"email": "alice@example.com"}',
    '{"age": 30, "city": "Paris"}'
) AS user_complet;
-- {"user": "alice", "email": "alice@example.com", "age": 30, "city": "Paris"}
```

**Cas d'usage** : Enrichir un document existant

```sql
-- Ajouter des m√©tadonn√©es √† un produit
UPDATE produits
SET details = JSON_MERGE_PRESERVE(
    details,
    JSON_OBJECT('derniere_modification', NOW(), 'modifie_par', 'admin')
)
WHERE id = 42;
```

---

## 2. Fonctions d'extraction

### JSON_EXTRACT() : Extraire des valeurs

```sql
-- Syntaxe : JSON_EXTRACT(json_doc, path, [path, ...])
SET @json = '{"nom": "Alice", "age": 30, "ville": "Paris"}';

-- Extraire une valeur simple
SELECT JSON_EXTRACT(@json, '$.nom') AS nom;
-- "Alice" (avec guillemets)

-- Extraire plusieurs valeurs
SELECT JSON_EXTRACT(@json, '$.nom', '$.age') AS valeurs;
-- ["Alice", 30]

-- Chemins imbriqu√©s
SET @json_nested = '{
    "user": {
        "profile": {
            "name": "Bob",
            "contact": {"email": "bob@example.com"}
        }
    }
}';

SELECT JSON_EXTRACT(@json_nested, '$.user.profile.name') AS nom;
-- "Bob"

SELECT JSON_EXTRACT(@json_nested, '$.user.profile.contact.email') AS email;
-- "bob@example.com"
```

**Syntaxe JSONPath** :

| Expression | Description | Exemple |
|------------|-------------|---------|
| `$` | Racine du document | `$` |
| `.key` | Acc√®s √† une cl√© | `$.nom` |
| `[n]` | √âl√©ment d'index n dans un tableau | `$.items[0]` |
| `[*]` | Tous les √©l√©ments d'un tableau | `$.items[*]` |
| `.*` | Toutes les valeurs d'un objet | `$.*` |
| `**` | Recherche r√©cursive (tous niveaux) | `$..email` |

```sql
-- Exemples avec tableaux
SET @json_array = '{"items": ["a", "b", "c", "d"]}';

SELECT JSON_EXTRACT(@json_array, '$.items[0]') AS premier;
-- "a"

SELECT JSON_EXTRACT(@json_array, '$.items[2]') AS troisieme;
-- "c"

SELECT JSON_EXTRACT(@json_array, '$.items[*]') AS tous;
-- ["a", "b", "c", "d"]

-- Exemple avec objets multiples
SET @json_products = '{
    "products": [
        {"id": 1, "name": "Product A", "price": 10},
        {"id": 2, "name": "Product B", "price": 20},
        {"id": 3, "name": "Product C", "price": 15}
    ]
}';

SELECT JSON_EXTRACT(@json_products, '$.products[*].name') AS noms;
-- ["Product A", "Product B", "Product C"]

SELECT JSON_EXTRACT(@json_products, '$.products[1].price') AS prix_b;
-- 20
```

### Op√©rateurs raccourcis : -> et ->>

```sql
-- -> : √âquivalent de JSON_EXTRACT (retourne JSON avec guillemets)
SELECT '{"nom": "Alice", "age": 30}'->>'$.nom' AS nom_quoted;
-- "Alice" (avec guillemets JSON)

-- ->> : Extrait et d√©quote (retourne texte brut)
SELECT '{"nom": "Alice", "age": 30}'->>'$.nom' AS nom_text;
-- Alice (sans guillemets)

-- Comparaison
SET @json = '{"prix": 99.99}';

SELECT
    JSON_EXTRACT(@json, '$.prix') AS extract,      -- 99.99 (nombre JSON)
    @json->'$.prix' AS operateur_fleche,           -- 99.99 (nombre JSON)
    @json->>'$.prix' AS operateur_double_fleche;   -- 99.99 (texte)
```

üí° **Recommandation** : Utiliser `->>` pour extraire des valeurs texte, `->` pour pr√©server le type JSON.

**Cas d'usage en requ√™te** :

```sql
-- Filtrer sur une valeur JSON
SELECT * FROM produits
WHERE details->>'$.categorie' = 'Electronique'
  AND CAST(details->>'$.prix' AS DECIMAL(10,2)) < 500;

-- Trier sur une valeur JSON
SELECT nom, details->>'$.prix' AS prix
FROM produits
ORDER BY CAST(details->>'$.prix' AS DECIMAL(10,2)) DESC;

-- Jointure sur valeur JSON extraite
SELECT
    p.nom,
    c.nom_categorie
FROM produits p
JOIN categories c ON c.id = CAST(p.details->>'$.categorie_id' AS UNSIGNED);
```

### JSON_UNQUOTE() : Retirer les guillemets

```sql
-- Convertir "texte JSON" ‚Üí texte brut
SELECT JSON_UNQUOTE('"Hello World"') AS texte;
-- Hello World (sans guillemets)

-- √âquivalent de ->>
SELECT JSON_UNQUOTE(JSON_EXTRACT('{"nom": "Alice"}', '$.nom')) AS nom;
-- Alice

-- Compar√© √† ->
SELECT '{"nom": "Alice"}'->'$.nom' AS avec_guillemets;
-- "Alice"

SELECT JSON_UNQUOTE('{"nom": "Alice"}'->'$.nom') AS sans_guillemets;
-- Alice
```

### JSON_VALUE() : Extraction scalaire (MariaDB 10.2.3+)

```sql
-- Extrait une valeur scalaire avec conversion de type automatique
SELECT JSON_VALUE('{"prix": 99.99}', '$.prix') AS prix;
-- 99.99 (converti en nombre)

-- Avec valeur par d√©faut si NULL ou absent
SELECT JSON_VALUE('{"nom": "Alice"}', '$.email' DEFAULT 'non renseign√©') AS email;
-- non renseign√©

-- Avec gestion d'erreur
SELECT JSON_VALUE('{"invalid": }', '$.invalid' DEFAULT 'erreur' ON ERROR) AS valeur;
-- erreur
```

---

## 3. Fonctions de modification

### JSON_SET() : D√©finir/Remplacer des valeurs

```sql
-- Syntaxe : JSON_SET(json_doc, path, value [, path, value] ...)
SET @json = '{"nom": "Alice", "age": 30}';

-- Modifier une valeur existante
SELECT JSON_SET(@json, '$.age', 31) AS modifie;
-- {"nom": "Alice", "age": 31}

-- Ajouter une nouvelle cl√©
SELECT JSON_SET(@json, '$.email', 'alice@example.com') AS ajoute;
-- {"nom": "Alice", "age": 30, "email": "alice@example.com"}

-- Modifier plusieurs valeurs
SELECT JSON_SET(@json, '$.age', 31, '$.ville', 'Paris') AS multiple;
-- {"nom": "Alice", "age": 31, "ville": "Paris"}

-- Modifier dans un tableau
SET @json_array = '{"items": ["a", "b", "c"]}';
SELECT JSON_SET(@json_array, '$.items[1]', 'B') AS modif_array;
-- {"items": ["a", "B", "c"]}

-- Ajouter un √©l√©ment imbriqu√©
SELECT JSON_SET(
    '{"user": {"nom": "Bob"}}',
    '$.user.email',
    'bob@example.com'
) AS nested;
-- {"user": {"nom": "Bob", "email": "bob@example.com"}}
```

**Cas d'usage** : Mettre √† jour une configuration

```sql
-- Modifier les param√®tres
UPDATE configurations
SET settings = JSON_SET(
    settings,
    '$.smtp_port', 465,
    '$.use_tls', TRUE,
    '$.derniere_maj', NOW()
)
WHERE module = 'email';
```

### JSON_INSERT() : Ajouter uniquement si n'existe pas

```sql
-- JSON_INSERT n'√©crase PAS les valeurs existantes
SET @json = '{"nom": "Alice", "age": 30}';

-- Ajouter une nouvelle cl√©
SELECT JSON_INSERT(@json, '$.email', 'alice@example.com') AS ajoute;
-- {"nom": "Alice", "age": 30, "email": "alice@example.com"}

-- Tenter de modifier une cl√© existante (ignor√©)
SELECT JSON_INSERT(@json, '$.age', 99) AS ignore;
-- {"nom": "Alice", "age": 30}  -- age n'est pas modifi√© !

-- Diff√©rence avec JSON_SET
SELECT
    JSON_SET(@json, '$.age', 99) AS json_set_result,
    JSON_INSERT(@json, '$.age', 99) AS json_insert_result;
-- json_set_result:    {"nom": "Alice", "age": 99}
-- json_insert_result: {"nom": "Alice", "age": 30}
```

**Cas d'usage** : Initialiser des valeurs par d√©faut

```sql
-- Ajouter des m√©tadonn√©es seulement si absentes
UPDATE produits
SET details = JSON_INSERT(
    details,
    '$.date_creation', NOW(),
    '$.actif', TRUE,
    '$.featured', FALSE
)
WHERE id = 42;
-- Si ces cl√©s existent d√©j√†, elles ne sont pas modifi√©es
```

### JSON_REPLACE() : Remplacer uniquement si existe

```sql
-- JSON_REPLACE modifie UNIQUEMENT les valeurs existantes
SET @json = '{"nom": "Alice", "age": 30}';

-- Modifier une cl√© existante
SELECT JSON_REPLACE(@json, '$.age', 31) AS modifie;
-- {"nom": "Alice", "age": 31}

-- Tenter d'ajouter une nouvelle cl√© (ignor√©)
SELECT JSON_REPLACE(@json, '$.email', 'alice@example.com') AS ignore;
-- {"nom": "Alice", "age": 30}  -- email n'est pas ajout√© !

-- Diff√©rence avec JSON_SET
SELECT
    JSON_SET(@json, '$.email', 'alice@example.com') AS json_set_result,
    JSON_REPLACE(@json, '$.email', 'alice@example.com') AS json_replace_result;
-- json_set_result:    {"nom": "Alice", "age": 30, "email": "alice@example.com"}
-- json_replace_result: {"nom": "Alice", "age": 30}
```

**Cas d'usage** : Mettre √† jour seulement les champs existants

```sql
-- Modifier uniquement les valeurs d√©j√† pr√©sentes
UPDATE utilisateurs
SET preferences = JSON_REPLACE(
    preferences,
    '$.theme', 'dark',
    '$.langue', 'fr'
)
WHERE user_id = 123;
-- Si theme ou langue n'existent pas, ils ne sont pas cr√©√©s
```

### JSON_REMOVE() : Supprimer des cl√©s

```sql
-- Syntaxe : JSON_REMOVE(json_doc, path [, path] ...)
SET @json = '{"nom": "Alice", "age": 30, "email": "alice@example.com"}';

-- Supprimer une cl√©
SELECT JSON_REMOVE(@json, '$.email') AS sans_email;
-- {"nom": "Alice", "age": 30}

-- Supprimer plusieurs cl√©s
SELECT JSON_REMOVE(@json, '$.age', '$.email') AS minimal;
-- {"nom": "Alice"}

-- Supprimer un √©l√©ment de tableau
SET @json_array = '{"items": ["a", "b", "c", "d"]}';
SELECT JSON_REMOVE(@json_array, '$.items[1]') AS supprime;
-- {"items": ["a", "c", "d"]}

-- Supprimer cl√© imbriqu√©e
SELECT JSON_REMOVE(
    '{"user": {"nom": "Bob", "email": "bob@example.com"}}',
    '$.user.email'
) AS nested;
-- {"user": {"nom": "Bob"}}
```

**Cas d'usage** : Nettoyer des donn√©es sensibles

```sql
-- Supprimer les donn√©es sensibles avant export
UPDATE utilisateurs_export
SET data = JSON_REMOVE(
    data,
    '$.password',
    '$.security_question',
    '$.ssn',
    '$.credit_card'
);
```

### JSON_ARRAY_APPEND() : Ajouter √† un tableau

```sql
-- Syntaxe : JSON_ARRAY_APPEND(json_doc, path, value [, path, value] ...)
SET @json = '{"tags": ["sql", "database"]}';

-- Ajouter un √©l√©ment au tableau
SELECT JSON_ARRAY_APPEND(@json, '$.tags', 'mariadb') AS ajoute;
-- {"tags": ["sql", "database", "mariadb"]}

-- Ajouter plusieurs √©l√©ments
SELECT JSON_ARRAY_APPEND(@json, '$.tags', 'mysql', '$.tags', 'postgresql') AS multiple;
-- {"tags": ["sql", "database", "mysql", "postgresql"]}

-- Si le chemin n'est pas un tableau, il devient un tableau
SET @json_simple = '{"count": 5}';
SELECT JSON_ARRAY_APPEND(@json_simple, '$.count', 10) AS devient_array;
-- {"count": [5, 10]}
```

**Cas d'usage** : G√©rer des listes d'√©l√©ments

```sql
-- Ajouter un tag √† un article
UPDATE articles
SET metadata = JSON_ARRAY_APPEND(metadata, '$.tags', 'nouveau-tag')
WHERE id = 42;

-- Ajouter une notification
UPDATE users
SET notifications = JSON_ARRAY_APPEND(
    notifications,
    '$.unread',
    JSON_OBJECT('type', 'message', 'from', 'Alice', 'timestamp', NOW())
)
WHERE user_id = 123;
```

### JSON_ARRAY_INSERT() : Ins√©rer √† une position

```sql
-- Syntaxe : JSON_ARRAY_INSERT(json_doc, path, value [, path, value] ...)
SET @json = '{"items": ["a", "c", "d"]}';

-- Ins√©rer √† l'index 1 (d√©cale les suivants)
SELECT JSON_ARRAY_INSERT(@json, '$.items[1]', 'b') AS insere;
-- {"items": ["a", "b", "c", "d"]}

-- Ins√©rer au d√©but
SELECT JSON_ARRAY_INSERT(@json, '$.items[0]', 'd√©but') AS debut;
-- {"items": ["d√©but", "a", "c", "d"]}

-- Ins√©rer √† la fin (utiliser l'index apr√®s le dernier)
SELECT JSON_ARRAY_INSERT(@json, '$.items[3]', 'fin') AS fin;
-- {"items": ["a", "c", "d", "fin"]}
```

---

## 4. Fonctions de recherche

### JSON_CONTAINS() : V√©rifier la pr√©sence d'une valeur

```sql
-- Syntaxe : JSON_CONTAINS(json_doc, candidate [, path])
SET @json = '{"tags": ["sql", "mariadb", "json"], "count": 42}';

-- V√©rifier si une valeur existe
SELECT JSON_CONTAINS(@json, '"sql"', '$.tags') AS contient_sql;
-- 1 (true)

SELECT JSON_CONTAINS(@json, '"python"', '$.tags') AS contient_python;
-- 0 (false)

-- V√©rifier un nombre
SELECT JSON_CONTAINS(@json, '42', '$.count') AS contient_42;
-- 1

-- V√©rifier un objet complet
SET @json_users = '[
    {"nom": "Alice", "age": 30},
    {"nom": "Bob", "age": 25}
]';

SELECT JSON_CONTAINS(@json_users, '{"nom": "Alice", "age": 30}') AS contient_alice;
-- 1
```

**Cas d'usage** : Filtrer sur pr√©sence d'une valeur

```sql
-- Trouver les produits avec un tag sp√©cifique
SELECT * FROM produits
WHERE JSON_CONTAINS(metadata->'$.tags', '"promotion"');

-- Utilisateurs avec permission sp√©cifique
SELECT * FROM users
WHERE JSON_CONTAINS(permissions, '"admin"');
```

### JSON_CONTAINS_PATH() : V√©rifier la pr√©sence d'un chemin

```sql
-- Syntaxe : JSON_CONTAINS_PATH(json_doc, one_or_all, path [, path] ...)
SET @json = '{"nom": "Alice", "email": "alice@example.com", "age": 30}';

-- V√©rifier si un chemin existe
SELECT JSON_CONTAINS_PATH(@json, 'one', '$.email') AS a_email;
-- 1 (true)

SELECT JSON_CONTAINS_PATH(@json, 'one', '$.telephone') AS a_telephone;
-- 0 (false)

-- V√©rifier plusieurs chemins avec 'one' (au moins un existe)
SELECT JSON_CONTAINS_PATH(@json, 'one', '$.email', '$.telephone') AS au_moins_un;
-- 1 (email existe)

-- V√©rifier plusieurs chemins avec 'all' (tous existent)
SELECT JSON_CONTAINS_PATH(@json, 'all', '$.nom', '$.email', '$.age') AS tous;
-- 1 (tous existent)

SELECT JSON_CONTAINS_PATH(@json, 'all', '$.nom', '$.telephone') AS tous_present;
-- 0 (telephone n'existe pas)
```

**Cas d'usage** : Valider la structure d'un document

```sql
-- V√©rifier que les champs obligatoires sont pr√©sents
SELECT
    id,
    nom,
    CASE
        WHEN JSON_CONTAINS_PATH(profile, 'all', '$.nom', '$.email', '$.age')
        THEN 'Complet'
        ELSE 'Incomplet'
    END AS statut_profil
FROM utilisateurs;

-- Filtrer les documents valides
SELECT * FROM commandes
WHERE JSON_CONTAINS_PATH(
    data,
    'all',
    '$.client_id',
    '$.montant',
    '$.date',
    '$.items'
);
```

### JSON_SEARCH() : Trouver le chemin d'une valeur

```sql
-- Syntaxe : JSON_SEARCH(json_doc, one_or_all, search_str [, escape_char [, path]])
SET @json = '{
    "users": [
        {"nom": "Alice", "email": "alice@example.com"},
        {"nom": "Bob", "email": "bob@example.com"},
        {"nom": "Alice", "email": "alice2@example.com"}
    ]
}';

-- Trouver le premier chemin contenant "Alice"
SELECT JSON_SEARCH(@json, 'one', 'Alice') AS chemin;
-- "$.users[0].nom"

-- Trouver tous les chemins contenant "Alice"
SELECT JSON_SEARCH(@json, 'all', 'Alice') AS chemins;
-- ["$.users[0].nom", "$.users[2].nom"]

-- Recherche avec wildcard
SELECT JSON_SEARCH(@json, 'all', 'alice%') AS avec_wildcard;
-- ["$.users[0].email", "$.users[2].email"]

-- Recherche dans un chemin sp√©cifique
SELECT JSON_SEARCH(@json, 'all', '%example.com', NULL, '$.users[*].email') AS emails;
-- ["$.users[0].email", "$.users[1].email", "$.users[2].email"]
```

**Cas d'usage** : Localiser des valeurs dans des structures complexes

```sql
-- Trouver o√π se trouve un email
SELECT
    id,
    JSON_SEARCH(data, 'one', 'alice@example.com') AS chemin_email
FROM users
WHERE JSON_SEARCH(data, 'one', 'alice@example.com') IS NOT NULL;
```

### JSON_OVERLAPS() : V√©rifier le chevauchement (MariaDB 10.5+)

```sql
-- Syntaxe : JSON_OVERLAPS(json_doc1, json_doc2)
-- Retourne 1 si les documents ont au moins un √©l√©ment en commun

-- Tableaux avec chevauchement
SELECT JSON_OVERLAPS('["a", "b", "c"]', '["c", "d", "e"]') AS overlap;
-- 1 (√©l√©ment commun : "c")

-- Tableaux sans chevauchement
SELECT JSON_OVERLAPS('["a", "b"]', '["x", "y"]') AS no_overlap;
-- 0

-- Objets avec chevauchement
SELECT JSON_OVERLAPS('{"a": 1, "b": 2}', '{"b": 2, "c": 3}') AS overlap_obj;
-- 1 (cl√©/valeur commune : "b": 2)
```

**Cas d'usage** : Comparer des ensembles de tags

```sql
-- Trouver les produits avec au moins un tag en commun
SELECT p1.nom AS produit1, p2.nom AS produit2
FROM produits p1
JOIN produits p2 ON p1.id < p2.id
WHERE JSON_OVERLAPS(p1.tags, p2.tags) = 1;

-- Recommandations bas√©es sur tags communs
SELECT
    p.nom,
    p.prix,
    JSON_OVERLAPS(p.tags, '["electronics", "gadgets"]') AS pertinent
FROM produits p
WHERE JSON_OVERLAPS(p.tags, '["electronics", "gadgets"]') = 1;
```

---

## 5. Fonctions d'agr√©gation

### JSON_ARRAYAGG() : Agr√©ger en tableau JSON

```sql
-- Syntaxe : JSON_ARRAYAGG(value)
-- Agr√®ge plusieurs valeurs en un tableau JSON

-- Exemple simple
SELECT JSON_ARRAYAGG(nom) AS tous_les_noms
FROM utilisateurs;
-- ["Alice", "Bob", "Charlie", "David"]

-- Avec GROUP BY
SELECT
    departement,
    JSON_ARRAYAGG(nom) AS employes
FROM employes
GROUP BY departement;
-- departement | employes
-- IT          | ["Alice", "Bob", "Charlie"]
-- Marketing   | ["David", "Eve"]
-- RH          | ["Frank"]

-- Agr√©ger des objets
SELECT JSON_ARRAYAGG(
    JSON_OBJECT('id', id, 'nom', nom, 'prix', prix)
) AS produits_json
FROM produits
WHERE categorie = 'Electronique';
-- [{"id": 1, "nom": "Laptop", "prix": 999}, {"id": 2, "nom": "Phone", "prix": 599}]
```

**Cas d'usage** : Construire des structures imbriqu√©es

```sql
-- Cat√©gories avec leurs produits
SELECT
    c.nom AS categorie,
    JSON_ARRAYAGG(
        JSON_OBJECT(
            'id', p.id,
            'nom', p.nom,
            'prix', p.prix
        )
    ) AS produits
FROM categories c
LEFT JOIN produits p ON c.id = p.categorie_id
GROUP BY c.id, c.nom;

-- Utilisateurs avec leurs commandes
SELECT
    u.id,
    u.nom,
    JSON_ARRAYAGG(
        JSON_OBJECT(
            'commande_id', c.id,
            'date', c.date_commande,
            'montant', c.montant_total
        )
    ) AS historique_commandes
FROM utilisateurs u
LEFT JOIN commandes c ON u.id = c.client_id
GROUP BY u.id, u.nom;
```

### JSON_OBJECTAGG() : Agr√©ger en objet JSON

```sql
-- Syntaxe : JSON_OBJECTAGG(key, value)
-- Agr√®ge des paires cl√©/valeur en un objet JSON

-- Exemple simple
SELECT JSON_OBJECTAGG(code, nom) AS pays
FROM pays
WHERE continent = 'Europe'
LIMIT 5;
-- {"FR": "France", "DE": "Allemagne", "IT": "Italie", "ES": "Espagne", "UK": "Royaume-Uni"}

-- Cr√©er un mapping ID ‚Üí Nom
SELECT JSON_OBJECTAGG(id, nom) AS produits_map
FROM produits
WHERE categorie_id = 3;
-- {"10": "Produit A", "11": "Produit B", "12": "Produit C"}

-- Avec GROUP BY
SELECT
    categorie,
    JSON_OBJECTAGG(nom, prix) AS prix_par_produit
FROM produits
GROUP BY categorie;
-- categorie    | prix_par_produit
-- Electronique | {"Laptop": 999, "Phone": 599, "Tablet": 399}
-- Vetements    | {"T-Shirt": 29, "Jeans": 79}
```

**Cas d'usage** : Cr√©er des dictionnaires

```sql
-- Configuration par module
SELECT JSON_OBJECTAGG(module, settings) AS configuration_complete
FROM configurations;
-- {
--   "email": {"smtp_host": "smtp.example.com", "smtp_port": 587},
--   "sms": {"provider": "twilio", "sender": "+1234567890"},
--   "storage": {"backend": "s3", "bucket": "my-bucket"}
-- }

-- Statistiques par r√©gion
SELECT JSON_OBJECTAGG(
    region,
    JSON_OBJECT('ventes', SUM(montant), 'nb_commandes', COUNT(*))
) AS stats_par_region
FROM commandes
JOIN clients ON commandes.client_id = clients.id
WHERE date_commande >= '2024-01-01';
```

---

## 6. Fonctions utilitaires

### JSON_TYPE() : D√©terminer le type d'une valeur

```sql
-- Types JSON possibles : NULL, BOOLEAN, INTEGER, DOUBLE, STRING, ARRAY, OBJECT
SELECT JSON_TYPE('null') AS type;
-- NULL

SELECT JSON_TYPE('true') AS type;
-- BOOLEAN

SELECT JSON_TYPE('123') AS type;
-- INTEGER

SELECT JSON_TYPE('123.45') AS type;
-- DOUBLE

SELECT JSON_TYPE('"texte"') AS type;
-- STRING

SELECT JSON_TYPE('["a", "b"]') AS type;
-- ARRAY

SELECT JSON_TYPE('{"key": "value"}') AS type;
-- OBJECT

-- Sur une valeur extraite
SET @json = '{"nom": "Alice", "age": 30, "tags": ["a", "b"]}';
SELECT
    JSON_TYPE(JSON_EXTRACT(@json, '$.nom')) AS type_nom,
    JSON_TYPE(JSON_EXTRACT(@json, '$.age')) AS type_age,
    JSON_TYPE(JSON_EXTRACT(@json, '$.tags')) AS type_tags;
-- type_nom: STRING, type_age: INTEGER, type_tags: ARRAY
```

**Cas d'usage** : Validation dynamique

```sql
-- V√©rifier le type avant conversion
SELECT
    id,
    data->'$.prix' AS prix_json,
    JSON_TYPE(data->'$.prix') AS type_prix,
    CASE
        WHEN JSON_TYPE(data->'$.prix') IN ('INTEGER', 'DOUBLE')
        THEN CAST(data->>'$.prix' AS DECIMAL(10,2))
        ELSE 0
    END AS prix_converti
FROM produits;
```

### JSON_LENGTH() : Compter les √©l√©ments

```sql
-- Pour un tableau : nombre d'√©l√©ments
SELECT JSON_LENGTH('["a", "b", "c", "d"]') AS longueur;
-- 4

-- Pour un objet : nombre de cl√©s
SELECT JSON_LENGTH('{"a": 1, "b": 2, "c": 3}') AS nb_cles;
-- 3

-- Pour un scalaire : 1
SELECT JSON_LENGTH('"texte"') AS longueur;
-- 1

-- Longueur √† un chemin sp√©cifique
SET @json = '{"items": ["a", "b", "c"], "metadata": {"x": 1, "y": 2}}';
SELECT
    JSON_LENGTH(@json, '$.items') AS nb_items,
    JSON_LENGTH(@json, '$.metadata') AS nb_metadata;
-- nb_items: 3, nb_metadata: 2
```

**Cas d'usage** : Validation et statistiques

```sql
-- Filtrer par nombre de tags
SELECT * FROM articles
WHERE JSON_LENGTH(tags) >= 3;

-- Statistiques sur la taille des tableaux
SELECT
    AVG(JSON_LENGTH(tags)) AS tags_moyen,
    MAX(JSON_LENGTH(tags)) AS tags_max,
    MIN(JSON_LENGTH(tags)) AS tags_min
FROM articles;
```

### JSON_DEPTH() : Profondeur d'imbrication

```sql
-- Profondeur = nombre maximum de niveaux d'imbrication
SELECT JSON_DEPTH('42') AS depth;
-- 1 (scalaire)

SELECT JSON_DEPTH('["a", "b"]') AS depth;
-- 2 (tableau de scalaires)

SELECT JSON_DEPTH('{"a": {"b": {"c": 1}}}') AS depth;
-- 4 (3 niveaux d'objets imbriqu√©s)

SELECT JSON_DEPTH('[1, [2, [3, [4]]]]') AS depth;
-- 5 (tableaux imbriqu√©s)
```

**Cas d'usage** : D√©tecter les structures trop complexes

```sql
-- Identifier les documents trop imbriqu√©s
SELECT
    id,
    JSON_DEPTH(data) AS profondeur
FROM documents
WHERE JSON_DEPTH(data) > 5
ORDER BY profondeur DESC;
-- Structures > 5 niveaux peuvent impacter les performances
```

### JSON_KEYS() : Lister les cl√©s d'un objet

```sql
-- Obtenir toutes les cl√©s d'un objet
SELECT JSON_KEYS('{"nom": "Alice", "age": 30, "ville": "Paris"}') AS cles;
-- ["nom", "age", "ville"]

-- Cl√©s √† un chemin sp√©cifique
SET @json = '{
    "user": {"nom": "Bob", "email": "bob@example.com"},
    "preferences": {"theme": "dark", "langue": "fr"}
}';

SELECT JSON_KEYS(@json, '$.user') AS cles_user;
-- ["nom", "email"]

SELECT JSON_KEYS(@json, '$.preferences') AS cles_prefs;
-- ["theme", "langue"]
```

**Cas d'usage** : Introspection de sch√©ma

```sql
-- D√©couvrir les champs disponibles
SELECT DISTINCT JSON_KEYS(metadata) AS champs_disponibles
FROM produits
WHERE categorie = 'Electronique';

-- Compter les documents avec une cl√© sp√©cifique
SELECT
    COUNT(*) AS nb_avec_email
FROM utilisateurs
WHERE JSON_CONTAINS(JSON_KEYS(profile), '"email"');
```

### JSON_VALID() : Valider un JSON

```sql
-- V√©rifier si une cha√Æne est un JSON valide
SELECT JSON_VALID('{"valid": true}') AS valide;
-- 1

SELECT JSON_VALID('{invalid}') AS valide;
-- 0

SELECT JSON_VALID('["a", "b", "c"]') AS valide;
-- 1

-- Valider avant insertion
SELECT
    texte,
    JSON_VALID(texte) AS est_json_valide
FROM imports
WHERE JSON_VALID(texte) = 0;
-- Identifier les lignes avec JSON invalide
```

### JSON_PRETTY() : Formater JSON lisible

```sql
-- Formater JSON avec indentation
SELECT JSON_PRETTY('{"nom":"Alice","age":30,"ville":"Paris"}') AS formate;
-- {
--   "nom": "Alice",
--   "age": 30,
--   "ville": "Paris"
-- }

-- Utile pour debugging
SET @json_complex = '{"user":{"profile":{"name":"Bob","contact":{"email":"bob@example.com","phone":"+123456"}}}}';
SELECT JSON_PRETTY(@json_complex) AS lisible;
-- {
--   "user": {
--     "profile": {
--       "name": "Bob",
--       "contact": {
--         "email": "bob@example.com",
--         "phone": "+123456"
--       }
--     }
--   }
-- }
```

---

## 7. Cas d'usage pratiques combin√©s

### Exemple 1 : API de configuration dynamique

```sql
-- Table de configuration modulaire
CREATE TABLE app_config (
    module VARCHAR(50) PRIMARY KEY,
    config JSON,
    version INT DEFAULT 1,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Ins√©rer des configurations
INSERT INTO app_config (module, config) VALUES
    ('database', JSON_OBJECT(
        'host', 'localhost',
        'port', 3306,
        'pool_size', 10,
        'timeout', 30
    )),
    ('email', JSON_OBJECT(
        'smtp_host', 'smtp.example.com',
        'smtp_port', 587,
        'use_tls', TRUE,
        'from', 'noreply@example.com'
    ));

-- Mettre √† jour un param√®tre sp√©cifique
UPDATE app_config
SET config = JSON_SET(config, '$.pool_size', 20)
WHERE module = 'database';

-- Ajouter un nouveau param√®tre
UPDATE app_config
SET config = JSON_SET(config, '$.debug_mode', FALSE)
WHERE module = 'database';

-- R√©cup√©rer une configuration compl√®te
SELECT JSON_PRETTY(config) AS configuration
FROM app_config
WHERE module = 'email';
```

### Exemple 2 : Syst√®me de tags flexible

```sql
-- Gestion de tags pour articles
CREATE TABLE articles (
    id INT PRIMARY KEY AUTO_INCREMENT,
    titre VARCHAR(200),
    contenu TEXT,
    tags JSON,
    INDEX idx_tags ((CAST(tags AS CHAR(500) ARRAY)))
);

-- Ajouter un article avec tags
INSERT INTO articles (titre, contenu, tags) VALUES
    ('Introduction SQL', 'Contenu...', JSON_ARRAY('sql', 'database', 'tutorial')),
    ('Window Functions', 'Contenu...', JSON_ARRAY('sql', 'advanced', 'analytics'));

-- Ajouter un tag
UPDATE articles
SET tags = JSON_ARRAY_APPEND(tags, '$', 'mariadb')
WHERE id = 1;

-- Supprimer un tag (n√©cessite reconstruction)
UPDATE articles
SET tags = JSON_REMOVE(tags, CONCAT('$[', JSON_SEARCH(tags, 'one', 'tutorial'), ']'))
WHERE id = 1;

-- Rechercher articles par tag
SELECT id, titre, tags
FROM articles
WHERE JSON_CONTAINS(tags, '"sql"');

-- Tags les plus populaires
SELECT
    tag,
    COUNT(*) AS nb_articles
FROM articles,
JSON_TABLE(tags, '$[*]' COLUMNS(tag VARCHAR(50) PATH '$')) AS jt
GROUP BY tag
ORDER BY nb_articles DESC;
```

### Exemple 3 : Audit trail avec contexte variable

```sql
-- Journal d'audit avec contexte JSON flexible
CREATE TABLE audit_log (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    timestamp DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    user_id INT,
    action VARCHAR(50),
    entity_type VARCHAR(50),
    entity_id INT,
    context JSON,
    INDEX(user_id, timestamp),
    INDEX(action),
    INDEX(entity_type, entity_id)
);

-- Diff√©rents types d'√©v√©nements
INSERT INTO audit_log (user_id, action, entity_type, entity_id, context) VALUES
    -- Connexion
    (101, 'login', NULL, NULL, JSON_OBJECT(
        'ip', '192.168.1.100',
        'user_agent', 'Chrome/120.0',
        'success', TRUE
    )),
    -- Modification
    (101, 'update', 'produit', 42, JSON_OBJECT(
        'champs_modifies', JSON_ARRAY('prix', 'stock'),
        'ancienne_valeur', JSON_OBJECT('prix', 99.99, 'stock', 10),
        'nouvelle_valeur', JSON_OBJECT('prix', 89.99, 'stock', 15)
    )),
    -- Suppression
    (102, 'delete', 'commande', 5042, JSON_OBJECT(
        'raison', 'Demande client',
        'montant', 149.99,
        'statut_avant', 'en_attente'
    ));

-- Requ√™tes d'analyse
-- Toutes les modifications de prix
SELECT
    timestamp,
    user_id,
    entity_id,
    context->>'$.ancienne_valeur.prix' AS ancien_prix,
    context->>'$.nouvelle_valeur.prix' AS nouveau_prix
FROM audit_log
WHERE action = 'update'
  AND entity_type = 'produit'
  AND JSON_CONTAINS_PATH(context, 'one', '$.champs_modifies')
  AND JSON_CONTAINS(context->'$.champs_modifies', '"prix"');
```

---

## ‚úÖ Points cl√©s √† retenir

- **Cr√©ation** : JSON_OBJECT() et JSON_ARRAY() pour construire des documents
- **Extraction** : JSON_EXTRACT() ou op√©rateurs -> et ->> (plus pratiques)
- **Modification** : JSON_SET() (ajoute/remplace), JSON_INSERT() (ajoute seulement), JSON_REPLACE() (remplace seulement)
- **Suppression** : JSON_REMOVE() pour supprimer cl√©s ou √©l√©ments de tableau
- **Recherche** : JSON_CONTAINS() (pr√©sence valeur), JSON_CONTAINS_PATH() (pr√©sence chemin), JSON_SEARCH() (trouver chemin)
- **Agr√©gation** : JSON_ARRAYAGG() (tableau), JSON_OBJECTAGG() (objet) pour construire JSON depuis lignes SQL
- **Utilitaires** : JSON_TYPE(), JSON_LENGTH(), JSON_KEYS(), JSON_VALID() pour introspection
- **-> vs ->>** : -> retourne JSON (avec guillemets), ->> retourne texte brut (sans guillemets)
- **Performance** : Extraction JSON = parsing √† chaque fois ‚Üí utiliser colonnes virtuelles pour valeurs fr√©quemment recherch√©es
- **Validation** : Toujours valider avec JSON_VALID() avant d'ins√©rer dans colonnes LONGTEXT non-JSON
- **Chemins JSONPath** : $ (racine), .key (cl√©), [n] (index), [*] (tous), .* (toutes valeurs)
- **JSON_MERGE_PRESERVE** : Fusionne documents (cl√©s dupliqu√©es deviennent tableaux)

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation officielle MariaDB - JSON Functions](https://mariadb.com/kb/en/json-functions/)
- [üìñ JSON_EXTRACT](https://mariadb.com/kb/en/json_extract/)
- [üìñ JSON_SET](https://mariadb.com/kb/en/json_set/)
- [üìñ JSON_ARRAYAGG](https://mariadb.com/kb/en/json_arrayagg/)
- [üìñ JSON_OBJECTAGG](https://mariadb.com/kb/en/json_objectagg/)
- [üìñ JSONPath Syntax](https://mariadb.com/kb/en/json-path-expressions/)

**R√©f√©rences externes** :
- [JSONPath Online Evaluator](https://jsonpath.com/)
- [JSON Schema Validator](https://www.jsonschemavalidator.net/)

---

## ‚û°Ô∏è Section suivante

**[4.7.3 Op√©rateur raccourci (->>)](/04-concepts-avances-sql/07.3-operateur-raccourci-json.md)** : Approfondir l'utilisation des op√©rateurs -> et ->> avec des exemples avanc√©s et optimisations.

---

**Note pratique** : MariaDB offre une biblioth√®que JSON riche et mature. Ma√Ætriser ces fonctions permet de cr√©er des applications hybrides alliant la flexibilit√© du JSON et la puissance du SQL relationnel. Privil√©giez les op√©rateurs raccourcis (->, ->>) pour la lisibilit√©, et utilisez des colonnes virtuelles pour optimiser les performances des requ√™tes fr√©quentes ! üéØ

‚è≠Ô∏è [Op√©rateur raccourci (->>)](/04-concepts-avances-sql/07.3-operateur-raccourci-json.md)
