üîù Retour au [Sommaire](/SOMMAIRE.md)

# 4.2.3 Frames de fen√™tre (ROWS, RANGE, GROUPS)

> **Niveau** : Avanc√©
> **Dur√©e estim√©e** : 3-4 heures
> **Pr√©requis** : Ma√Ætrise des Window Functions (4.2), fonctions de rang (4.2.1), fonctions de valeur (4.2.2)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre le concept de frame (cadre) dans une fen√™tre
- Distinguer les trois types de frames : ROWS, RANGE et GROUPS
- Ma√Ætriser la syntaxe des bornes de frame (PRECEDING, FOLLOWING, UNBOUNDED)
- Calculer des moyennes mobiles et cumuls avec pr√©cision
- Choisir le type de frame appropri√© selon le contexte
- √âviter les pi√®ges li√©s au frame par d√©faut
- Optimiser les performances des calculs glissants

---

## Introduction

Un **frame** (cadre de fen√™tre) d√©finit un **sous-ensemble de lignes** √† l'int√©rieur d'une partition pour le calcul d'une fonction de fen√™tre. C'est l'un des concepts les plus puissants et les plus subtils des Window Functions.

### Pourquoi les frames sont-ils importants ?

Sans frame explicite, MariaDB utilise un **frame par d√©faut** qui peut ne pas correspondre √† vos attentes :

```sql
-- Ces deux requ√™tes sont IDENTIQUES (frame par d√©faut)
SELECT
    date_vente,
    montant,
    SUM(montant) OVER (ORDER BY date_vente) AS cumul
FROM ventes;

SELECT
    date_vente,
    montant,
    SUM(montant) OVER (
        ORDER BY date_vente
        RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW  -- Frame par d√©faut !
    ) AS cumul
FROM ventes;
```

üí° **Point cl√©** : Le frame d√©termine **quelles lignes** sont incluses dans le calcul pour chaque ligne courante.

### Analogie visuelle

Imaginez une fen√™tre qui se d√©place ligne par ligne. Le **frame** est comme un **cadre photo** qui s√©lectionne certaines lignes √† travers cette fen√™tre :

```
Partition compl√®te : [1] [2] [3] [4] [5] [6] [7] [8]

Frame pour ligne 5 avec "3 PRECEDING TO 2 FOLLOWING" :
                    [3] [4] [5] [6] [7]
                         ‚ñ≤
                    ligne courante
```

---

## Syntaxe g√©n√©rale des frames

```sql
fonction_window() OVER (
    [PARTITION BY ...]
    ORDER BY ...
    {ROWS | RANGE | GROUPS} BETWEEN frame_start AND frame_end
)
```

### Options de bornes (frame_start et frame_end)

| Option | Description | Exemple |
|--------|-------------|---------|
| **UNBOUNDED PRECEDING** | D√©but de la partition | Depuis le premier √©l√©ment |
| **n PRECEDING** | n √©l√©ments avant la ligne courante | 3 lignes avant |
| **CURRENT ROW** | Ligne courante | L'√©l√©ment actuel |
| **n FOLLOWING** | n √©l√©ments apr√®s la ligne courante | 2 lignes apr√®s |
| **UNBOUNDED FOLLOWING** | Fin de la partition | Jusqu'au dernier √©l√©ment |

### Formes raccourcies

```sql
-- Forme compl√®te
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW

-- Formes raccourcies √©quivalentes
ROWS UNBOUNDED PRECEDING
ROWS CURRENT ROW  -- Uniquement la ligne courante
```

---

## ROWS : Frame bas√© sur les lignes physiques

### D√©finition

`ROWS` d√©finit le frame en comptant un **nombre fixe de lignes physiques** avant et apr√®s la ligne courante, ind√©pendamment des valeurs.

### Caract√©ristiques

- ‚úÖ Compte les lignes **physiquement** (1, 2, 3...)
- ‚úÖ Pr√©visible et d√©terministe
- ‚úÖ Id√©al pour fen√™tres glissantes de taille fixe
- ‚úÖ Ignore les valeurs, se base uniquement sur la position

### Exemple 1 : Moyenne mobile simple (SMA)

```sql
-- Moyenne mobile sur 7 jours
SELECT
    date_vente,
    montant,
    ROUND(
        AVG(montant) OVER (
            ORDER BY date_vente
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ),
        2
    ) AS moyenne_mobile_7j,
    -- Pour comparaison : moyenne mobile sur 3 jours
    ROUND(
        AVG(montant) OVER (
            ORDER BY date_vente
            ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
        ),
        2
    ) AS moyenne_mobile_3j
FROM ventes_quotidiennes
ORDER BY date_vente DESC
LIMIT 30;
```

**R√©sultat conceptuel :**
```
| date_vente | montant | moyenne_mobile_7j | moyenne_mobile_3j |
|------------|---------|-------------------|-------------------|
| 2024-12-10 | 1500    | 1423.57           | 1466.67           |
| 2024-12-09 | 1450    | 1398.43           | 1450.00           |
| 2024-12-08 | 1450    | 1385.71           | 1433.33           |
| 2024-12-07 | 1400    | 1371.43           | 1400.00           |
```

üí° **Explication** : Chaque ligne prend en compte exactement 7 lignes (6 pr√©c√©dentes + actuelle), m√™me si certains jours ont les m√™mes valeurs.

### Exemple 2 : Total cumul√© (running total)

```sql
-- Cumul des ventes depuis le d√©but
SELECT
    date_vente,
    montant,
    SUM(montant) OVER (
        ORDER BY date_vente
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumul_total,
    -- Cumul des 30 derniers jours glissants
    SUM(montant) OVER (
        ORDER BY date_vente
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS cumul_30j_glissant
FROM ventes_quotidiennes
ORDER BY date_vente;
```

### Exemple 3 : Fen√™tre centr√©e

```sql
-- Moyenne centr√©e sur la ligne actuelle
-- (1 avant + actuelle + 1 apr√®s = fen√™tre de 3 lignes)
SELECT
    date_mesure,
    temperature,
    ROUND(
        AVG(temperature) OVER (
            ORDER BY date_mesure
            ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
        ),
        2
    ) AS temperature_lissee,
    -- √âcart par rapport √† la moyenne liss√©e
    ROUND(
        temperature - AVG(temperature) OVER (
            ORDER BY date_mesure
            ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
        ),
        2
    ) AS ecart
FROM mesures_meteo
ORDER BY date_mesure;
```

### Exemple 4 : Fen√™tre asym√©trique

```sql
-- Maximum des 5 derni√®res valeurs + 2 valeurs suivantes
SELECT
    date_vente,
    produit_id,
    quantite,
    MAX(quantite) OVER (
        PARTITION BY produit_id
        ORDER BY date_vente
        ROWS BETWEEN 5 PRECEDING AND 2 FOLLOWING
    ) AS max_fenetre_asymetrique,
    -- Minimum de la fen√™tre
    MIN(quantite) OVER (
        PARTITION BY produit_id
        ORDER BY date_vente
        ROWS BETWEEN 5 PRECEDING AND 2 FOLLOWING
    ) AS min_fenetre_asymetrique
FROM ventes
ORDER BY produit_id, date_vente;
```

### Cas d'usage ROWS : Indicateurs techniques financiers

```sql
-- RSI (Relative Strength Index) simplifi√©
WITH variations AS (
    SELECT
        date_cotation,
        cours_cloture,
        cours_cloture - LAG(cours_cloture, 1) OVER (ORDER BY date_cotation) AS variation
    FROM cours_bourse
    WHERE symbole = 'AAPL'
),
gains_pertes AS (
    SELECT
        date_cotation,
        cours_cloture,
        CASE WHEN variation > 0 THEN variation ELSE 0 END AS gain,
        CASE WHEN variation < 0 THEN ABS(variation) ELSE 0 END AS perte,
        -- Moyenne des gains sur 14 jours
        AVG(CASE WHEN variation > 0 THEN variation ELSE 0 END) OVER (
            ORDER BY date_cotation
            ROWS BETWEEN 13 PRECEDING AND CURRENT ROW
        ) AS avg_gain_14j,
        -- Moyenne des pertes sur 14 jours
        AVG(CASE WHEN variation < 0 THEN ABS(variation) ELSE 0 END) OVER (
            ORDER BY date_cotation
            ROWS BETWEEN 13 PRECEDING AND CURRENT ROW
        ) AS avg_perte_14j
    FROM variations
)
SELECT
    date_cotation,
    cours_cloture,
    ROUND(
        100 - (100 / (1 + (avg_gain_14j / NULLIF(avg_perte_14j, 0)))),
        2
    ) AS rsi_14j,
    CASE
        WHEN 100 - (100 / (1 + (avg_gain_14j / NULLIF(avg_perte_14j, 0)))) > 70
            THEN 'üî¥ Surachat'
        WHEN 100 - (100 / (1 + (avg_gain_14j / NULLIF(avg_perte_14j, 0)))) < 30
            THEN 'üü¢ Survente'
        ELSE 'üü° Neutre'
    END AS signal
FROM gains_pertes
ORDER BY date_cotation DESC
LIMIT 30;
```

---

## RANGE : Frame bas√© sur les valeurs

### D√©finition

`RANGE` d√©finit le frame en se basant sur les **valeurs** de la colonne ORDER BY, et non sur le nombre de lignes. Toutes les lignes ayant la **m√™me valeur** dans ORDER BY sont trait√©es comme un groupe.

### Caract√©ristiques

- ‚úÖ Se base sur les **valeurs**, pas les positions physiques
- ‚úÖ Inclut toutes les lignes avec la m√™me valeur ORDER BY
- ‚ö†Ô∏è Moins intuitif que ROWS
- ‚ö†Ô∏è Limit√© aux colonnes num√©riques ou temporelles pour les intervalles

### Diff√©rence ROWS vs RANGE

```sql
-- Dataset d'exemple avec doublons de dates
CREATE TEMPORARY TABLE ventes_test (
    date_vente DATE,
    montant DECIMAL(10,2)
);

INSERT INTO ventes_test VALUES
    ('2024-12-01', 100),
    ('2024-12-01', 200),  -- M√™me date
    ('2024-12-01', 150),  -- M√™me date
    ('2024-12-02', 300),
    ('2024-12-03', 250);

-- Comparaison ROWS vs RANGE
SELECT
    date_vente,
    montant,
    -- ROWS : Compte 2 lignes physiques avant + actuelle
    SUM(montant) OVER (
        ORDER BY date_vente
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS sum_rows,
    -- RANGE : Inclut toutes les lignes avec date <= date_courante
    SUM(montant) OVER (
        ORDER BY date_vente
        RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS sum_range
FROM ventes_test
ORDER BY date_vente, montant;
```

**R√©sultat :**
```
| date_vente | montant | sum_rows | sum_range |
|------------|---------|----------|-----------|
| 2024-12-01 | 100     | 100      | 450       | -- RANGE inclut les 3 lignes du 01/12
| 2024-12-01 | 150     | 250      | 450       | -- RANGE : m√™me total pour m√™me date
| 2024-12-01 | 200     | 450      | 450       | -- RANGE : m√™me total pour m√™me date
| 2024-12-02 | 300     | 650      | 750       | -- RANGE inclut tout jusqu'au 02/12
| 2024-12-03 | 250     | 750      | 1000      | -- RANGE inclut tout
```

üí° **Observation** :
- **ROWS** : Calculs diff√©rents pour chaque ligne, m√™me avec date identique
- **RANGE** : Calculs identiques pour toutes les lignes ayant la m√™me date

### Exemple 5 : RANGE avec intervalles temporels

```sql
-- Somme des ventes dans une fen√™tre de 7 jours calendaires
SELECT
    date_vente,
    montant,
    SUM(montant) OVER (
        ORDER BY date_vente
        RANGE BETWEEN INTERVAL 7 DAY PRECEDING AND CURRENT ROW
    ) AS ventes_7j_calendaires
FROM ventes_quotidiennes
ORDER BY date_vente;
```

‚ö†Ô∏è **Important** : Avec RANGE et INTERVAL, MariaDB inclut toutes les ventes dont la date est entre `date_courante - 7 jours` et `date_courante`, m√™me s'il y a des jours sans ventes.

### Exemple 6 : RANGE avec valeurs num√©riques

```sql
-- Produits dans une fourchette de prix ¬±10%
SELECT
    produit_id,
    nom,
    prix,
    COUNT(*) OVER (
        ORDER BY prix
        RANGE BETWEEN prix * 0.9 PRECEDING AND prix * 1.1 FOLLOWING
    ) AS nb_produits_fourchette_10pct
FROM produits
ORDER BY prix;
```

‚ö†Ô∏è **Limitation** : La syntaxe `prix * 0.9 PRECEDING` n'est pas support√©e directement par MariaDB. Il faut utiliser des valeurs absolues ou des CTE.

### Cas d'usage RANGE : Groupement par p√©riodes

```sql
-- Ventes totales par jour (g√®re plusieurs transactions par jour)
SELECT DISTINCT
    date_vente,
    SUM(montant) OVER (
        ORDER BY date_vente
        RANGE BETWEEN CURRENT ROW AND CURRENT ROW
    ) AS total_jour,
    -- Ventes cumul√©es
    SUM(montant) OVER (
        ORDER BY date_vente
        RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumul_total
FROM ventes
ORDER BY date_vente;
```

---

## GROUPS : Frame bas√© sur les groupes de valeurs

### D√©finition

`GROUPS` (introduit dans MariaDB 10.2) traite chaque ensemble de lignes ayant la **m√™me valeur ORDER BY** comme un **groupe unique**. C'est un compromis entre ROWS et RANGE.

### Caract√©ristiques

- ‚úÖ Compte les **groupes de valeurs distinctes**
- ‚úÖ Un groupe = toutes les lignes avec la m√™me valeur ORDER BY
- ‚úÖ Utile pour les donn√©es avec beaucoup de doublons
- ‚úÖ Plus intuitif que RANGE pour certains cas

### Exemple 7 : ROWS vs RANGE vs GROUPS

```sql
-- Dataset avec doublons
WITH donnees AS (
    SELECT * FROM (VALUES
        ROW('2024-12-01', 100),
        ROW('2024-12-01', 200),
        ROW('2024-12-01', 150),
        ROW('2024-12-02', 300),
        ROW('2024-12-02', 250),
        ROW('2024-12-03', 400)
    ) AS t(date_vente, montant)
)
SELECT
    date_vente,
    montant,
    -- ROWS : 2 lignes physiques avant
    COUNT(*) OVER (
        ORDER BY date_vente
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS count_rows_2,
    -- GROUPS : 2 groupes de dates distinctes avant
    COUNT(*) OVER (
        ORDER BY date_vente
        GROUPS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS count_groups_2,
    -- RANGE : Toutes les lignes avec date <= date actuelle
    COUNT(*) OVER (
        ORDER BY date_vente
        RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS count_range
FROM donnees
ORDER BY date_vente, montant;
```

**R√©sultat :**
```
| date_vente | montant | count_rows_2 | count_groups_2 | count_range |
|------------|---------|--------------|----------------|-------------|
| 2024-12-01 | 100     | 1            | 3              | 3           |
| 2024-12-01 | 150     | 2            | 3              | 3           |
| 2024-12-01 | 200     | 3            | 3              | 3           |
| 2024-12-02 | 250     | 3            | 5              | 5           |
| 2024-12-02 | 300     | 3            | 5              | 5           |
| 2024-12-03 | 400     | 3            | 6              | 6           |
```

üí° **Explication count_groups_2** :
- Pour les lignes du 01/12 : 1 groupe (01/12 seulement)
- Pour les lignes du 02/12 : 2 groupes (01/12 et 02/12)
- Pour la ligne du 03/12 : 3 groupes (01/12, 02/12, 03/12)

### Exemple 8 : Somme des 3 derniers jours distincts

```sql
-- Ventes des 3 derniers jours de vente distincts (pas forc√©ment cons√©cutifs)
SELECT
    date_vente,
    montant,
    SUM(montant) OVER (
        ORDER BY date_vente
        GROUPS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS ventes_3_derniers_jours_distincts,
    -- Pour comparaison : 3 derni√®res lignes (ROWS)
    SUM(montant) OVER (
        ORDER BY date_vente
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS ventes_3_dernieres_lignes
FROM ventes
ORDER BY date_vente;
```

### Cas d'usage GROUPS : Analyse de tendances

```sql
-- Identifier si le prix augmente sur les 3 derni√®res modifications distinctes
WITH prix_groupes AS (
    SELECT
        produit_id,
        date_modification,
        prix,
        -- Premier prix du groupe de 3 modifications
        FIRST_VALUE(prix) OVER (
            PARTITION BY produit_id
            ORDER BY date_modification
            GROUPS BETWEEN 2 PRECEDING AND CURRENT ROW
        ) AS prix_debut_periode,
        -- Dernier prix du groupe
        LAST_VALUE(prix) OVER (
            PARTITION BY produit_id
            ORDER BY date_modification
            GROUPS BETWEEN 2 PRECEDING AND CURRENT ROW
            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) AS prix_fin_periode
    FROM historique_prix
)
SELECT
    produit_id,
    date_modification,
    prix,
    CASE
        WHEN prix > prix_debut_periode THEN 'üìà Tendance haussi√®re (3 p√©riodes)'
        WHEN prix < prix_debut_periode THEN 'üìâ Tendance baissi√®re (3 p√©riodes)'
        ELSE '‚û°Ô∏è Stable'
    END AS tendance
FROM prix_groupes
ORDER BY produit_id, date_modification DESC;
```

---

## Frame par d√©faut : Comprendre le comportement implicite

### R√®gle du frame par d√©faut

Lorsqu'aucun frame n'est sp√©cifi√©, MariaDB applique ces r√®gles :

| Situation | Frame par d√©faut |
|-----------|------------------|
| **Avec ORDER BY** | `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW` |
| **Sans ORDER BY** | `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING` |

### Exemple 9 : Implications du frame par d√©faut

```sql
-- CAS 1 : Avec ORDER BY (frame par d√©faut = RANGE ... CURRENT ROW)
SELECT
    date_vente,
    montant,
    SUM(montant) OVER (ORDER BY date_vente) AS cumul_implicite,
    -- √âquivalent explicite
    SUM(montant) OVER (
        ORDER BY date_vente
        RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumul_explicite
FROM ventes;

-- CAS 2 : Sans ORDER BY (frame par d√©faut = toute la partition)
SELECT
    departement_id,
    nom,
    salaire,
    AVG(salaire) OVER (PARTITION BY departement_id) AS salaire_moyen_dept
FROM employes;
-- Frame implicite : ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
```

### ‚ö†Ô∏è Pi√®ge du frame par d√©faut

```sql
-- ‚ùå PI√àGE : MAX avec ORDER BY et frame par d√©faut
SELECT
    date_vente,
    montant,
    MAX(montant) OVER (ORDER BY date_vente) AS max_montant
FROM ventes;
-- Retourne le maximum JUSQU'√Ä la ligne courante, pas le maximum global !

-- ‚úÖ SOLUTION : Frame explicite pour maximum global
SELECT
    date_vente,
    montant,
    MAX(montant) OVER (
        ORDER BY date_vente
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS max_montant_global
FROM ventes;

-- üéØ ALTERNATIVE : Sans ORDER BY (frame = toute la partition)
SELECT
    date_vente,
    montant,
    MAX(montant) OVER () AS max_montant_global
FROM ventes;
```

---

## Comparaison d√©taill√©e : ROWS vs RANGE vs GROUPS

### Tableau r√©capitulatif

| Crit√®re | ROWS | RANGE | GROUPS |
|---------|------|-------|--------|
| **Base de calcul** | Lignes physiques | Valeurs ORDER BY | Groupes de valeurs |
| **Traitement doublons** | Chaque ligne s√©par√©ment | Toutes ensemble | Toutes ensemble |
| **Comptage** | Nombre de lignes | Plage de valeurs | Nombre de groupes distincts |
| **Performance** | üü¢ Rapide | üü° Moyen | üü° Moyen |
| **Pr√©visibilit√©** | üü¢ Tr√®s pr√©visible | üü† Moins intuitif | üü¢ Intuitif |
| **Support intervalles** | ‚ùå Non | ‚úÖ Oui (INTERVAL) | ‚ùå Non |
| **Cas d'usage** | Fen√™tres fixes | Fen√™tres temporelles | Comptage de p√©riodes |

### Exemple 10 : Comparaison compl√®te

```sql
-- Dataset : Ventes avec plusieurs transactions par jour
WITH ventes_exemple AS (
    SELECT DATE '2024-12-01' AS date_vente, 100 AS montant UNION ALL
    SELECT DATE '2024-12-01', 200 UNION ALL
    SELECT DATE '2024-12-02', 150 UNION ALL
    SELECT DATE '2024-12-03', 300 UNION ALL
    SELECT DATE '2024-12-03', 250 UNION ALL
    SELECT DATE '2024-12-03', 400 UNION ALL
    SELECT DATE '2024-12-04', 175
)
SELECT
    date_vente,
    montant,
    -- ROWS : 2 lignes physiques avant + actuelle
    SUM(montant) OVER (
        ORDER BY date_vente
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS sum_rows_2,
    -- RANGE : Toutes les lignes jusqu'√† la date actuelle
    SUM(montant) OVER (
        ORDER BY date_vente
        RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS sum_range_cumul,
    -- GROUPS : 2 dates distinctes avant + actuelle
    SUM(montant) OVER (
        ORDER BY date_vente
        GROUPS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS sum_groups_2,
    -- Comptage correspondant
    COUNT(*) OVER (
        ORDER BY date_vente
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS count_rows,
    COUNT(*) OVER (
        ORDER BY date_vente
        GROUPS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS count_groups
FROM ventes_exemple
ORDER BY date_vente, montant;
```

**R√©sultat d√©taill√© :**
```
| date_vente | montant | sum_rows_2 | sum_range_cumul | sum_groups_2 | count_rows | count_groups |
|------------|---------|------------|-----------------|--------------|------------|--------------|
| 2024-12-01 | 100     | 100        | 300             | 300          | 1          | 2            |
| 2024-12-01 | 200     | 300        | 300             | 300          | 2          | 2            |
| 2024-12-02 | 150     | 450        | 450             | 450          | 3          | 3            |
| 2024-12-03 | 250     | 600        | 1400            | 1250         | 3          | 5            |
| 2024-12-03 | 300     | 700        | 1400            | 1250         | 3          | 5            |
| 2024-12-03 | 400     | 950        | 1400            | 1250         | 3          | 5            |
| 2024-12-04 | 175     | 875        | 1575            | 1575         | 3          | 7            |
```

---

## Cas d'usage pratiques avanc√©s

### 1. Moyenne mobile pond√©r√©e (WMA)

```sql
-- Moyenne mobile o√π les valeurs r√©centes ont plus de poids
WITH ventes_ponderees AS (
    SELECT
        date_vente,
        montant,
        ROW_NUMBER() OVER (ORDER BY date_vente DESC) AS poids_recence
    FROM ventes_quotidiennes
)
SELECT
    date_vente,
    montant,
    ROUND(
        SUM(montant * (8 - poids_recence)) OVER (
            ORDER BY date_vente
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ) / SUM(8 - poids_recence) OVER (
            ORDER BY date_vente
            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
        ),
        2
    ) AS wma_7j
FROM ventes_ponderees
WHERE poids_recence <= 7
ORDER BY date_vente DESC;
```

### 2. √âcart-type mobile (volatilit√©)

```sql
-- Volatilit√© sur 30 jours glissants
SELECT
    date_cotation,
    cours_cloture,
    ROUND(
        STDDEV(cours_cloture) OVER (
            ORDER BY date_cotation
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ),
        2
    ) AS volatilite_30j,
    -- Bandes de Bollinger (moyenne ¬± 2 √©carts-types)
    ROUND(
        AVG(cours_cloture) OVER (
            ORDER BY date_cotation
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) + 2 * STDDEV(cours_cloture) OVER (
            ORDER BY date_cotation
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ),
        2
    ) AS bollinger_sup,
    ROUND(
        AVG(cours_cloture) OVER (
            ORDER BY date_cotation
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ) - 2 * STDDEV(cours_cloture) OVER (
            ORDER BY date_cotation
            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
        ),
        2
    ) AS bollinger_inf
FROM cours_bourse
WHERE symbole = 'AAPL'
ORDER BY date_cotation DESC
LIMIT 60;
```

### 3. Taux de croissance glissant

```sql
-- CAGR (Compound Annual Growth Rate) sur fen√™tre mobile
SELECT
    mois,
    ventes,
    -- Premi√®re valeur de la fen√™tre de 12 mois
    FIRST_VALUE(ventes) OVER (
        ORDER BY mois
        ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
    ) AS ventes_debut_periode,
    -- CAGR sur 12 mois glissants
    CASE
        WHEN COUNT(*) OVER (
            ORDER BY mois
            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
        ) = 12
        THEN ROUND(
            (POW(
                ventes / FIRST_VALUE(ventes) OVER (
                    ORDER BY mois
                    ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
                ),
                1.0 / 12
            ) - 1) * 100,
            2
        )
        ELSE NULL
    END AS cagr_12m_pct
FROM ventes_mensuelles
ORDER BY mois DESC;
```

### 4. D√©tection d'anomalies avec z-score

```sql
-- Identifier les valeurs anormales (z-score > 3)
WITH statistiques_mobiles AS (
    SELECT
        date_vente,
        montant,
        AVG(montant) OVER w AS moyenne_30j,
        STDDEV(montant) OVER w AS ecart_type_30j,
        -- Z-score : (valeur - moyenne) / √©cart-type
        (montant - AVG(montant) OVER w) / NULLIF(STDDEV(montant) OVER w, 0) AS z_score
    FROM ventes_quotidiennes
    WINDOW w AS (
        ORDER BY date_vente
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    )
)
SELECT
    date_vente,
    montant,
    moyenne_30j,
    ROUND(z_score, 2) AS z_score,
    CASE
        WHEN ABS(z_score) > 3 THEN 'üî¥ Anomalie forte'
        WHEN ABS(z_score) > 2 THEN 'üü† Anomalie mod√©r√©e'
        WHEN ABS(z_score) > 1.5 THEN 'üü° Attention'
        ELSE 'üü¢ Normal'
    END AS statut
FROM statistiques_mobiles
WHERE ABS(z_score) > 1.5
ORDER BY ABS(z_score) DESC;
```

### 5. Forecast simple (moyenne mobile exponentielle)

```sql
-- EMA (Exponential Moving Average) approximation
-- EMA = (Prix_actuel * k) + (EMA_pr√©c√©dente * (1-k))
-- o√π k = 2 / (p√©riode + 1)
WITH ema_recursive AS (
    SELECT
        date_vente,
        montant,
        montant AS ema_12,  -- Initialisation
        ROW_NUMBER() OVER (ORDER BY date_vente) AS row_num
    FROM ventes_quotidiennes
    WHERE date_vente >= (SELECT MIN(date_vente) FROM ventes_quotidiennes)
    LIMIT 1

    UNION ALL

    SELECT
        v.date_vente,
        v.montant,
        -- EMA = montant * (2/13) + EMA_pr√©c√©dente * (11/13)
        (v.montant * 2.0 / 13) + (e.ema_12 * 11.0 / 13) AS ema_12,
        e.row_num + 1
    FROM ventes_quotidiennes v
    INNER JOIN ema_recursive e ON v.date_vente > e.date_vente
    WHERE e.row_num < (SELECT COUNT(*) FROM ventes_quotidiennes)
    LIMIT 1
)
SELECT
    date_vente,
    montant,
    ROUND(ema_12, 2) AS ema_12_jours
FROM ema_recursive
ORDER BY date_vente DESC
LIMIT 30;
```

üí° **Note** : Cette requ√™te r√©cursive n√©cessite l'activation des CTE r√©cursives (voir section 4.1).

---

## Optimisation des frames

### 1. R√©utilisation avec WINDOW clause

```sql
-- ‚ùå INEFFICACE : Frame d√©fini 3 fois
SELECT
    date_vente,
    montant,
    AVG(montant) OVER (
        ORDER BY date_vente
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS avg_7j,
    MIN(montant) OVER (
        ORDER BY date_vente
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS min_7j,
    MAX(montant) OVER (
        ORDER BY date_vente
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS max_7j
FROM ventes;

-- ‚úÖ OPTIMIS√â : Frame d√©fini une fois, r√©utilis√©
SELECT
    date_vente,
    montant,
    AVG(montant) OVER w AS avg_7j,
    MIN(montant) OVER w AS min_7j,
    MAX(montant) OVER w AS max_7j
FROM ventes
WINDOW w AS (
    ORDER BY date_vente
    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
);
```

### 2. Limitation du dataset

```sql
-- Filtrer avant d'appliquer les frames
SELECT
    date_vente,
    montant,
    AVG(montant) OVER (
        PARTITION BY produit_id
        ORDER BY date_vente
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS avg_30j
FROM ventes
WHERE date_vente >= CURRENT_DATE - INTERVAL 1 YEAR  -- R√©duit le volume
  AND produit_id IN (SELECT produit_id FROM produits WHERE actif = 1)
ORDER BY date_vente DESC;
```

### 3. Indexation appropri√©e

```sql
-- Index pour optimiser ORDER BY et PARTITION BY
CREATE INDEX idx_ventes_prod_date ON ventes(produit_id, date_vente);

-- Requ√™te optimis√©e par l'index
SELECT
    produit_id,
    date_vente,
    quantite,
    SUM(quantite) OVER (
        PARTITION BY produit_id
        ORDER BY date_vente
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS total_7j
FROM ventes
WHERE produit_id = 42;
```

### 4. Choix du type de frame

```sql
-- ROWS est g√©n√©ralement plus rapide que RANGE/GROUPS
-- Pr√©f√©rer ROWS quand possible

-- üü¢ RAPIDE : ROWS (nombre fixe de lignes)
SELECT
    date_vente,
    SUM(montant) OVER (
        ORDER BY date_vente
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS sum_7_lignes
FROM ventes;

-- üü° MOYEN : RANGE avec doublons
SELECT
    date_vente,
    SUM(montant) OVER (
        ORDER BY date_vente
        RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS sum_range
FROM ventes;
```

---

## Pi√®ges et erreurs courantes

### 1. Frame par d√©faut avec LAST_VALUE

```sql
-- ‚ùå PI√àGE : LAST_VALUE avec frame par d√©faut
SELECT
    date_vente,
    montant,
    LAST_VALUE(montant) OVER (ORDER BY date_vente) AS dernier_montant
FROM ventes;
-- Retourne le montant ACTUEL, pas le dernier de la partition !

-- ‚úÖ SOLUTION : Frame explicite
SELECT
    date_vente,
    montant,
    LAST_VALUE(montant) OVER (
        ORDER BY date_vente
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS dernier_montant
FROM ventes;

-- üéØ ALTERNATIVE : FIRST_VALUE invers√©
SELECT
    date_vente,
    montant,
    FIRST_VALUE(montant) OVER (ORDER BY date_vente DESC) AS dernier_montant
FROM ventes;
```

### 2. Frame d√©passant les limites de la partition

```sql
-- ‚ö†Ô∏è Frame demande 30 lignes mais partition en a moins
SELECT
    produit_id,
    date_vente,
    montant,
    AVG(montant) OVER (
        PARTITION BY produit_id
        ORDER BY date_vente
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS avg_30j,
    -- Nombre r√©el de lignes dans le calcul
    COUNT(*) OVER (
        PARTITION BY produit_id
        ORDER BY date_vente
        ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS nb_lignes_reelles
FROM ventes
WHERE produit_id = 999;  -- Produit r√©cent avec peu d'historique
```

üí° **Comportement** : MariaDB utilise toutes les lignes disponibles, m√™me si moins que demand√©.

### 3. RANGE avec colonnes non num√©riques

```sql
-- ‚ùå ERREUR : RANGE BETWEEN avec VARCHAR
SELECT
    nom,
    categorie,
    prix,
    AVG(prix) OVER (
        ORDER BY nom
        RANGE BETWEEN 'A' PRECEDING AND 'Z' FOLLOWING  -- ‚ùå Invalide
    ) AS avg_prix
FROM produits;

-- ‚úÖ SOLUTION : Utiliser ROWS ou GROUPS
SELECT
    nom,
    categorie,
    prix,
    AVG(prix) OVER (
        ORDER BY nom
        ROWS BETWEEN 5 PRECEDING AND 5 FOLLOWING
    ) AS avg_prix
FROM produits;
```

### 4. Confusion entre frame et partition

```sql
-- ‚ö†Ô∏è CONFUSION : Frame ne remplace pas PARTITION BY
-- ‚ùå MAUVAIS : Essayer de limiter aux derniers mois avec frame
SELECT
    date_vente,
    montant,
    SUM(montant) OVER (
        ORDER BY date_vente
        ROWS BETWEEN 90 PRECEDING AND CURRENT ROW  -- Prend 90 LIGNES, pas 90 jours !
    ) AS sum_90_lignes
FROM ventes;

-- ‚úÖ BON : Filtrer d'abord avec WHERE
SELECT
    date_vente,
    montant,
    SUM(montant) OVER (ORDER BY date_vente) AS sum_periode
FROM ventes
WHERE date_vente >= CURRENT_DATE - INTERVAL 90 DAY;

-- üéØ ALTERNATIVE : RANGE avec INTERVAL
SELECT
    date_vente,
    montant,
    SUM(montant) OVER (
        ORDER BY date_vente
        RANGE BETWEEN INTERVAL 90 DAY PRECEDING AND CURRENT ROW
    ) AS sum_90_jours_calendaires
FROM ventes;
```

---

## ‚úÖ Points cl√©s √† retenir

- Un **frame** d√©finit le sous-ensemble de lignes utilis√© pour le calcul dans chaque position
- **ROWS** compte les **lignes physiques** ‚Üí pr√©visible, rapide, id√©al pour fen√™tres fixes
- **RANGE** se base sur les **valeurs** ORDER BY ‚Üí toutes les lignes avec m√™me valeur trait√©es ensemble
- **GROUPS** compte les **groupes de valeurs distinctes** ‚Üí compromis entre ROWS et RANGE
- Frame par d√©faut **avec ORDER BY** : `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`
- Frame par d√©faut **sans ORDER BY** : `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`
- **LAST_VALUE** n√©cessite presque toujours un frame explicite `UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`
- **ROWS** est g√©n√©ralement plus performant que RANGE ou GROUPS
- Les frames peuvent √™tre **asym√©triques** : `ROWS BETWEEN 5 PRECEDING AND 2 FOLLOWING`
- Utiliser la clause **WINDOW** pour r√©utiliser les d√©finitions de frame et optimiser
- **RANGE INTERVAL** fonctionne avec les types temporels : `INTERVAL 7 DAY PRECEDING`
- Un frame peut demander plus de lignes que disponibles ‚Üí MariaDB utilise ce qu'il peut
- Toujours tester avec des donn√©es aux limites (d√©but/fin de partition, partitions petites)

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation officielle MariaDB - Window Frames](https://mariadb.com/kb/en/window-frames/)
- [üìñ Window Functions Overview](https://mariadb.com/kb/en/window-functions-overview/)
- [üìñ ROWS, RANGE and GROUPS](https://mariadb.com/kb/en/window-frames-rows-range-and-groups/)
- [üìñ Frame Clause](https://mariadb.com/kb/en/window-frames-frame-clause/)

**Lectures compl√©mentaires :**
- [Modern SQL - Window Frame Clauses](https://modern-sql.com/feature/over/frame-clause)
- [PostgreSQL Window Functions](https://www.postgresql.org/docs/current/tutorial-window.html)

---

## ‚û°Ô∏è Section suivante

**[4.2.4 Cas d'usage : Top N, moyenne mobile, cumuls](/04-concepts-avances-sql/02.4-cas-usage-window.md)** : Approfondir les applications pratiques des window functions avec des exemples m√©tier complets et des patterns de requ√™tes r√©utilisables.

---

**Note pratique** : La ma√Ætrise des frames est ce qui distingue un utilisateur avanc√© des window functions. Prenez le temps d'exp√©rimenter avec des datasets vari√©s (avec/sans doublons, grandes/petites partitions) pour bien comprendre les subtilit√©s de ROWS, RANGE et GROUPS. Les frames sont puissants mais peuvent √™tre trompeurs si mal compris ! üéØ

‚è≠Ô∏è [Cas d'usage : Top N, moyenne mobile, cumuls](/04-concepts-avances-sql/02.4-cas-usage-window.md)
