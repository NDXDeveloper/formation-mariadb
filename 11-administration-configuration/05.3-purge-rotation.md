üîù Retour au [Sommaire](/SOMMAIRE.md)

# 11.5.3 Purge et rotation

> **Niveau** : Avanc√© (DBA/Administrateur Syst√®me)  
> **Dur√©e estim√©e** : 2 heures  
> **Pr√©requis** : 11.5.1 - Configuration binlog, 11.5.2 - Formats binlog, r√©plication MariaDB  

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Configurer la rotation automatique des binary logs
- Impl√©menter des strat√©gies de purge s√©curis√©es
- G√©rer l'espace disque des binary logs en production
- Purger les binlogs sans casser la r√©plication
- Automatiser la maintenance des binlogs
- Monitorer et alerter sur les probl√®mes d'espace
- G√©rer les situations d'urgence (disque plein)
- Appliquer les bonnes pratiques de r√©tention

---

## Introduction

La **rotation** et la **purge** des binary logs sont des op√©rations critiques pour :

- üíæ **Gestion de l'espace disque** : √âviter saturation
- üîÑ **Performance r√©plication** : Replicas n'ont pas besoin de binlogs tr√®s anciens
- üì¶ **Simplicit√© op√©rationnelle** : Moins de fichiers = plus facile √† g√©rer
- üí∞ **Co√ªts** : R√©duction du stockage n√©cessaire
- üõ°Ô∏è **S√©curit√©** : Limiter dur√©e de r√©tention des logs

‚ö†Ô∏è **DANGER** : Une purge incorrecte peut **casser la r√©plication** ou **emp√™cher le recovery**.

---

## Rotation des binary logs

### Qu'est-ce que la rotation ?

La **rotation** cr√©e un nouveau fichier binlog et ferme l'actuel.

```
Avant rotation:
mysql-bin.000045 (actif, en √©criture)

Apr√®s rotation:
mysql-bin.000045 (ferm√©, lecture seule)
mysql-bin.000046 (nouveau, actif, en √©criture)
```

### D√©clencheurs de rotation automatique

| D√©clencheur | Description | Fr√©quence |
|-------------|-------------|-----------|
| **Taille max atteinte** | `max_binlog_size` d√©pass√© | Variable |
| **Red√©marrage serveur** | MariaDB restart | Rare |
| **FLUSH LOGS** | Commande manuelle | √Ä la demande |
| **Changement binlog_format** | Modification du format | Rare |

### Configuration max_binlog_size

```ini
# /etc/mysql/mariadb.conf.d/50-server.cnf

[mysqld]
# Taille maximale par fichier binlog
max_binlog_size = 1G  # D√©faut recommand√©

# Alternatives selon cas d'usage
# max_binlog_size = 512M  # Rotation plus fr√©quente
# max_binlog_size = 2G    # Moins de fichiers
```

**Impact du choix** :

```
Petit (128M-256M) :
‚úÖ Rotation fr√©quente ‚Üí Purge granulaire facile
‚úÖ Fichiers manipulables individuellement
‚ùå Plus de fichiers √† g√©rer
‚ùå Plus d'overhead rotation

Moyen (512M-1G) : ‚≠ê RECOMMAND√â
‚úÖ √âquilibre optimal
‚úÖ ~100-500 rotations/jour selon activit√©

Grand (2G-4G) :
‚úÖ Moins de fichiers
‚ùå Purge moins granulaire
‚ùå Fichiers volumineux difficiles √† manipuler
```

üí° **Best practice** : Conserver la valeur par d√©faut (1GB) sauf besoin sp√©cifique document√©.

### Rotation manuelle

```sql
-- Forcer rotation imm√©diate
FLUSH BINARY LOGS;

-- V√©rifier nouveau fichier cr√©√©
SHOW BINARY LOGS;

-- R√©sultat :
+------------------+-----------+-----------+
| Log_name         | File_size | Encrypted |
+------------------+-----------+-----------+
| mysql-bin.000045 | 234567890 | No        |
| mysql-bin.000046 | 154       | No        | ‚Üê NOUVEAU
+------------------+-----------+-----------+
```

**Cas d'usage rotation manuelle** :

1. **Avant backup** : Marquer un point coh√©rent
2. **Apr√®s maintenance** : Nouveau binlog "propre"
3. **Avant purge** : S√©parer ancien/nouveau
4. **Debugging** : Isoler probl√®me temporellement

```bash
#!/bin/bash
# rotate-before-backup.sh

echo "Rotating binlog before backup..."
mysql -e "FLUSH BINARY LOGS;"

# Backup
mysqldump --all-databases --single-transaction \
  --master-data=2 > /backup/full-backup-$(date +%Y%m%d).sql

echo "Backup complete"
```

---

## Purge automatique

### expire_logs_days : R√©tention temporelle

```ini
[mysqld]
# Purge automatique des binlogs > N jours
expire_logs_days = 7
```

**Comportement** :

```sql
-- MariaDB v√©rifie AUTOMATIQUEMENT √† chaque :
-- 1. D√©marrage du serveur
-- 2. Rotation binlog (FLUSH LOGS)
-- 3. Ex√©cution PURGE BINARY LOGS

-- Supprime binlogs dont :
-- timestamp < (NOW() - expire_logs_days)
```

**Configuration par type d'environnement** :

| Environnement | R√©tention | Justification |
|---------------|-----------|---------------|
| **Production (avec backup quotidien)** | 7 jours | 1 semaine de marge |
| **Production (backup hebdomadaire)** | 14 jours | 2 semaines de s√©curit√© |
| **D√©veloppement** | 3 jours | Espace limit√© acceptable |
| **Staging** | 5 jours | Compromis dev/prod |
| **Compliance/Audit** | 30-90 jours | Exigences r√©glementaires |

### binlog_expire_logs_seconds (MariaDB 10.6+)

```ini
[mysqld]
# R√©tention en secondes (plus pr√©cis que jours)
binlog_expire_logs_seconds = 604800  # 7 jours

# OU
# binlog_expire_logs_seconds = 259200   # 3 jours
# binlog_expire_logs_seconds = 1209600  # 14 jours
```

**Avantages vs expire_logs_days** :

```
expire_logs_days = 7
‚Üí Purge √† minuit, perd granularit√©

binlog_expire_logs_seconds = 604800
‚Üí Purge pr√©cise √† la seconde
‚Üí Meilleure gestion espace disque
```

üí° **Recommandation** : Utiliser `binlog_expire_logs_seconds` si MariaDB ‚â• 10.6.

### V√©rification configuration

```sql
-- V√©rifier r√©tention active
SHOW VARIABLES LIKE '%expire_logs%';

-- R√©sultat :
+----------------------------+--------+
| Variable_name              | Value  |
+----------------------------+--------+
| expire_logs_days           | 7      |
| binlog_expire_logs_seconds | 604800 |
+----------------------------+--------+

-- Si binlog_expire_logs_seconds > 0, il prend PRIORIT√â sur expire_logs_days
```

### D√©sactiver purge automatique (DANGER)

```ini
[mysqld]
# ‚ö†Ô∏è AUCUNE purge automatique
expire_logs_days = 0
binlog_expire_logs_seconds = 0
```

‚ö†Ô∏è **ATTENTION** : Les binlogs s'accumuleront **ind√©finiment** jusqu'√† remplir le disque !

**Usage l√©gitime** : Uniquement si purge manuelle automatis√©e via script externe.

---

## Purge manuelle

### PURGE BINARY LOGS TO

```sql
-- Purger tous les binlogs AVANT un fichier sp√©cifique
PURGE BINARY LOGS TO 'mysql-bin.000050';

-- R√©sultat :
-- mysql-bin.000001 √† mysql-bin.000049 ‚Üí SUPPRIM√âS
-- mysql-bin.000050 et suivants ‚Üí CONSERV√âS
```

‚ö†Ô∏è **Important** : Le fichier sp√©cifi√© est **conserv√©** (‚â• not >).

### PURGE BINARY LOGS BEFORE

```sql
-- Purger binlogs avant une date/heure
PURGE BINARY LOGS BEFORE '2025-12-01 00:00:00';

-- Purger binlogs > 7 jours
PURGE BINARY LOGS BEFORE DATE_SUB(NOW(), INTERVAL 7 DAY);

-- Purger binlogs > 72 heures
PURGE BINARY LOGS BEFORE DATE_SUB(NOW(), INTERVAL 72 HOUR);
```

### RESET MASTER (DANGER EXTR√äME)

```sql
-- Supprimer TOUS les binlogs
RESET MASTER;
```

‚ö†Ô∏è **DANGER EXTR√äME** :
- Supprime **tous** les binlogs sans exception
- **Casse la r√©plication** si replicas actifs
- Perte du historical pour PITR

**Usage l√©gitime** :
- Aucun replica actif
- Reconfiguration compl√®te de la r√©plication
- Environnement dev/test

```sql
-- V√©rifier qu'aucun replica avant RESET MASTER
SHOW SLAVE HOSTS;

-- Si aucun replica :
-- Empty set (0.00 sec)
-- ‚Üí S√©curitaire de faire RESET MASTER
```

---

## Purge s√©curis√©e avec r√©plication

### Probl√®me : Purger trop t√¥t

```
Sc√©nario dangereux :

Primary :
- mysql-bin.000045 (position 12345)
- mysql-bin.000046 (actuel)

Replica (en retard) :
- Lit mysql-bin.000045 position 8000

DBA fait :
PURGE BINARY LOGS TO 'mysql-bin.000046';

R√©sultat :
- mysql-bin.000045 supprim√©
- Replica ne peut plus lire position 8000
- R√âPLICATION CASS√âE ‚ùå
```

### V√©rifier positions des replicas

```sql
-- Sur Primary : Lister les replicas connect√©s
SHOW SLAVE HOSTS;

-- R√©sultat :
+-----------+------+------+-----------+
| Server_id | Host | Port | Master_id |
+-----------+------+------+-----------+
| 2         | rep1 | 3306 | 1         |
| 3         | rep2 | 3306 | 1         |
+-----------+------+------+-----------+

-- Sur CHAQUE replica : V√©rifier position
SHOW SLAVE STATUS\G

-- Champs importants :
-- Master_Log_File: mysql-bin.000045
-- Read_Master_Log_Pos: 8234567
-- Exec_Master_Log_Pos: 8234567
```

### Script de purge s√©curis√©e

```bash
#!/bin/bash
# safe-purge-binlogs.sh

set -e

MYSQL_USER="root"
MYSQL_PASS="password"
MYSQL_CMD="mysql -u$MYSQL_USER -p$MYSQL_PASS"

echo "=== Safe Binary Log Purge ==="

# 1. Trouver le binlog le plus ancien utilis√© par un replica
OLDEST_BINLOG=$($MYSQL_CMD -N -e "
    SELECT IFNULL(MIN(Master_Log_File), 'none')
    FROM information_schema.SLAVE_STATUS
")

if [ "$OLDEST_BINLOG" = "none" ] || [ -z "$OLDEST_BINLOG" ]; then
    echo "No replicas detected"
    echo "Safe to purge based on expire_logs_days"

    # Purge bas√© sur temps (7 jours)
    $MYSQL_CMD -e "PURGE BINARY LOGS BEFORE DATE_SUB(NOW(), INTERVAL 7 DAY);"

else
    echo "Oldest binlog in use by replicas: $OLDEST_BINLOG"

    # V√©rifier que ce n'est pas le binlog actuel
    CURRENT_BINLOG=$($MYSQL_CMD -N -e "SHOW MASTER STATUS" | awk '{print $1}')

    if [ "$OLDEST_BINLOG" = "$CURRENT_BINLOG" ]; then
        echo "Replicas are up-to-date (current binlog)"
        echo "No purge needed"
    else
        echo "Purging binlogs before $OLDEST_BINLOG"
        $MYSQL_CMD -e "PURGE BINARY LOGS TO '$OLDEST_BINLOG';"
    fi
fi

# 2. Afficher r√©sultat
echo ""
echo "Remaining binlogs:"
$MYSQL_CMD -e "SHOW BINARY LOGS;"

# 3. Calculer espace lib√©r√©
echo ""
TOTAL_SIZE=$($MYSQL_CMD -N -e "
    SELECT ROUND(SUM(file_size)/1024/1024/1024, 2) AS size_gb
    FROM information_schema.BINARY_LOG_FILES
")
echo "Total binlog size: ${TOTAL_SIZE} GB"
```

### Automatisation avec cron

```bash
# /etc/cron.d/mariadb-purge-binlogs

# Purge s√©curis√©e tous les jours √† 3h00
0 3 * * * mysql /usr/local/bin/safe-purge-binlogs.sh >> /var/log/mysql/purge.log 2>&1
```

---

## Gestion de l'espace disque

### Monitoring de l'espace binlog

```sql
-- Espace total utilis√© par binlogs
SELECT
    COUNT(*) AS file_count,
    ROUND(SUM(file_size)/1024/1024, 2) AS total_mb,
    ROUND(SUM(file_size)/1024/1024/1024, 2) AS total_gb,
    ROUND(AVG(file_size)/1024/1024, 2) AS avg_mb
FROM information_schema.BINARY_LOG_FILES;

-- R√©sultat :
+------------+----------+----------+--------+
| file_count | total_mb | total_gb | avg_mb |
+------------+----------+----------+--------+
| 156        | 89234.56 | 87.14    | 572.02 |
+------------+----------+----------+--------+
```

### Distribution par √¢ge

```sql
-- Binlogs par jour
SELECT
    DATE(FROM_UNIXTIME(file_modified_time)) AS day,
    COUNT(*) AS file_count,
    ROUND(SUM(file_size)/1024/1024/1024, 2) AS size_gb
FROM information_schema.BINARY_LOG_FILES
GROUP BY day
ORDER BY day DESC;

-- R√©sultat :
+------------+------------+---------+
| day        | file_count | size_gb |
+------------+------------+---------+
| 2025-12-13 | 24         | 12.34   |
| 2025-12-12 | 26         | 13.56   |
| 2025-12-11 | 22         | 11.23   |
| ...        | ...        | ...     |
+------------+------------+---------+
```

### Taux de croissance

```bash
#!/bin/bash
# binlog-growth-rate.sh

# Taille actuelle
CURRENT_SIZE=$(mysql -N -e "
    SELECT ROUND(SUM(file_size)/1024/1024/1024, 2)
    FROM information_schema.BINARY_LOG_FILES
")

# Sauvegarder pour comparaison future
echo "$(date +%s) $CURRENT_SIZE" >> /var/log/mysql/binlog-size-history.log

# Calculer croissance sur 24h
if [ -f /var/log/mysql/binlog-size-history.log ]; then
    PREV_SIZE=$(tail -2 /var/log/mysql/binlog-size-history.log | head -1 | awk '{print $2}')
    GROWTH=$(echo "$CURRENT_SIZE - $PREV_SIZE" | bc)

    echo "Current size: ${CURRENT_SIZE} GB"
    echo "Growth (24h): ${GROWTH} GB"
    echo "Growth rate: $(echo "scale=2; $GROWTH / $CURRENT_SIZE * 100" | bc)%"
fi
```

### Alertes espace disque

```bash
#!/bin/bash
# alert-binlog-disk-usage.sh

THRESHOLD_PERCENT=80
BINLOG_DIR="/var/log/mysql"
EMAIL="dba@example.com"

# Utilisation partition binlogs
USAGE=$(df -h "$BINLOG_DIR" | awk 'NR==2 {print $5}' | sed 's/%//')

if [ "$USAGE" -gt "$THRESHOLD_PERCENT" ]; then
    echo "‚ö†Ô∏è  ALERT: Binlog disk usage at ${USAGE}%" | \
        mail -s "[CRITICAL] Binlog disk usage high" "$EMAIL"

    # Purge d'urgence si > 90%
    if [ "$USAGE" -gt 90 ]; then
        echo "Emergency purge triggered"
        mysql -e "PURGE BINARY LOGS BEFORE DATE_SUB(NOW(), INTERVAL 3 DAY);"
    fi
fi
```

---

## Strat√©gies de r√©tention

### Strat√©gie bas√©e sur le temps

```ini
[mysqld]
# Garder 7 jours (standard)
binlog_expire_logs_seconds = 604800

# Variantes
# 3 jours  = 259200
# 14 jours = 1209600
# 30 jours = 2592000
```

**Avantages** :
- ‚úÖ Simple √† configurer
- ‚úÖ Pr√©visible
- ‚úÖ Automatique

**Inconv√©nients** :
- ‚ùå Ne consid√®re pas l'espace disque
- ‚ùå Ne consid√®re pas les replicas

### Strat√©gie bas√©e sur l'espace

```bash
#!/bin/bash
# purge-by-space.sh

MAX_SIZE_GB=100
BINLOG_DIR="/var/log/mysql"

while true; do
    CURRENT_SIZE=$(mysql -N -e "
        SELECT ROUND(SUM(file_size)/1024/1024/1024, 2)
        FROM information_schema.BINARY_LOG_FILES
    ")

    if (( $(echo "$CURRENT_SIZE > $MAX_SIZE_GB" | bc -l) )); then
        echo "Binlog size (${CURRENT_SIZE}GB) exceeds limit (${MAX_SIZE_GB}GB)"

        # Purger binlog le plus ancien
        OLDEST=$(mysql -N -e "
            SELECT file_name
            FROM information_schema.BINARY_LOG_FILES
            ORDER BY file_name
            LIMIT 1,1
        ")

        mysql -e "PURGE BINARY LOGS TO '$OLDEST';"
        echo "Purged up to $OLDEST"
    else
        break
    fi
done
```

### Strat√©gie hybride (RECOMMAND√âE)

```bash
#!/bin/bash
# hybrid-purge-strategy.sh

MIN_RETENTION_DAYS=3
MAX_RETENTION_DAYS=14
MAX_SIZE_GB=100

# 1. Toujours garder au moins MIN_RETENTION_DAYS
mysql -e "PURGE BINARY LOGS BEFORE DATE_SUB(NOW(), INTERVAL $MAX_RETENTION_DAYS DAY);"

# 2. Si espace > MAX_SIZE_GB, purger progressivement jusqu'√† MIN_RETENTION
CURRENT_SIZE=$(mysql -N -e "
    SELECT ROUND(SUM(file_size)/1024/1024/1024, 2)
    FROM information_schema.BINARY_LOG_FILES
")

if (( $(echo "$CURRENT_SIZE > $MAX_SIZE_GB" | bc -l) )); then
    echo "Space constraint triggered"
    DAYS=$MAX_RETENTION_DAYS

    while [ $DAYS -ge $MIN_RETENTION_DAYS ]; do
        mysql -e "PURGE BINARY LOGS BEFORE DATE_SUB(NOW(), INTERVAL $DAYS DAY);"

        CURRENT_SIZE=$(mysql -N -e "
            SELECT ROUND(SUM(file_size)/1024/1024/1024, 2)
            FROM information_schema.BINARY_LOG_FILES
        ")

        if (( $(echo "$CURRENT_SIZE <= $MAX_SIZE_GB" | bc -l) )); then
            echo "Space constraint satisfied at $DAYS days retention"
            break
        fi

        DAYS=$((DAYS - 1))
    done
fi
```

### Strat√©gie par environnement

| Environnement | Temps | Espace | Justification |
|---------------|-------|--------|---------------|
| **Production critique** | 14 jours | 200 GB | S√©curit√© maximale |
| **Production standard** | 7 jours | 100 GB | √âquilibre |
| **Staging** | 5 jours | 50 GB | Compromis |
| **D√©veloppement** | 3 jours | 20 GB | Ressources limit√©es |
| **CI/CD** | 1 jour | 10 GB | √âph√©m√®re |

---

## Situations d'urgence

### Disque plein : R√©cup√©ration d'urgence

```bash
#!/bin/bash
# emergency-binlog-cleanup.sh

echo "=== EMERGENCY BINLOG CLEANUP ==="
echo "‚ö†Ô∏è  WARNING: This will aggressively purge binlogs"

# 1. V√©rifier espace disque
USAGE=$(df -h /var/log/mysql | awk 'NR==2 {print $5}' | sed 's/%//')
echo "Current disk usage: ${USAGE}%"

if [ "$USAGE" -lt 90 ]; then
    echo "Disk usage below 90%, emergency cleanup not needed"
    exit 0
fi

# 2. Arr√™ter purge automatique temporairement
mysql -e "SET GLOBAL binlog_expire_logs_seconds = 0;"

# 3. Identifier binlogs n√©cessaires pour replicas
OLDEST_NEEDED=$(mysql -N -e "
    SELECT IFNULL(MIN(Master_Log_File), 'none')
    FROM information_schema.SLAVE_STATUS
")

if [ "$OLDEST_NEEDED" != "none" ]; then
    echo "Purging up to $OLDEST_NEEDED (replica requirement)"
    mysql -e "PURGE BINARY LOGS TO '$OLDEST_NEEDED';"
else
    # Aucun replica : purge agressive (garder 24h)
    echo "No replicas detected, purging aggressively (keeping 24h)"
    mysql -e "PURGE BINARY LOGS BEFORE DATE_SUB(NOW(), INTERVAL 1 DAY);"
fi

# 4. Forcer rotation pour lib√©rer espace imm√©diatement
mysql -e "FLUSH BINARY LOGS;"

# 5. V√©rifier r√©sultat
NEW_USAGE=$(df -h /var/log/mysql | awk 'NR==2 {print $5}' | sed 's/%//')
echo "New disk usage: ${NEW_USAGE}%"

# 6. Restaurer purge automatique
mysql -e "SET GLOBAL binlog_expire_logs_seconds = 604800;"

echo "Emergency cleanup complete"
```

### R√©plication cass√©e apr√®s purge

```sql
-- Sympt√¥me sur replica
SHOW SLAVE STATUS\G
-- Last_IO_Error: Got fatal error 1236 from master when reading data from
--   binary log: 'Could not find first log file name in binary log index file'

-- Cause : Binlog purg√© trop t√¥t sur primary

-- Solution 1 : Resynchroniser depuis un point plus r√©cent
-- Sur primary, trouver binlog le plus ancien disponible
SHOW BINARY LOGS;
-- mysql-bin.000050 (le plus ancien)

-- Sur replica, repositionner
STOP SLAVE;
CHANGE MASTER TO
    MASTER_LOG_FILE='mysql-bin.000050',
    MASTER_LOG_POS=4;
START SLAVE;

-- V√©rifier
SHOW SLAVE STATUS\G
-- Slave_IO_Running: Yes ‚úÖ

-- Solution 2 : Si gap trop important, restaurer backup + binlogs
-- Voir section Point-in-Time Recovery
```

---

## Archivage des binary logs

### Archivage vers stockage externe

```bash
#!/bin/bash
# archive-old-binlogs.sh

BINLOG_DIR="/var/log/mysql"
ARCHIVE_DIR="/backup/binlog-archive"
ARCHIVE_DAYS=7  # Archiver binlogs > 7 jours

mkdir -p "$ARCHIVE_DIR"

# Trouver binlogs √† archiver
ARCHIVE_BEFORE=$(date -d "$ARCHIVE_DAYS days ago" +%Y-%m-%d)

mysql -N -e "
    SELECT file_name, FROM_UNIXTIME(file_modified_time)
    FROM information_schema.BINARY_LOG_FILES
    WHERE FROM_UNIXTIME(file_modified_time) < '$ARCHIVE_BEFORE 00:00:00'
" | while read BINLOG TIMESTAMP; do

    YEAR=$(date -d "$TIMESTAMP" +%Y)
    MONTH=$(date -d "$TIMESTAMP" +%m)
    ARCHIVE_SUBDIR="$ARCHIVE_DIR/$YEAR/$MONTH"

    mkdir -p "$ARCHIVE_SUBDIR"

    # Copier vers archive (avec compression)
    if [ -f "$BINLOG_DIR/$BINLOG" ]; then
        echo "Archiving $BINLOG to $ARCHIVE_SUBDIR"
        gzip -c "$BINLOG_DIR/$BINLOG" > "$ARCHIVE_SUBDIR/${BINLOG}.gz"
    fi
done

echo "Archive complete"
```

### Archivage vers S3/Glacier

```bash
#!/bin/bash
# archive-binlogs-to-s3.sh

BINLOG_DIR="/var/log/mysql"
S3_BUCKET="s3://my-company-binlog-archive"
ARCHIVE_DAYS=7

# Trouver binlogs √† archiver
ARCHIVE_BEFORE=$(date -d "$ARCHIVE_DAYS days ago" +%s)

mysql -N -e "
    SELECT file_name, file_modified_time
    FROM information_schema.BINARY_LOG_FILES
" | while read BINLOG TIMESTAMP; do

    if [ "$TIMESTAMP" -lt "$ARCHIVE_BEFORE" ]; then
        YEAR=$(date -d "@$TIMESTAMP" +%Y)
        MONTH=$(date -d "@$TIMESTAMP" +%m)
        DAY=$(date -d "@$TIMESTAMP" +%d)

        S3_PATH="$S3_BUCKET/$YEAR/$MONTH/$DAY/"

        # Upload vers S3 (avec compression)
        echo "Uploading $BINLOG to S3"
        gzip -c "$BINLOG_DIR/$BINLOG" | \
            aws s3 cp - "$S3_PATH${BINLOG}.gz" \
            --storage-class GLACIER

        # V√©rifier upload r√©ussi
        if [ $? -eq 0 ]; then
            echo "‚úì Uploaded $BINLOG"
        else
            echo "‚úó Failed to upload $BINLOG"
        fi
    fi
done
```

---

## Monitoring et alerting

### M√©triques cl√©s √† surveiller

```sql
-- 1. Nombre de binlogs
SELECT COUNT(*) AS binlog_count
FROM information_schema.BINARY_LOG_FILES;

-- 2. Espace total utilis√©
SELECT ROUND(SUM(file_size)/1024/1024/1024, 2) AS total_gb
FROM information_schema.BINARY_LOG_FILES;

-- 3. Binlog le plus ancien
SELECT
    file_name,
    FROM_UNIXTIME(file_modified_time) AS created_at,
    TIMESTAMPDIFF(DAY, FROM_UNIXTIME(file_modified_time), NOW()) AS age_days
FROM information_schema.BINARY_LOG_FILES
ORDER BY file_name
LIMIT 1;

-- 4. Taux de croissance quotidien
SELECT
    DATE(FROM_UNIXTIME(file_modified_time)) AS day,
    ROUND(SUM(file_size)/1024/1024/1024, 2) AS daily_gb
FROM information_schema.BINARY_LOG_FILES
WHERE FROM_UNIXTIME(file_modified_time) >= DATE_SUB(CURDATE(), INTERVAL 7 DAY)
GROUP BY day
ORDER BY day;

-- 5. Replica lag (si applicable)
SELECT
    Host,
    IFNULL(MAX(Seconds_Behind_Master), 0) AS max_lag_seconds
FROM information_schema.SLAVE_STATUS
GROUP BY Host;
```

### Dashboard Grafana

```json
{
  "dashboard": {
    "title": "Binary Log Management",
    "panels": [
      {
        "title": "Total Binlog Size",
        "targets": [{
          "expr": "mysql_binlog_size_bytes / 1024 / 1024 / 1024"
        }]
      },
      {
        "title": "Binlog Count",
        "targets": [{
          "expr": "mysql_binlog_file_count"
        }]
      },
      {
        "title": "Oldest Binlog Age",
        "targets": [{
          "expr": "(time() - mysql_binlog_oldest_timestamp) / 86400"
        }]
      },
      {
        "title": "Daily Growth Rate",
        "targets": [{
          "expr": "rate(mysql_binlog_size_bytes[1d])"
        }]
      }
    ]
  }
}
```

### Alertes Prometheus

```yaml
# prometheus-binlog-alerts.yml

groups:
  - name: binlog_alerts
    rules:
      # Alerte si espace binlog > 100GB
      - alert: BinlogSizeHigh
        expr: mysql_binlog_size_bytes / 1024 / 1024 / 1024 > 100
        for: 15m
        labels:
          severity: warning
        annotations:
          summary: "Binary log size exceeds 100GB"
          description: "Current size: {{ $value }}GB"

      # Alerte si binlog le plus ancien > 14 jours
      - alert: BinlogRetentionTooLong
        expr: (time() - mysql_binlog_oldest_timestamp) / 86400 > 14
        for: 1h
        labels:
          severity: warning
        annotations:
          summary: "Oldest binlog is older than 14 days"
          description: "Age: {{ $value }} days"

      # Alerte si partition binlog > 85%
      - alert: BinlogDiskUsageHigh
        expr: node_filesystem_avail_bytes{mountpoint="/var/log/mysql"} /
              node_filesystem_size_bytes{mountpoint="/var/log/mysql"} < 0.15
        for: 10m
        labels:
          severity: critical
        annotations:
          summary: "Binlog partition almost full"
          description: "Only {{ $value | humanizePercentage }} space remaining"
```

---

## Bonnes pratiques

### 1. Configurer r√©tention automatique

```ini
[mysqld]
# TOUJOURS configurer une r√©tention
binlog_expire_logs_seconds = 604800  # 7 jours

# ‚ùå JAMAIS
# binlog_expire_logs_seconds = 0  # Aucune purge = danger
```

### 2. Partition d√©di√©e pour binlogs

```bash
# Binlogs sur partition s√©par√©e
/dev/sdb1 on /var/log/mysql type ext4

# Avantages :
# - Pas d'impact sur datadir si binlog remplit disque
# - Monitoring espace d√©di√©
# - Performance I/O isol√©e
```

### 3. Monitoring proactif

```bash
# Surveiller AVANT que le disque soit plein
# Alerte √† 80%, action √† 85%

# Cron quotidien
0 6 * * * /usr/local/bin/check-binlog-space.sh
```

### 4. Tester proc√©dures de purge

```bash
# En staging, tester :
# - Purge manuelle
# - Purge avec replicas
# - Recovery apr√®s purge trop agressive
```

### 5. Documenter strat√©gie de r√©tention

```bash
cat > /etc/mysql/binlog-retention-policy.md <<EOF
# Binary Log Retention Policy

Environment: Production
Retention: 7 days (binlog_expire_logs_seconds = 604800)
Max size: 100 GB
Purge schedule: Daily at 03:00

Justification:
- Daily backups with 7-day retention
- Replicas sync within minutes (no need for old binlogs)
- 100GB sufficient for 7 days based on historical growth

Last review: 2025-12-13
Next review: 2026-06-13
EOF
```

### 6. Archiver avant purge

```bash
# Pour compliance/audit, archiver vers stockage froid
# AVANT de purger d√©finitivement
```

### 7. V√©rifier replicas avant purge

```bash
# Script de purge DOIT toujours v√©rifier
# que replicas ne lisent pas encore le binlog
```

---

## Checklist op√©rationnelle

### Configuration initiale

- [ ] D√©finir `max_binlog_size` appropri√© (d√©faut 1G OK)
- [ ] Configurer `binlog_expire_logs_seconds` (7-14 jours)
- [ ] Partition d√©di√©e pour binlogs si possible
- [ ] Script de purge s√©curis√©e en place
- [ ] Cron automatis√© configur√©
- [ ] Monitoring et alertes actifs
- [ ] Documentation strat√©gie de r√©tention

### V√©rifications quotidiennes

- [ ] Espace disque partition binlogs < 80%
- [ ] Nombre de binlogs raisonnable
- [ ] Binlog le plus ancien < r√©tention configur√©e
- [ ] Replicas √† jour (si applicable)
- [ ] Pas d'erreur dans logs purge

### V√©rifications hebdomadaires

- [ ] Analyser taux de croissance
- [ ] V√©rifier efficacit√© purge automatique
- [ ] Tester archivage (si configur√©)
- [ ] R√©viser alertes d√©clench√©es
- [ ] Valider strat√©gie de r√©tention encore appropri√©e

### Maintenance mensuelle

- [ ] Audit complet utilisation espace binlog
- [ ] Test recovery depuis archive
- [ ] R√©vision documentation
- [ ] Optimisation strat√©gie si n√©cessaire
- [ ] Validation proc√©dures d'urgence

---

## Troubleshooting

### Probl√®me 1 : Binlogs ne sont pas purg√©s automatiquement

```sql
-- Diagnostic
SHOW VARIABLES LIKE '%expire_logs%';
-- binlog_expire_logs_seconds = 0  ‚ö†Ô∏è D√©sactiv√© !

-- Solution
SET PERSIST binlog_expire_logs_seconds = 604800;

-- Forcer purge imm√©diate
FLUSH BINARY LOGS;  -- D√©clenche v√©rification purge
```

### Probl√®me 2 : Purge trop agressive

```sql
-- Sympt√¥me : Replica ne peut plus lire binlog
SHOW SLAVE STATUS\G
-- Last_IO_Error: Could not find first log file name...

-- Solution : Resynchroniser
-- Voir section "R√©plication cass√©e apr√®s purge"
```

### Probl√®me 3 : Disque plein malgr√© purge

```bash
# V√©rifier que purge fonctionne
mysql -e "SHOW BINARY LOGS;"

# Si beaucoup de binlogs alors que expire_logs configur√© :
# ‚Üí Peut-√™tre replica tr√®s en retard

# V√©rifier replicas
mysql -e "SHOW SLAVE HOSTS;"
mysql -e "SELECT * FROM information_schema.SLAVE_STATUS\G"

# Solution : Resync replica + purge manuelle apr√®s
```

### Probl√®me 4 : Corruption index binlog

```bash
# Sympt√¥me
mysql -e "SHOW BINARY LOGS;"
# ERROR 1105 (HY000): Binary log file index corrupted

# Solution
# 1. Arr√™ter MariaDB
systemctl stop mariadb

# 2. Reconstruire index
cd /var/log/mysql
rm mysql-bin.index

# Liste tous les binlogs
ls -1 mysql-bin.[0-9]* > mysql-bin.index

# 3. Red√©marrer
systemctl start mariadb

# 4. V√©rifier
mysql -e "SHOW BINARY LOGS;"
```

---

## ‚úÖ Points cl√©s √† retenir

- **Rotation automatique** : D√©clench√©e par max_binlog_size (1GB recommand√©)
- **Purge automatique** : binlog_expire_logs_seconds (604800 = 7 jours)
- **V√©rifier replicas** : TOUJOURS avant purge manuelle
- **Partition d√©di√©e** : Isoler binlogs pour √©viter saturation datadir
- **Monitoring proactif** : Alerter √† 80% utilisation disque
- **Strat√©gie hybride** : Temps + espace pour optimisation
- **Archivage** : Vers S3/Glacier pour compliance
- **Documentation** : Strat√©gie de r√©tention √©crite et r√©vis√©e
- **Tests r√©guliers** : Proc√©dures d'urgence valid√©es
- **RESET MASTER = DANGER** : Uniquement sans replicas actifs

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation officielle : PURGE BINARY LOGS](https://mariadb.com/kb/en/purge-binary-logs/)
- [üìñ Documentation officielle : binlog_expire_logs_seconds](https://mariadb.com/kb/en/replication-and-binary-log-system-variables/#binlog_expire_logs_seconds)
- [üìñ SHOW BINARY LOGS](https://mariadb.com/kb/en/show-binary-logs/)
- [üìñ FLUSH BINARY LOGS](https://mariadb.com/kb/en/flush/)
- [üìñ RESET MASTER](https://mariadb.com/kb/en/reset-master/)
- [Blog : Binary Log Management Best Practices](https://mariadb.org/binlog-management/)

---

## ‚û°Ô∏è Section suivante

**11.6 - Maintenance des tables** : Commandes OPTIMIZE TABLE, ANALYZE TABLE, CHECK TABLE et REPAIR TABLE pour maintenir la sant√©, les performances et l'int√©grit√© des tables InnoDB et MyISAM.

‚è≠Ô∏è [Maintenance des tables](/11-administration-configuration/06-maintenance-tables.md)
