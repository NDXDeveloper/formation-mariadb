üîù Retour au [Sommaire](/SOMMAIRE.md)

# 11.6.2 ANALYZE TABLE

> **Niveau** : Avanc√© (DBA/Administrateur Syst√®me)  
> **Dur√©e estim√©e** : 1.5 heures  
> **Pr√©requis** : 11.6.1 - OPTIMIZE TABLE, optimiseur de requ√™tes, EXPLAIN

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre le r√¥le des statistiques dans l'optimisation de requ√™tes
- Utiliser ANALYZE TABLE pour mettre √† jour les statistiques
- Configurer les statistiques persistantes vs transitoires
- Impl√©menter les histogrammes de colonnes pour une meilleure s√©lectivit√©
- Identifier quand analyser une table est n√©cessaire
- Automatiser la collecte de statistiques
- Monitorer la qualit√© des statistiques
- Diagnostiquer et r√©soudre les probl√®mes d'estimation
- Appliquer les bonnes pratiques de gestion des statistiques

---

## Introduction

### R√¥le des statistiques

Les **statistiques de table** sont des m√©tadonn√©es utilis√©es par l'**optimiseur de requ√™tes** pour :

- üìä **Estimer le nombre de lignes** retourn√©es par une requ√™te
- üéØ **Choisir le meilleur plan d'ex√©cution** (index scan vs full scan)
- üîÄ **D√©terminer l'ordre des jointures** (petite table en premier)
- üìà **√âvaluer la s√©lectivit√© des index** (% de lignes uniques)
- ‚ö° **Optimiser les performances** en √©vitant les mauvais plans

**Exemple d'impact** :

```sql
-- Requ√™te avec statistiques √† jour
SELECT * FROM orders WHERE status = 'pending';
-- Optimiseur estime : 1000 lignes ‚Üí Utilise index sur status ‚úÖ

-- Requ√™te avec statistiques obsol√®tes
SELECT * FROM orders WHERE status = 'pending';
-- Optimiseur estime : 500000 lignes ‚Üí Full table scan ‚ùå
-- Alors qu'en r√©alit√© : 1000 lignes
```

### ANALYZE TABLE : Objectif

**ANALYZE TABLE** recalcule les statistiques de la table :

- ‚úÖ Nombre total de lignes (cardinality)
- ‚úÖ Distribution des valeurs dans les index
- ‚úÖ S√©lectivit√© des colonnes
- ‚úÖ Taille moyenne des lignes
- ‚úÖ Histogrammes de colonnes (optionnel)

üí° **Important** : ANALYZE TABLE est **l√©ger** compar√© √† OPTIMIZE TABLE (pas de reconstruction).

---

## Fonctionnement par moteur

### InnoDB (moteur principal)

```sql
ANALYZE TABLE orders;

-- R√©sultat :
+---------------+----------+----------+----------+
| Table         | Op       | Msg_type | Msg_text |
+---------------+----------+----------+----------+
| shop.orders   | analyze  | status   | OK       |
+---------------+----------+----------+----------+
```

**Ce qui se passe** :

1. **√âchantillonnage** de pages de donn√©es (pas lecture compl√®te)
2. **Calcul statistiques** : cardinality, distribution
3. **Mise √† jour** tables syst√®me (mysql.innodb_table_stats, mysql.innodb_index_stats)
4. **Invalidation** cache de plans de requ√™tes

**Rapidit√©** : Tr√®s rapide car √©chantillonnage (pas full scan).

```
Table 1 GB   : ~1-5 secondes
Table 10 GB  : ~5-15 secondes
Table 100 GB : ~15-60 secondes
```

### MyISAM (legacy)

```sql
ANALYZE TABLE old_myisam_table;
```

**Fonctionnement MyISAM** :

1. **Lecture compl√®te** de l'index
2. **Calcul exact** des statistiques
3. **Mise √† jour** fichier .MYI

‚ö†Ô∏è **Lock lecture** : Table verrouill√©e en lecture (pas √©criture) pendant analyse.

### Aria (MariaDB-specific)

```sql
ANALYZE TABLE aria_table;
```

Similaire √† MyISAM mais avec optimisations Aria.

---

## Statistiques persistantes vs transitoires

### Configuration InnoDB

```ini
# /etc/mysql/mariadb.conf.d/50-server.cnf

[mysqld]
# === Statistiques InnoDB ===

# Statistiques persistantes (recommand√©)
innodb_stats_persistent = ON

# Recalcul automatique des stats
innodb_stats_auto_recalc = ON

# √âchantillonnage (nombre de pages)
innodb_stats_persistent_sample_pages = 20  # D√©faut

# Statistiques transitoires (si persistent = OFF)
innodb_stats_transient_sample_pages = 8

# Inclusion de statistiques pour index supprim√©s
innodb_stats_include_delete_marked = OFF
```

### Statistiques persistantes (PERSISTENT)

```sql
-- Cr√©er table avec statistiques persistantes
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    category VARCHAR(50),
    KEY idx_category (category)
) STATS_PERSISTENT=1;

-- Activer pour table existante
ALTER TABLE products STATS_PERSISTENT=1;
```

**Avantages PERSISTENT** :

- ‚úÖ Statistiques **sauvegard√©es** dans tables syst√®me (mysql.innodb_table_stats)
- ‚úÖ **Persistance** apr√®s red√©marrage serveur
- ‚úÖ **Stabilit√©** : Plans de requ√™tes plus pr√©visibles
- ‚úÖ **Contr√¥le** : Recalcul manuel possible

**Tables syst√®me** :

```sql
-- Voir statistiques persistantes
SELECT * FROM mysql.innodb_table_stats 
WHERE database_name = 'shop' AND table_name = 'products';

-- R√©sultat :
+--------------+------------+---------------+--------+
| database_name| table_name | last_update   | n_rows |
+--------------+------------+---------------+--------+
| shop         | products   | 2025-12-13... | 125000 |
+--------------+------------+---------------+--------+

-- Statistiques par index
SELECT * FROM mysql.innodb_index_stats
WHERE database_name = 'shop' AND table_name = 'products';
```

### Statistiques transitoires (NON PERSISTENT)

```sql
-- Table avec statistiques transitoires
CREATE TABLE temp_data (
    id INT PRIMARY KEY,
    value VARCHAR(100)
) STATS_PERSISTENT=0;
```

**Caract√©ristiques TRANSIENT** :

- ‚ö†Ô∏è Statistiques **en m√©moire** uniquement
- ‚ö†Ô∏è **Perdues** au red√©marrage serveur
- ‚ö†Ô∏è **Recalcul√©es** automatiquement selon seuils
- ‚ö†Ô∏è Plans de requ√™tes peuvent **varier**

**Usage** : Tables temporaires, donn√©es √©ph√©m√®res.

### Recalcul automatique

```sql
-- Configuration par table
ALTER TABLE products 
    STATS_AUTO_RECALC=1,     -- Activer recalcul auto
    STATS_SAMPLE_PAGES=20;   -- Nombre pages √©chantillonn√©es

-- V√©rifier configuration
SELECT 
    table_name,
    stats_persistent,
    stats_auto_recalc,
    stats_sample_pages
FROM information_schema.TABLES
WHERE table_schema = 'shop' AND table_name = 'products';
```

**D√©clenchement automatique** :

```
Recalcul si modification > 10% des lignes depuis dernier ANALYZE
```

---

## Syntaxe et options

### Syntaxe de base

```sql
-- Analyser une table
ANALYZE TABLE table_name;

-- Analyser plusieurs tables
ANALYZE TABLE table1, table2, table3;

-- Avec option NO_WRITE_TO_BINLOG
ANALYZE NO_WRITE_TO_BINLOG TABLE table_name;

-- Ou LOCAL (alias)
ANALYZE LOCAL TABLE table_name;
```

### Options avanc√©es

```sql
-- Analyser table partitionn√©e (partition sp√©cifique)
ALTER TABLE logs ANALYZE PARTITION p202512;

-- Analyser avec histogrammes (MariaDB 10.0+)
ANALYZE TABLE orders PERSISTENT FOR ALL;

-- Analyser colonnes sp√©cifiques
ANALYZE TABLE products PERSISTENT FOR COLUMNS (category, brand);

-- Supprimer statistiques d'une colonne
ANALYZE TABLE products PERSISTENT FOR COLUMNS () DROP HISTOGRAM ON (old_column);
```

### R√©sultats ANALYZE TABLE

```sql
ANALYZE TABLE orders;

-- R√©sultat succ√®s :
+---------------+----------+----------+----------+
| Table         | Op       | Msg_type | Msg_text |
+---------------+----------+----------+----------+
| shop.orders   | analyze  | status   | OK       |
+---------------+----------+----------+----------+

-- R√©sultat avec warning :
+---------------+----------+----------+-----------------------------------+
| Table         | Op       | Msg_type | Msg_text                          |
+---------------+----------+----------+-----------------------------------+
| shop.orders   | analyze  | status   | OK                                |
| shop.orders   | analyze  | warning  | Engine does not support histograms|
+---------------+----------+----------+-----------------------------------+
```

---

## Histogrammes de colonnes

### Concept

Les **histogrammes** fournissent des statistiques d√©taill√©es sur la **distribution des valeurs** :

```sql
-- Sans histogramme
-- Optimiseur sait : 100000 lignes total
-- Mais ne sait pas : Distribution des valeurs 'status'

-- Avec histogramme
-- Optimiseur sait :
-- - 'pending': 1000 lignes (1%)
-- - 'processing': 5000 lignes (5%)
-- - 'completed': 94000 lignes (94%)
```

### Cr√©ation histogrammes

```sql
-- Activer statistiques ind√©pendantes du moteur
SET GLOBAL use_stat_tables = 'preferably';

-- Cr√©er histogramme pour colonne
ANALYZE TABLE orders PERSISTENT FOR COLUMNS (status) INDEXES (idx_status);

-- V√©rifier histogrammes cr√©√©s
SELECT * FROM mysql.column_stats
WHERE db_name = 'shop' AND table_name = 'orders';

-- R√©sultat :
+---------+------------+-------------+-----------------+------------+
| db_name | table_name | column_name | min_value       | max_value  |
+---------+------------+-------------+-----------------+------------+
| shop    | orders     | status      | completed       | pending    |
+---------+------------+-------------+-----------------+------------+
```

### Impact sur l'optimiseur

```sql
-- AVANT histogramme
EXPLAIN SELECT * FROM orders WHERE status = 'pending';

-- rows: 50000 (estimation grossi√®re, 50% de 100000)
-- ‚Üí Full table scan

-- Cr√©er histogramme
ANALYZE TABLE orders PERSISTENT FOR COLUMNS (status);

-- APR√àS histogramme
EXPLAIN SELECT * FROM orders WHERE status = 'pending';

-- rows: 1000 (estimation pr√©cise bas√©e sur histogramme)
-- ‚Üí Index scan ‚úÖ
```

### Configuration use_stat_tables

```sql
-- Options possibles
SET GLOBAL use_stat_tables = 'never';          -- D√©sactiv√©
SET GLOBAL use_stat_tables = 'complementary';  -- Si stats moteur inexistantes
SET GLOBAL use_stat_tables = 'preferably';     -- Pr√©f√©rer stats ind√©pendantes ‚≠ê
SET GLOBAL use_stat_tables = 'preferably_for_queries'; -- Seulement SELECT

-- Persister
SET PERSIST use_stat_tables = 'preferably';
```

**Recommandation** :

```ini
[mysqld]
use_stat_tables = preferably
```

---

## Quand analyser une table

### Indicateurs d'analyse n√©cessaire

```
‚úÖ Apr√®s chargement massif de donn√©es (INSERT bulk)
‚úÖ Apr√®s DELETE/UPDATE massif (>10% lignes)
‚úÖ Apr√®s CREATE INDEX / DROP INDEX
‚úÖ Plans de requ√™tes suboptimaux (EXPLAIN montre mauvaises estimations)
‚úÖ Performance d√©grad√©e sans raison apparente
‚úÖ Apr√®s migration/restauration base de donn√©es
‚úÖ Maintenance pr√©ventive r√©guli√®re
```

### Comparaison estimations vs r√©alit√©

```sql
-- V√©rifier qualit√© des estimations
EXPLAIN SELECT * FROM orders WHERE status = 'pending';

-- rows: 50000 (estimation optimiseur)

-- Comparer avec r√©alit√©
SELECT COUNT(*) FROM orders WHERE status = 'pending';
-- 1000 (r√©alit√©)

-- √âcart > 50% ‚Üí ANALYZE TABLE n√©cessaire ‚ö†Ô∏è
```

### Script de d√©tection

```bash
#!/bin/bash
# detect-outdated-stats.sh

mysql -N -e "
SELECT 
    table_schema,
    table_name,
    table_rows,
    update_time,
    DATEDIFF(NOW(), update_time) AS days_since_update
FROM information_schema.TABLES
WHERE table_schema NOT IN ('information_schema', 'mysql', 'performance_schema', 'sys')
  AND engine = 'InnoDB'
  AND update_time IS NOT NULL
  AND DATEDIFF(NOW(), update_time) > 7  -- Stats > 7 jours
ORDER BY days_since_update DESC
" | while read SCHEMA TABLE ROWS UPDATE DAYS; do
    echo "‚ö†Ô∏è  $SCHEMA.$TABLE : Stats not updated for $DAYS days (${ROWS} rows)"
done
```

---

## Diff√©rence avec OPTIMIZE TABLE

### Comparaison

| Aspect | ANALYZE TABLE | OPTIMIZE TABLE |
|--------|---------------|----------------|
| **Objectif** | Met √† jour statistiques | D√©fragmente + reconstruit |
| **Dur√©e** | ‚ö° Rapide (secondes) | üêå Lent (minutes √† heures) |
| **Impact I/O** | ‚úÖ Minimal | ‚ùå Tr√®s √©lev√© |
| **Locks** | ‚úÖ Lecture seule | ‚ùå √âcriture (table verrouill√©e) |
| **Espace disque** | ‚úÖ Aucun additionnel | ‚ùå 2√ó taille table |
| **Fr√©quence** | üìÖ Hebdomadaire/Mensuelle | üìÜ Rare (si fragmentation) |
| **Production** | ‚úÖ En ligne, peu impact | ‚ö†Ô∏è Fen√™tre maintenance |

### Quand utiliser chacun

```sql
-- Probl√®me : Requ√™tes lentes avec mauvais plans
-- ‚Üí ANALYZE TABLE (99% des cas)
ANALYZE TABLE orders;

-- Probl√®me : Fragmentation > 10%, espace non r√©cup√©r√©
-- ‚Üí OPTIMIZE TABLE (rare)
OPTIMIZE TABLE orders;
```

üí° **Best practice** : Toujours essayer ANALYZE TABLE en premier (rapide, sans risque).

---

## Automatisation

### Script d'analyse automatique

```bash
#!/bin/bash
# auto-analyze-tables.sh

MYSQL_USER="admin"
MYSQL_PASS="password"
LOG_FILE="/var/log/mysql/analyze-$(date +%Y%m%d).log"

echo "=== Auto-Analyze Tables - $(date) ===" | tee -a $LOG_FILE

# Trouver tables √† analyser
mysql -u$MYSQL_USER -p$MYSQL_PASS -N -e "
SELECT CONCAT(table_schema, '.', table_name) AS full_table_name
FROM information_schema.TABLES
WHERE table_schema NOT IN ('information_schema', 'mysql', 'performance_schema', 'sys')
  AND engine IN ('InnoDB', 'Aria')
  AND (
    -- Tables modifi√©es r√©cemment
    update_time > DATE_SUB(NOW(), INTERVAL 7 DAY)
    OR
    -- Ou stats jamais calcul√©es
    update_time IS NULL
  )
ORDER BY table_rows DESC
" | while read FULL_TABLE; do
    
    echo "Analyzing $FULL_TABLE..." | tee -a $LOG_FILE
    
    START_TIME=$(date +%s)
    
    mysql -u$MYSQL_USER -p$MYSQL_PASS -e "ANALYZE TABLE $FULL_TABLE" >> $LOG_FILE 2>&1
    
    END_TIME=$(date +%s)
    DURATION=$((END_TIME - START_TIME))
    
    echo "‚úì Completed in ${DURATION}s" | tee -a $LOG_FILE
    
done

echo "=== Analysis Complete ===" | tee -a $LOG_FILE
```

### Analyse apr√®s op√©rations massives

```bash
#!/bin/bash
# post-bulk-operation-analyze.sh

# Apr√®s chargement massif de donn√©es
mysql -e "LOAD DATA INFILE '/tmp/orders.csv' INTO TABLE orders;"

# Analyser imm√©diatement
mysql -e "ANALYZE TABLE orders;"

echo "Bulk load and analysis complete"
```

### Cron scheduling

```bash
# /etc/cron.d/mysql-analyze

# Analyse quotidienne (tables actives)
0 4 * * * mysql /usr/local/bin/auto-analyze-tables.sh

# OU analyse hebdomadaire (dimanche 3h00)
0 3 * * 0 mysql /usr/local/bin/auto-analyze-tables.sh
```

### Analyse selective bas√©e sur changements

```sql
-- Vue pour identifier tables n√©cessitant analyse
CREATE OR REPLACE VIEW v_tables_need_analyze AS
SELECT 
    t.table_schema,
    t.table_name,
    t.table_rows,
    t.update_time,
    its.last_update AS stats_last_update,
    DATEDIFF(NOW(), its.last_update) AS days_since_analyze,
    CASE 
        WHEN its.last_update IS NULL THEN 'Never analyzed'
        WHEN DATEDIFF(NOW(), its.last_update) > 30 THEN 'Urgent (>30 days)'
        WHEN DATEDIFF(NOW(), its.last_update) > 14 THEN 'Recommended (>14 days)'
        WHEN DATEDIFF(NOW(), its.last_update) > 7 THEN 'Consider (>7 days)'
        ELSE 'OK'
    END AS recommendation
FROM information_schema.TABLES t
LEFT JOIN mysql.innodb_table_stats its 
    ON t.table_schema = its.database_name 
    AND t.table_name = its.table_name
WHERE t.table_schema NOT IN ('information_schema', 'mysql', 'performance_schema', 'sys')
  AND t.engine = 'InnoDB'
HAVING recommendation != 'OK'
ORDER BY days_since_analyze DESC;

-- Utilisation
SELECT * FROM v_tables_need_analyze;
```

---

## Monitoring des statistiques

### V√©rifier fra√Æcheur des statistiques

```sql
-- Statistiques par table
SELECT 
    database_name,
    table_name,
    n_rows,
    clustered_index_size,
    last_update,
    DATEDIFF(NOW(), last_update) AS days_old
FROM mysql.innodb_table_stats
WHERE database_name = 'shop'
ORDER BY last_update DESC;

-- Statistiques par index
SELECT 
    database_name,
    table_name,
    index_name,
    stat_name,
    stat_value,
    sample_size,
    last_update
FROM mysql.innodb_index_stats
WHERE database_name = 'shop' AND table_name = 'orders';
```

### Comparer estimations vs r√©alit√©

```sql
-- Cr√©er table de benchmark
CREATE TABLE stats_accuracy_check (
    id INT AUTO_INCREMENT PRIMARY KEY,
    table_name VARCHAR(64),
    query_condition VARCHAR(255),
    estimated_rows BIGINT,
    actual_rows BIGINT,
    accuracy_pct DECIMAL(5,2),
    check_date DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Proc√©dure de v√©rification
DELIMITER $$
CREATE PROCEDURE check_stats_accuracy(
    IN p_table VARCHAR(64),
    IN p_condition VARCHAR(255)
)
BEGIN
    DECLARE v_estimated BIGINT;
    DECLARE v_actual BIGINT;
    
    -- Obtenir estimation via EXPLAIN
    SET @query = CONCAT('EXPLAIN SELECT * FROM ', p_table, ' WHERE ', p_condition);
    PREPARE stmt FROM @query;
    EXECUTE stmt;
    -- Parser r√©sultat pour obtenir 'rows'
    
    -- Obtenir valeur r√©elle
    SET @count_query = CONCAT('SELECT COUNT(*) INTO @actual FROM ', p_table, ' WHERE ', p_condition);
    PREPARE count_stmt FROM @count_query;
    EXECUTE count_stmt;
    
    -- Calculer pr√©cision
    INSERT INTO stats_accuracy_check (table_name, query_condition, estimated_rows, actual_rows, accuracy_pct)
    VALUES (p_table, p_condition, v_estimated, @actual, 
            CASE WHEN v_estimated > 0 
                 THEN (1 - ABS(v_estimated - @actual) / v_estimated) * 100 
                 ELSE 0 
            END);
END$$
DELIMITER ;
```

### Dashboard statistiques

```sql
-- Vue d'ensemble statistiques
SELECT 
    COUNT(DISTINCT table_name) AS total_tables,
    COUNT(DISTINCT CASE WHEN last_update >= DATE_SUB(NOW(), INTERVAL 7 DAY) 
                       THEN table_name END) AS fresh_stats,
    COUNT(DISTINCT CASE WHEN last_update < DATE_SUB(NOW(), INTERVAL 7 DAY) 
                       THEN table_name END) AS stale_stats,
    COUNT(DISTINCT CASE WHEN last_update IS NULL 
                       THEN table_name END) AS no_stats
FROM mysql.innodb_table_stats
WHERE database_name NOT IN ('mysql', 'information_schema', 'performance_schema', 'sys');
```

---

## Impact sur les performances

### Overhead ANALYZE TABLE

```sql
-- Benchmark simple
SET @start = NOW(6);
ANALYZE TABLE large_table;
SET @end = NOW(6);

SELECT TIMESTAMPDIFF(MICROSECOND, @start, @end) / 1000000 AS duration_seconds;

-- R√©sultat typique :
-- Table 10 GB : 5-15 secondes
```

**Impact minimal car** :

- ‚úÖ √âchantillonnage (pas full scan)
- ‚úÖ Lock lecture seule (SELECT continuent)
- ‚úÖ Op√©ration rapide

### Locks pendant ANALYZE

```sql
-- V√©rifier locks actifs
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    LOCK_TYPE,
    LOCK_MODE,
    LOCK_STATUS,
    LOCK_DATA
FROM performance_schema.metadata_locks
WHERE OBJECT_NAME = 'orders';

-- Pendant ANALYZE TABLE :
-- LOCK_TYPE: TABLE
-- LOCK_MODE: SHARED_READ
-- ‚Üí Lectures OK, √©critures OK, DDL bloqu√©
```

---

## Cas particuliers

### Tables partitionn√©es

```sql
-- Analyser toutes les partitions
ANALYZE TABLE logs_partitioned;

-- Analyser partition sp√©cifique
ALTER TABLE logs_partitioned ANALYZE PARTITION p202512;

-- Analyser plusieurs partitions
ALTER TABLE logs_partitioned ANALYZE PARTITION p202511, p202512;
```

### Tables avec index full-text

```sql
-- Table avec full-text index
CREATE TABLE articles (
    id INT PRIMARY KEY,
    title VARCHAR(200),
    content TEXT,
    FULLTEXT KEY ft_content (content)
);

-- ANALYZE TABLE met √† jour stats y compris full-text
ANALYZE TABLE articles;

-- V√©rifier
SHOW INDEX FROM articles WHERE Key_name = 'ft_content';
```

### Tables temporaires

```sql
-- Table temporaire
CREATE TEMPORARY TABLE temp_calculations (
    id INT PRIMARY KEY,
    value DECIMAL(10,2)
);

-- Statistiques transitoires (non persistantes)
INSERT INTO temp_calculations SELECT ...;
ANALYZE TABLE temp_calculations;  -- Stats en m√©moire uniquement
```

---

## Bonnes pratiques

### 1. Analyser apr√®s op√©rations massives

```sql
-- Bon pattern
LOAD DATA INFILE '/tmp/data.csv' INTO TABLE products;
ANALYZE TABLE products;  -- ‚úÖ Imm√©diatement apr√®s

-- OU
DELETE FROM logs WHERE created_at < '2024-01-01';
-- Supprim√© 1,000,000 lignes (>10%)
ANALYZE TABLE logs;  -- ‚úÖ Recalculer stats
```

### 2. Configurer statistiques persistantes

```sql
-- Pour toutes les nouvelles tables
SET GLOBAL innodb_stats_persistent = ON;

-- Pour table sp√©cifique
ALTER TABLE orders STATS_PERSISTENT=1, STATS_AUTO_RECALC=1;
```

### 3. Utiliser histogrammes pour colonnes s√©lectives

```sql
-- Colonne avec distribution in√©gale
-- status: 'pending' (1%), 'completed' (99%)

-- Cr√©er histogramme
ANALYZE TABLE orders PERSISTENT FOR COLUMNS (status);

-- Am√©liore estimations pour requ√™tes filtr√©es
SELECT * FROM orders WHERE status = 'pending';
```

### 4. Automatiser avec cron

```bash
# Analyse r√©guli√®re, hors heures de pointe
0 3 * * * /usr/local/bin/auto-analyze-tables.sh
```

### 5. Ne pas sur-analyser

```bash
# ‚ùå MAUVAIS : Analyser trop souvent (overhead inutile)
# Toutes les heures pour table stable

# ‚úÖ BON : Selon fr√©quence modifications
# Hebdomadaire pour tables moder√©ment actives
# Quotidien pour tables tr√®s actives
# Apr√®s bulk operations
```

### 6. Monitorer pr√©cision des estimations

```sql
-- Dashboard r√©gulier
SELECT * FROM v_tables_need_analyze WHERE recommendation != 'OK';

-- Investiguer si plans suboptimaux fr√©quents
```

### 7. NO_WRITE_TO_BINLOG pour maintenance locale

```sql
-- Si analyse locale (pas de r√©plication n√©cessaire)
ANALYZE NO_WRITE_TO_BINLOG TABLE temp_table;

-- √âvite flood binlog
```

---

## Troubleshooting

### Probl√®me 1 : Estimations toujours inexactes

```sql
-- Sympt√¥me
EXPLAIN SELECT * FROM orders WHERE status = 'pending';
-- rows: 50000 (mais r√©alit√©: 1000)

-- M√™me apr√®s ANALYZE TABLE
ANALYZE TABLE orders;
-- Toujours rows: 50000

-- Diagnostic 1 : V√©rifier stats sample pages
SHOW VARIABLES LIKE 'innodb_stats_persistent_sample_pages';
-- 20 (peut √™tre insuffisant pour grande table)

-- Solution : Augmenter √©chantillonnage
ALTER TABLE orders STATS_SAMPLE_PAGES=100;
ANALYZE TABLE orders;

-- Diagnostic 2 : Cr√©er histogramme
SET GLOBAL use_stat_tables = 'preferably';
ANALYZE TABLE orders PERSISTENT FOR COLUMNS (status);
```

### Probl√®me 2 : ANALYZE TABLE tr√®s lent

```sql
-- Sympt√¥me
ANALYZE TABLE huge_table;
-- Bloqu√© pendant plusieurs minutes

-- Cause : Table √©norme avec beaucoup d'index

-- Solution 1 : R√©duire √©chantillonnage (moins pr√©cis mais rapide)
ALTER TABLE huge_table STATS_SAMPLE_PAGES=10;
ANALYZE TABLE huge_table;

-- Solution 2 : Analyser hors heures de pointe
-- Via cron nocturne

-- Solution 3 : D√©sactiver recalcul auto
ALTER TABLE huge_table STATS_AUTO_RECALC=0;
-- Analyser manuellement de fa√ßon contr√¥l√©e
```

### Probl√®me 3 : Statistiques perdues apr√®s red√©marrage

```sql
-- Sympt√¥me : Plans de requ√™tes diff√©rents apr√®s restart

-- Cause : Statistiques transitoires (non persistantes)
SELECT stats_persistent FROM information_schema.TABLES 
WHERE table_name = 'orders';
-- 0 (transitoire)

-- Solution : Activer statistiques persistantes
ALTER TABLE orders STATS_PERSISTENT=1;
ANALYZE TABLE orders;

-- V√©rifier sauvegarde
SELECT * FROM mysql.innodb_table_stats 
WHERE table_name = 'orders';
```

### Probl√®me 4 : Erreur "Table is read only"

```bash
# Sympt√¥me
ANALYZE TABLE products;
# ERROR 1036 (HY000): Table 'products' is read only

# Cause : Permissions filesystem
ls -l /var/lib/mysql/shop/products.ibd
# -r--r--r-- (read only)

# Solution
sudo chmod 660 /var/lib/mysql/shop/products.ibd
sudo chown mysql:mysql /var/lib/mysql/shop/products.ibd

# R√©essayer
ANALYZE TABLE products;
```

---

## Nouveaut√©s MariaDB 11.8

### Statistiques optimis√©es

MariaDB 11.8 apporte des am√©liorations aux statistiques :

```sql
-- Meilleure estimation pour utf8mb4 avec UCA 14.0.0
-- Histogrammes plus pr√©cis pour colonnes avec collation moderne

CREATE TABLE users (
    id INT PRIMARY KEY,
    email VARCHAR(255) COLLATE utf8mb4_unicode_ci  -- UCA 14.0.0
);

ANALYZE TABLE users PERSISTENT FOR COLUMNS (email);
-- Histogrammes optimis√©s pour nouvelle collation
```

### Statistiques pour colonnes calcul√©es

```sql
-- Colonnes STORED avec stats
CREATE TABLE products (
    price DECIMAL(10,2),
    tax_rate DECIMAL(4,2),
    price_with_tax DECIMAL(10,2) AS (price * (1 + tax_rate)) STORED,
    INDEX idx_price_tax (price_with_tax)
);

-- ANALYZE collecte stats pour colonnes calcul√©es
ANALYZE TABLE products;

-- Optimiseur utilise ces stats
EXPLAIN SELECT * FROM products WHERE price_with_tax > 100;
```

---

## Checklist op√©rationnelle

### Configuration initiale

- [ ] Activer innodb_stats_persistent = ON
- [ ] Configurer innodb_stats_auto_recalc = ON
- [ ] D√©finir sample pages appropri√© (20-100 selon taille tables)
- [ ] Activer use_stat_tables = preferably
- [ ] Cr√©er vue v_tables_need_analyze
- [ ] Impl√©menter script auto-analyze
- [ ] Configurer cron hebdomadaire/mensuel

### Maintenance r√©guli√®re

- [ ] V√©rifier tables n√©cessitant analyse (v_tables_need_analyze)
- [ ] Analyser apr√®s bulk INSERT/DELETE (>10% lignes)
- [ ] Analyser apr√®s CREATE/DROP INDEX
- [ ] Monitorer pr√©cision estimations vs r√©alit√©
- [ ] Cr√©er histogrammes pour colonnes s√©lectives
- [ ] Documenter fr√©quence analyse par table

### Troubleshooting performance

- [ ] EXPLAIN requ√™tes lentes
- [ ] Comparer estimated rows vs actual rows
- [ ] V√©rifier last_update des statistiques
- [ ] ANALYZE TABLE si stats obsol√®tes
- [ ] Cr√©er histogrammes si estimations inexactes
- [ ] Augmenter sample_pages si n√©cessaire
- [ ] V√©rifier stats_persistent activ√©

---

## ‚úÖ Points cl√©s √† retenir

- **Statistiques = Guide optimiseur** : Essentielles pour bons plans de requ√™tes
- **ANALYZE TABLE l√©ger** : Rapide (secondes), peu d'impact, √©chantillonnage
- **vs OPTIMIZE TABLE** : ANALYZE = stats, OPTIMIZE = d√©fragmentation
- **Statistiques persistantes** : innodb_stats_persistent = ON (recommand√©)
- **Recalcul automatique** : innodb_stats_auto_recalc = ON
- **Histogrammes** : Am√©liore estimations pour colonnes s√©lectives
- **Fr√©quence** : Apr√®s bulk ops, ou hebdomadaire/mensuelle
- **Monitoring** : V√©rifier fra√Æcheur et pr√©cision des stats
- **Automatisation** : Script + cron pour maintenance r√©guli√®re
- **use_stat_tables** : preferably pour histogrammes

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation officielle : ANALYZE TABLE](https://mariadb.com/kb/en/analyze-table/)
- [üìñ InnoDB Persistent Statistics](https://mariadb.com/kb/en/innodb-persistent-statistics/)
- [üìñ Engine-Independent Table Statistics](https://mariadb.com/kb/en/engine-independent-table-statistics/)
- [üìñ Histogram-Based Statistics](https://mariadb.com/kb/en/histogram-based-statistics/)
- [üìñ mysql.innodb_table_stats](https://mariadb.com/kb/en/mysqlinnodb_table_stats/)
- [Blog : Query Optimizer Statistics](https://mariadb.org/optimizer-statistics/)

---

## ‚û°Ô∏è Section suivante

**11.6.3 - CHECK TABLE** : V√©rification de l'int√©grit√© des tables, d√©tection de corruption, diff√©rentes options de v√©rification, et strat√©gies de maintenance pr√©ventive.

‚è≠Ô∏è [CHECK TABLE et REPAIR TABLE](/11-administration-configuration/06.3-check-repair-table.md)
