üîù Retour au [Sommaire](/SOMMAIRE.md)

# 11.6.3 CHECK TABLE et REPAIR TABLE

> **Niveau** : Avanc√© (DBA/Administrateur Syst√®me)  
> **Dur√©e estim√©e** : 2 heures  
> **Pr√©requis** : 11.6.1 - OPTIMIZE TABLE, 11.6.2 - ANALYZE TABLE, corruption de donn√©es

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- D√©tecter et diagnostiquer la corruption de tables
- Utiliser CHECK TABLE avec les options appropri√©es
- R√©parer les tables corrompues avec REPAIR TABLE
- Comprendre les limitations par moteur de stockage
- Impl√©menter des strat√©gies de v√©rification pr√©ventive
- Automatiser les v√©rifications d'int√©grit√©
- Appliquer les proc√©dures de recovery en cas de corruption
- Choisir entre r√©paration et restauration depuis backup

---

## Introduction

### Types de corruption

La **corruption de donn√©es** peut survenir √† plusieurs niveaux :

| Type | Description | Gravit√© | R√©cup√©rable |
|------|-------------|---------|-------------|
| **Index corrompu** | Index incoh√©rent avec donn√©es | ‚ö†Ô∏è Moyenne | ‚úÖ Oui (rebuild) |
| **Donn√©es corrompues** | Valeurs incorrectes/illisibles | üî¥ Haute | ‚ö†Ô∏è Partiel |
| **Corruption structurelle** | M√©tadonn√©es table endommag√©es | üî¥ Tr√®s haute | ‚ö†Ô∏è Difficile |
| **Corruption tablespace** | Fichier .ibd endommag√© | üî¥ Critique | ‚ùå Backup requis |

### Causes de corruption

```
üíæ D√©faillance mat√©rielle (disque, RAM, contr√¥leur)
‚ö° Coupure √©lectrique pendant √©criture
üêõ Bugs logiciels (OS, filesystem, MariaDB)
üí• Crash serveur pendant transaction
üîß Arr√™t forc√© (kill -9) de MariaDB
üì¶ Probl√®me filesystem (ext4, xfs corruption)
üîÑ Erreur r√©plication (binlog/relay log)
```

### Pr√©vention vs Correction

```
Pr√©vention :
‚úÖ Hardware fiable (RAID, ECC RAM)
‚úÖ UPS (onduleur)
‚úÖ Backups r√©guliers
‚úÖ Monitoring proactif
‚úÖ Tests d'int√©grit√© pr√©ventifs

Correction :
üîß CHECK TABLE (diagnostic)
üîß REPAIR TABLE (r√©paration)
üîß Restauration depuis backup
```

---

## CHECK TABLE : V√©rification d'int√©grit√©

### Principe de fonctionnement

**CHECK TABLE** v√©rifie l'int√©grit√© structurelle et logique d'une table :

- üîç **Coh√©rence index** : Correspondance index ‚Üî donn√©es
- üîç **Int√©grit√© cl√©s** : PRIMARY KEY, UNIQUE, FOREIGN KEY
- üîç **Structure fichiers** : .frm, .ibd, .MYD, .MYI
- üîç **Checksums** : V√©rification sommes de contr√¥le

### Syntaxe de base

```sql
-- V√©rification simple
CHECK TABLE table_name;

-- V√©rification avec options
CHECK TABLE table_name [option];

-- V√©rifier plusieurs tables
CHECK TABLE table1, table2, table3;
```

### Options CHECK TABLE

| Option | Description | Dur√©e | Use case |
|--------|-------------|-------|----------|
| **QUICK** | V√©rifie uniquement index | ‚ö° Rapide | Test rapide |
| **FAST** | V√©rifie si ferm√©e proprement | ‚ö°‚ö° Tr√®s rapide | Apr√®s crash |
| **MEDIUM** | V√©rifie lignes + index (d√©faut) | üêå Moyen | Standard |
| **EXTENDED** | V√©rification exhaustive | üêåüêå Lent | Approfondi |
| **CHANGED** | V√©rifie si modifi√©e depuis dernier check | ‚ö° Variable | Optimisation |

### Exemples par option

```sql
-- Option 1 : QUICK (rapide, index seulement)
CHECK TABLE orders QUICK;

-- Option 2 : FAST (tr√®s rapide, √©tat de fermeture)
CHECK TABLE orders FAST;

-- Option 3 : MEDIUM (d√©faut, v√©rification standard)
CHECK TABLE orders;
-- OU explicitement
CHECK TABLE orders MEDIUM;

-- Option 4 : EXTENDED (complet, ligne par ligne)
CHECK TABLE orders EXTENDED;

-- Option 5 : CHANGED (si modifi√© depuis dernier check)
CHECK TABLE orders CHANGED;

-- Combinaison (selon moteur)
CHECK TABLE orders QUICK, EXTENDED;
```

---

## CHECK TABLE par moteur de stockage

### InnoDB

```sql
CHECK TABLE innodb_table;

-- R√©sultat typique :
+--------------------+-------+----------+----------+
| Table              | Op    | Msg_type | Msg_text |
+--------------------+-------+----------+----------+
| shop.innodb_table  | check | status   | OK       |
+--------------------+-------+----------+----------+
```

**Ce qui est v√©rifi√© (InnoDB)** :

1. **Structure de la table** (.frm coh√©rent avec .ibd)
2. **Index B-tree** : Coh√©rence des pointeurs
3. **Pages de donn√©es** : Checksums valides
4. **Cl√©s √©trang√®res** : Int√©grit√© r√©f√©rentielle
5. **Auto-increment** : Valeur coh√©rente

**Limitations InnoDB** :

- ‚ö†Ô∏è QUICK, FAST, CHANGED = **ignor√©es** (toujours MEDIUM)
- ‚ö†Ô∏è EXTENDED = **identique √† MEDIUM** pour InnoDB
- ‚úÖ Pas de rebuild automatique (contrairement MyISAM)

### MyISAM

```sql
CHECK TABLE myisam_table EXTENDED;

-- R√©sultat d√©taill√© :
+-------------------+-------+----------+---------------------------+
| Table             | Op    | Msg_type | Msg_text                  |
+-------------------+-------+----------+---------------------------+
| shop.myisam_table | check | status   | OK                        |
| shop.myisam_table | check | info     | 125000 records checked    |
+-------------------+-------+----------+---------------------------+
```

**Ce qui est v√©rifi√© (MyISAM)** :

1. **Fichier .MYD** (donn√©es) : Int√©grit√©
2. **Fichier .MYI** (index) : Coh√©rence
3. **Correspondance donn√©es-index** : V√©rification crois√©e
4. **Checksums** : Si activ√© (myisam_recover_options)

**Options MyISAM** :

```sql
-- QUICK : Index seulement (pas de scan donn√©es)
CHECK TABLE myisam_table QUICK;

-- FAST : Seulement si non ferm√©e proprement
CHECK TABLE myisam_table FAST;

-- EXTENDED : Ligne par ligne + checksum
CHECK TABLE myisam_table EXTENDED;
```

### Aria

```sql
CHECK TABLE aria_table;

-- Similaire √† MyISAM avec am√©liorations Aria
-- V√©rification transactionnelle si table transactionnelle
```

---

## Interpr√©tation des r√©sultats

### R√©sultat OK

```sql
CHECK TABLE orders;

+---------------+-------+----------+----------+
| Table         | Op    | Msg_type | Msg_text |
+---------------+-------+----------+----------+
| shop.orders   | check | status   | OK       |
+---------------+-------+----------+----------+
```

‚úÖ **Signification** : Table saine, aucune corruption d√©tect√©e.

### R√©sultat avec erreurs

```sql
CHECK TABLE orders;

+---------------+-------+----------+-----------------------------------+
| Table         | Op    | Msg_type | Msg_text                          |
+---------------+-------+----------+-----------------------------------+
| shop.orders   | check | error    | Corrupt                           |
| shop.orders   | check | error    | Key in wrong position at page 1234|
| shop.orders   | check | status   | Operation failed                  |
+---------------+-------+----------+-----------------------------------+
```

üî¥ **Signification** : Corruption d√©tect√©e, r√©paration n√©cessaire.

### R√©sultat avec warnings

```sql
CHECK TABLE orders;

+---------------+-------+----------+-----------------------------------+
| Table         | Op    | Msg_type | Msg_text                          |
+---------------+-------+----------+-----------------------------------+
| shop.orders   | check | warning  | Table is marked as crashed        |
| shop.orders   | check | status   | OK                                |
+---------------+-------+----------+-----------------------------------+
```

‚ö†Ô∏è **Signification** : Attention requise, mais table utilisable.

### Messages courants

| Msg_text | Gravit√© | Action |
|----------|---------|--------|
| **OK** | ‚úÖ Aucune | Continue normalement |
| **Table is marked as crashed** | ‚ö†Ô∏è Moyenne | REPAIR TABLE |
| **Corrupt** | üî¥ Haute | REPAIR ou restore |
| **Key in wrong position** | üî¥ Haute | REPAIR TABLE |
| **Size of datafile is: X Should be: Y** | üî¥ Haute | REPAIR TABLE |
| **Table is already up to date** | ‚úÖ Info | Aucune (CHANGED) |

---

## REPAIR TABLE : R√©paration

### Principe

**REPAIR TABLE** tente de r√©parer une table corrompue :

- üîß **Reconstruction index** : Recr√©e index √† partir donn√©es
- üîß **R√©organisation donn√©es** : Trie et d√©fragmente
- üîß **R√©cup√©ration lignes** : Sauve lignes valides

‚ö†Ô∏è **IMPORTANT** : REPAIR TABLE fonctionne **uniquement** sur MyISAM et Aria (pas InnoDB).

### Syntaxe

```sql
-- R√©paration standard
REPAIR TABLE table_name;

-- Avec options
REPAIR TABLE table_name [option];

-- Plusieurs tables
REPAIR TABLE table1, table2;

-- Ne pas logger dans binlog
REPAIR NO_WRITE_TO_BINLOG TABLE table_name;
REPAIR LOCAL TABLE table_name;  -- Alias
```

### Options REPAIR TABLE

| Option | Description | Dur√©e | Risque perte donn√©es |
|--------|-------------|-------|----------------------|
| **QUICK** | R√©paration rapide (index uniquement) | ‚ö° Rapide | ‚úÖ Faible |
| **EXTENDED** | R√©paration exhaustive (ligne par ligne) | üêåüêå Tr√®s lent | ‚úÖ Faible |
| **USE_FRM** | Recr√©e .MYI depuis .frm (si .MYI perdu) | üêå Moyen | ‚ö†Ô∏è Possible |

### Exemples REPAIR TABLE

```sql
-- R√©paration standard
REPAIR TABLE myisam_table;

-- R√©sultat :
+-------------------+--------+----------+----------+
| Table             | Op     | Msg_type | Msg_text |
+-------------------+--------+----------+----------+
| shop.myisam_table | repair | status   | OK       |
+-------------------+--------+----------+----------+

-- R√©paration rapide (tentative index seulement)
REPAIR TABLE myisam_table QUICK;

-- R√©paration exhaustive (si QUICK √©choue)
REPAIR TABLE myisam_table EXTENDED;

-- Reconstruction depuis .frm (cas extr√™me)
REPAIR TABLE myisam_table USE_FRM;
```

---

## REPAIR TABLE limitations et InnoDB

### InnoDB : Pas de REPAIR TABLE

```sql
-- Tentative REPAIR sur table InnoDB
REPAIR TABLE innodb_table;

-- R√©sultat :
+--------------------+--------+----------+-------------------------------------------------------+
| Table              | Op     | Msg_type | Msg_text                                              |
+--------------------+--------+----------+-------------------------------------------------------+
| shop.innodb_table  | repair | note     | The storage engine for the table doesn't support repair|
+--------------------+--------+----------+-------------------------------------------------------+
```

### Alternatives pour InnoDB

#### Option 1 : Rebuild table (ALTER TABLE)

```sql
-- Reconstruire table compl√®te
ALTER TABLE innodb_table ENGINE=InnoDB;

-- OU
ALTER TABLE innodb_table FORCE;

-- Effet : Recr√©e table + index (√©quivalent OPTIMIZE + REPAIR)
```

#### Option 2 : Dump & Restore

```bash
#!/bin/bash
# repair-innodb-via-dump.sh

TABLE="corrupted_table"
DB="shop"

# Dump (skip corrupted rows si possible)
mysqldump --skip-opt --create-options --quick --set-charset \
          --add-drop-table --disable-keys \
          --force \
          $DB $TABLE > /tmp/${TABLE}_dump.sql

# Drop table
mysql -e "DROP TABLE $DB.$TABLE;"

# Restore
mysql $DB < /tmp/${TABLE}_dump.sql

echo "Table rebuilt from dump"
```

#### Option 3 : InnoDB recovery mode

```ini
# /etc/mysql/mariadb.conf.d/50-server.cnf

[mysqld]
# Mode recovery (1-6, selon gravit√© corruption)
innodb_force_recovery = 1

# Red√©marrer MariaDB
# systemctl restart mariadb

# Dumper donn√©es r√©cup√©rables
# mysqldump ...

# Retirer innodb_force_recovery et red√©marrer normalement
```

**Niveaux innodb_force_recovery** :

| Niveau | Description | Risque |
|--------|-------------|--------|
| **0** | Normal (d√©faut) | Aucun |
| **1** | Ignore pages corrompues | ‚úÖ Faible |
| **2** | Ne lance pas background threads | ‚úÖ Faible |
| **3** | Pas de rollback apr√®s crash | ‚ö†Ô∏è Moyen |
| **4** | Emp√™che INSERT/UPDATE/DELETE | ‚ö†Ô∏è Moyen |
| **5** | Ignore undo logs | ‚ö†Ô∏è √âlev√© |
| **6** | Ignore redo logs | üî¥ Tr√®s √©lev√© |

‚ö†Ô∏è **ATTENTION** : Niveaux 4-6 = Mode **READ ONLY**. Dumper donn√©es puis recr√©er table.

---

## D√©tection proactive de corruption

### Script de v√©rification automatis√©

```bash
#!/bin/bash
# check-all-tables.sh

MYSQL_USER="admin"
MYSQL_PASS="password"
LOG_FILE="/var/log/mysql/table-check-$(date +%Y%m%d).log"
EMAIL="dba@example.com"

echo "=== Table Integrity Check - $(date) ===" | tee -a $LOG_FILE

CORRUPTION_FOUND=0

# Lister toutes les tables
mysql -u$MYSQL_USER -p$MYSQL_PASS -N -e "
SELECT CONCAT(table_schema, '.', table_name) 
FROM information_schema.TABLES 
WHERE table_schema NOT IN ('information_schema', 'mysql', 'performance_schema', 'sys')
  AND engine IN ('InnoDB', 'MyISAM', 'Aria')
ORDER BY table_schema, table_name
" | while read FULL_TABLE; do
    
    echo "Checking $FULL_TABLE..." | tee -a $LOG_FILE
    
    # CHECK TABLE
    RESULT=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -N -e "CHECK TABLE $FULL_TABLE" 2>&1)
    
    # V√©rifier r√©sultat
    if echo "$RESULT" | grep -qi "corrupt\|error\|crashed"; then
        echo "‚ö†Ô∏è  CORRUPTION DETECTED: $FULL_TABLE" | tee -a $LOG_FILE
        echo "$RESULT" | tee -a $LOG_FILE
        CORRUPTION_FOUND=1
        
        # Tenter r√©paration automatique si MyISAM/Aria
        ENGINE=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -N -e "
            SELECT engine FROM information_schema.TABLES 
            WHERE CONCAT(table_schema, '.', table_name) = '$FULL_TABLE'
        ")
        
        if [ "$ENGINE" = "MyISAM" ] || [ "$ENGINE" = "Aria" ]; then
            echo "Attempting automatic repair..." | tee -a $LOG_FILE
            mysql -u$MYSQL_USER -p$MYSQL_PASS -e "REPAIR TABLE $FULL_TABLE" >> $LOG_FILE 2>&1
        else
            echo "InnoDB table - manual intervention required" | tee -a $LOG_FILE
        fi
    else
        echo "‚úì OK" | tee -a $LOG_FILE
    fi
    
done

# Alerte email si corruption
if [ $CORRUPTION_FOUND -eq 1 ]; then
    cat $LOG_FILE | mail -s "[CRITICAL] Database Corruption Detected" $EMAIL
fi

echo "=== Check Complete ===" | tee -a $LOG_FILE
```

### V√©rification post-crash

```bash
#!/bin/bash
# post-crash-check.sh

# Apr√®s crash/restart non planifi√©
echo "Post-crash integrity check..."

# InnoDB : V√©rifier recovery
tail -100 /var/log/mysql/error.log | grep -i "crash recovery"

# Tables marqu√©es crashed (MyISAM/Aria)
mysql -N -e "
SELECT CONCAT(table_schema, '.', table_name) AS crashed_table
FROM information_schema.TABLES
WHERE engine IN ('MyISAM', 'Aria')
" | while read TABLE; do
    
    # CHECK FAST (tables ferm√©es improprement)
    RESULT=$(mysql -e "CHECK TABLE $TABLE FAST")
    
    if echo "$RESULT" | grep -qi "crashed"; then
        echo "Table $TABLE marked as crashed, repairing..."
        mysql -e "REPAIR TABLE $TABLE"
    fi
done
```

### Monitoring avec Performance Schema

```sql
-- Cr√©er √©v√©nement de v√©rification quotidienne
CREATE EVENT IF NOT EXISTS daily_table_check
ON SCHEDULE EVERY 1 DAY
STARTS TIMESTAMP(CURRENT_DATE, '03:00:00')
DO
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE tbl_name VARCHAR(200);
    DECLARE tbl_schema VARCHAR(64);
    DECLARE check_result TEXT;
    
    DECLARE table_cursor CURSOR FOR
        SELECT table_schema, table_name
        FROM information_schema.TABLES
        WHERE table_schema NOT IN ('information_schema', 'mysql', 'performance_schema')
          AND engine IN ('InnoDB', 'MyISAM', 'Aria');
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    
    OPEN table_cursor;
    
    read_loop: LOOP
        FETCH table_cursor INTO tbl_schema, tbl_name;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- V√©rifier table
        SET @sql = CONCAT('CHECK TABLE ', tbl_schema, '.', tbl_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
    END LOOP;
    
    CLOSE table_cursor;
END;

-- Activer event scheduler
SET GLOBAL event_scheduler = ON;
```

---

## Proc√©dures de recovery

### Proc√©dure compl√®te : MyISAM corrompu

```bash
#!/bin/bash
# recover-myisam-table.sh

DB="shop"
TABLE="products"

echo "=== MyISAM Table Recovery Procedure ==="

# 1. Backup actuel (m√™me si corrompu)
echo "Step 1: Backup current state..."
tar -czf /backup/${TABLE}-corrupt-$(date +%Y%m%d_%H%M%S).tar.gz \
    /var/lib/mysql/$DB/${TABLE}.*

# 2. CHECK TABLE
echo "Step 2: Check table..."
mysql -e "CHECK TABLE $DB.$TABLE EXTENDED"

# 3. REPAIR TABLE QUICK (tentative rapide)
echo "Step 3: Attempting QUICK repair..."
mysql -e "REPAIR TABLE $DB.$TABLE QUICK"

CHECK_RESULT=$(mysql -N -e "CHECK TABLE $DB.$TABLE" | grep -c "OK")

if [ $CHECK_RESULT -eq 0 ]; then
    # 4. REPAIR TABLE EXTENDED (si QUICK √©choue)
    echo "Step 4: Attempting EXTENDED repair..."
    mysql -e "REPAIR TABLE $DB.$TABLE EXTENDED"
    
    CHECK_RESULT=$(mysql -N -e "CHECK TABLE $DB.$TABLE" | grep -c "OK")
fi

if [ $CHECK_RESULT -eq 0 ]; then
    # 5. REPAIR TABLE USE_FRM (derni√®re tentative)
    echo "Step 5: Attempting USE_FRM repair..."
    mysql -e "REPAIR TABLE $DB.$TABLE USE_FRM"
    
    CHECK_RESULT=$(mysql -N -e "CHECK TABLE $DB.$TABLE" | grep -c "OK")
fi

# 6. V√©rifier r√©sultat final
if [ $CHECK_RESULT -gt 0 ]; then
    echo "‚úì Table successfully repaired"
    
    # ANALYZE TABLE apr√®s r√©paration
    mysql -e "ANALYZE TABLE $DB.$TABLE"
else
    echo "‚úó Repair failed - restore from backup required"
fi
```

### Proc√©dure compl√®te : InnoDB corrompu

```bash
#!/bin/bash
# recover-innodb-table.sh

DB="shop"
TABLE="orders"

echo "=== InnoDB Table Recovery Procedure ==="

# 1. Backup complet base
echo "Step 1: Full database backup..."
mysqldump --single-transaction --routines --triggers \
          --all-databases > /backup/full-backup-pre-recovery.sql

# 2. Identifier niveau corruption
echo "Step 2: Attempting table access..."
mysql -e "SELECT COUNT(*) FROM $DB.$TABLE LIMIT 1" 2>&1

# 3. Tenter ALTER TABLE (rebuild)
echo "Step 3: Attempting table rebuild..."
mysql -e "ALTER TABLE $DB.$TABLE ENGINE=InnoDB" 2>&1

if [ $? -eq 0 ]; then
    echo "‚úì Table successfully rebuilt"
    exit 0
fi

# 4. Si √©chec, mode recovery InnoDB
echo "Step 4: Enabling InnoDB recovery mode..."

# Backup my.cnf
cp /etc/mysql/mariadb.conf.d/50-server.cnf \
   /etc/mysql/mariadb.conf.d/50-server.cnf.backup

# Ajouter innodb_force_recovery
echo "innodb_force_recovery = 1" >> /etc/mysql/mariadb.conf.d/50-server.cnf

# Red√©marrer MariaDB
systemctl restart mariadb
sleep 10

# 5. Dump table (mode recovery)
echo "Step 5: Dumping table in recovery mode..."
mysqldump --single-transaction --skip-lock-tables --force \
          $DB $TABLE > /backup/${TABLE}-recovery-dump.sql

# 6. Retirer recovery mode
echo "Step 6: Disabling recovery mode..."
cp /etc/mysql/mariadb.conf.d/50-server.cnf.backup \
   /etc/mysql/mariadb.conf.d/50-server.cnf

systemctl restart mariadb
sleep 10

# 7. Drop et recr√©er table
echo "Step 7: Recreating table..."
mysql -e "DROP TABLE IF EXISTS $DB.${TABLE}_old"
mysql -e "RENAME TABLE $DB.$TABLE TO $DB.${TABLE}_old"

# 8. Restore depuis dump
echo "Step 8: Restoring from dump..."
mysql $DB < /backup/${TABLE}-recovery-dump.sql

# 9. V√©rifier
echo "Step 9: Verification..."
COUNT=$(mysql -N -e "SELECT COUNT(*) FROM $DB.$TABLE")
echo "Rows recovered: $COUNT"

echo "Recovery complete - review ${TABLE}_old before dropping"
```

---

## Bonnes pratiques

### 1. V√©rifications r√©guli√®res pr√©ventives

```bash
# Cron hebdomadaire (dimanche 2h00)
0 2 * * 0 /usr/local/bin/check-all-tables.sh
```

### 2. CHECK apr√®s √©v√©nements critiques

```
‚úÖ Apr√®s crash serveur
‚úÖ Apr√®s coupure √©lectrique
‚úÖ Apr√®s migration hardware
‚úÖ Apr√®s upgrade MariaDB
‚úÖ Apr√®s erreurs I/O disque
```

### 3. Toujours backup avant REPAIR

```bash
# AVANT r√©paration
mysqldump mydb corrupted_table > /backup/corrupted_table-pre-repair.sql

# PUIS r√©paration
mysql -e "REPAIR TABLE mydb.corrupted_table"
```

### 4. Pr√©f√©rer restauration si backup r√©cent

```
Backup < 24h + corruption s√©v√®re
‚Üí Restaurer plut√¥t que r√©parer
  (Plus rapide, plus fiable)
```

### 5. InnoDB : √âviter innodb_force_recovery > 3

```
Niveaux 4-6 : Donn√©es perdues possibles
‚Üí Dumper ce qui reste
‚Üí Recr√©er table from scratch
```

### 6. Monitoring proactif

```sql
-- Dashboard corruption
CREATE OR REPLACE VIEW v_table_health AS
SELECT 
    table_schema,
    table_name,
    engine,
    table_rows,
    update_time,
    check_time,
    CASE 
        WHEN check_time IS NULL THEN 'Never checked'
        WHEN DATEDIFF(NOW(), check_time) > 30 THEN 'Check overdue'
        WHEN DATEDIFF(NOW(), check_time) > 7 THEN 'Check recommended'
        ELSE 'Recently checked'
    END AS health_status
FROM information_schema.TABLES
WHERE table_schema NOT IN ('information_schema', 'mysql', 'performance_schema', 'sys')
ORDER BY check_time ASC NULLS FIRST;
```

### 7. Documentation proc√©dures

```bash
# Documenter chaque incident
cat > /var/log/mysql/corruption-incident-$(date +%Y%m%d).md <<EOF
# Corruption Incident Report

Date: $(date)
Table: shop.orders
Engine: InnoDB

## Detection
CHECK TABLE result: Corrupt

## Actions taken
1. Backup created: /backup/orders-corrupt-20251213.sql
2. Attempted ALTER TABLE ENGINE=InnoDB: Failed
3. innodb_force_recovery = 1: Success
4. Dumped table: /backup/orders-recovery.sql
5. Dropped and recreated table
6. Restored from dump

## Data loss
Rows before: 125000
Rows after: 124987
Lost rows: 13 (0.01%)

## Root cause
Disk I/O errors detected in dmesg

## Prevention
- Hardware diagnostics scheduled
- RAID rebuild initiated
- Monitoring enhanced
EOF
```

---

## Troubleshooting

### Probl√®me 1 : REPAIR TABLE ne fonctionne pas (InnoDB)

```sql
-- Sympt√¥me
REPAIR TABLE innodb_table;
-- Storage engine doesn't support repair

-- Solution : ALTER TABLE
ALTER TABLE innodb_table ENGINE=InnoDB;

-- Ou dump & restore
mysqldump mydb innodb_table > /tmp/table.sql
mysql -e "DROP TABLE mydb.innodb_table"
mysql mydb < /tmp/table.sql
```

### Probl√®me 2 : CHECK TABLE infiniment lent

```sql
-- Sympt√¥me
CHECK TABLE huge_table EXTENDED;
-- Bloqu√© depuis heures

-- Solution 1 : Utiliser QUICK d'abord
CHECK TABLE huge_table QUICK;

-- Solution 2 : V√©rifier par partition (si partitionn√©e)
ALTER TABLE huge_table CHECK PARTITION p202512;

-- Solution 3 : myisamchk offline (MyISAM)
# Arr√™ter MariaDB
systemctl stop mariadb

# myisamchk manuel
myisamchk /var/lib/mysql/mydb/huge_table.MYI

# Red√©marrer
systemctl start mariadb
```

### Probl√®me 3 : REPAIR √©choue avec "not enough space"

```bash
# Sympt√¥me
REPAIR TABLE large_table;
# ERROR: The table is full

# Solution 1 : Lib√©rer espace disque
df -h /var/lib/mysql
# Purger logs, tmp files

# Solution 2 : tmpdir sur partition diff√©rente
SET GLOBAL tmpdir = '/mnt/large-tmp';
REPAIR TABLE large_table;

# Solution 3 : Repair offline avec myisamchk
systemctl stop mariadb
myisamchk --recover --tmpdir=/mnt/large-tmp /var/lib/mysql/mydb/large_table.MYI
systemctl start mariadb
```

### Probl√®me 4 : Corruption apr√®s crash r√©p√©t√©e

```bash
# Sympt√¥me : Table corrompue √† chaque crash

# Diagnostic 1 : V√©rifier hardware
dmesg | grep -i "error\|fail"
smartctl -a /dev/sda  # SMART status disque

# Diagnostic 2 : Filesystem check
umount /var/lib/mysql
fsck -f /dev/sdb1
mount /var/lib/mysql

# Diagnostic 3 : V√©rifier RAM (memtest86+)

# Solution : Corriger hardware + restaurer depuis backup sain
```

---

## Checklist op√©rationnelle

### V√©rification r√©guli√®re

- [ ] Script check-all-tables.sh configur√©
- [ ] Cron hebdomadaire actif
- [ ] Logs v√©rification archiv√©s
- [ ] Alertes email configur√©es
- [ ] Dashboard sant√© tables actif

### Apr√®s incident (crash, coupure)

- [ ] V√©rifier error log pour signes corruption
- [ ] CHECK TABLE FAST sur tables MyISAM/Aria
- [ ] V√©rifier InnoDB crash recovery dans error log
- [ ] REPAIR tables marqu√©es crashed
- [ ] ANALYZE TABLE apr√®s r√©paration
- [ ] Documenter incident

### Proc√©dure corruption d√©tect√©e

- [ ] Backup imm√©diat (m√™me table corrompue)
- [ ] Identifier moteur stockage
- [ ] CHECK TABLE EXTENDED
- [ ] Si MyISAM/Aria : REPAIR TABLE (QUICK ‚Üí EXTENDED ‚Üí USE_FRM)
- [ ] Si InnoDB : ALTER TABLE ou innodb_force_recovery
- [ ] V√©rifier int√©grit√© donn√©es r√©cup√©r√©es
- [ ] ANALYZE TABLE
- [ ] Documenter cause et r√©solution

### Pr√©vention corruption

- [ ] Hardware fiable (RAID, ECC RAM)
- [ ] UPS actif et test√©
- [ ] Backups quotidiens test√©s
- [ ] Monitoring disque (SMART, I/O errors)
- [ ] Arr√™ts propres MariaDB (systemctl stop)
- [ ] innodb_flush_log_at_trx_commit = 1
- [ ] sync_binlog = 1

---

## ‚úÖ Points cl√©s √† retenir

- **CHECK TABLE** : Diagnostic corruption (QUICK, MEDIUM, EXTENDED)
- **REPAIR TABLE** : MyISAM/Aria uniquement (pas InnoDB)
- **InnoDB corruption** : ALTER TABLE ENGINE=InnoDB ou innodb_force_recovery
- **Pr√©vention** : Hardware fiable, UPS, backups, monitoring
- **V√©rifications r√©guli√®res** : Hebdomadaire automatis√©
- **Post-crash** : CHECK TABLE FAST obligatoire
- **Backup avant REPAIR** : Toujours, m√™me table corrompue
- **innodb_force_recovery** : Niveaux 1-3 safe, 4-6 dangereux
- **Documentation** : Chaque incident document√©
- **Restauration vs R√©paration** : Restaurer si backup r√©cent

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation officielle : CHECK TABLE](https://mariadb.com/kb/en/check-table/)
- [üìñ Documentation officielle : REPAIR TABLE](https://mariadb.com/kb/en/repair-table/)
- [üìñ InnoDB Recovery](https://mariadb.com/kb/en/innodb-recovery-modes/)
- [üìñ innodb_force_recovery](https://mariadb.com/kb/en/innodb-system-variables/#innodb_force_recovery)
- [üìñ myisamchk](https://mariadb.com/kb/en/myisamchk/)
- [Blog : Table Corruption Prevention](https://mariadb.org/table-corruption-prevention/)

---

## ‚û°Ô∏è Section suivante

**11.3 - Modes SQL (sql_mode)** : Configuration et impact des diff√©rents modes SQL, compatibilit√©, validation des donn√©es, et bonnes pratiques pour chaque type d'application.

‚è≠Ô∏è [Gestion de l'espace disque](/11-administration-configuration/07-gestion-espace-disque.md)
