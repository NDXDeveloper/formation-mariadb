ðŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 11.5.2 Formats : STATEMENT, ROW, MIXED

> **Niveau** : AvancÃ© (DBA/Architecte SystÃ¨me)  
> **DurÃ©e estimÃ©e** : 2 heures  
> **PrÃ©requis** : 11.5.1 - Configuration binlog, concepts de rÃ©plication, SQL avancÃ©

## ðŸŽ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre en profondeur les diffÃ©rences entre formats STATEMENT, ROW et MIXED
- Choisir le format optimal selon le cas d'usage
- Identifier et rÃ©soudre les problÃ¨mes liÃ©s au format binlog
- Migrer entre formats en production de maniÃ¨re sÃ©curisÃ©e
- Optimiser la taille et performance du binlog selon le format
- GÃ©rer les cas particuliers et piÃ¨ges de chaque format
- ImplÃ©menter des stratÃ©gies de Change Data Capture (CDC)
- Appliquer les bonnes pratiques modernes de binary logging

---

## Introduction

Le format du binary log dÃ©termine **comment** les changements de donnÃ©es sont enregistrÃ©s. Ce choix a un impact majeur sur :

- ðŸ“Š **Taille des fichiers** binlog
- ðŸ”„ **FiabilitÃ© de la rÃ©plication**
- âš¡ **Performance** du serveur
- ðŸ” **CapacitÃ©s de debugging**
- ðŸ“¡ **Change Data Capture** (CDC)

ðŸ’¡ **Ã‰volution historique** :
- MySQL 5.0 : Uniquement STATEMENT
- MySQL 5.1 : Introduction ROW et MIXED
- **MariaDB 10.2.4** : ROW devient le dÃ©faut
- **MariaDB 11.8** : ROW reste le standard recommandÃ©

---

## Format STATEMENT : Logging basÃ© requÃªtes

### Principe de fonctionnement

Le format STATEMENT enregistre la **requÃªte SQL exacte** exÃ©cutÃ©e.

```sql
-- RequÃªte exÃ©cutÃ©e sur le primary
UPDATE products
SET price = price * 1.1,
    updated_at = NOW()
WHERE category = 'electronics';
-- Affecte 5000 lignes

-- Dans le binlog (STATEMENT)
# at 4
#251213 14:30:00 server id 1  end_log_pos 157 CRC32 0x12345678
SET TIMESTAMP=1702476600/*!*/;
UPDATE products
SET price = price * 1.1,
    updated_at = NOW()
WHERE category = 'electronics'
/*!*/;
```

**Taille binlog** : ~200 bytes (juste la requÃªte)

### Avantages

#### 1. Fichiers binlog trÃ¨s compacts

```sql
-- Exemple : Mise Ã  jour massive
UPDATE users SET status = 'active' WHERE country = 'FR';
-- Affecte 1,000,000 de lignes

-- Binlog STATEMENT : ~100 bytes
-- Binlog ROW : ~50 MB (50 bytes Ã— 1M lignes)
```

**Ratio** : STATEMENT peut Ãªtre **500 Ã  1000Ã— plus compact** pour updates massifs.

#### 2. Moins d'I/O disque

```
Moins de donnÃ©es Ã©crites â†’ Moins d'I/O â†’ Meilleure performance
```

#### 3. LisibilitÃ© pour humains

```bash
# Binlog STATEMENT est directement lisible
mysqlbinlog mysql-bin.000123 | grep "UPDATE products"
# On voit la requÃªte SQL exacte
```

#### 4. RÃ©plication rÃ©seau plus rapide

```
Primary â†’ Replica
100 bytes transmis au lieu de 50 MB
```

### InconvÃ©nients et dangers

#### 1. Fonctions non-dÃ©terministes

**ProblÃ¨me critique** : Fonctions donnant rÃ©sultats diffÃ©rents Ã  chaque exÃ©cution.

```sql
-- Sur primary Ã  14:00:00
INSERT INTO logs (id, timestamp, random_val)
VALUES (1, NOW(), RAND());

-- Primary enregistre :
-- timestamp = '2025-12-13 14:00:00'
-- random_val = 0.73412

-- Sur replica rejouÃ©e Ã  14:00:05
-- timestamp = '2025-12-13 14:00:05'  âš ï¸ DIFFÃ‰RENT
-- random_val = 0.91267                âš ï¸ DIFFÃ‰RENT
```

**Fonctions problÃ©matiques** :

| Fonction | ProblÃ¨me | Exemple |
|----------|----------|---------|
| `NOW()` | Timestamp diffÃ©rent | Chaque exÃ©cution = temps diffÃ©rent |
| `CURDATE()` | Date peut changer | Minuit = changement de jour |
| `RAND()` | Valeur alÃ©atoire | Jamais la mÃªme |
| `UUID()` | ID unique | Chaque appel = UUID diffÃ©rent |
| `USER()` | Utilisateur courant | Peut diffÃ©rer sur replica |
| `LOAD_FILE()` | Contenu fichier | Fichier peut avoir changÃ© |

**RÃ©sultat** : **Divergence des donnÃ©es** entre primary et replicas !

#### 2. Triggers et procÃ©dures stockÃ©es

```sql
-- Trigger sur primary
CREATE TRIGGER audit_log
AFTER UPDATE ON products
FOR EACH ROW
INSERT INTO audit (action, timestamp, random_id)
VALUES ('UPDATE', NOW(), UUID());

-- ProblÃ¨me : NOW() et UUID() donnent valeurs diffÃ©rentes sur replica
```

#### 3. RequÃªtes avec LIMIT sans ORDER BY

```sql
-- Sur primary
DELETE FROM temp_data LIMIT 1000;

-- Sans ORDER BY : Ordre non garanti
-- Primary peut supprimer lignes 1-1000
-- Replica peut supprimer lignes 501-1500
-- â†’ DIVERGENCE !
```

**Avertissement MariaDB** :

```
[Warning] Unsafe statement written to the binary log using statement format
since BINLOG_FORMAT = STATEMENT. Statement is unsafe because it uses a
LIMIT clause. This is unsafe because the set of rows included cannot be
predicted.
```

#### 4. INSERT ... SELECT avec AUTO_INCREMENT

```sql
-- Sur primary
INSERT INTO target_table (name, created_at)
SELECT name, NOW() FROM source_table
WHERE status = 'active';

-- Ordre des lignes peut diffÃ©rer
-- AUTO_INCREMENT peut Ãªtre dÃ©calÃ© sur replica
```

### Cas d'usage lÃ©gitimes

STATEMENT reste pertinent dans certains cas **trÃ¨s spÃ©cifiques** :

1. **Data warehousing** : Imports massifs, pas de rÃ©plication temps rÃ©el
2. **Batch processing** : Scripts dÃ©terministes sans fonctions dangereuses
3. **Espace disque critique** : Environnement avec contraintes extrÃªmes
4. **Legacy** : Migration progressive depuis ancien systÃ¨me

âš ï¸ **Recommandation** : Ã‰viter STATEMENT en production moderne sauf cas trÃ¨s spÃ©cifique et maÃ®trisÃ©.

---

## Format ROW : Logging basÃ© lignes

### Principe de fonctionnement

Le format ROW enregistre les **changements ligne par ligne** (before/after).

```sql
-- RequÃªte exÃ©cutÃ©e
UPDATE products
SET price = 110.00, updated_at = '2025-12-13 14:30:00'
WHERE id IN (1, 2, 3);

-- Dans le binlog (ROW) - simplifiÃ©
### UPDATE `shop`.`products`
### WHERE
###   @1=1 /* id */
###   @2=100.00 /* price */
### SET
###   @2=110.00 /* price */
###   @3='2025-12-13 14:30:00' /* updated_at */

### UPDATE `shop`.`products`
### WHERE
###   @1=2 /* id */
###   @2=100.00 /* price */
### SET
###   @2=110.00 /* price */
###   @3='2025-12-13 14:30:00' /* updated_at */

### UPDATE `shop`.`products`
### WHERE
###   @1=3 /* id */
###   @2=100.00 /* price */
### SET
###   @2=110.00 /* price */
###   @3='2025-12-13 14:30:00' /* updated_at */
```

**Taille binlog** : ~300 bytes (3 lignes Ã— ~100 bytes)

### Avantages

#### 1. DÃ©terminisme total

```sql
-- NOW(), RAND(), UUID() ne posent AUCUN problÃ¨me
UPDATE logs SET timestamp = NOW(), random_id = UUID();

-- Binlog ROW enregistre les VALEURS rÃ©elles :
### SET
###   @2='2025-12-13 14:30:00.123456' /* timestamp */
###   @3='f47ac10b-58cc-4372-a567-0e02b2c3d479' /* random_id */

-- Sur replica : Valeurs EXACTEMENT identiques âœ…
```

#### 2. RÃ©plication fiable

```
Primary et replicas garantis identiques Ã  100%
Aucun risque de divergence
```

#### 3. Point-in-Time Recovery prÃ©cis

```bash
# Voir exactement quelles donnÃ©es ont changÃ©
mysqlbinlog --base64-output=DECODE-ROWS -v mysql-bin.000123

# RÃ©sultat : Avant/AprÃ¨s pour chaque ligne
# Permet recovery chirurgical
```

#### 4. Change Data Capture (CDC) facile

```sql
-- Applications comme Debezium peuvent :
-- 1. Lire binlog ROW
-- 2. DÃ©tecter chaque changement de ligne
-- 3. Streamer vers Kafka/autres systÃ¨mes
```

#### 5. Audit prÃ©cis

```bash
# Identifier exactement quelle ligne a Ã©tÃ© modifiÃ©e
mysqlbinlog -v mysql-bin.000123 | grep "id.*42"
# Voir : OLD values â†’ NEW values
```

#### 6. Triggers et procÃ©dures sÃ»rs

```sql
-- Triggers avec NOW(), UUID() : Aucun problÃ¨me
-- Les valeurs rÃ©elles sont loggÃ©es
```

### InconvÃ©nients

#### 1. Fichiers binlog plus volumineux

```sql
-- UPDATE massif
UPDATE users SET last_login = NOW() WHERE active = 1;
-- Affecte 10,000,000 lignes

-- Binlog STATEMENT : ~100 bytes
-- Binlog ROW : ~500 MB (50 bytes Ã— 10M lignes)
```

#### 2. Plus d'I/O disque

```
Plus de donnÃ©es â†’ Plus d'I/O â†’ Impact performance
```

#### 3. RÃ©plication rÃ©seau plus lente

```
Primary â†’ Replica : Transfer de 500 MB au lieu de 100 bytes
```

#### 4. Moins lisible pour humains

```bash
# Binlog ROW en format base64
mysqlbinlog mysql-bin.000123
# Difficilement lisible sans -v --base64-output=DECODE-ROWS
```

### Optimisation : binlog_row_image

**Solution** : RÃ©duire la taille des Ã©vÃ©nements ROW

```ini
[mysqld]
binlog_format = ROW
binlog_row_image = MINIMAL  # â­ ClÃ© de l'optimisation
```

#### Options binlog_row_image

| Valeur | Colonnes loggÃ©es | Taille | Use case |
|--------|------------------|--------|----------|
| **FULL** | Toutes les colonnes | Grande | Maximum compatibilitÃ© |
| **MINIMAL** | Colonnes modifiÃ©es + clÃ©s | **Optimale** | Production recommandÃ© |
| **NOBLOB** | Tout sauf BLOB/TEXT | Moyenne | Si peu de BLOBs |

#### Exemple MINIMAL vs FULL

```sql
-- Table avec 50 colonnes
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    description TEXT,
    price DECIMAL(10,2),
    -- ... 46 autres colonnes
);

-- UPDATE d'une seule colonne
UPDATE products SET price = 99.99 WHERE id = 123;

-- Binlog FULL : Log 50 colonnes (~2 KB)
-- Binlog MINIMAL : Log id + price (~100 bytes)
-- Ratio : 20Ã— plus compact !
```

**Recommandation production** :

```ini
[mysqld]
binlog_format = ROW
binlog_row_image = MINIMAL
```

**Gain** : RÃ©duction typique de **40-60%** de la taille des binlogs.

### Cas d'usage

ROW est le format **standard moderne** pour :

1. âœ… **Toute production avec rÃ©plication** (dÃ©terminisme critique)
2. âœ… **Point-in-Time Recovery** (prÃ©cision nÃ©cessaire)
3. âœ… **Change Data Capture** (streaming vers data lake, Kafka)
4. âœ… **Audit et compliance** (traÃ§abilitÃ© prÃ©cise)
5. âœ… **Applications avec triggers complexes**
6. âœ… **Multi-master** (Galera nÃ©cessite ROW)

ðŸ’¡ **Best practice** : Utiliser ROW par dÃ©faut sauf raison trÃ¨s spÃ©cifique.

---

## Format MIXED : Hybride intelligent

### Principe de fonctionnement

MIXED utilise STATEMENT par dÃ©faut et bascule automatiquement en ROW si nÃ©cessaire.

```sql
-- RequÃªte dÃ©terministe â†’ STATEMENT
UPDATE products SET active = 1 WHERE id = 42;
-- Binlog : UPDATE products SET active = 1 WHERE id = 42

-- RequÃªte non-dÃ©terministe â†’ ROW
UPDATE logs SET timestamp = NOW(), random_val = UUID();
-- Binlog : Format ROW avec valeurs exactes
```

### RÃ¨gles de basculement

MariaDB bascule en ROW dans ces cas :

1. **Fonctions non-dÃ©terministes** : NOW(), RAND(), UUID(), etc.
2. **UDF** (User Defined Functions) : Sauf si dÃ©clarÃ©e DETERMINISTIC
3. **LIMIT sans ORDER BY**
4. **INSERT DELAYED**
5. **Triggers complexes**
6. **Temporary tables** dans certains cas

### Avantages

#### 1. Ã‰quilibre taille/sÃ©curitÃ©

```sql
-- Cas 1 : UPDATE simple dÃ©terministe
UPDATE products SET active = 0 WHERE category = 'old';
-- STATEMENT : Compact âœ…

-- Cas 2 : INSERT avec NOW()
INSERT INTO events (name, created_at) VALUES ('login', NOW());
-- ROW : SÃ»r âœ…
```

#### 2. Optimisation automatique

```
MariaDB dÃ©cide du meilleur format
Pas besoin d'intervention manuelle
```

### InconvÃ©nients

#### 1. ComplexitÃ© accrue

```
Deux formats dans les mÃªmes binlogs
Parsing plus complexe pour CDC
```

#### 2. Comportement moins prÃ©visible

```
MÃªme requÃªte peut Ãªtre STATEMENT ou ROW selon contexte
Complique debugging
```

#### 3. Surprises possibles

```sql
-- Cette requÃªte peut Ãªtre STATEMENT ou ROW selon version, configuration
SELECT @var := COUNT(*) FROM table;
```

#### 4. CDC plus difficile

```
Outils de streaming (Debezium, etc.) doivent gÃ©rer deux formats
ComplexitÃ© supplÃ©mentaire
```

### Cas d'usage

MIXED peut Ãªtre pertinent pour :

1. **Migration progressive** : Transition STATEMENT â†’ ROW
2. **Environnement mixte** : Workload variÃ© (OLTP + batch)
3. **Contraintes espace** : Besoin compression mais avec sÃ©curitÃ©

âš ï¸ **Recommandation** : En 2025, prÃ©fÃ©rer **ROW** directement. MIXED ajoute de la complexitÃ© pour un gain marginal.

---

## Comparaison dÃ©taillÃ©e

### Tableau rÃ©capitulatif complet

| CritÃ¨re | STATEMENT | ROW | MIXED |
|---------|-----------|-----|-------|
| **Taille binlog** | â­â­â­â­â­ TrÃ¨s petit | â­â­ Grand | â­â­â­ Moyen |
| **DÃ©terminisme** | âŒ Non garanti | âœ… Total | âœ… Total |
| **Performance Ã©criture** | â­â­â­â­â­ Excellente | â­â­â­ Bonne | â­â­â­â­ TrÃ¨s bonne |
| **RÃ©plication fiable** | âŒ Risques | âœ… Garantie | âœ… Garantie |
| **CDC/Streaming** | â­ LimitÃ© | â­â­â­â­â­ Excellent | â­â­â­ Bon |
| **PITR prÃ©cision** | â­â­ Moyenne | â­â­â­â­â­ Maximale | â­â­â­â­ Haute |
| **LisibilitÃ©** | â­â­â­â­â­ Haute | â­â­ Basse | â­â­â­ Variable |
| **Audit** | â­â­ LimitÃ© | â­â­â­â­â­ Complet | â­â­â­â­ Bon |
| **ComplexitÃ©** | â­â­â­â­ Simple | â­â­â­â­ Simple | â­â­ Complexe |
| **Galera support** | âŒ Non supportÃ© | âœ… Requis | âš ï¸ Partiel |

### Impact sur la taille : Exemples rÃ©els

```sql
-- ScÃ©nario 1 : UPDATE massif
UPDATE users SET last_login = NOW() WHERE country = 'US';
-- Affecte 5,000,000 lignes

-- STATEMENT : 150 bytes
-- ROW (FULL) : ~250 MB
-- ROW (MINIMAL) : ~100 MB  â­ Avec optimization
-- MIXED : 150 bytes (dÃ©terministe, donc STATEMENT)

-- ScÃ©nario 2 : INSERT individuel avec UUID
INSERT INTO sessions (id, user_id, token)
VALUES (NULL, 42, UUID());

-- STATEMENT : 80 bytes (mais UUID diffÃ©rent sur replica âŒ)
-- ROW : 120 bytes (UUID correct partout âœ…)
-- MIXED : 120 bytes (bascule en ROW)

-- ScÃ©nario 3 : Batch INSERT dÃ©terministe
INSERT INTO products (name, price, active)
SELECT name, price, 1 FROM staging_products;
-- 100,000 lignes

-- STATEMENT : 100 bytes
-- ROW : ~10 MB
-- MIXED : 100 bytes
```

---

## Migration entre formats

### Changement de format en production

#### MÃ©thode 1 : Dynamique (session ou global)

```sql
-- VÃ©rifier format actuel
SELECT @@GLOBAL.binlog_format;
-- STATEMENT

-- Changer globalement (nouvelles sessions)
SET GLOBAL binlog_format = 'ROW';

-- Changer pour session courante uniquement
SET SESSION binlog_format = 'ROW';

-- Persister (MariaDB 10.5+)
SET PERSIST binlog_format = 'ROW';
```

âš ï¸ **Attention** : Changement GLOBAL n'affecte PAS les sessions existantes !

```sql
-- Session 1 (dÃ©jÃ  connectÃ©e)
SELECT @@SESSION.binlog_format;
-- STATEMENT (inchangÃ©)

-- Session 2 (nouvelle connexion aprÃ¨s SET GLOBAL)
SELECT @@SESSION.binlog_format;
-- ROW âœ…
```

#### MÃ©thode 2 : Configuration my.cnf (permanent)

```ini
# /etc/mysql/mariadb.conf.d/50-server.cnf

[mysqld]
# Ancienne valeur
# binlog_format = STATEMENT

# Nouvelle valeur
binlog_format = ROW
binlog_row_image = MINIMAL
```

RedÃ©marrage :

```bash
sudo systemctl restart mariadb
```

### ProcÃ©dure de migration sÃ©curisÃ©e

#### Ã‰tape 1 : Planification

```bash
# 1. Documenter la migration
cat > /var/log/mysql/migration-plan.md <<EOF
# Migration binlog_format : STATEMENT â†’ ROW

Date: 2025-12-13
DBA: John Doe
Ticket: OPS-5678

## Raison
- PrÃ©parer CDC avec Debezium
- AmÃ©liorer fiabilitÃ© rÃ©plication
- Standard moderne

## Impact attendu
- Taille binlog : +50-100%
- I/O disque : +10-20%
- Aucun downtime

## Rollback
SET GLOBAL binlog_format = 'STATEMENT';
EOF
```

#### Ã‰tape 2 : Test sur staging

```bash
# Sur staging
mysql -e "SET GLOBAL binlog_format = 'ROW';"

# Surveiller pendant 24h
# - Taille binlogs
# - Performance
# - RÃ©plication lag

# Mesurer
du -sh /var/log/mysql/mysql-bin.*
```

#### Ã‰tape 3 : Migration production

```sql
-- Pendant fenÃªtre de faible activitÃ©
SET GLOBAL binlog_format = 'ROW';

-- VÃ©rifier
SHOW VARIABLES LIKE 'binlog_format';

-- Nouveau binlog crÃ©Ã© avec nouveau format
FLUSH BINARY LOGS;

-- Confirmer
SHOW BINARY LOGS;
```

#### Ã‰tape 4 : Monitoring post-migration

```bash
#!/bin/bash
# monitor-post-migration.sh

echo "=== Post-Migration Monitoring ==="

# Taille binlogs (7 derniers jours)
echo "Binlog size (last 7 days):"
find /var/log/mysql -name "mysql-bin.*" -mtime -7 -exec du -sh {} \; | \
  awk '{sum+=$1} END {print sum "MB"}'

# VÃ©rifier format actif
echo "Current format:"
mysql -N -e "SELECT @@GLOBAL.binlog_format;"

# Surveiller rÃ©plication
echo "Replication status:"
mysql -e "SHOW SLAVE STATUS\G" | grep -E "(Seconds_Behind|Running)"
```

#### Ã‰tape 5 : Persister dans my.cnf

```bash
# Modifier my.cnf
sudo vim /etc/mysql/mariadb.conf.d/50-server.cnf
# binlog_format = ROW
# binlog_row_image = MINIMAL

# Valider syntaxe
mysqld --verbose --help >/dev/null 2>&1 && echo "Config OK"
```

### Rollback si problÃ¨me

```sql
-- Si problÃ¨me dÃ©tectÃ©, rollback immÃ©diat
SET GLOBAL binlog_format = 'STATEMENT';

-- Nouveau binlog avec ancien format
FLUSH BINARY LOGS;

-- VÃ©rifier
SHOW VARIABLES LIKE 'binlog_format';
-- STATEMENT (rollback rÃ©ussi)
```

---

## Cas particuliers et piÃ¨ges

### PiÃ¨ge 1 : STATEMENT avec fonctions non-dÃ©terministes

```sql
-- Configuration
SET binlog_format = STATEMENT;

-- RequÃªte
UPDATE users SET token = UUID(), updated_at = NOW() WHERE id = 42;

-- Warning dans error log
[Warning] Unsafe statement written to the binary log using statement
format since BINLOG_FORMAT = STATEMENT. Statement uses a non-transactional
storage engine, uses LIMIT, or uses any of the following functions:
UUID(), NOW(), etc.

-- ProblÃ¨me : Replica aura valeurs diffÃ©rentes âš ï¸
```

**Solution** :

```sql
SET binlog_format = ROW;  -- Force ROW
```

### PiÃ¨ge 2 : Temporary tables

```sql
-- STATEMENT
CREATE TEMPORARY TABLE tmp_data AS
SELECT * FROM large_table WHERE date > '2025-01-01';

-- ProblÃ¨me : Temp table non rÃ©pliquÃ©e
-- RequÃªtes suivantes utilisant tmp_data Ã©choueront sur replica
```

**Solution** : ROW ou Ã©viter temp tables dans workload rÃ©pliquÃ©.

### PiÃ¨ge 3 : Triggers avec effets de bord

```sql
-- Trigger avec INSERT dans autre table
CREATE TRIGGER audit_trigger
AFTER UPDATE ON products
FOR EACH ROW
INSERT INTO audit_log (changed_at, random_id)
VALUES (NOW(), UUID());

-- STATEMENT : NOW() et UUID() diffÃ©rents sur replica
-- ROW : Valeurs correctes partout âœ…
```

### PiÃ¨ge 4 : LOAD DATA avec STATEMENT

```sql
SET binlog_format = STATEMENT;

LOAD DATA INFILE '/tmp/data.csv' INTO TABLE products;

-- ProblÃ¨me : Fichier /tmp/data.csv peut ne pas exister sur replica
-- Ou contenir donnÃ©es diffÃ©rentes
```

**Solution** :

```sql
SET binlog_format = ROW;  -- Force ROW pour LOAD DATA
```

### PiÃ¨ge 5 : DELETE/UPDATE sans WHERE avec LIMIT

```sql
SET binlog_format = STATEMENT;

DELETE FROM temp_logs LIMIT 10000;

-- Sans ORDER BY : Ordre non garanti
-- Primary et replica peuvent supprimer lignes diffÃ©rentes âš ï¸
```

**Solution** :

```sql
-- Option 1 : Ajouter ORDER BY
DELETE FROM temp_logs ORDER BY id LIMIT 10000;

-- Option 2 : Utiliser ROW
SET binlog_format = ROW;
```

---

## Change Data Capture (CDC)

### CDC avec format ROW

**ROW** est optimal pour CDC car il fournit :

1. **Before image** : Valeurs avant modification
2. **After image** : Valeurs aprÃ¨s modification
3. **Ã‰vÃ©nements clairs** : INSERT, UPDATE, DELETE

#### Exemple avec Debezium

```yaml
# debezium-connector.yaml
apiVersion: kafka.strimzi.io/v1beta2
kind: KafkaConnector
metadata:
  name: mariadb-connector
spec:
  class: io.debezium.connector.mysql.MySqlConnector
  config:
    database.hostname: mariadb-primary
    database.port: 3306
    database.user: debezium
    database.password: secret
    database.server.id: 184054
    database.server.name: production

    # Lecture binlog ROW
    binlog.format: ROW  # âœ… Optimal

    # Tables Ã  capturer
    table.include.list: shop.products,shop.orders
```

**Ã‰vÃ©nement Kafka** (simplifiÃ©) :

```json
{
  "before": {
    "id": 123,
    "name": "Product A",
    "price": 99.99
  },
  "after": {
    "id": 123,
    "name": "Product A",
    "price": 109.99
  },
  "op": "u",  // UPDATE
  "ts_ms": 1702476600000
}
```

### CDC avec format STATEMENT

**STATEMENT** est trÃ¨s limitÃ© pour CDC :

```sql
-- Binlog STATEMENT
UPDATE products SET price = price * 1.1 WHERE category = 'electronics';

-- CDC tool voit :
-- "UPDATE products SET price = price * 1.1 WHERE category = 'electronics'"

-- ProblÃ¨me : Impossible de savoir :
-- - Quels produits ont Ã©tÃ© modifiÃ©s
-- - Anciennes valeurs de price
-- - Nouvelles valeurs de price
```

âš ï¸ **Limitation** : CDC impossible ou trÃ¨s limitÃ© avec STATEMENT.

---

## Performance et optimisation

### Benchmark des formats

```bash
#!/bin/bash
# benchmark-binlog-formats.sh

for FORMAT in STATEMENT ROW MIXED; do
    echo "=== Testing $FORMAT ==="

    # Configurer format
    mysql -e "SET GLOBAL binlog_format = '$FORMAT';"

    # Benchmark
    sysbench oltp_read_write \
        --mysql-host=localhost \
        --mysql-user=root \
        --mysql-db=test \
        --tables=10 \
        --table-size=100000 \
        --threads=16 \
        --time=60 \
        run | grep "transactions:"

    # Taille binlog gÃ©nÃ©rÃ©e
    SIZE=$(du -sh /var/log/mysql/mysql-bin.* | tail -1 | awk '{print $1}')
    echo "Binlog size: $SIZE"

    sleep 10
done
```

**RÃ©sultats typiques** :

```
STATEMENT : 10,000 TPS, 50 MB binlog
ROW (FULL) : 9,500 TPS, 800 MB binlog
ROW (MINIMAL) : 9,600 TPS, 400 MB binlog  â­ Sweet spot
MIXED : 9,800 TPS, 200 MB binlog
```

### Optimisations ROW

```ini
[mysqld]
# Format ROW optimisÃ©
binlog_format = ROW

# 1. MINIMAL = -50% taille
binlog_row_image = MINIMAL

# 2. Compression = -60% taille additionnelle
binlog_compress = ON

# 3. Cache appropriÃ©
binlog_cache_size = 128K  # Ajuster selon taille transactions

# RÃ©sultat : ROW presque aussi compact que STATEMENT
# Avec tous les avantages du dÃ©terminisme
```

---

## Bonnes pratiques

### 1. Utiliser ROW par dÃ©faut

```ini
[mysqld]
binlog_format = ROW
binlog_row_image = MINIMAL
```

**Raison** : Standard moderne, dÃ©terministe, compatible CDC.

### 2. STATEMENT uniquement si raison spÃ©cifique

```
Use cases lÃ©gitimes STATEMENT :
- Data warehouse sans rÃ©plication temps rÃ©el
- Batch processing dÃ©terministe pur
- Contraintes espace disque extrÃªmes
```

### 3. Ã‰viter MIXED en 2025

```
MIXED ajoute complexitÃ©
BÃ©nÃ©fice marginal vs ROW MINIMAL
```

### 4. Tester avant migration production

```bash
# Toujours tester sur staging
# Mesurer taille binlog, performance, rÃ©plication lag
```

### 5. Monitoring taille binlog

```sql
-- Surveiller croissance
SELECT
    DATE(FROM_UNIXTIME(file_modified_time)) AS day,
    ROUND(SUM(file_size)/1024/1024/1024, 2) AS size_gb
FROM information_schema.BINARY_LOG_FILES
GROUP BY day
ORDER BY day DESC;
```

### 6. Documentation du choix

```bash
# Documenter pourquoi format choisi
cat > /etc/mysql/binlog-format-rationale.md <<EOF
# Binlog Format: ROW

Raison : Production avec rÃ©plication + CDC Debezium
Date dÃ©cision : 2025-12-13
DBA : John Doe

Alternatives considÃ©rÃ©es :
- STATEMENT : RejetÃ© (non-dÃ©terministe)
- MIXED : RejetÃ© (complexitÃ© inutile)

Optimisations :
- binlog_row_image = MINIMAL (-50% taille)
- binlog_compress = ON (-60% additionnel)
EOF
```

---

## Checklist de dÃ©cision

### Choisir le format appropriÃ©

```
â˜ RÃ©plication active ?
   â””â”€ OUI â†’ ROW (obligatoire pour fiabilitÃ©)
   â””â”€ NON â†’ Peut considÃ©rer STATEMENT

â˜ Fonctions non-dÃ©terministes (NOW, UUID, RAND) ?
   â””â”€ OUI â†’ ROW (obligatoire)
   â””â”€ NON â†’ STATEMENT possible

â˜ Triggers complexes ?
   â””â”€ OUI â†’ ROW (recommandÃ©)
   â””â”€ NON â†’ STATEMENT possible

â˜ CDC / Streaming vers Kafka ?
   â””â”€ OUI â†’ ROW (obligatoire)
   â””â”€ NON â†’ Autres formats possibles

â˜ Galera Cluster ?
   â””â”€ OUI â†’ ROW (obligatoire)
   â””â”€ NON â†’ Autres formats possibles

â˜ Point-in-Time Recovery critique ?
   â””â”€ OUI â†’ ROW (prÃ©cision maximale)
   â””â”€ NON â†’ STATEMENT acceptable

â˜ Audit prÃ©cis requis ?
   â””â”€ OUI â†’ ROW (traÃ§abilitÃ© ligne par ligne)
   â””â”€ NON â†’ STATEMENT acceptable

â˜ Espace disque trÃ¨s limitÃ© ?
   â””â”€ OUI â†’ STATEMENT ou ROW MINIMAL + compress
   â””â”€ NON â†’ ROW sans hÃ©sitation
```

**RÃ©sultat** : Dans 95% des cas â†’ **ROW avec MINIMAL**

---

## âœ… Points clÃ©s Ã  retenir

- **ROW = Standard moderne** : DÃ©terministe, fiable, compatible CDC
- **STATEMENT = Legacy** : Compact mais risquÃ© (non-dÃ©terministe)
- **MIXED = ComplexitÃ©** : Peu de bÃ©nÃ©fice en 2025
- **binlog_row_image = MINIMAL** : Optimisation clÃ© (-50% taille ROW)
- **Compression** : Combiner avec ROW pour compacitÃ© (-60% additionnel)
- **Galera requiert ROW** : Pas de choix en multi-master
- **CDC optimal avec ROW** : Before/After images complÃ¨tes
- **Migration simple** : SET GLOBAL + FLUSH BINARY LOGS
- **Tester avant prod** : Mesurer impact taille/performance
- **Documenter choix** : Rationale pour futures dÃ©cisions

---

## ðŸ”— Ressources et rÃ©fÃ©rences

- [ðŸ“– Documentation officielle : Binary Log Formats](https://mariadb.com/kb/en/binary-log-formats/)
- [ðŸ“– Documentation officielle : binlog_format](https://mariadb.com/kb/en/replication-and-binary-log-system-variables/#binlog_format)
- [ðŸ“– Documentation officielle : binlog_row_image](https://mariadb.com/kb/en/replication-and-binary-log-system-variables/#binlog_row_image)
- [ðŸ“– Unsafe Statements for Statement-Based Replication](https://mariadb.com/kb/en/unsafe-statements-for-statement-based-replication/)
- [Blog : Why ROW format is the modern standard](https://mariadb.org/binlog-row-format-best-practice/)
- [Debezium MariaDB Connector](https://debezium.io/documentation/reference/stable/connectors/mysql.html)

---

## âž¡ï¸ Section suivante

**11.6 - Maintenance des tables** : Commandes OPTIMIZE, ANALYZE, CHECK, REPAIR pour maintenir la santÃ© et les performances des tables, stratÃ©gies de maintenance prÃ©ventive et automatisation.

â­ï¸ [Purge et rotation](/11-administration-configuration/05.3-purge-rotation.md)
