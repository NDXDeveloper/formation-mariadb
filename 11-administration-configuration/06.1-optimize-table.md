ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 11.6.1 OPTIMIZE TABLE

> **Niveau** : AvancÃ© (DBA/Administrateur SystÃ¨me)  
> **DurÃ©e estimÃ©e** : 1.5 heures  
> **PrÃ©requis** : Administration MariaDB, concepts InnoDB, gestion de l'espace disque

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre le principe de fragmentation et son impact
- Utiliser OPTIMIZE TABLE efficacement selon le moteur de stockage
- Identifier quand optimiser une table est nÃ©cessaire
- Mesurer l'impact et le bÃ©nÃ©fice de l'optimisation
- ImplÃ©menter des stratÃ©gies d'optimisation automatisÃ©es
- GÃ©rer l'impact sur la disponibilitÃ© et les performances
- Choisir entre OPTIMIZE TABLE et ses alternatives
- Appliquer les bonnes pratiques de maintenance

---

## Introduction

### Qu'est-ce que la fragmentation ?

La **fragmentation** est la dispersion des donnÃ©es d'une table sur le disque, causant :

- ğŸ“‰ **Performances dÃ©gradÃ©es** : Lectures/Ã©critures plus lentes
- ğŸ’¾ **Gaspillage d'espace** : Espace inutilisÃ© dans les pages de donnÃ©es
- ğŸŒ **Full table scans lents** : Plus de pages Ã  lire
- ğŸ“Š **Index inefficaces** : Index fragmentÃ©s Ã©galement

**Causes principales** :

```sql
-- DELETE : Laisse des "trous" dans les pages
DELETE FROM logs WHERE created_at < '2024-01-01';
-- 1,000,000 lignes supprimÃ©es â†’ Espace non rÃ©cupÃ©rÃ© immÃ©diatement

-- UPDATE : Peut dÃ©placer lignes si taille change
UPDATE articles SET content = CONCAT(content, '...long text...');
-- Lignes ne tiennent plus dans pages originales

-- INSERT aprÃ¨s DELETE : Remplit partiellement les trous
INSERT INTO logs (message) VALUES ('new log');
-- Fragmentation continue
```

### OPTIMIZE TABLE : Objectif

**OPTIMIZE TABLE** rÃ©organise physiquement les donnÃ©es pour :

- âœ… RÃ©cupÃ©rer l'espace disque inutilisÃ©
- âœ… DÃ©fragmenter la table (pages contiguÃ«s)
- âœ… Reconstruire les index
- âœ… Mettre Ã  jour les statistiques de table
- âœ… AmÃ©liorer les performances de lecture

---

## Fonctionnement par moteur de stockage

### InnoDB (moteur principal)

#### Comportement par dÃ©faut

```sql
OPTIMIZE TABLE users;

-- En rÃ©alitÃ©, MariaDB exÃ©cute :
-- ALTER TABLE users ENGINE=InnoDB;
```

**Ce qui se passe** :

1. **CrÃ©ation table temporaire** : Nouvelle table avec structure identique
2. **Copie des donnÃ©es** : Ligne par ligne dans la nouvelle table
3. **Reconstruction index** : Tous les index recrÃ©Ã©s
4. **Swap atomique** : Ancienne table â†’ nouvelle table
5. **Suppression ancienne** : LibÃ©ration espace disque

**ConsÃ©quences** :

```
Espace requis : ~2Ã— taille de la table (temporaire)
Temps : Proportionnel Ã  la taille de la table
Locks : Table verrouillÃ©e en lecture/Ã©criture (sauf avec ALGORITHM=INPLACE)
Performance : Impact significatif pendant l'opÃ©ration
```

#### Options InnoDB

```sql
-- Option 1 : DÃ©faut (recrÃ©ation complÃ¨te)
OPTIMIZE TABLE products;

-- Option 2 : ONLINE (MariaDB 10.3+)
-- Permet lectures mais pas Ã©critures concurrentes
ALTER TABLE products ENGINE=InnoDB, ALGORITHM=INPLACE, LOCK=SHARED;

-- Option 3 : NO_WRITE_TO_BINLOG (pas de rÃ©plication)
OPTIMIZE NO_WRITE_TO_BINLOG TABLE products;

-- Option 4 : LOCAL (alias de NO_WRITE_TO_BINLOG)
OPTIMIZE LOCAL TABLE products;
```

### MyISAM (legacy)

```sql
OPTIMIZE TABLE old_myisam_table;
```

**Fonctionnement MyISAM** :

1. **Trie les donnÃ©es** physiquement
2. **DÃ©fragmente** les fichiers .MYD (donnÃ©es) et .MYI (index)
3. **Met Ã  jour** les statistiques
4. **Plus rapide** qu'InnoDB car manipulation directe fichiers

âš ï¸ **Lock table** : Table complÃ¨tement verrouillÃ©e (lecture + Ã©criture)

ğŸ’¡ **Note** : MyISAM est obsolÃ¨te. Migration vers InnoDB recommandÃ©e.

### Aria (MariaDB-specific)

```sql
OPTIMIZE TABLE aria_table;
```

**Similaire Ã  MyISAM** :
- DÃ©fragmentation fichiers
- Lock table complet
- Mise Ã  jour statistiques

---

## Syntaxe et options

### Syntaxe de base

```sql
-- Optimiser une table
OPTIMIZE TABLE table_name;

-- Optimiser plusieurs tables
OPTIMIZE TABLE table1, table2, table3;

-- Avec options
OPTIMIZE [NO_WRITE_TO_BINLOG | LOCAL] TABLE table_name;
```

### Options disponibles

| Option | Description | Use case |
|--------|-------------|----------|
| **NO_WRITE_TO_BINLOG** | Ne pas logger dans binlog | Ã‰viter rÃ©plication |
| **LOCAL** | Alias de NO_WRITE_TO_BINLOG | MÃªme usage |
| Aucune | Standard (rÃ©pliquÃ©) | Production normale |

### Exemples pratiques

```sql
-- Exemple 1 : Table standard
OPTIMIZE TABLE orders;

-- RÃ©sultat :
+----------------+----------+----------+----------+
| Table          | Op       | Msg_type | Msg_text |
+----------------+----------+----------+----------+
| shop.orders    | optimize | status   | OK       |
+----------------+----------+----------+----------+

-- Exemple 2 : Table partitionnÃ©e (optimiser une partition)
ALTER TABLE logs_partitioned OPTIMIZE PARTITION p202512;

-- Exemple 3 : Ne pas rÃ©pliquer (maintenance locale uniquement)
OPTIMIZE NO_WRITE_TO_BINLOG TABLE temp_calculations;
```

---

## DÃ©tection de la fragmentation

### MÃ©triques de fragmentation

```sql
-- VÃ©rifier fragmentation d'une table
SELECT 
    table_name,
    engine,
    ROUND(data_length / 1024 / 1024, 2) AS data_mb,
    ROUND(index_length / 1024 / 1024, 2) AS index_mb,
    ROUND(data_free / 1024 / 1024, 2) AS free_mb,
    ROUND(data_free / data_length * 100, 2) AS fragmentation_pct
FROM information_schema.TABLES
WHERE table_schema = 'mydb'
  AND table_name = 'users';

-- RÃ©sultat :
+------------+--------+---------+----------+---------+-------------------+
| table_name | engine | data_mb | index_mb | free_mb | fragmentation_pct |
+------------+--------+---------+----------+---------+-------------------+
| users      | InnoDB | 1234.56 | 234.78   | 123.45  | 10.00             |
+------------+--------+---------+----------+---------+-------------------+
```

**InterprÃ©tation** :

```
fragmentation_pct < 5%   : âœ… Excellent, pas besoin d'optimiser
fragmentation_pct 5-10%  : âš ï¸  Surveiller
fragmentation_pct 10-20% : âš ï¸  Optimisation recommandÃ©e
fragmentation_pct > 20%  : ğŸ”´ Optimisation urgente
```

### Identifier tables Ã  optimiser

```sql
-- Top 10 tables les plus fragmentÃ©es
SELECT 
    table_schema,
    table_name,
    engine,
    ROUND(data_length / 1024 / 1024, 2) AS data_mb,
    ROUND(data_free / 1024 / 1024, 2) AS free_mb,
    ROUND(data_free / data_length * 100, 2) AS fragmentation_pct
FROM information_schema.TABLES
WHERE table_schema NOT IN ('information_schema', 'mysql', 'performance_schema', 'sys')
  AND data_free > 0
  AND engine = 'InnoDB'
ORDER BY fragmentation_pct DESC
LIMIT 10;

-- RÃ©sultat :
+--------------+-------------------+--------+---------+---------+-------------------+
| table_schema | table_name        | engine | data_mb | free_mb | fragmentation_pct |
+--------------+-------------------+--------+---------+---------+-------------------+
| ecommerce    | order_history     | InnoDB | 5678.90 | 1234.56 | 21.74             |
| logs         | application_logs  | InnoDB | 3456.78 | 567.89  | 16.42             |
| analytics    | events            | InnoDB | 2345.67 | 345.67  | 14.73             |
+--------------+-------------------+--------+---------+---------+-------------------+
```

### Script de dÃ©tection automatique

```bash
#!/bin/bash
# detect-fragmented-tables.sh

THRESHOLD=10  # Seuil de fragmentation en %
MYSQL_USER="monitoring"
MYSQL_PASS="password"

mysql -u$MYSQL_USER -p$MYSQL_PASS -N -e "
SELECT 
    CONCAT(table_schema, '.', table_name) AS full_table_name,
    ROUND(data_free / data_length * 100, 2) AS fragmentation_pct,
    ROUND(data_free / 1024 / 1024, 2) AS free_mb
FROM information_schema.TABLES
WHERE table_schema NOT IN ('information_schema', 'mysql', 'performance_schema', 'sys')
  AND data_free > 0
  AND engine = 'InnoDB'
  AND data_free / data_length * 100 > $THRESHOLD
ORDER BY fragmentation_pct DESC
" | while read TABLE FRAG FREE_MB; do
    echo "âš ï¸  $TABLE : ${FRAG}% fragmented (${FREE_MB} MB free)"
done
```

---

## Impact et considÃ©rations

### Impact sur les performances

#### Pendant OPTIMIZE TABLE

```
CPU : ğŸ“ˆ Ã‰levÃ© (reconstruction index, copie donnÃ©es)
I/O : ğŸ“ˆ TrÃ¨s Ã©levÃ© (lecture ancienne table + Ã©criture nouvelle)
RAM : ğŸ“ˆ Ã‰levÃ© (buffer pool, sort buffer)
Locks : ğŸ”’ Table verrouillÃ©e (lectures/Ã©critures bloquÃ©es)
```

**Mesure de l'impact** :

```sql
-- Avant optimisation
SELECT COUNT(*) FROM information_schema.PROCESSLIST 
WHERE State LIKE '%Waiting for table%';

-- Pendant optimisation
-- Threads en attente : 50+ âš ï¸

-- AprÃ¨s optimisation
-- Threads en attente : 0 âœ…
```

#### AprÃ¨s OPTIMIZE TABLE

```
Lectures : ğŸ“ˆ Plus rapides (donnÃ©es contiguÃ«s)
Ã‰critures : ğŸ“ˆ Plus rapides (moins de fragmentation)
Full scans : ğŸ“ˆ Significativement plus rapides
Index scans : ğŸ“ˆ Plus efficaces
```

### Temps d'exÃ©cution

```
Table 1 GB   : ~2-5 minutes
Table 10 GB  : ~20-50 minutes
Table 100 GB : ~3-8 heures
Table 1 TB   : ~1-2 jours
```

**Facteurs influenÃ§ant** :

- Taille de la table
- Nombre d'index
- Performance du disque (HDD vs SSD)
- Charge serveur
- Configuration InnoDB (buffer pool, etc.)

### Espace disque requis

```sql
-- Estimer espace nÃ©cessaire
SELECT 
    table_name,
    ROUND((data_length + index_length) / 1024 / 1024 / 1024, 2) AS total_gb,
    ROUND((data_length + index_length) * 2 / 1024 / 1024 / 1024, 2) AS required_gb
FROM information_schema.TABLES
WHERE table_schema = 'ecommerce'
  AND table_name = 'orders';

-- RÃ©sultat :
+------------+----------+-------------+
| table_name | total_gb | required_gb |
+------------+----------+-------------+
| orders     | 123.45   | 246.90      | â† Besoin de 247 GB libres
+------------+----------+-------------+
```

âš ï¸ **Important** : OPTIMIZE TABLE nÃ©cessite ~2Ã— l'espace de la table.

---

## Quand optimiser ?

### Indicateurs d'optimisation nÃ©cessaire

```
âœ… Fragmentation > 10%
âœ… Nombreux DELETE/UPDATE sur table
âœ… Performance dÃ©gradÃ©e (queries plus lentes)
âœ… Espace disque non rÃ©cupÃ©rÃ© aprÃ¨s purge
âœ… AprÃ¨s migration/import massif de donnÃ©es
âœ… Maintenance prÃ©ventive planifiÃ©e
```

### Quand NE PAS optimiser

```
âŒ Table constamment modifiÃ©e (re-fragmentation immÃ©diate)
âŒ FenÃªtre de maintenance insuffisante
âŒ Espace disque insuffisant (< 2Ã— taille table)
âŒ Fragmentation < 5% (gain marginal)
âŒ Pendant heures de pointe
âŒ Sans backup rÃ©cent
```

### FrÃ©quence recommandÃ©e

| Type de table | FrÃ©quence | Justification |
|---------------|-----------|---------------|
| **TrÃ¨s volatile** (logs) | Hebdomadaire | Nombreux DELETE |
| **ModerÃ©ment active** | Mensuelle | Optimisation prÃ©ventive |
| **Stable** | Trimestrielle | Maintenance de routine |
| **Archive** (read-only) | Unique (aprÃ¨s chargement) | Pas de modification |
| **Temporaires** | Jamais | Ã‰phÃ©mÃ¨res |

---

## Alternatives Ã  OPTIMIZE TABLE

### ALTER TABLE ... ENGINE=InnoDB

```sql
-- Ã‰quivalent Ã  OPTIMIZE TABLE
ALTER TABLE products ENGINE=InnoDB;

-- Avantages :
-- - Plus de contrÃ´le (ALGORITHM, LOCK)
-- - Options additionnelles possibles

-- Avec options
ALTER TABLE products 
    ENGINE=InnoDB,
    ALGORITHM=INPLACE,  -- Ou COPY
    LOCK=SHARED;        -- Permet lectures
```

### ALTER TABLE ... FORCE

```sql
-- Reconstruire table (MariaDB 10.4+)
ALTER TABLE products FORCE;

-- Ã‰quivalent Ã  ALTER TABLE ... ENGINE=InnoDB
-- Mais syntaxe plus claire
```

### Rebuild en ligne (pt-online-schema-change)

```bash
# Percona Toolkit : Rebuild sans bloquer table
pt-online-schema-change \
    --alter "ENGINE=InnoDB" \
    D=mydb,t=products \
    --execute

# Avantages :
# - Table reste accessible (lectures/Ã©critures)
# - Pas de downtime
# - ContrÃ´le granulaire
```

### Partitionnement (prÃ©vention)

```sql
-- CrÃ©er table partitionnÃ©e par date
CREATE TABLE logs (
    id BIGINT AUTO_INCREMENT,
    message TEXT,
    created_at DATETIME,
    PRIMARY KEY (id, created_at)
)
PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION pmax VALUES LESS THAN MAXVALUE
);

-- Optimiser seulement partition affectÃ©e
ALTER TABLE logs OPTIMIZE PARTITION p2024;

-- Ou drop partition ancienne (plus rapide)
ALTER TABLE logs DROP PARTITION p2023;
```

---

## Automatisation

### Script d'optimisation automatisÃ©e

```bash
#!/bin/bash
# auto-optimize-tables.sh

MYSQL_USER="admin"
MYSQL_PASS="password"
MYSQL_DB="ecommerce"
FRAG_THRESHOLD=10  # Optimiser si fragmentation > 10%
LOG_FILE="/var/log/mysql/optimize-$(date +%Y%m%d).log"

echo "=== Auto-Optimize Tables - $(date) ===" | tee -a $LOG_FILE

# Trouver tables Ã  optimiser
mysql -u$MYSQL_USER -p$MYSQL_PASS -N -e "
SELECT table_name
FROM information_schema.TABLES
WHERE table_schema = '$MYSQL_DB'
  AND engine = 'InnoDB'
  AND data_free > 0
  AND data_free / data_length * 100 > $FRAG_THRESHOLD
ORDER BY data_free / data_length DESC
" | while read TABLE; do
    
    echo "Optimizing $MYSQL_DB.$TABLE..." | tee -a $LOG_FILE
    
    # VÃ©rifier espace disque disponible
    TABLE_SIZE=$(mysql -u$MYSQL_USER -p$MYSQL_PASS -N -e "
        SELECT ROUND((data_length + index_length) / 1024 / 1024 / 1024, 2)
        FROM information_schema.TABLES
        WHERE table_schema = '$MYSQL_DB' AND table_name = '$TABLE'
    ")
    
    AVAILABLE_GB=$(df /var/lib/mysql | awk 'NR==2 {print int($4/1024/1024)}')
    REQUIRED_GB=$(echo "$TABLE_SIZE * 2" | bc)
    
    if (( $(echo "$AVAILABLE_GB < $REQUIRED_GB" | bc -l) )); then
        echo "âš ï¸  Insufficient disk space (need ${REQUIRED_GB}GB, have ${AVAILABLE_GB}GB)" | tee -a $LOG_FILE
        continue
    fi
    
    # Optimiser
    START_TIME=$(date +%s)
    
    mysql -u$MYSQL_USER -p$MYSQL_PASS -e "OPTIMIZE TABLE $MYSQL_DB.$TABLE" >> $LOG_FILE 2>&1
    
    END_TIME=$(date +%s)
    DURATION=$((END_TIME - START_TIME))
    
    echo "âœ“ Completed in ${DURATION}s" | tee -a $LOG_FILE
    echo "" | tee -a $LOG_FILE
    
done

echo "=== Optimization Complete ===" | tee -a $LOG_FILE
```

### Cron scheduling

```bash
# /etc/cron.d/mysql-optimize

# Optimisation hebdomadaire (dimanche 2h00)
0 2 * * 0 mysql /usr/local/bin/auto-optimize-tables.sh

# OU optimisation mensuelle (1er du mois 3h00)
0 3 1 * * mysql /usr/local/bin/auto-optimize-tables.sh
```

### Optimisation progressive (pour grandes tables)

```bash
#!/bin/bash
# progressive-optimize.sh

# Pour table trÃ¨s volumineuse : optimiser partition par partition
TABLE="logs_partitioned"

# Lister partitions
mysql -N -e "
    SELECT PARTITION_NAME 
    FROM information_schema.PARTITIONS 
    WHERE TABLE_NAME = '$TABLE' 
      AND TABLE_SCHEMA = 'mydb'
    ORDER BY PARTITION_NAME
" | while read PARTITION; do
    
    echo "Optimizing partition $PARTITION..."
    
    mysql -e "ALTER TABLE mydb.$TABLE OPTIMIZE PARTITION $PARTITION"
    
    echo "Partition $PARTITION optimized"
    echo "Waiting 60 seconds before next partition..."
    sleep 60  # Pause entre partitions
    
done
```

---

## Monitoring et validation

### Mesurer le bÃ©nÃ©fice

```sql
-- AVANT optimisation
SELECT 
    table_name,
    ROUND((data_length + index_length) / 1024 / 1024, 2) AS total_mb,
    ROUND(data_free / 1024 / 1024, 2) AS free_mb,
    ROUND(data_free / data_length * 100, 2) AS frag_pct
FROM information_schema.TABLES
WHERE table_schema = 'mydb' AND table_name = 'orders';

-- RÃ©sultat AVANT :
+------------+----------+---------+----------+
| table_name | total_mb | free_mb | frag_pct |
+------------+----------+---------+----------+
| orders     | 1234.56  | 123.45  | 10.00    |
+------------+----------+---------+----------+

-- Optimiser
OPTIMIZE TABLE mydb.orders;

-- RÃ©sultat APRÃˆS :
+------------+----------+---------+----------+
| table_name | total_mb | free_mb | frag_pct |
+------------+----------+---------+----------+
| orders     | 1111.11  | 0.00    | 0.00     | â† 123 MB rÃ©cupÃ©rÃ©s âœ…
+------------+----------+---------+----------+
```

### Performance avant/aprÃ¨s

```bash
#!/bin/bash
# benchmark-optimize-impact.sh

TABLE="products"

echo "=== Benchmark Before Optimization ==="
mysql -e "SELECT BENCHMARK(10000, (SELECT COUNT(*) FROM $TABLE WHERE category = 'electronics'));"

# Note le temps

echo "=== Optimizing Table ==="
mysql -e "OPTIMIZE TABLE $TABLE;"

echo "=== Benchmark After Optimization ==="
mysql -e "SELECT BENCHMARK(10000, (SELECT COUNT(*) FROM $TABLE WHERE category = 'electronics'));"

# Comparer temps
```

### MÃ©triques Ã  suivre

```sql
-- CrÃ©ation vue de monitoring
CREATE OR REPLACE VIEW v_table_fragmentation AS
SELECT 
    table_schema,
    table_name,
    engine,
    table_rows,
    ROUND(data_length / 1024 / 1024, 2) AS data_mb,
    ROUND(index_length / 1024 / 1024, 2) AS index_mb,
    ROUND(data_free / 1024 / 1024, 2) AS free_mb,
    ROUND(data_free / (data_length + 0.0001) * 100, 2) AS frag_pct,
    update_time
FROM information_schema.TABLES
WHERE table_schema NOT IN ('information_schema', 'mysql', 'performance_schema', 'sys')
  AND engine = 'InnoDB'
ORDER BY frag_pct DESC;

-- Utilisation
SELECT * FROM v_table_fragmentation WHERE frag_pct > 10;
```

---

## Bonnes pratiques

### 1. Planifier pendant fenÃªtre de maintenance

```sql
-- âœ… BON : En dehors heures de pointe
-- Dimanche 2h00-6h00

-- âŒ MAUVAIS : Pendant heures de forte activitÃ©
-- Lundi 10h00 (rush heure)
```

### 2. VÃ©rifier espace disque disponible

```bash
# Avant optimisation
df -h /var/lib/mysql

# S'assurer d'avoir au moins 2Ã— la taille de la table
```

### 3. Backup avant optimisation

```bash
# Backup table avant optimize
mysqldump mydb orders > /backup/orders-before-optimize-$(date +%Y%m%d).sql

# Ou snapshot LVM si disponible
```

### 4. Utiliser NO_WRITE_TO_BINLOG si appropriÃ©

```sql
-- Si optimisation locale (pas de rÃ©plication)
OPTIMIZE NO_WRITE_TO_BINLOG TABLE temp_calculations;

-- Ã‰vite :
-- - Flood binlog
-- - RÃ©plication inutile sur replicas
```

### 5. Optimiser tables une par une

```bash
# âœ… BON : Une table Ã  la fois
OPTIMIZE TABLE table1;
# Attendre fin
OPTIMIZE TABLE table2;

# âŒ MAUVAIS : Toutes en mÃªme temps
OPTIMIZE TABLE table1, table2, table3, table4;
# Surcharge serveur
```

### 6. Monitorer pendant optimisation

```bash
# Terminal 1 : Lancer optimisation
mysql -e "OPTIMIZE TABLE large_table;"

# Terminal 2 : Monitorer
watch -n 5 'mysql -e "SHOW PROCESSLIST" | grep -i optimize'

# Terminal 3 : Surveiller I/O
iostat -x 5
```

### 7. PrÃ©fÃ©rer partitionnement pour tables massives

```sql
-- Au lieu d'optimiser table 1 TB entiÃ¨re
-- Partitionner et optimiser partition par partition
ALTER TABLE logs OPTIMIZE PARTITION p202512;
```

---

## Cas particuliers MariaDB 11.8

### InnoDB avec compression de page

```sql
-- Table avec compression
CREATE TABLE compressed_logs (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    message TEXT
) ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;

-- OPTIMIZE TABLE dÃ©compresse puis recompresse
OPTIMIZE TABLE compressed_logs;

-- Peut Ãªtre long, considÃ©rer alternatives
```

### Tables avec colonnes virtuelles

```sql
-- Table avec colonnes gÃ©nÃ©rÃ©es
CREATE TABLE products (
    id INT PRIMARY KEY,
    price DECIMAL(10,2),
    vat_rate DECIMAL(4,2),
    price_with_vat DECIMAL(10,2) AS (price * (1 + vat_rate)) STORED
);

-- OPTIMIZE TABLE recalcule colonnes STORED
OPTIMIZE TABLE products;
```

### Tables chiffrÃ©es (encryption)

```sql
-- Table chiffrÃ©e
CREATE TABLE sensitive_data (
    id INT PRIMARY KEY,
    ssn VARCHAR(11)
) ENCRYPTED=YES;

-- OPTIMIZE TABLE :
-- - DÃ©chiffre donnÃ©es
-- - Copie vers nouvelle table chiffrÃ©e
-- - Plus lent que table non chiffrÃ©e
OPTIMIZE TABLE sensitive_data;
```

---

## Troubleshooting

### ProblÃ¨me 1 : OPTIMIZE TABLE trop lent

```sql
-- SymptÃ´me
OPTIMIZE TABLE huge_table;
-- BloquÃ© pendant des heures

-- Solution 1 : Utiliser pt-online-schema-change
pt-online-schema-change --alter "ENGINE=InnoDB" D=mydb,t=huge_table --execute

-- Solution 2 : Partitionner puis optimiser par partition
-- Solution 3 : Optimiser pendant maintenance planifiÃ©e
```

### ProblÃ¨me 2 : Espace disque insuffisant

```bash
# SymptÃ´me
OPTIMIZE TABLE large_table;
# ERROR 1114 (HY000): The table is full

# VÃ©rifier espace
df -h /var/lib/mysql

# Solution 1 : LibÃ©rer espace (purger logs, tmp files)
# Solution 2 : Utiliser tmpdir sur partition avec plus d'espace
SET GLOBAL tmpdir = '/tmp/mysql-large';

# Solution 3 : Ã‰tendre partition
```

### ProblÃ¨me 3 : Locks excessifs

```sql
-- SymptÃ´me : Queries bloquÃ©es
SHOW PROCESSLIST;
-- Ã‰tat : Waiting for table metadata lock

-- Solution : Utiliser ALTER TABLE avec LOCK=SHARED
ALTER TABLE products ENGINE=InnoDB, LOCK=SHARED;

-- Ou pt-online-schema-change pour zÃ©ro downtime
```

### ProblÃ¨me 4 : Performance dÃ©gradÃ©e aprÃ¨s optimisation

```sql
-- SymptÃ´me : Queries plus lentes aprÃ¨s OPTIMIZE

-- Cause possible : Statistiques obsolÃ¨tes
-- Solution : Analyser table
ANALYZE TABLE products;

-- Ou recalculer statistiques persistentes
SET GLOBAL innodb_stats_persistent = ON;
ANALYZE TABLE products;
```

---

## Checklist opÃ©rationnelle

### Avant OPTIMIZE TABLE

- [ ] VÃ©rifier fragmentation (> 10% recommandÃ©)
- [ ] Estimer temps d'exÃ©cution
- [ ] VÃ©rifier espace disque disponible (2Ã— taille table)
- [ ] Backup rÃ©cent de la table
- [ ] FenÃªtre de maintenance planifiÃ©e
- [ ] Notification Ã©quipes si table critique
- [ ] Plan de rollback si problÃ¨me

### Pendant OPTIMIZE TABLE

- [ ] Monitorer processlist
- [ ] Surveiller I/O disque
- [ ] VÃ©rifier espace disque restant
- [ ] Confirmer pas de queries bloquÃ©es
- [ ] Logger dÃ©but/fin pour audit

### AprÃ¨s OPTIMIZE TABLE

- [ ] VÃ©rifier succÃ¨s (msg_type = status, msg_text = OK)
- [ ] Mesurer rÃ©duction fragmentation
- [ ] Calculer espace rÃ©cupÃ©rÃ©
- [ ] ANALYZE TABLE si nÃ©cessaire
- [ ] Tester performance (queries reprÃ©sentatives)
- [ ] Documenter rÃ©sultats

---

## âœ… Points clÃ©s Ã  retenir

- **Fragmentation > 10%** : Indicateur d'optimisation nÃ©cessaire
- **InnoDB = ALTER TABLE** : OPTIMIZE TABLE = reconstruction complÃ¨te
- **Espace requis** : ~2Ã— taille de la table
- **Impact significatif** : Table verrouillÃ©e, I/O Ã©levÃ©
- **FenÃªtre maintenance** : Planifier en dehors heures de pointe
- **Alternatives** : pt-online-schema-change pour zÃ©ro downtime
- **Partitionnement** : Optimiser partition par partition pour grandes tables
- **Monitoring** : Mesurer avant/aprÃ¨s pour valider bÃ©nÃ©fice
- **Automatisation** : Script avec vÃ©rifications (espace, fragmentation)
- **NO_WRITE_TO_BINLOG** : Ã‰viter rÃ©plication si appropriÃ©

---

## ğŸ”— Ressources et rÃ©fÃ©rences

- [ğŸ“– Documentation officielle : OPTIMIZE TABLE](https://mariadb.com/kb/en/optimize-table/)
- [ğŸ“– InnoDB Table Defragmentation](https://mariadb.com/kb/en/innodb-defragmentation/)
- [ğŸ“– Information Schema TABLES](https://mariadb.com/kb/en/information-schema-tables-table/)
- [ğŸ“– ALTER TABLE](https://mariadb.com/kb/en/alter-table/)
- [Percona Toolkit : pt-online-schema-change](https://docs.percona.com/percona-toolkit/pt-online-schema-change.html)
- [Blog : Table Maintenance Best Practices](https://mariadb.org/table-optimization/)

---

## â¡ï¸ Section suivante

**11.6.2 - ANALYZE TABLE** : Mise Ã  jour des statistiques de table pour l'optimiseur de requÃªtes, statistiques persistantes vs transitoires, et stratÃ©gies d'analyse automatisÃ©e.

â­ï¸ [ANALYZE TABLE](/11-administration-configuration/06.2-analyze-table.md)
