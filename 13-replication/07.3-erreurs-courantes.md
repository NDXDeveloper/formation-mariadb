üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.7.3 Erreurs courantes et r√©solution

> **Niveau** : Avanc√©  
> **Dur√©e estim√©e** : 3 heures  
> **Pr√©requis** : 
> - Section 13.7.1 (SHOW REPLICA STATUS)
> - Section 13.7.2 (Seconds_Behind_Master et lag)
> - Exp√©rience en troubleshooting de syst√®mes distribu√©s
> - Ma√Ætrise de SQL et des commandes syst√®me

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Identifier rapidement les erreurs de r√©plication via leurs codes
- Diagnostiquer les erreurs I/O thread et SQL thread
- R√©soudre les conflits de cl√©s, contraintes et transactions
- G√©rer les erreurs GTID et positions binlog
- Appliquer les proc√©dures de r√©cup√©ration appropri√©es
- Pr√©venir les erreurs courantes par la configuration
- Utiliser les outils de diagnostic avanc√©s
- Comprendre quand utiliser les solutions de contournement vs reconstruction

---

## Introduction

Les erreurs de r√©plication sont **in√©vitables** en production, m√™me avec une configuration optimale. Elles peuvent √™tre caus√©es par :

- **Probl√®mes r√©seau** : Perte de connexion, latence, firewall
- **Incoh√©rences de donn√©es** : √âcritures manuelles, cl√©s dupliqu√©es
- **Probl√®mes de configuration** : Permissions, SSL, filtrage
- **Binlog purg√©s** : Positions perdues, GTID manquants
- **Contraintes** : Foreign keys, triggers, validation
- **Ressources** : Espace disque plein, m√©moire insuffisante
- **Bugs** : Corruptions, incompatibilit√©s de versions

Cette section d√©taille les **20+ erreurs les plus courantes**, leur diagnostic et leur r√©solution **step-by-step**.

### Classification des erreurs

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     ERREURS DE R√âPLICATION          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ  I/O THREAD ERRORS         ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  (Connexion, r√©seau)       ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - 2003: Connection refused‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - 1236: Binlog not found  ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - 1045: Access denied     ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ  SQL THREAD ERRORS         ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  (Application donn√©es)     ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - 1062: Duplicate entry   ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - 1032: Can't find record ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - 1452: FK constraint     ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - 1146: Table not exists  ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ  GTID ERRORS               ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - GTID hole               ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - GTID not found          ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  - Out-of-order sequence   ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Diagnostic G√©n√©ral des Erreurs

### M√©thodologie de diagnostic

**√âtape 1 : V√©rifier l'√©tat de la r√©plication**

```sql
-- Commande principale de diagnostic
SHOW REPLICA STATUS\G

-- Champs critiques √† v√©rifier :
Slave_IO_Running: [Yes/No/Connecting]
Slave_SQL_Running: [Yes/No]
Last_Errno: [Code d'erreur]
Last_Error: [Message d'erreur]
Last_IO_Errno: [Code erreur I/O]
Last_IO_Error: [Message erreur I/O]
Last_SQL_Errno: [Code erreur SQL]
Last_SQL_Error: [Message erreur SQL]
```

**√âtape 2 : Identifier le type d'erreur**

```sql
-- Si Slave_IO_Running = No ‚Üí Erreur I/O thread
SELECT 
  Last_IO_Errno AS error_code,
  Last_IO_Error AS error_message
FROM information_schema.SLAVE_STATUS
WHERE Last_IO_Errno != 0;

-- Si Slave_SQL_Running = No ‚Üí Erreur SQL thread
SELECT 
  Last_SQL_Errno AS error_code,
  Last_SQL_Error AS error_message
FROM information_schema.SLAVE_STATUS
WHERE Last_SQL_Errno != 0;
```

**√âtape 3 : Consulter les logs**

```bash
# Error log MariaDB
sudo tail -f /var/log/mysql/error.log

# Logs syst√®me
sudo journalctl -u mariadb -f

# Slow query log (si SQL thread lent)
sudo tail -f /var/log/mysql/slow-query.log
```

**√âtape 4 : V√©rifier les ressources**

```bash
# Espace disque
df -h

# M√©moire
free -h

# Processus MariaDB
ps aux | grep mariadb

# I/O
iostat -x 1
```

---

## Erreurs I/O Thread

### Erreur 2003 : Connection Refused

**Sympt√¥mes** :

```sql
Slave_IO_Running: No
Last_IO_Errno: 2003
Last_IO_Error: Error connecting to master 'repl_user@192.168.1.100:3306' - 
  retry-time: 60  retries: 5  message: Can't connect to MySQL server on 
  '192.168.1.100' (111 Connection refused)
```

**Causes possibles** :
1. Primary arr√™t√© ou crash
2. Firewall bloque le port 3306
3. Primary √©coute sur localhost uniquement (bind-address)
4. Mauvaise IP/hostname dans configuration

**Diagnostic** :

```bash
# 1. V√©rifier que Primary est up
ping 192.168.1.100

# 2. Tester connexion TCP
telnet 192.168.1.100 3306
# ou
nc -zv 192.168.1.100 3306

# 3. V√©rifier firewall sur Primary
sudo iptables -L -n | grep 3306
# ou
sudo firewall-cmd --list-all

# 4. V√©rifier bind-address sur Primary
mariadb -h 192.168.1.100 -u root -p -e "SHOW VARIABLES LIKE 'bind_address'"
```

**Solutions** :

```bash
# Solution 1 : D√©marrer le Primary
sudo systemctl start mariadb

# Solution 2 : Ouvrir firewall sur Primary
sudo firewall-cmd --permanent --add-port=3306/tcp
sudo firewall-cmd --reload

# ou avec iptables
sudo iptables -I INPUT -p tcp --dport 3306 -j ACCEPT
sudo service iptables save

# Solution 3 : Modifier bind-address sur Primary
# my.cnf
[mariadb]
bind-address = 0.0.0.0  # √âcouter sur toutes les interfaces

# Red√©marrer Primary
sudo systemctl restart mariadb
```

**Solution 4 : Corriger la configuration de r√©plication**

```sql
-- Sur Replica : V√©rifier/corriger l'IP du Primary
STOP REPLICA;
CHANGE REPLICATION SOURCE TO
  SOURCE_HOST = '192.168.1.100',  -- IP correcte
  SOURCE_PORT = 3306;
START REPLICA;
```

---

### Erreur 1236 : Could Not Find First Log File

**Sympt√¥mes** :

```sql
Slave_IO_Running: No
Last_IO_Errno: 1236
Last_IO_Error: Got fatal error 1236 from master when reading data from binary log:
  'Could not find first log file name in binary log index file'
```

**Cause** : Le binlog demand√© a √©t√© **purg√©** sur le Primary.

**Diagnostic** :

```sql
-- Sur Replica : Position demand√©e
SHOW REPLICA STATUS\G
-- Master_Log_File: mariadb-bin.000010

-- Sur Primary : Binlogs disponibles
SHOW BINARY LOGS;
-- R√©sultat : mariadb-bin.000015 (le plus ancien)
--            mariadb-bin.000020 (le plus r√©cent)

-- Le binlog 000010 n'existe plus ‚Üí Erreur 1236
```

**Solutions** :

**Option 1 : Utiliser GTID pour repositionner (recommand√©)**

```sql
-- Si GTID activ√©
STOP REPLICA;
CHANGE REPLICATION SOURCE TO
  SOURCE_USE_GTID = current_pos;  -- Sauter au binlog actuel
START REPLICA;

-- V√©rifier
SHOW REPLICA STATUS\G
```

‚ö†Ô∏è **Risque** : Peut sauter des transactions si le Replica avait beaucoup de lag.

**Option 2 : Refaire un snapshot complet (recommand√© pour donn√©es critiques)**

```bash
# 1. Sur Primary : Dump avec position GTID
mariadb-dump \
  --single-transaction \
  --master-data=2 \
  --gtid \
  --all-databases \
  > full_backup.sql

# 2. Copier sur Replica
scp full_backup.sql replica:/tmp/

# 3. Sur Replica : Restaurer
mariadb < /tmp/full_backup.sql

# 4. Extraire la position GTID du dump
grep "SET GLOBAL gtid_slave_pos" /tmp/full_backup.sql
# SET GLOBAL gtid_slave_pos='0-1-5000';

# 5. Reconfigurer la r√©plication
mariadb <<EOF
SET GLOBAL gtid_slave_pos = '0-1-5000';
CHANGE REPLICATION SOURCE TO
  SOURCE_HOST = '192.168.1.100',
  SOURCE_USER = 'repl_user',
  SOURCE_PASSWORD = 'SecurePassword123!',
  SOURCE_USE_GTID = slave_pos;
START REPLICA;
EOF
```

**Option 3 : Augmenter la r√©tention binlog sur Primary (pr√©vention)**

```sql
-- Sur Primary : Conserver binlogs plus longtemps
SET GLOBAL binlog_expire_logs_seconds = 604800;  -- 7 jours au lieu de 3

-- Ou dans my.cnf
[mariadb]
binlog_expire_logs_seconds = 604800
```

---

### Erreur 1045 : Access Denied

**Sympt√¥mes** :

```sql
Slave_IO_Running: No
Last_IO_Errno: 1045
Last_IO_Error: Error connecting to master: 
  Access denied for user 'repl_user'@'192.168.1.101' (using password: YES)
```

**Causes possibles** :
1. Mot de passe incorrect
2. Utilisateur n'existe pas
3. Hostname/IP non autoris√©
4. Privil√®ges insuffisants

**Diagnostic** :

```sql
-- Sur Primary : V√©rifier l'utilisateur
SELECT User, Host FROM mysql.user WHERE User = 'repl_user';
-- R√©sultat attendu : repl_user | %

-- V√©rifier les privil√®ges
SHOW GRANTS FOR 'repl_user'@'%';
-- Doit avoir : GRANT REPLICATION SLAVE ON *.* TO `repl_user`@`%`

-- Tester connexion depuis Replica
mariadb -h 192.168.1.100 -u repl_user -p
```

**Solutions** :

```sql
-- Solution 1 : Cr√©er/recr√©er l'utilisateur sur Primary
DROP USER IF EXISTS 'repl_user'@'%';
CREATE USER 'repl_user'@'%' 
IDENTIFIED VIA ed25519 
USING PASSWORD('SecurePassword123!');

GRANT REPLICATION SLAVE ON *.* TO 'repl_user'@'%';
GRANT REPLICATION CLIENT ON *.* TO 'repl_user'@'%';  -- Optionnel
FLUSH PRIVILEGES;

-- Solution 2 : Corriger le mot de passe sur Replica
STOP REPLICA;
CHANGE REPLICATION SOURCE TO
  SOURCE_PASSWORD = 'SecurePassword123!';  -- Correct password
START REPLICA;
```

---

## Erreurs SQL Thread

### Erreur 1062 : Duplicate Entry

**Sympt√¥mes** :

```sql
Slave_SQL_Running: No
Last_SQL_Errno: 1062
Last_SQL_Error: Error 'Duplicate entry '123' for key 'PRIMARY'' on query. 
  Default database: 'production'. Query: 'INSERT INTO orders (id, user_id, amount) 
  VALUES (123, 456, 99.99)'
```

**Causes possibles** :
1. **√âcriture manuelle sur Replica** (super_read_only = OFF)
2. √âv√©nement binlog rejou√© (probl√®me de position)
3. Auto-increment d√©synchronis√©
4. Corruption de donn√©es

**Diagnostic** :

```sql
-- 1. V√©rifier si la ligne existe vraiment
SELECT * FROM orders WHERE id = 123;

-- 2. V√©rifier super_read_only
SHOW VARIABLES LIKE 'super_read_only';
-- Devrait √™tre ON

-- 3. V√©rifier l'historique des √©critures
SELECT * FROM information_schema.PROCESSLIST 
WHERE Command != 'Sleep' AND User != 'system user';

-- 4. Comparer avec Primary
-- Sur Primary :
SELECT * FROM orders WHERE id = 123;
```

**Solutions** :

**Option A : Supprimer la ligne conflictuelle (si donn√©es identiques)**

```sql
-- V√©rifier que les donn√©es sont identiques
-- Sur Replica :
SELECT * FROM orders WHERE id = 123;

-- Sur Primary :
SELECT * FROM orders WHERE id = 123;

-- Si identiques, supprimer sur Replica
DELETE FROM orders WHERE id = 123;

-- Red√©marrer SQL thread
START REPLICA SQL_THREAD;

-- V√©rifier
SHOW REPLICA STATUS\G
```

**Option B : Sauter l'√©v√©nement probl√©matique (DANGEREUX)**

```sql
-- Sans GTID
STOP REPLICA;
SET GLOBAL sql_slave_skip_counter = 1;  -- Sauter 1 √©v√©nement
START REPLICA;

-- Avec GTID
STOP REPLICA;
-- Incr√©menter manuellement la position GTID
SET GLOBAL gtid_slave_pos = '0-1-5001';  -- Position suivante
START REPLICA;
```

‚ö†Ô∏è **DANGER** : Cette m√©thode peut causer des **incoh√©rences de donn√©es**. √Ä n'utiliser qu'apr√®s analyse approfondie.

**Option C : Resynchronisation compl√®te (recommand√© pour donn√©es critiques)**

```bash
# 1. Dump du Primary
# 2. Restaurer sur Replica
# 3. Reconfigurer r√©plication
```

**Pr√©vention** :

```sql
-- Toujours activer super_read_only sur Replicas
SET GLOBAL super_read_only = ON;

-- Dans my.cnf
[mariadb]
super_read_only = ON
```

---

### Erreur 1032 : Can't Find Record

**Sympt√¥mes** :

```sql
Slave_SQL_Running: No
Last_SQL_Errno: 1032
Last_SQL_Error: Could not execute Update_rows event on table production.orders; 
  Can't find record in 'orders', Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND
```

**Causes possibles** :
1. Ligne supprim√©e manuellement sur Replica
2. DELETE ex√©cut√© sur Replica sans r√©plication
3. Filtrage de r√©plication incorrect
4. Corruption de donn√©es

**Diagnostic** :

```sql
-- 1. V√©rifier si la ligne existe sur Primary
-- Sur Primary :
SELECT * FROM orders WHERE id = 456;

-- Sur Replica :
SELECT * FROM orders WHERE id = 456;
-- R√©sultat : Vide (ligne manquante)

-- 2. V√©rifier le filtrage de r√©plication
SHOW REPLICA STATUS\G
-- Replicate_Do_DB
-- Replicate_Ignore_DB
-- Replicate_Wild_Ignore_Table
```

**Solutions** :

**Option A : Ins√©rer la ligne manquante depuis Primary**

```sql
-- 1. Sur Primary : Extraire les donn√©es
SELECT * FROM orders WHERE id = 456\G

-- 2. Sur Replica : Ins√©rer la ligne
INSERT INTO orders (id, user_id, amount, status, created_at)
VALUES (456, 789, 149.99, 'pending', '2025-12-10 14:30:00');

-- 3. Red√©marrer SQL thread
START REPLICA SQL_THREAD;
```

**Option B : Sauter l'√©v√©nement**

```sql
-- M√™me proc√©dure que pour erreur 1062
STOP REPLICA;
SET GLOBAL sql_slave_skip_counter = 1;
START REPLICA;
```

**Option C : Ignorer temporairement l'erreur 1032**

```sql
-- ‚ö†Ô∏è Temporaire uniquement pour debugging
SET GLOBAL slave_skip_errors = 1032;

-- Red√©marrer r√©plication
START REPLICA;

-- Apr√®s r√©solution, d√©sactiver
SET GLOBAL slave_skip_errors = OFF;
```

‚ö†Ô∏è **Ne jamais utiliser slave_skip_errors en production permanente** : Masque les probl√®mes au lieu de les r√©soudre.

---

### Erreur 1452 : Foreign Key Constraint

**Sympt√¥mes** :

```sql
Slave_SQL_Running: No
Last_SQL_Errno: 1452
Last_SQL_Error: Error 'Cannot add or update a child row: a foreign key constraint fails 
  (`production`.`order_items`, CONSTRAINT `fk_order_id` FOREIGN KEY (`order_id`) 
  REFERENCES `orders` (`id`))' on query
```

**Causes possibles** :
1. Ordre d'application des √©v√©nements incorrect
2. Parent row supprim√©e manuellement sur Replica
3. Filtrage de r√©plication partiel (r√©plique enfants mais pas parents)
4. Donn√©es incoh√©rentes

**Diagnostic** :

```sql
-- 1. V√©rifier la contrainte
SHOW CREATE TABLE order_items\G

-- 2. V√©rifier si parent existe
-- Sur Primary :
SELECT * FROM orders WHERE id = 123;

-- Sur Replica :
SELECT * FROM orders WHERE id = 123;
-- Si vide ‚Üí parent manquant

-- 3. V√©rifier le filtrage
SHOW REPLICA STATUS\G
-- V√©rifier que les deux tables sont r√©pliqu√©es
```

**Solutions** :

**Option A : Cr√©er le parent row manquant**

```sql
-- 1. Sur Primary : Extraire parent
SELECT * FROM orders WHERE id = 123\G

-- 2. Sur Replica : Ins√©rer parent
INSERT INTO orders (id, user_id, amount, status)
VALUES (123, 456, 99.99, 'completed');

-- 3. Red√©marrer SQL thread
START REPLICA SQL_THREAD;
```

**Option B : D√©sactiver temporairement les FK checks (TR√àS DANGEREUX)**

```sql
-- Sur Replica : D√©sactiver FK temporairement
SET GLOBAL foreign_key_checks = OFF;

-- Red√©marrer r√©plication
START REPLICA;

-- Attendre que l'√©v√©nement passe

-- IMPORTANT : R√©activer imm√©diatement
SET GLOBAL foreign_key_checks = ON;
```

‚ö†Ô∏è **Extr√™mement dangereux** : √Ä n'utiliser qu'en dernier recours et sous supervision DBA senior.

**Pr√©vention** :

```sql
-- Toujours r√©pliquer les tables li√©es ensemble
-- Ne jamais filtrer seulement les tables enfants
CHANGE REPLICATION SOURCE TO
  REPLICATE_WILD_DO_TABLE = 'production.%';  -- Toutes les tables
```

---

### Erreur 1146 : Table Doesn't Exist

**Sympt√¥mes** :

```sql
Slave_SQL_Running: No
Last_SQL_Errno: 1146
Last_SQL_Error: Error 'Table 'production.new_orders' doesn't exist' on query
```

**Causes possibles** :
1. Table cr√©√©e sur Primary mais pas sur Replica (filtrage)
2. DDL non r√©pliqu√©
3. Table supprim√©e manuellement sur Replica
4. Sch√©ma d√©synchronis√©

**Diagnostic** :

```sql
-- Sur Primary : V√©rifier que la table existe
SHOW TABLES FROM production LIKE 'new_orders';

-- Sur Replica : V√©rifier
SHOW TABLES FROM production LIKE 'new_orders';
-- R√©sultat : Vide

-- V√©rifier le filtrage DDL
SHOW REPLICA STATUS\G
-- Replicate_Do_DB
```

**Solutions** :

**Option A : Cr√©er la table depuis Primary**

```sql
-- 1. Sur Primary : Extraire le CREATE TABLE
SHOW CREATE TABLE production.new_orders\G

-- 2. Sur Replica : Cr√©er la table
CREATE TABLE production.new_orders (
  id INT PRIMARY KEY AUTO_INCREMENT,
  user_id INT NOT NULL,
  amount DECIMAL(10,2),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;

-- 3. Red√©marrer SQL thread
START REPLICA SQL_THREAD;
```

**Option B : Resynchronisation avec Mariabackup**

```bash
# Si beaucoup de tables manquantes, refaire snapshot complet
```

**Pr√©vention** :

```sql
-- Toujours r√©pliquer les DDL
-- Ne pas filtrer au niveau binlog sur Primary
-- Utiliser filtrage c√¥t√© Replica si n√©cessaire
```

---

## Erreurs GTID

### Erreur : GTID Position Not in Binlog

**Sympt√¥mes** :

```sql
Slave_IO_Running: No
Last_IO_Errno: 1236
Last_IO_Error: Got fatal error 1236 from master when reading data from binary log: 
  'The slave is connecting using GTID, it requested events starting with GTID 0-1-1000, 
  which is not in the master's binlog'
```

**Cause** : Binlog contenant le GTID demand√© a √©t√© purg√© sur Primary.

**Solution** :

```sql
-- Option 1 : Utiliser current_pos (perte de donn√©es possible)
STOP REPLICA;
CHANGE REPLICATION SOURCE TO SOURCE_USE_GTID = current_pos;
START REPLICA;

-- Option 2 : Refaire snapshot (recommand√©)
-- M√™me proc√©dure que erreur 1236 sans GTID
```

---

### Erreur : Out-of-Order GTID Sequence

**Sympt√¥mes** :

```sql
Slave_SQL_Running: No
Last_SQL_Errno: 1950
Last_SQL_Error: An attempt was made to binlog GTID 0-1-1500 
  which would create an out-of-order sequence number with existing GTID 0-1-1502
```

**Cause** : GTID saut√© dans la s√©quence (trou dans les GTID).

**Diagnostic** :

```sql
-- V√©rifier la position actuelle
SELECT @@gtid_slave_pos;
-- R√©sultat : 0-1-1502

-- L'√©v√©nement demande 0-1-1500 (plus ancien) ‚Üí Erreur
```

**Solution** :

```sql
-- Injecter un √©v√©nement vide pour combler le trou
SET gtid_domain_id = 0;
SET SESSION server_id = 1;
SET gtid_seq_no = 1500;  -- GTID manquant
BEGIN;
COMMIT;  -- Transaction vide

-- Red√©marrer r√©plication
START REPLICA SQL_THREAD;
```

---

### Erreur : Duplicate GTID

**Sympt√¥mes** :

```sql
Slave_SQL_Running: No
Last_SQL_Errno: 1950
Last_SQL_Error: Duplicate entry for GTID 0-1-1000
```

**Cause** : √âcriture manuelle sur Replica avec GTID activ√©.

**Solution** :

```sql
-- Option 1 : Activer ignore duplicates (temporaire)
SET GLOBAL gtid_ignore_duplicates = ON;
START REPLICA;
-- Attendre que le Replica rattrape
SET GLOBAL gtid_ignore_duplicates = OFF;

-- Option 2 : Resynchronisation compl√®te
```

**Pr√©vention** :

```sql
-- Toujours activer strict mode
SET GLOBAL gtid_strict_mode = ON;
SET GLOBAL super_read_only = ON;
```

---

## Erreurs de Ressources

### Erreur : Disk Full

**Sympt√¥mes** :

```bash
# Logs syst√®me
ERROR: Error writing file '/var/lib/mysql/relay-bin.000015' (Errcode: 28 - No space left on device)

Slave_IO_Running: No
Last_IO_Errno: 1595
Last_IO_Error: Relay log write failure
```

**Diagnostic** :

```bash
# V√©rifier espace disque
df -h /var/lib/mysql

# Identifier les gros fichiers
du -sh /var/lib/mysql/* | sort -h

# Taille des relay logs
mariadb -e "SELECT Relay_Log_Space / 1024 / 1024 / 1024 AS relay_log_gb FROM information_schema.SLAVE_STATUS"
```

**Solutions** :

```bash
# 1. Lib√©rer de l'espace
# Purger vieux binlogs sur Primary (si c'est le Primary)
mariadb -e "PURGE BINARY LOGS BEFORE NOW() - INTERVAL 3 DAY"

# 2. Purger relay logs sur Replica
mariadb <<EOF
STOP REPLICA;
RESET SLAVE;  -- Supprime relay logs
START REPLICA;
EOF

# 3. Augmenter la partition ou ajouter espace
# √âtendre LVM ou ajouter disque

# 4. Configurer limite relay log
mariadb -e "SET GLOBAL max_relay_log_size = 1073741824"  -- 1 GB
```

**Pr√©vention** :

```sql
-- Monitoring proactif de l'espace disque
-- Alertes √† 80% d'utilisation
```

---

## Proc√©dures de R√©cup√©ration Avanc√©es

### Proc√©dure 1 : Reset et Reconfiguration Compl√®te

Quand tout le reste √©choue, reset complet :

```sql
-- 1. Arr√™ter la r√©plication
STOP REPLICA;

-- 2. Reset complet
RESET REPLICA ALL;

-- 3. Dump du Primary
-- Sur Primary
mariadb-dump \
  --single-transaction \
  --master-data=2 \
  --gtid \
  --all-databases \
  > /backup/full_dump.sql

-- 4. Restaurer sur Replica
mariadb < /backup/full_dump.sql

-- 5. Extraire position GTID
grep "SET GLOBAL gtid_slave_pos" /backup/full_dump.sql
# SET GLOBAL gtid_slave_pos='0-1-10000';

-- 6. Reconfigurer
SET GLOBAL gtid_slave_pos = '0-1-10000';

CHANGE REPLICATION SOURCE TO
  SOURCE_HOST = '192.168.1.100',
  SOURCE_USER = 'repl_user',
  SOURCE_PASSWORD = 'SecurePassword123!',
  SOURCE_USE_GTID = slave_pos,
  SOURCE_SSL = 1;

START REPLICA;

-- 7. V√©rifier
SHOW REPLICA STATUS\G
```

### Proc√©dure 2 : Resynchronisation avec Mariabackup

Pour bases volumineuses :

```bash
# 1. Sur Primary : Backup physique
mariabackup --backup \
  --target-dir=/backup/full \
  --user=root \
  --password=RootPass

# 2. Pr√©parer le backup
mariabackup --prepare --target-dir=/backup/full

# 3. Extraire position GTID
cat /backup/full/xtrabackup_binlog_info
# mariadb-bin.000050  12345  0-1-10000

# 4. Sur Replica : Arr√™ter MariaDB
systemctl stop mariadb

# 5. Supprimer datadir
rm -rf /var/lib/mysql/*

# 6. Restaurer
mariabackup --copy-back --target-dir=/backup/full
chown -R mysql:mysql /var/lib/mysql

# 7. D√©marrer MariaDB
systemctl start mariadb

# 8. Configurer r√©plication
mariadb <<EOF
SET GLOBAL gtid_slave_pos = '0-1-10000';
CHANGE REPLICATION SOURCE TO
  SOURCE_HOST = '192.168.1.100',
  SOURCE_USER = 'repl_user',
  SOURCE_PASSWORD = 'SecurePassword123!',
  SOURCE_USE_GTID = slave_pos;
START REPLICA;
EOF
```

---

## Scripts de Troubleshooting

### Script 1 : Diagnostic Automatis√©

```bash
#!/bin/bash
# diagnose_replication.sh - Diagnostic complet de r√©plication

echo "=== DIAGNOSTIC R√âPLICATION MARIADB ==="
echo "Timestamp: $(date)"
echo ""

# 1. √âtat global
echo "=== √âTAT GLOBAL ==="
mariadb -e "SHOW REPLICA STATUS\G" | grep -E "Slave_IO_Running|Slave_SQL_Running|Seconds_Behind_Master|Using_Gtid"

# 2. Erreurs
echo ""
echo "=== ERREURS ==="
mariadb -e "SELECT Last_IO_Errno, Last_IO_Error, Last_SQL_Errno, Last_SQL_Error FROM information_schema.SLAVE_STATUS\G"

# 3. Positions
echo ""
echo "=== POSITIONS ==="
mariadb -e "SELECT Master_Log_File, Read_Master_Log_Pos, Exec_Master_Log_Pos, Gtid_IO_Pos, Gtid_Slave_Pos FROM information_schema.SLAVE_STATUS\G"

# 4. Ressources
echo ""
echo "=== RESSOURCES ==="
echo "Espace disque:"
df -h /var/lib/mysql
echo ""
echo "Relay log space:"
mariadb -e "SELECT Relay_Log_Space / 1024 / 1024 AS relay_log_mb FROM information_schema.SLAVE_STATUS"

# 5. R√©seau (si Primary connu)
PRIMARY_HOST=$(mariadb -N -e "SELECT Master_Host FROM information_schema.SLAVE_STATUS")
if [ -n "$PRIMARY_HOST" ]; then
  echo ""
  echo "=== CONNECTIVIT√â PRIMARY ($PRIMARY_HOST) ==="
  ping -c 3 $PRIMARY_HOST
  nc -zv $PRIMARY_HOST 3306 2>&1
fi

# 6. Processus
echo ""
echo "=== PROCESSUS R√âPLICATION ==="
mariadb -e "SELECT * FROM information_schema.PROCESSLIST WHERE User = 'system user'\G"

echo ""
echo "=== FIN DIAGNOSTIC ==="
```

### Script 2 : Auto-Recovery

```bash
#!/bin/bash
# auto_recovery.sh - Tentative de r√©cup√©ration automatique

ERROR_CODE=$(mariadb -N -e "SELECT COALESCE(Last_SQL_Errno, Last_IO_Errno, 0) FROM information_schema.SLAVE_STATUS")

if [ "$ERROR_CODE" -eq 0 ]; then
  echo "No errors detected"
  exit 0
fi

echo "Detected error code: $ERROR_CODE"

case $ERROR_CODE in
  1062)
    echo "Duplicate entry error - Attempting to skip"
    mariadb <<EOF
STOP REPLICA;
SET GLOBAL sql_slave_skip_counter = 1;
START REPLICA;
EOF
    ;;
  
  1032)
    echo "Record not found error - Attempting to skip"
    mariadb <<EOF
STOP REPLICA;
SET GLOBAL sql_slave_skip_counter = 1;
START REPLICA;
EOF
    ;;
  
  2003)
    echo "Connection refused - Retrying in 30s"
    sleep 30
    mariadb -e "START REPLICA IO_THREAD"
    ;;
  
  *)
    echo "Unknown error code: $ERROR_CODE"
    echo "Manual intervention required"
    exit 1
    ;;
esac

# V√©rifier le r√©sultat
sleep 5
mariadb -e "SHOW REPLICA STATUS\G" | grep -E "Slave_IO_Running|Slave_SQL_Running|Last_Errno"
```

‚ö†Ô∏è **Attention** : Ce script auto-recovery est **dangereux** et ne devrait √™tre utilis√© qu'en environnement de test ou avec supervision.

---

## Pr√©vention des Erreurs

### Configuration Recommand√©e pour √âviter les Erreurs

```ini
# /etc/my.cnf.d/replication.cnf

[mariadb]
# ===== PR√âVENTION ERREURS I/O =====
# Reconnexion automatique
master_connect_retry = 60
master_retry_count = 0  # Illimit√©

# Heartbeat pour d√©tecter pannes
heartbeat_period = 30

# SSL obligatoire (√©vite interceptions)
require_secure_transport = ON

# ===== PR√âVENTION ERREURS SQL =====
# Read-only strict sur Replicas
super_read_only = ON

# GTID strict mode (√©vite incoh√©rences)
gtid_strict_mode = ON

# Ne JAMAIS skip errors en production
# slave_skip_errors = JAMAIS !

# ===== PR√âVENTION ERREURS RESSOURCES =====
# Limiter taille relay log
max_relay_log_size = 1G
relay_log_space_limit = 10G

# Monitoring espace disque
max_tmp_space_usage = 10G

# ===== PR√âVENTION ERREURS GTID =====
gtid_ignore_duplicates = OFF  # D√©tecter les probl√®mes

# ===== BINLOG R√âTENTION =====
# Conserver binlogs assez longtemps
binlog_expire_logs_seconds = 604800  # 7 jours minimum

# ===== R√âPLICATION PARALL√àLE =====
# R√©duire le lag ‚Üí moins d'erreurs
slave_parallel_threads = 8
slave_parallel_mode = optimistic
```

### Bonnes Pratiques Op√©rationnelles

```sql
-- 1. Toujours tester en non-prod d'abord
-- 2. Monitorer proactivement
-- 3. Alerting sur erreurs
-- 4. Backups r√©guliers
-- 5. Documentation des proc√©dures
-- 6. Jamais d'√©critures manuelles sur Replicas
-- 7. Tests de failover r√©guliers
-- 8. Rotation des credentials
-- 9. Audits de configuration
-- 10. Formation des √©quipes
```

---

## Impact MariaDB 11.8

### R√©duction des Erreurs DDL

üÜï **Optimistic ALTER TABLE** r√©duit les erreurs li√©es aux DDL longues :

**Avant 11.8** :

```
Sc√©nario : ALTER TABLE de 2h sur Primary

Probl√®me :
- Replica bloqu√© pendant 2h
- Timeout possible ‚Üí Erreur r√©plication
- Lag critique ‚Üí Failover impossible
- Risque erreur 1236 si binlog purg√© pendant
```

**Avec 11.8** :

```
M√™me ALTER de 2h

Am√©lioration :
- Autres tables continuent la r√©plication
- Lag global r√©duit de 99%
- Failover possible (gestion intelligente de l'ALTER en cours)
- Moins de timeouts
- Moins d'erreurs de r√©plication
```

**Configuration** :

```sql
-- Activ√© automatiquement avec GTID
SET GLOBAL replication_optimize_for_static_plugin_config = ON;
```

---

## ‚úÖ Points cl√©s √† retenir

- **Diagnostic syst√©matique** : SHOW REPLICA STATUS ‚Üí Identifier error code ‚Üí Consulter logs
- **Erreurs I/O (2003, 1236, 1045)** : Probl√®mes r√©seau, binlog, authentification
- **Erreurs SQL (1062, 1032, 1452, 1146)** : Incoh√©rences donn√©es, contraintes
- **Erreurs GTID** : Positions perdues, trous, duplicates
- **JAMAIS slave_skip_errors en production** : Masque les probl√®mes sans les r√©soudre
- **super_read_only = ON** obligatoire sur Replicas pour √©viter 90% des erreurs
- **Resynchronisation compl√®te** est souvent plus s√ªre que skip counter
- **GTID simplifie** la r√©cup√©ration (current_pos vs calculs positions)
- **Monitoring proactif** : D√©tecter avant que √ßa casse
- üÜï **Optimistic ALTER TABLE (11.8)** r√©duit erreurs li√©es aux DDL longues
- **Scripts de diagnostic** : Automatiser pour r√©ponse rapide
- **Documentation** : Toujours documenter les incidents et r√©solutions

---

## üîó Ressources et r√©f√©rences

- [üìñ Replication Error Codes](https://mariadb.com/kb/en/replication-error-codes/)
- [üìñ Troubleshooting Replication](https://mariadb.com/kb/en/troubleshooting-replication/)
- [üìñ SHOW REPLICA STATUS](https://mariadb.com/kb/en/show-replica-status/)
- [üìñ GTID Troubleshooting](https://mariadb.com/kb/en/gtid-troubleshooting/)
- [üìÑ Blog : Common Replication Errors](https://mariadb.com/resources/blog/common-replication-errors/)
- [üìÑ MariaDB 11.8 : Optimistic ALTER](https://mariadb.org/optimistic-alter-table/)

---

## ‚û°Ô∏è Section suivante

**13.8 Failover et switchover)** : Nous allons explorer les proc√©dures compl√®tes de failover (non planifi√©) et switchover (planifi√©), avec scripts d'automatisation et bonnes pratiques.

---


‚è≠Ô∏è [Failover et switchover](/13-replication/08-failover-switchover.md)
