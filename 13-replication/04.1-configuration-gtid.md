ðŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 13.4.1 Configuration GTID

> **Niveau** : AvancÃ©  
> **DurÃ©e estimÃ©e** : 2-3 heures  
> **PrÃ©requis** : 
> - Section 13.1 (Concepts de rÃ©plication)
> - Section 13.2 (Configuration Master-Slave)
> - Section 13.3 (RÃ©plication basÃ©e sur les positions)
> - ComprÃ©hension des systÃ¨mes distribuÃ©s

## ðŸŽ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre en profondeur l'architecture et le fonctionnement du GTID
- Configurer GTID sur un nouveau cluster ou migrer depuis positions binlog
- MaÃ®triser les concepts de domain_id, server_id et sequence number
- GÃ©rer des topologies complexes (multi-source, cascade) avec GTID
- RÃ©soudre les problÃ¨mes courants liÃ©s au GTID
- Utiliser GTID pour simplifier les opÃ©rations de failover et switchover
- Optimiser les performances de rÃ©plication avec GTID strict mode

---

## Introduction

Le **GTID (Global Transaction Identifier)** est un mÃ©canisme d'identification unique de chaque transaction rÃ©pliquÃ©e dans un cluster MariaDB. Introduit dans MariaDB 10.0, il rÃ©volutionne la gestion de la rÃ©plication en **simplifiant drastiquement** la configuration, le monitoring et les opÃ©rations de haute disponibilitÃ©.

### ProblÃ©matique rÃ©solue par GTID

**Sans GTID** (positions binlog traditionnelles) :
```
Primary crash â†’ Failover vers Replica
Question : Quelle position binlog utiliser sur le nouveau Primary ?
RÃ©ponse : Complexe, calculs manuels, risque d'erreur Ã©levÃ©
```

**Avec GTID** :
```
Primary crash â†’ Failover vers Replica
Question : Quelle position utiliser ?
RÃ©ponse : Automatique ! GTID se synchronise tout seul
```

ðŸ’¡ **Avantages majeurs du GTID** :
- **Failover automatique** : Plus besoin de calculer les positions binlog
- **CohÃ©rence garantie** : Chaque transaction a un identifiant unique global
- **Multi-source simplifiÃ©** : Gestion propre de plusieurs sources
- **Monitoring amÃ©liorÃ©** : VisibilitÃ© claire de la progression de la rÃ©plication
- **OpÃ©rations simplifiÃ©es** : Promotion de Replica, reconfiguration, re-pointing

---

## Architecture et Fonctionnement du GTID

### Structure d'un GTID MariaDB

Un GTID MariaDB suit le format : **`domain_id-server_id-sequence_number`**

```
Format : D-S-N
Exemple : 0-1-1000

D = Domain ID (0 Ã  2^32-1)
S = Server ID (identifiant du serveur qui a crÃ©Ã© la transaction)
N = Sequence Number (compteur sÃ©quentiel par domain)
```

**Composants** :

| Composant | Description | Exemple | Plage |
|-----------|-------------|---------|-------|
| **domain_id** | Identifie un flux de rÃ©plication logique | 0, 1, 2 | 0 - 4,294,967,295 |
| **server_id** | Identifie le serveur qui a exÃ©cutÃ© la transaction | 1, 2, 100 | 1 - 4,294,967,295 |
| **sequence_number** | NumÃ©ro sÃ©quentiel unique par domain | 1000, 1001 | 1 - 2^64-1 |

### DiffÃ©rence avec MySQL GTID

**MySQL GTID** :
```
Format : UUID:TRANSACTION_ID
Exemple : 3E11FA47-71CA-11E1-9E33-C80AA9429562:23
```

**MariaDB GTID** (plus flexible) :
```
Format : DOMAIN-SERVER-SEQUENCE
Exemple : 0-1-1000
```

ðŸ’¡ **Avantage MariaDB** : Les domain IDs permettent la **rÃ©plication multi-source** sans conflits, contrairement Ã  MySQL qui nÃ©cessite des UUID complexes.

### Progression du GTID

```
Transaction 1 : 0-1-1000
Transaction 2 : 0-1-1001
Transaction 3 : 0-1-1002
...
Transaction N : 0-1-5000

Chaque transaction incrÃ©mente le sequence_number dans son domain.
```

**En cas de multi-source** :

```
Primary A (domain 0) : 0-1-1000, 0-1-1001, 0-1-1002
Primary B (domain 1) : 1-2-500, 1-2-501, 1-2-502

Replica multi-source : 
  @@gtid_slave_pos = '0-1-1002,1-2-502'
  
Deux sÃ©quences indÃ©pendantes !
```

---

## Configuration GTID : Nouveau Cluster

### Activation sur le Primary

```ini
# Configuration my.cnf sur le Primary
[mariadb]
# Identifiant unique du serveur
server-id = 1

# Activer le binary log
log-bin = /var/log/mariadb/mariadb-bin
binlog-format = ROW

# Configuration GTID
gtid_strict_mode = ON          # Mode strict (recommandÃ© production)
gtid_domain_id = 0             # Domain ID de ce Primary
log_slave_updates = ON         # NÃ©cessaire pour cascade/multi-tier

# Optionnel mais recommandÃ©
gtid_ignore_duplicates = OFF   # Ne pas ignorer les GTID dupliquÃ©s
```

**RedÃ©marrer MariaDB** :

```bash
sudo systemctl restart mariadb
```

**VÃ©rification** :

```sql
-- VÃ©rifier que GTID est actif
SELECT @@gtid_strict_mode;
-- RÃ©sultat : 1 (ON)

SELECT @@gtid_domain_id;
-- RÃ©sultat : 0

-- Position GTID actuelle (vide au dÃ©marrage)
SELECT @@gtid_binlog_pos;
-- RÃ©sultat : 0-1-0 ou vide si pas encore de transactions

-- CrÃ©er une transaction pour gÃ©nÃ©rer un GTID
CREATE DATABASE test_gtid;
SELECT @@gtid_binlog_pos;
-- RÃ©sultat : 0-1-1 (premiÃ¨re transaction)
```

### Activation sur le Replica

```ini
# Configuration my.cnf sur le Replica
[mariadb]
# Identifiant unique DIFFÃ‰RENT du Primary
server-id = 2

# Binary log (recommandÃ© pour promotion)
log-bin = /var/log/mariadb/mariadb-bin
binlog-format = ROW

# GTID configuration
gtid_strict_mode = ON
gtid_domain_id = 0             # MÃªme domain que le Primary
log_slave_updates = ON         # Pour rÃ©plication en cascade

# Read-only
read_only = ON
super_read_only = ON

# Relay log
relay-log = /var/log/mariadb/relay-bin
relay-log-recovery = ON
```

**Configuration de la rÃ©plication avec GTID** :

```sql
-- Sur le Replica : Configurer la connexion au Primary
CHANGE REPLICATION SOURCE TO
  SOURCE_HOST = '192.168.1.100',
  SOURCE_PORT = 3306,
  SOURCE_USER = 'repl_user',
  SOURCE_PASSWORD = 'SecurePassword123!',
  
  -- IMPORTANT : Utiliser GTID
  SOURCE_USE_GTID = slave_pos;

-- DÃ©marrer la rÃ©plication
START REPLICA;

-- VÃ©rifier
SHOW REPLICA STATUS\G
```

**Champs GTID dans SHOW REPLICA STATUS** :

```
Using_Gtid: Slave_Pos          -- GTID activÃ©
Gtid_IO_Pos: 0-1-1000          -- Position GTID lue depuis le Primary
Gtid_Slave_Pos: 0-1-1000       -- Position GTID exÃ©cutÃ©e sur le Replica
```

---

## Migration depuis Positions Binlog vers GTID

Pour un cluster existant utilisant les positions binlog, vous pouvez migrer vers GTID **sans interruption**.

### Ã‰tape 1 : Activer GTID sur le Primary

```ini
# my.cnf sur le Primary
[mariadb]
# Ajouter/modifier ces lignes
gtid_strict_mode = ON
gtid_domain_id = 0
log_slave_updates = ON  # Si rÃ©plication en cascade
```

**RedÃ©marrer le Primary** :

```bash
sudo systemctl restart mariadb
```

### Ã‰tape 2 : Activer GTID sur les Replicas

```ini
# my.cnf sur chaque Replica
[mariadb]
gtid_strict_mode = ON
gtid_domain_id = 0
log_slave_updates = ON
```

**RedÃ©marrer chaque Replica** :

```bash
sudo systemctl restart mariadb
```

### Ã‰tape 3 : Basculer la rÃ©plication vers GTID

```sql
-- Sur chaque Replica (un par un pour tester)
STOP REPLICA;

-- Basculer vers GTID
CHANGE REPLICATION SOURCE TO
  SOURCE_USE_GTID = slave_pos;

START REPLICA;

-- VÃ©rifier que Ã§a fonctionne
SHOW REPLICA STATUS\G
-- VÃ©rifier : Using_Gtid: Slave_Pos
```

ðŸ’¡ **Migration progressive** : Testez d'abord sur un Replica non critique, puis migrez les autres un par un.

### Ã‰tape 4 : VÃ©rifier la cohÃ©rence GTID

```sql
-- Sur le Primary
SELECT @@gtid_binlog_pos;
-- RÃ©sultat : 0-1-5000

-- Sur chaque Replica
SELECT @@gtid_slave_pos;
-- RÃ©sultat : 0-1-4998 (peut avoir un lÃ©ger lag)

-- Attendre que le Replica rattrape
-- Puis vÃ©rifier Ã  nouveau
SELECT @@gtid_slave_pos;
-- RÃ©sultat : 0-1-5000 (synchronisÃ©)
```

---

## GTID Strict Mode

Le **GTID Strict Mode** (`gtid_strict_mode = ON`) est **fortement recommandÃ©** en production. Il garantit la cohÃ©rence en empÃªchant certaines opÃ©rations dangereuses.

### Comportement avec strict mode ON

```sql
-- Avec gtid_strict_mode = ON
SET GLOBAL gtid_strict_mode = ON;

-- âŒ INTERDIT : Ã‰criture sur un Replica (garantit read-only)
-- Sur un Replica actif en rÃ©plication
INSERT INTO table VALUES (1, 'test');
-- Erreur : The MariaDB server is running with the --gtid-strict-mode option so it cannot execute this statement

-- âŒ INTERDIT : CREATE TEMPORARY TABLE en transaction rÃ©pliquÃ©e
START TRANSACTION;
CREATE TEMPORARY TABLE tmp (id INT);
COMMIT;
-- Erreur : Cannot execute statement in a GTID-consistent manner
```

### Comportement avec strict mode OFF

```sql
-- Avec gtid_strict_mode = OFF (DANGEREUX)
SET GLOBAL gtid_strict_mode = OFF;

-- âœ… AUTORISÃ‰ mais DANGEREUX : Ã‰criture sur Replica
INSERT INTO table VALUES (1, 'test');
-- Risque : Divergence entre Primary et Replica
```

âš ï¸ **Production** : Toujours utiliser `gtid_strict_mode = ON` pour Ã©viter les incohÃ©rences.

### Exceptions et cas particuliers

```sql
-- OpÃ©rations autorisÃ©es mÃªme en strict mode :

-- 1. Transactions locales (non rÃ©pliquÃ©es)
SET SESSION sql_log_bin = 0;
INSERT INTO local_table VALUES (1, 'local');
SET SESSION sql_log_bin = 1;

-- 2. DDL hors transaction
CREATE TABLE test (id INT);  -- OK

-- 3. Temporary tables hors transaction
CREATE TEMPORARY TABLE tmp (id INT);  -- OK
DROP TEMPORARY TABLE tmp;  -- OK
```

---

## Domain IDs : RÃ©plication Multi-Source

Les **domain IDs** sont la fonctionnalitÃ© distinctive de MariaDB GTID, permettant une rÃ©plication multi-source propre et sans conflits.

### Concept de Domain ID

Chaque **flux de rÃ©plication indÃ©pendant** utilise un domain_id unique :

```
Primary A (e-commerce) : domain_id = 0
Primary B (CRM)        : domain_id = 1
Primary C (Analytics)  : domain_id = 2

Replica multi-source :
  ReÃ§oit : domain 0, 1, 2
  Position GTID : 0-100-5000,1-200-3000,2-300-1000
```

### Configuration Multi-Source avec Domain IDs

**Sur Primary A (e-commerce)** :

```ini
[mariadb]
server-id = 100
gtid_domain_id = 0    # Domain e-commerce
log-bin = mariadb-bin
gtid_strict_mode = ON
```

**Sur Primary B (CRM)** :

```ini
[mariadb]
server-id = 200
gtid_domain_id = 1    # Domain CRM (DIFFÃ‰RENT)
log-bin = mariadb-bin
gtid_strict_mode = ON
```

**Sur Primary C (Analytics)** :

```ini
[mariadb]
server-id = 300
gtid_domain_id = 2    # Domain Analytics (DIFFÃ‰RENT)
log-bin = mariadb-bin
gtid_strict_mode = ON
```

**Sur le Replica multi-source** :

```sql
-- Connexion 1 : Primary A (e-commerce)
CHANGE REPLICATION SOURCE 'ecommerce' TO
  SOURCE_HOST = '192.168.1.100',
  SOURCE_USER = 'repl_user',
  SOURCE_PASSWORD = 'SecurePass1',
  SOURCE_USE_GTID = slave_pos,
  DO_DOMAIN_IDS = (0);  -- Filtrer : seulement domain 0

-- Connexion 2 : Primary B (CRM)
CHANGE REPLICATION SOURCE 'crm' TO
  SOURCE_HOST = '192.168.1.200',
  SOURCE_USER = 'repl_user',
  SOURCE_PASSWORD = 'SecurePass2',
  SOURCE_USE_GTID = slave_pos,
  DO_DOMAIN_IDS = (1);  -- Filtrer : seulement domain 1

-- Connexion 3 : Primary C (Analytics)
CHANGE REPLICATION SOURCE 'analytics' TO
  SOURCE_HOST = '192.168.1.300',
  SOURCE_USER = 'repl_user',
  SOURCE_PASSWORD = 'SecurePass3',
  SOURCE_USE_GTID = slave_pos,
  DO_DOMAIN_IDS = (2);  -- Filtrer : seulement domain 2

-- DÃ©marrer toutes les rÃ©plications
START ALL REPLICAS;
```

**VÃ©rification** :

```sql
-- Position GTID composite
SELECT @@gtid_slave_pos;
-- RÃ©sultat : 0-100-5000,1-200-3000,2-300-1000
--           â””â”€ domain 0  â””â”€ domain 1  â””â”€ domain 2

-- Statut de chaque rÃ©plication
SHOW ALL REPLICAS STATUS\G

-- Ou par connexion
SHOW REPLICA 'ecommerce' STATUS\G
SHOW REPLICA 'crm' STATUS\G
SHOW REPLICA 'analytics' STATUS\G
```

### Architecture Multi-Source avec Domains

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  Domain 0
â”‚  PRIMARY A       â”‚  GTID: 0-100-XXXX
â”‚  (e-commerce)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  Domain 1          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PRIMARY B       â”‚  GTID: 1-200-XXXX  â”‚   REPLICA        â”‚
â”‚  (CRM)           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> â”‚  Multi-Source    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚                  â”‚
                                        â”‚  GTID Position:  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  Domain 2          â”‚  0-100-5000,     â”‚
â”‚  PRIMARY C       â”‚  GTID: 2-300-XXXX  â”‚  1-200-3000,     â”‚
â”‚  (Analytics)     â”‚                    â”‚  2-300-1000      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>
```

ðŸ’¡ **Avantage** : Chaque domain maintient son propre compteur sÃ©quentiel, **pas de conflits** possibles entre sources.

---

## Variables GTID et Leur Signification

MariaDB expose plusieurs variables pour gÃ©rer et monitorer GTID.

### @@gtid_binlog_pos

Position GTID **Ã©crite dans le binary log local**.

```sql
SELECT @@gtid_binlog_pos;
-- Sur Primary : 0-1-5000
-- Sur Replica (si log-bin actif) : 0-1-5000

-- Cette variable reprÃ©sente :
-- "Quelle est la derniÃ¨re transaction que j'ai Ã©crite dans mon binlog ?"
```

ðŸ’¡ **Usage** : ConnaÃ®tre la position actuelle pour un snapshot ou un failover.

### @@gtid_slave_pos

Position GTID **exÃ©cutÃ©e depuis la rÃ©plication** (appliquÃ©e sur le Replica).

```sql
SELECT @@gtid_slave_pos;
-- Sur Replica : 0-1-4998

-- Cette variable reprÃ©sente :
-- "Quelle est la derniÃ¨re transaction rÃ©pliquÃ©e que j'ai exÃ©cutÃ©e ?"
```

ðŸ’¡ **Usage** : ConnaÃ®tre la progression de la rÃ©plication, calculer le lag.

### @@gtid_current_pos

Position GTID **globale** : MAX(binlog_pos, slave_pos).

```sql
SELECT @@gtid_current_pos;
-- Retourne la position la plus avancÃ©e entre binlog et slave

-- Exemple :
-- @@gtid_binlog_pos = 0-1-5000
-- @@gtid_slave_pos = 0-1-4998
-- @@gtid_current_pos = 0-1-5000 (le max)
```

ðŸ’¡ **Usage** : Position de rÃ©fÃ©rence pour initialiser un nouveau Replica.

### @@gtid_binlog_state

Ã‰tat complet du binlog incluant **tous les domains**.

```sql
SELECT @@gtid_binlog_state;
-- RÃ©sultat multi-source : 0-100-5000,1-200-3000,2-300-1000
```

ðŸ’¡ **Usage** : Monitoring multi-source, vue d'ensemble complÃ¨te.

### @@gtid_domain_id

Domain ID **utilisÃ© pour les nouvelles transactions** crÃ©Ã©es sur ce serveur.

```sql
SELECT @@gtid_domain_id;
-- RÃ©sultat : 0

-- Changer dynamiquement (SESSION uniquement)
SET SESSION gtid_domain_id = 5;
-- Les transactions de cette session utiliseront domain 5
```

ðŸ’¡ **Usage** : Configurations avancÃ©es, rÃ©plication multi-tier.

### Tableau rÃ©capitulatif

| Variable | Scope | Description | Usage typique |
|----------|-------|-------------|---------------|
| `@@gtid_binlog_pos` | GLOBAL | Position dans le binlog local | Snapshot, failover |
| `@@gtid_slave_pos` | GLOBAL | Position de la rÃ©plication | Monitoring Replica |
| `@@gtid_current_pos` | GLOBAL | MAX(binlog, slave) | Init nouveau Replica |
| `@@gtid_binlog_state` | GLOBAL | Ã‰tat complet (tous domains) | Multi-source monitoring |
| `@@gtid_domain_id` | SESSION/GLOBAL | Domain pour nouvelles transactions | Configuration |
| `@@gtid_strict_mode` | GLOBAL | Mode strict activÃ© | SÃ©curitÃ© |
| `@@gtid_ignore_duplicates` | GLOBAL | Ignorer GTID dupliquÃ©s | Edge cases |

---

## OpÃ©rations AvancÃ©es avec GTID

### DÃ©finir manuellement la position GTID

NÃ©cessaire lors de l'initialisation d'un nouveau Replica depuis un snapshot.

```sql
-- ArrÃªter la rÃ©plication
STOP REPLICA;

-- DÃ©finir la position GTID
-- Format : 'domain-server-sequence'
SET GLOBAL gtid_slave_pos = '0-1-1000';

-- Ou avec plusieurs domains (multi-source)
SET GLOBAL gtid_slave_pos = '0-1-1000,1-2-500,2-3-2000';

-- Configurer la rÃ©plication
CHANGE REPLICATION SOURCE TO
  SOURCE_HOST = '192.168.1.100',
  SOURCE_USER = 'repl_user',
  SOURCE_PASSWORD = 'SecurePassword123!',
  SOURCE_USE_GTID = slave_pos;

-- DÃ©marrer
START REPLICA;
```

### Reset GTID position

```sql
-- âš ï¸ DANGEREUX : RÃ©initialiser complÃ¨tement la position GTID
STOP REPLICA;
RESET SLAVE ALL;  -- Efface la configuration de rÃ©plication
SET GLOBAL gtid_slave_pos = '';  -- RÃ©initialise la position

-- Reconfigurer depuis le dÃ©but
```

### Sauter une transaction spÃ©cifique (troubleshooting)

En cas d'erreur bloquante sur une transaction spÃ©cifique :

```sql
-- Identifier la transaction problÃ©matique
SHOW REPLICA STATUS\G
-- Last_SQL_Error: ... GTID 0-1-1500 ...

-- Option 1 : IncrÃ©menter manuellement (DANGEREUX)
SET GLOBAL gtid_slave_pos = '0-1-1501';  -- Sauter 1500, passer Ã  1501
START REPLICA;

-- Option 2 : Injecter un Ã©vÃ©nement vide pour cette position
SET gtid_domain_id = 0;
SET SESSION server_id = 1;
SET SESSION gtid_seq_no = 1500;
BEGIN;
COMMIT;  -- Transaction vide avec GTID 0-1-1500
-- Maintenant le Replica peut continuer
START REPLICA;
```

âš ï¸ **Danger** : Sauter des transactions peut causer des **incohÃ©rences de donnÃ©es**. Ã€ n'utiliser qu'en dernier recours.

### Changer de domain_id en production

```sql
-- ScÃ©nario : Migrer d'un domain Ã  un autre
-- Ancien domain : 0
-- Nouveau domain : 5

-- 1. ArrÃªter temporairement les Ã©critures
SET GLOBAL read_only = ON;

-- 2. Attendre que tous les Replicas soient Ã  jour
-- VÃ©rifier @@gtid_slave_pos sur chaque Replica

-- 3. Changer le domain_id
SET GLOBAL gtid_domain_id = 5;

-- 4. RÃ©activer les Ã©critures
SET GLOBAL read_only = OFF;

-- 5. Les nouvelles transactions utiliseront domain 5
-- Format GTID : 5-1-XXXX

-- 6. Sur les Replicas : pas de changement nÃ©cessaire
-- Ils suivront automatiquement les deux domains (0 et 5)
SELECT @@gtid_slave_pos;
-- RÃ©sultat : 0-1-5000,5-1-1 (ancien domain + nouveau domain)
```

---

## Failover et Switchover avec GTID

GTID **simplifie drastiquement** les opÃ©rations de failover et switchover.

### Scenario 1 : Failover automatique (Primary crash)

```
Ã‰tat initial :
  Primary A (crashed) : 0-1-5000
  Replica B           : 0-1-4998 (lag de 2 transactions)
  Replica C           : 0-1-5000 (Ã  jour)

Objectif : Promouvoir Replica C en nouveau Primary
```

**Ã‰tape 1 : VÃ©rifier les positions GTID**

```sql
-- Sur Replica B
SELECT @@gtid_slave_pos;
-- RÃ©sultat : 0-1-4998

-- Sur Replica C
SELECT @@gtid_slave_pos;
-- RÃ©sultat : 0-1-5000  âœ… Le plus Ã  jour
```

**Ã‰tape 2 : Promouvoir Replica C**

```sql
-- Sur Replica C : ArrÃªter la rÃ©plication
STOP REPLICA;

-- DÃ©sactiver read-only
SET GLOBAL read_only = OFF;
SET GLOBAL super_read_only = OFF;

-- Effacer la configuration de rÃ©plication (devient Primary)
RESET REPLICA ALL;

-- Replica C est maintenant le nouveau Primary
```

**Ã‰tape 3 : Reconfigurer Replica B vers nouveau Primary**

```sql
-- Sur Replica B : ArrÃªter l'ancienne rÃ©plication
STOP REPLICA;

-- Pointer vers le nouveau Primary (Replica C)
CHANGE REPLICATION SOURCE TO
  SOURCE_HOST = '192.168.1.102',  -- IP de Replica C
  SOURCE_USE_GTID = slave_pos;    -- GTID trouve automatiquement la position

-- DÃ©marrer
START REPLICA;

-- VÃ©rifier
SHOW REPLICA STATUS\G
-- Using_Gtid: Slave_Pos
-- Gtid_Slave_Pos: 0-1-5000 (va rattraper automatiquement)
```

ðŸ’¡ **Magie du GTID** : Pas besoin de calculer les positions binlog ! Le Replica B sait qu'il est Ã  0-1-4998 et doit rattraper jusqu'Ã  0-1-5000+.

### Scenario 2 : Switchover planifiÃ© (maintenance)

```
Objectif : Basculer le Primary A vers Replica B pour maintenance
```

**Ã‰tape 1 : ArrÃªter les Ã©critures sur Primary A**

```sql
-- Sur Primary A
SET GLOBAL read_only = ON;
SET GLOBAL super_read_only = ON;
```

**Ã‰tape 2 : Attendre la synchronisation complÃ¨te**

```sql
-- Sur Primary A
SELECT @@gtid_binlog_pos;
-- RÃ©sultat : 0-1-5000

-- Sur Replica B (rÃ©pÃ©ter jusqu'Ã  synchronisation)
SELECT @@gtid_slave_pos;
-- RÃ©sultat : 0-1-5000 âœ… SynchronisÃ©
```

**Ã‰tape 3 : Promouvoir Replica B**

```sql
-- Sur Replica B
STOP REPLICA;
SET GLOBAL read_only = OFF;
SET GLOBAL super_read_only = OFF;
RESET REPLICA ALL;

-- Replica B est maintenant le nouveau Primary
```

**Ã‰tape 4 : Configurer Primary A comme Replica**

```sql
-- Sur ancien Primary A (devenu Replica)
CHANGE REPLICATION SOURCE TO
  SOURCE_HOST = '192.168.1.102',  -- Nouveau Primary (Replica B)
  SOURCE_USER = 'repl_user',
  SOURCE_PASSWORD = 'SecurePassword123!',
  SOURCE_USE_GTID = slave_pos;

START REPLICA;
```

**Ã‰tape 5 : VÃ©rifier la nouvelle topologie**

```
Nouvelle topologie :
  Primary B (anciennement Replica B)
    â””â”€â”€ Replica A (anciennement Primary A)
```

---

## Monitoring GTID

### MÃ©triques clÃ©s Ã  surveiller

```sql
-- 1. Progression GTID sur le Primary
SELECT @@gtid_binlog_pos AS primary_position;
-- Exporter cette mÃ©trique vers Prometheus/Grafana

-- 2. Progression GTID sur chaque Replica
SELECT @@gtid_slave_pos AS replica_position;

-- 3. Lag GTID (diffÃ©rence entre Primary et Replica)
-- Sur le Primary :
SELECT @@gtid_binlog_pos;  -- 0-1-5000

-- Sur le Replica :
SELECT @@gtid_slave_pos;   -- 0-1-4998

-- Lag = 5000 - 4998 = 2 transactions
```

### Script de monitoring GTID

```bash
#!/bin/bash
# monitor_gtid.sh - Surveillance du lag GTID

PRIMARY_HOST="192.168.1.100"
REPLICA_HOST="192.168.1.101"

# Position sur le Primary
PRIMARY_POS=$(mariadb -h $PRIMARY_HOST -N -e "SELECT @@gtid_binlog_pos")

# Position sur le Replica
REPLICA_POS=$(mariadb -h $REPLICA_HOST -N -e "SELECT @@gtid_slave_pos")

echo "Primary GTID: $PRIMARY_POS"
echo "Replica GTID: $REPLICA_POS"

# Extraire le sequence number (simplifiÃ© pour domain 0)
PRIMARY_SEQ=$(echo $PRIMARY_POS | cut -d'-' -f3)
REPLICA_SEQ=$(echo $REPLICA_POS | cut -d'-' -f3)

# Calculer le lag
LAG=$((PRIMARY_SEQ - REPLICA_SEQ))

echo "GTID Lag: $LAG transactions"

# Alerter si lag > 100
if [ $LAG -gt 100 ]; then
    echo "WARNING: GTID lag is high ($LAG transactions)"
    exit 1
fi
```

### RequÃªtes de monitoring avancÃ©es

```sql
-- Analyser la progression par domain (multi-source)
SELECT 
  SUBSTRING_INDEX(SUBSTRING_INDEX(@@gtid_slave_pos, ',', n.n), ',', -1) AS domain_gtid
FROM (
  SELECT 1 AS n UNION SELECT 2 UNION SELECT 3
) n
WHERE n.n <= 1 + (LENGTH(@@gtid_slave_pos) - LENGTH(REPLACE(@@gtid_slave_pos, ',', '')));

-- VÃ©rifier les GTID en attente
SELECT 
  gtid,
  domain_id,
  server_id,
  seq_no
FROM mysql.gtid_slave_pos
ORDER BY domain_id, seq_no DESC;
```

---

## Troubleshooting GTID

### Erreur : "GTID position not found in binlog"

**SymptÃ´me** :
```
Last_IO_Error: Got fatal error 1236 from master when reading data from binary log:
'The slave is connecting using GTID, it requested events starting with GTID 0-1-1000,
which is not in the master's binlog'
```

**Cause** : Le binlog demandÃ© a Ã©tÃ© purgÃ© sur le Primary.

**Solution** :

```sql
-- Option 1 : Refaire un snapshot complet
-- 1. Sur Primary : mysqldump avec --master-data
-- 2. Sur Replica : restaurer et reconfigurer

-- Option 2 : Utiliser current_pos pour rattraper
STOP REPLICA;
CHANGE REPLICATION SOURCE TO SOURCE_USE_GTID = current_pos;
START REPLICA;
-- âš ï¸ Risque : peut perdre des transactions si lag trop important
```

### Erreur : "GTID sequence number hole"

**SymptÃ´me** :
```
Last_SQL_Error: An attempt was made to binlog GTID 0-1-1500 
which would create an out-of-order sequence number
```

**Cause** : Un GTID est manquant dans la sÃ©quence (transaction sautÃ©e).

**Solution** :

```sql
-- Identifier le GTID manquant
SHOW REPLICA STATUS\G
-- Last_SQL_Error indique le GTID problÃ©matique : 0-1-1500

-- Injecter un Ã©vÃ©nement vide pour combler le trou
SET gtid_domain_id = 0;
SET SESSION server_id = 1;
SET gtid_seq_no = 1500;  -- Le GTID manquant
BEGIN;
COMMIT;  -- Transaction vide

-- Reprendre la rÃ©plication
START REPLICA;
```

### Erreur : "Duplicate GTID"

**SymptÃ´me** :
```
Last_SQL_Error: Duplicate entry for GTID 0-1-1000
```

**Cause** : La mÃªme transaction a Ã©tÃ© exÃ©cutÃ©e deux fois (Ã©criture manuelle sur Replica).

**Solution** :

```sql
-- Option 1 : Activer l'ignorance de GTID dupliquÃ©s (temporaire)
SET GLOBAL gtid_ignore_duplicates = ON;
START REPLICA;
-- Attendre que le Replica rattrape
SET GLOBAL gtid_ignore_duplicates = OFF;

-- Option 2 : RÃ©initialiser et resynchroniser
STOP REPLICA;
RESET REPLICA ALL;
-- Restaurer depuis un nouveau snapshot
```

âš ï¸ **PrÃ©vention** : Toujours utiliser `super_read_only = ON` sur les Replicas pour empÃªcher les Ã©critures accidentelles.

### ProblÃ¨me : Positions GTID divergentes aprÃ¨s split-brain

**Scenario** : Deux serveurs ont tous deux agi comme Primary temporairement.

```
Server A : 0-1-5000 Ã  0-1-5100 (100 transactions)
Server B : 0-1-5000 Ã  0-1-5050 (50 transactions diffÃ©rentes)

Conflit ! MÃªme domain, mÃªme range de sequence numbers, transactions diffÃ©rentes.
```

**Solution** : Resynchronisation complÃ¨te nÃ©cessaire.

```sql
-- Choisir un Primary de rÃ©fÃ©rence (ex: Server A)
-- Sur Server B : Effacer et resynchroniser
STOP REPLICA;
RESET REPLICA ALL;
-- Restaurer depuis un snapshot de Server A
```

ðŸ†• **MariaDB 11.8** : Les mÃ©canismes d'Optimistic ALTER et de rÃ©plication amÃ©liorÃ©e rÃ©duisent les risques de split-brain.

---

## Optimisations et Bonnes Pratiques

### 1. Toujours activer gtid_strict_mode

```ini
[mariadb]
gtid_strict_mode = ON  # âœ… OBLIGATOIRE en production
```

**Raison** : EmpÃªche les Ã©critures accidentelles qui causeraient des incohÃ©rences.

### 2. Utiliser des domain_id diffÃ©rents pour chaque flux

```ini
# Primary E-commerce
gtid_domain_id = 0

# Primary CRM
gtid_domain_id = 1

# Primary Analytics
gtid_domain_id = 2
```

**Raison** : Ã‰vite les conflits en multi-source, permet un monitoring clair.

### 3. Activer log_slave_updates pour cascade

```ini
[mariadb]
log_slave_updates = ON  # NÃ©cessaire pour rÃ©plication en cascade
```

**Raison** : Permet Ã  un Replica de devenir Primary pour d'autres Replicas.

### 4. Monitorer rÃ©guliÃ¨rement les positions GTID

```sql
-- Script quotidien de vÃ©rification
SELECT 
  @@hostname AS server,
  @@gtid_binlog_pos AS binlog_pos,
  @@gtid_slave_pos AS slave_pos,
  @@gtid_current_pos AS current_pos;
```

**Raison** : DÃ©tection prÃ©coce des dÃ©rives ou problÃ¨mes.

### 5. Documenter les domain_id utilisÃ©s

```
# Documentation du cluster
# /opt/mariadb/gtid_domains.txt

Domain 0 : Production E-commerce (Primary: srv-prod-01)
Domain 1 : CRM (Primary: srv-crm-01)
Domain 2 : Analytics (Primary: srv-analytics-01)
Domain 3 : Test/Staging (Primary: srv-test-01)
Domain 4-9 : RÃ©servÃ©s pour expansion
```

**Raison** : Ã‰vite les rÃ©utilisations accidentelles de domain_id.

### 6. Automatiser les failover avec GTID

Avec GTID, le failover peut Ãªtre automatisÃ© via des outils :

- **MaxScale** : Auto-failover avec GTID
- **Orchestrator** : Topologie automatique avec GTID
- **ProxySQL** : Query routing avec dÃ©tection failover
- **MariaDB Operator (Kubernetes)** : Failover automatique

---

## âœ… Points clÃ©s Ã  retenir

- **GTID** = Domain-Server-Sequence : identification unique de chaque transaction
- **gtid_strict_mode = ON** est **obligatoire** en production pour garantir la cohÃ©rence
- **Domain IDs** permettent la rÃ©plication multi-source sans conflits (spÃ©cificitÃ© MariaDB)
- **SOURCE_USE_GTID = slave_pos** est la configuration recommandÃ©e pour les Replicas
- Les **failovers** sont **automatiques** avec GTID (pas de calcul de position binlog)
- **@@gtid_binlog_pos** : position dans le binlog local
- **@@gtid_slave_pos** : position de la rÃ©plication exÃ©cutÃ©e
- **@@gtid_current_pos** : MAX(binlog, slave) pour rÃ©fÃ©rence globale
- La **migration** depuis positions binlog vers GTID est possible sans interruption
- GTID simplifie le **monitoring**, le **troubleshooting** et les **opÃ©rations HA**
- ðŸ†• **MariaDB 11.8** : Optimisations GTID, support amÃ©liorÃ© pour Optimistic ALTER

---

## ðŸ”— Ressources et rÃ©fÃ©rences

- [ðŸ“– MariaDB GTID Documentation](https://mariadb.com/kb/en/gtid/)
- [ðŸ“– Global Transaction ID Overview](https://mariadb.com/kb/en/global-transaction-id/)
- [ðŸ“– Using GTID for Replication](https://mariadb.com/kb/en/using-mariadb-replication/)
- [ðŸ“– GTID Strict Mode](https://mariadb.com/kb/en/gtid-strict-mode/)
- [ðŸ“– Multi-Source Replication with GTID](https://mariadb.com/kb/en/multi-source-replication/)
- [ðŸ“„ Blog : GTID Best Practices](https://mariadb.org/gtid-best-practices/)

---

## âž¡ï¸ Section suivante

**13.4.2 Avantages pour failover** : Nous allons explorer en dÃ©tail comment GTID simplifie et automatise les opÃ©rations de failover, avec des scÃ©narios pratiques et des architectures haute disponibilitÃ©.

---


â­ï¸ [Avantages pour failover](/13-replication/04.2-avantages-failover.md)
