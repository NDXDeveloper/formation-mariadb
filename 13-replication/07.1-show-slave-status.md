üîù Retour au [Sommaire](/SOMMAIRE.md)

# 13.7.1 SHOW SLAVE STATUS / SHOW REPLICA STATUS

> **Niveau** : Avanc√©  
> **Dur√©e estim√©e** : 2 heures  
> **Pr√©requis** : 
> - Section 13.2 (Configuration Master-Slave)
> - Section 13.4 (GTID)
> - Compr√©hension de la r√©plication MariaDB
> - Exp√©rience en monitoring de bases de donn√©es

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Ma√Ætriser la commande SHOW REPLICA STATUS et interpr√©ter tous ses champs
- Identifier rapidement les probl√®mes de r√©plication via cette commande
- Cr√©er des requ√™tes de monitoring automatis√©es
- Analyser les m√©triques de performance de r√©plication
- Diagnostiquer le lag et les erreurs de r√©plication
- Int√©grer SHOW REPLICA STATUS dans vos outils de monitoring
- Comprendre les diff√©rences entre SHOW SLAVE STATUS et SHOW REPLICA STATUS

---

## Introduction

La commande **SHOW REPLICA STATUS** (anciennement **SHOW SLAVE STATUS**) est l'**outil principal** pour surveiller l'√©tat de la r√©plication sur un Replica. Elle fournit une vue compl√®te et d√©taill√©e de :

- **L'√©tat de connexion** au Primary (I/O thread)
- **L'√©tat d'application** des √©v√©nements (SQL thread)
- **Les positions de r√©plication** (binlog et GTID)
- **Les erreurs** √©ventuelles
- **Les m√©triques de performance** (lag, throughput)
- **La configuration** de la r√©plication

Cette commande retourne **plus de 50 champs** contenant des informations critiques. Comprendre chaque champ est **essentiel** pour op√©rer une r√©plication en production.

üí° **√âvolution de la nomenclature** :
- MariaDB < 10.5 : `SHOW SLAVE STATUS`
- MariaDB ‚â• 10.5 : `SHOW REPLICA STATUS` (recommand√©)
- Les deux commandes sont **identiques** et compatibles

---

## Syntaxe et Utilisation de Base

### Commande simple

```sql
-- Syntaxe moderne (MariaDB 10.5+)
SHOW REPLICA STATUS\G

-- Ancienne syntaxe (toujours fonctionnelle)
SHOW SLAVE STATUS\G

-- Sans \G (format tabulaire, moins lisible)
SHOW REPLICA STATUS;
```

üí° **Le `\G` est recommand√©** : Il affiche les r√©sultats en format vertical, beaucoup plus lisible pour les nombreux champs.

### Multi-source : Afficher une connexion sp√©cifique

```sql
-- Afficher le statut d'une connexion nomm√©e
SHOW REPLICA 'connection_name' STATUS\G

-- Exemple avec r√©plication multi-source
SHOW REPLICA 'production' STATUS\G
SHOW REPLICA 'analytics' STATUS\G

-- Afficher toutes les connexions
SHOW ALL REPLICAS STATUS\G
```

### Exemple de sortie

```sql
SHOW REPLICA STATUS\G

*************************** 1. row ***************************
                Slave_IO_State: Waiting for master to send event
                   Master_Host: 192.168.1.100
                   Master_User: repl_user
                   Master_Port: 3306
                 Connect_Retry: 60
               Master_Log_File: mariadb-bin.000003
           Read_Master_Log_Pos: 67890
                Relay_Log_File: relay-bin.000005
                 Relay_Log_Pos: 12345
         Relay_Master_Log_File: mariadb-bin.000003
              Slave_IO_Running: Yes
             Slave_SQL_Running: Yes
               Replicate_Do_DB: 
           Replicate_Ignore_DB: 
            Replicate_Do_Table: 
        Replicate_Ignore_Table: 
       Replicate_Wild_Do_Table: 
   Replicate_Wild_Ignore_Table: 
                    Last_Errno: 0
                    Last_Error: 
                  Skip_Counter: 0
           Exec_Master_Log_Pos: 67890
               Relay_Log_Space: 45678
               Until_Condition: None
                Until_Log_File: 
                 Until_Log_Pos: 0
            Master_SSL_Allowed: Yes
            Master_SSL_CA_File: /etc/mysql/ssl/ca-cert.pem
            Master_SSL_CA_Path: 
               Master_SSL_Cert: /etc/mysql/ssl/client-cert.pem
             Master_SSL_Cipher: 
                Master_SSL_Key: /etc/mysql/ssl/client-key.pem
         Seconds_Behind_Master: 0
 Master_SSL_Verify_Server_Cert: Yes
                 Last_IO_Errno: 0
                 Last_IO_Error: 
                Last_SQL_Errno: 0
                Last_SQL_Error: 
   Replicate_Ignore_Server_Ids: 
              Master_Server_Id: 1
                Master_SSL_Crl: 
            Master_SSL_Crlpath: 
                    Using_Gtid: Slave_Pos
                   Gtid_IO_Pos: 0-1-5000
       Replicate_Do_Domain_Ids: 
   Replicate_Ignore_Domain_Ids: 
                 Parallel_Mode: optimistic
                     SQL_Delay: 0
           SQL_Remaining_Delay: NULL
       Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates
              Slave_DDL_Groups: 0
Slave_Non_Transactional_Groups: 0
    Slave_Transactional_Groups: 5000
          Retried_transactions: 0
            Max_relay_log_size: 1073741824
          Executed_log_entries: 5000
     Slave_received_heartbeats: 120
        Slave_heartbeat_period: 30.000
                Gtid_Slave_Pos: 0-1-5000
```

---

## Champs Critiques : √âtat de la R√©plication

### Slave_IO_Running et Slave_SQL_Running

**Les deux champs les plus importants** pour v√©rifier que la r√©plication fonctionne.

```sql
Slave_IO_Running: Yes
Slave_SQL_Running: Yes
```

**Valeurs possibles** :

| Valeur | Signification | Action |
|--------|---------------|--------|
| **Yes** | Thread actif et fonctionnel | ‚úÖ OK |
| **No** | Thread arr√™t√© (erreur ou STOP REPLICA) | ‚ö†Ô∏è Investiguer |
| **Connecting** | I/O thread tente de se connecter | ‚è≥ Attendre ou v√©rifier r√©seau |

**Interpr√©tation** :

```sql
-- ‚úÖ CAS OK : R√©plication normale
Slave_IO_Running: Yes
Slave_SQL_Running: Yes
‚Üí R√©plication fonctionne correctement

-- ‚ùå CAS ERREUR : I/O thread arr√™t√©
Slave_IO_Running: No
Slave_SQL_Running: Yes
‚Üí Probl√®me de connexion au Primary ou erreur I/O
‚Üí V√©rifier : Last_IO_Errno, Last_IO_Error

-- ‚ùå CAS ERREUR : SQL thread arr√™t√©
Slave_IO_Running: Yes
Slave_SQL_Running: No
‚Üí Erreur d'application des √©v√©nements (conflit, contrainte)
‚Üí V√©rifier : Last_SQL_Errno, Last_SQL_Error

-- ‚ùå CAS CRITIQUE : Les deux threads arr√™t√©s
Slave_IO_Running: No
Slave_SQL_Running: No
‚Üí R√©plication compl√®tement arr√™t√©e
‚Üí V√©rifier : Last_Errno, ou STOP REPLICA manuel
```

### Slave_IO_State

D√©crit l'**√©tat actuel du thread I/O**.

```sql
Slave_IO_State: Waiting for master to send event
```

**√âtats courants** :

| √âtat | Signification | Normal ? |
|------|---------------|----------|
| `Waiting for master to send event` | Connect√©, en attente d'√©v√©nements | ‚úÖ Normal |
| `Connecting to master` | Tentative de connexion en cours | ‚è≥ Temporaire |
| `Reconnecting after a failed master event read` | Reconnexion apr√®s erreur | ‚ö†Ô∏è V√©rifier r√©seau |
| `Waiting for master heartbeat` | En attente de heartbeat | ‚úÖ Normal |
| `Queueing master event to the relay log` | √âcriture dans relay log | ‚úÖ Normal |
| (Vide) | Thread I/O arr√™t√© | ‚ùå Probl√®me |

üí° **Bon r√©flexe** : Si `Slave_IO_State` est vide et `Slave_IO_Running = No`, v√©rifier `Last_IO_Error`.

### Slave_SQL_Running_State

D√©crit l'**√©tat actuel du thread SQL**.

```sql
Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates
```

**√âtats courants** :

| √âtat | Signification |
|------|---------------|
| `Slave has read all relay log; waiting for more updates` | ‚úÖ √Ä jour, en attente |
| `Reading event from the relay log` | ‚úÖ Lecture relay log |
| `Making temporary file` | ‚ö†Ô∏è Op√©ration temporaire (LOAD DATA) |
| `Waiting for dependent transaction to commit` | ‚ö†Ô∏è R√©plication parall√®le (normal) |
| `Applying batch of row changes` | ‚úÖ Application ROW events |
| (Vide) | ‚ùå Thread SQL arr√™t√© |

---

## Champs Critiques : Positions et Synchronisation

### Master_Log_File et Read_Master_Log_Pos

Position de **lecture** dans le binlog du Primary par le thread I/O.

```sql
Master_Log_File: mariadb-bin.000003
Read_Master_Log_Pos: 67890
```

**Signification** :
- Le thread I/O a **lu** jusqu'√† la position 67890 du fichier `mariadb-bin.000003` sur le Primary
- Ces √©v√©nements sont **stock√©s** dans le relay log, mais pas forc√©ment encore **ex√©cut√©s**

### Exec_Master_Log_Pos

Position **d'ex√©cution** dans le binlog du Primary par le thread SQL.

```sql
Exec_Master_Log_Pos: 67850
```

**Signification** :
- Le thread SQL a **ex√©cut√©** jusqu'√† la position 67850 du binlog du Primary
- Si `Read_Master_Log_Pos > Exec_Master_Log_Pos`, il y a un **lag d'ex√©cution**

**Calcul du lag (en octets)** :

```sql
-- Lag = Position lue - Position ex√©cut√©e
Lag (octets) = Read_Master_Log_Pos - Exec_Master_Log_Pos
             = 67890 - 67850
             = 40 octets
```

‚ö†Ô∏è **Attention** : Le lag en octets n'est **pas** une mesure du temps. Utilisez `Seconds_Behind_Master` pour le lag temporel.

### Relay_Log_File et Relay_Log_Pos

Position dans le **relay log local**.

```sql
Relay_Log_File: relay-bin.000005
Relay_Log_Pos: 12345
```

**Signification** :
- Le thread SQL lit actuellement le fichier `relay-bin.000005` √† la position 12345
- Le relay log contient une **copie locale** des √©v√©nements du binlog du Primary

### Relay_Log_Space

Espace disque total utilis√© par **tous les relay logs**.

```sql
Relay_Log_Space: 45678910  -- octets
```

**Surveillance** :

```sql
-- Convertir en MB/GB
SELECT 
  Relay_Log_Space / 1024 / 1024 AS relay_log_mb,
  Relay_Log_Space / 1024 / 1024 / 1024 AS relay_log_gb
FROM information_schema.SLAVE_STATUS;
```

‚ö†Ô∏è **Alerte** : Si `Relay_Log_Space` augmente continuellement, le Replica ne suit pas le rythme (lag croissant).

---

## Champs Critiques : GTID

### Using_Gtid

Indique si GTID est utilis√© pour la r√©plication.

```sql
Using_Gtid: Slave_Pos
```

**Valeurs possibles** :

| Valeur | Signification |
|--------|---------------|
| `No` | GTID d√©sactiv√©, utilise positions binlog |
| `Slave_Pos` | ‚úÖ GTID activ√©, utilise `@@gtid_slave_pos` |
| `Current_Pos` | GTID activ√©, utilise `@@gtid_current_pos` |

üí° **Production** : `Slave_Pos` est la valeur recommand√©e pour production moderne.

### Gtid_IO_Pos

Position GTID **lue** par le thread I/O depuis le Primary.

```sql
Gtid_IO_Pos: 0-1-5000
```

**Format** : `domain_id-server_id-sequence_number`

**Signification** :
- Le thread I/O a lu jusqu'√† la transaction avec GTID `0-1-5000`
- Ces √©v√©nements sont dans le relay log, mais pas forc√©ment ex√©cut√©s

### Gtid_Slave_Pos

Position GTID **ex√©cut√©e** par le thread SQL.

```sql
Gtid_Slave_Pos: 0-1-4998
```

**Signification** :
- Le thread SQL a ex√©cut√© jusqu'√† la transaction avec GTID `0-1-4998`
- Lag GTID = `5000 - 4998 = 2 transactions`

**Multi-source** :

```sql
Gtid_Slave_Pos: 0-100-5000,1-200-3000,2-300-1500
```

Chaque domain a sa propre s√©quence :
- Domain 0 : Position 5000 (server_id 100)
- Domain 1 : Position 3000 (server_id 200)
- Domain 2 : Position 1500 (server_id 300)

---

## Champs Critiques : Lag de R√©plication

### Seconds_Behind_Master

**LA m√©trique principale** pour mesurer le lag de r√©plication.

```sql
Seconds_Behind_Master: 0
```

**Interpr√©tation** :

| Valeur | Signification | Action |
|--------|---------------|--------|
| `0` | ‚úÖ Pas de lag, Replica √† jour | Parfait |
| `1-60` | ‚úÖ Lag acceptable (< 1 minute) | Surveiller |
| `60-300` | ‚ö†Ô∏è Lag mod√©r√© (1-5 minutes) | Investiguer |
| `300-3600` | ‚ùå Lag √©lev√© (5-60 minutes) | Action requise |
| `> 3600` | ‚ùå Lag critique (> 1 heure) | Urgence |
| `NULL` | ‚ö†Ô∏è R√©plication arr√™t√©e ou en cours de d√©marrage | V√©rifier √©tat |

**Calcul** :

```
Seconds_Behind_Master = Temps_actuel - Timestamp_derni√®re_transaction_ex√©cut√©e
```

**Exemple** :

```sql
-- Il est 14:00:00
-- Derni√®re transaction ex√©cut√©e avait timestamp : 13:59:50
-- Seconds_Behind_Master = 14:00:00 - 13:59:50 = 10 secondes
```

‚ö†Ô∏è **Limitations** :

1. **Delayed replication** : Si `SQL_Delay = 3600`, alors `Seconds_Behind_Master ‚â• 3600` est **normal**
2. **Transactions longues** : Une transaction de 30 minutes sur le Primary peut fausser la m√©trique
3. **Pas d'√©v√©nements** : Si le Primary est inactif, le lag peut appara√Ætre artificiellement √©lev√©

**Lag r√©el avec delayed replication** :

```sql
-- Si SQL_Delay configur√©
Lag_r√©el = Seconds_Behind_Master - SQL_Delay

-- Exemple :
Seconds_Behind_Master: 3610
SQL_Delay: 3600
Lag_r√©el = 3610 - 3600 = 10 secondes (acceptable)
```

### SQL_Delay et SQL_Remaining_Delay

Pour les **delayed replications** (r√©plication retard√©e intentionnellement).

```sql
SQL_Delay: 3600              -- D√©lai configur√© (1 heure)
SQL_Remaining_Delay: 2456    -- Temps restant avant ex√©cution
```

**Usage** :

```sql
-- Configurer un d√©lai de 1 heure
CHANGE REPLICATION SOURCE TO SOURCE_DELAY = 3600;

-- V√©rifier
SHOW REPLICA STATUS\G
-- SQL_Delay: 3600
-- SQL_Remaining_Delay: NULL (si pas d'√©v√©nement en attente)
```

üí° **Cas d'usage** : Protection contre les DROP TABLE accidentels, fen√™tre de r√©cup√©ration.

---

## Champs Critiques : Erreurs

### Last_Errno, Last_Error

**Derni√®re erreur globale** de r√©plication (I/O ou SQL).

```sql
Last_Errno: 0
Last_Error: 
```

- `0` = Pas d'erreur
- `> 0` = Code d'erreur MySQL/MariaDB

### Last_IO_Errno, Last_IO_Error

**Derni√®re erreur du thread I/O** (connexion, lecture binlog).

```sql
Last_IO_Errno: 2003
Last_IO_Error: Can't connect to MySQL server on '192.168.1.100' (111)
```

**Erreurs courantes** :

| Errno | Erreur | Cause |
|-------|--------|-------|
| `2003` | Connection refused | Firewall, Primary arr√™t√© |
| `1045` | Access denied | Credentials incorrects |
| `1236` | Binlog file not found | Binlog purg√© sur Primary |
| `2013` | Lost connection | Timeout r√©seau |

### Last_SQL_Errno, Last_SQL_Error

**Derni√®re erreur du thread SQL** (application des √©v√©nements).

```sql
Last_SQL_Errno: 1062
Last_SQL_Error: Error 'Duplicate entry '123' for key 'PRIMARY'' on query...
```

**Erreurs courantes** :

| Errno | Erreur | Cause |
|-------|--------|-------|
| `1062` | Duplicate entry | Cl√© primaire/unique d√©j√† existante |
| `1032` | Can't find record | Ligne manquante (DELETE/UPDATE d'une ligne inexistante) |
| `1146` | Table doesn't exist | Table manquante sur Replica |
| `1452` | Foreign key constraint | Violation de contrainte FK |

üí° **Diagnostic** : Quand `Slave_SQL_Running = No`, **toujours** v√©rifier `Last_SQL_Error` pour identifier le probl√®me.

---

## Champs de Configuration

### Master_Host, Master_Port, Master_User

Configuration de connexion au Primary.

```sql
Master_Host: 192.168.1.100
Master_Port: 3306
Master_User: repl_user
```

### Connect_Retry

D√©lai (secondes) entre les tentatives de reconnexion.

```sql
Connect_Retry: 60
```

### Master_SSL_*

Configuration SSL/TLS de la connexion.

```sql
Master_SSL_Allowed: Yes
Master_SSL_CA_File: /etc/mysql/ssl/ca-cert.pem
Master_SSL_Cert: /etc/mysql/ssl/client-cert.pem
Master_SSL_Key: /etc/mysql/ssl/client-key.pem
Master_SSL_Verify_Server_Cert: Yes
```

‚úÖ **Production** : `Master_SSL_Allowed = Yes` est obligatoire pour s√©curit√©.

### Filtrage de R√©plication

```sql
Replicate_Do_DB: production,analytics
Replicate_Ignore_DB: test,staging
Replicate_Do_Table: production.orders,production.users
Replicate_Ignore_Table: 
Replicate_Wild_Do_Table: production.%
Replicate_Wild_Ignore_Table: %.temp_%
Replicate_Ignore_Server_Ids: 3,4,5
Replicate_Do_Domain_Ids: 0,1
Replicate_Ignore_Domain_Ids: 2,3
```

---

## Champs de Performance

### Parallel_Mode

Mode de parall√©lisation de la r√©plication.

```sql
Parallel_Mode: optimistic
```

**Valeurs** :

| Mode | Description |
|------|-------------|
| `none` | Pas de parall√©lisation (d√©faut legacy) |
| `conservative` | Parall√©lisation prudente |
| `optimistic` | ‚úÖ Parall√©lisation agressive (recommand√©) |
| `aggressive` | Maximum parall√®le (depuis 10.3) |

### Slave_DDL_Groups, Slave_Transactional_Groups

Compteurs de transactions appliqu√©es.

```sql
Slave_DDL_Groups: 0                 -- DDL statements
Slave_Transactional_Groups: 5000    -- DML transactions
Slave_Non_Transactional_Groups: 0   -- MyISAM, etc.
```

üí° **Monitoring** : Suivre l'√©volution de ces compteurs pour mesurer le throughput.

### Executed_log_entries

Nombre total d'√©v√©nements ex√©cut√©s depuis le d√©marrage de la r√©plication.

```sql
Executed_log_entries: 5000
```

### Slave_received_heartbeats, Slave_heartbeat_period

Monitoring des heartbeats.

```sql
Slave_received_heartbeats: 120       -- Nombre de heartbeats re√ßus
Slave_heartbeat_period: 30.000       -- Intervalle (secondes)
```

üí° **Sant√© de connexion** : Si `Slave_received_heartbeats` n'augmente pas, probl√®me de connexion.

---

## Requ√™tes de Monitoring Automatis√©es

### V√©rification rapide de sant√©

```sql
-- Requ√™te de sant√© globale
SELECT 
  Slave_IO_Running,
  Slave_SQL_Running,
  Seconds_Behind_Master,
  Last_Errno,
  Last_Error,
  Using_Gtid,
  Gtid_Slave_Pos
FROM information_schema.SLAVE_STATUS
WHERE Slave_IO_Running != 'Yes' 
   OR Slave_SQL_Running != 'Yes'
   OR Seconds_Behind_Master > 60
   OR Last_Errno != 0\G
```

Si cette requ√™te retourne des lignes ‚Üí **Probl√®me d√©tect√©**.

### Monitoring du lag

```sql
-- Lag actuel
SELECT 
  COALESCE(Seconds_Behind_Master, -1) AS lag_seconds,
  CASE 
    WHEN Seconds_Behind_Master IS NULL THEN 'STOPPED'
    WHEN Seconds_Behind_Master = 0 THEN 'OK'
    WHEN Seconds_Behind_Master <= 60 THEN 'WARNING'
    WHEN Seconds_Behind_Master > 60 THEN 'CRITICAL'
  END AS lag_status
FROM information_schema.SLAVE_STATUS;
```

### Monitoring GTID

```sql
-- Positions GTID
SELECT 
  Using_Gtid,
  Gtid_IO_Pos AS io_position,
  Gtid_Slave_Pos AS exec_position,
  -- Extraire le sequence number (simplifi√© pour domain 0)
  CAST(SUBSTRING_INDEX(Gtid_IO_Pos, '-', -1) AS UNSIGNED) AS io_seq,
  CAST(SUBSTRING_INDEX(Gtid_Slave_Pos, '-', -1) AS UNSIGNED) AS exec_seq,
  -- Lag GTID
  CAST(SUBSTRING_INDEX(Gtid_IO_Pos, '-', -1) AS UNSIGNED) - 
  CAST(SUBSTRING_INDEX(Gtid_Slave_Pos, '-', -1) AS UNSIGNED) AS gtid_lag
FROM information_schema.SLAVE_STATUS;
```

### Monitoring erreurs

```sql
-- Toutes les erreurs actives
SELECT 
  Connection_name,
  CASE 
    WHEN Last_IO_Errno != 0 THEN CONCAT('IO: ', Last_IO_Errno, ' - ', Last_IO_Error)
    WHEN Last_SQL_Errno != 0 THEN CONCAT('SQL: ', Last_SQL_Errno, ' - ', Last_SQL_Error)
    ELSE 'No errors'
  END AS error_info
FROM information_schema.SLAVE_STATUS
WHERE Last_IO_Errno != 0 OR Last_SQL_Errno != 0;
```

### Monitoring multi-source

```sql
-- Statut de toutes les connexions
SELECT 
  Connection_name,
  Slave_IO_Running,
  Slave_SQL_Running,
  Seconds_Behind_Master,
  Gtid_Slave_Pos,
  Last_Error
FROM information_schema.SLAVE_STATUS
ORDER BY Connection_name;
```

---

## Scripts de Monitoring Production

### Script Bash de surveillance

```bash
#!/bin/bash
# check_replication.sh - Monitoring de r√©plication MariaDB

MYSQL="mariadb -N -e"
THRESHOLD_WARN=60        # Lag warning √† 60s
THRESHOLD_CRIT=300       # Lag critical √† 300s

# Fonction de v√©rification
check_replication() {
  # R√©cup√©rer les m√©triques
  IO_RUNNING=$($MYSQL "SELECT Slave_IO_Running FROM information_schema.SLAVE_STATUS")
  SQL_RUNNING=$($MYSQL "SELECT Slave_SQL_Running FROM information_schema.SLAVE_STATUS")
  LAG=$($MYSQL "SELECT COALESCE(Seconds_Behind_Master, -1) FROM information_schema.SLAVE_STATUS")
  LAST_ERROR=$($MYSQL "SELECT Last_Error FROM information_schema.SLAVE_STATUS")
  
  # V√©rifier √©tat des threads
  if [ "$IO_RUNNING" != "Yes" ] || [ "$SQL_RUNNING" != "Yes" ]; then
    echo "CRITICAL: Replication stopped!"
    echo "IO Running: $IO_RUNNING"
    echo "SQL Running: $SQL_RUNNING"
    echo "Last Error: $LAST_ERROR"
    exit 2
  fi
  
  # V√©rifier le lag
  if [ "$LAG" -eq -1 ]; then
    echo "WARNING: Lag is NULL (replication may be stopped or starting)"
    exit 1
  elif [ "$LAG" -ge "$THRESHOLD_CRIT" ]; then
    echo "CRITICAL: Lag is $LAG seconds (>$THRESHOLD_CRIT)"
    exit 2
  elif [ "$LAG" -ge "$THRESHOLD_WARN" ]; then
    echo "WARNING: Lag is $LAG seconds (>$THRESHOLD_WARN)"
    exit 1
  else
    echo "OK: Replication healthy (lag: $LAG seconds)"
    exit 0
  fi
}

# Ex√©cuter la v√©rification
check_replication
```

### Int√©gration Prometheus (mysqld_exporter)

```sql
-- mysqld_exporter expose automatiquement ces m√©triques :

# mysql_slave_status_slave_io_running (0 ou 1)
# mysql_slave_status_slave_sql_running (0 ou 1)
# mysql_slave_status_seconds_behind_master
# mysql_slave_status_last_errno

-- Exemple de requ√™te Prometheus :
-- Alerter si lag > 60s
alert: ReplicationLagHigh
expr: mysql_slave_status_seconds_behind_master > 60
for: 5m
labels:
  severity: warning
annotations:
  summary: "Replication lag is high on {{ $labels.instance }}"
  description: "Lag is {{ $value }} seconds"
```

### Requ√™te pour Grafana Dashboard

```sql
-- M√©trique lag temporel
SELECT 
  UNIX_TIMESTAMP() AS time_sec,
  COALESCE(Seconds_Behind_Master, 0) AS lag_seconds
FROM information_schema.SLAVE_STATUS;

-- M√©trique GTID lag (transactions)
SELECT 
  UNIX_TIMESTAMP() AS time_sec,
  CAST(SUBSTRING_INDEX(Gtid_IO_Pos, '-', -1) AS UNSIGNED) - 
  CAST(SUBSTRING_INDEX(Gtid_Slave_Pos, '-', -1) AS UNSIGNED) AS gtid_lag
FROM information_schema.SLAVE_STATUS;

-- √âtat binaire (0/1) pour threads
SELECT 
  UNIX_TIMESTAMP() AS time_sec,
  IF(Slave_IO_Running = 'Yes', 1, 0) AS io_running,
  IF(Slave_SQL_Running = 'Yes', 1, 0) AS sql_running
FROM information_schema.SLAVE_STATUS;
```

---

## Interpr√©tation et Troubleshooting

### Sc√©nario 1 : Lag croissant

**Sympt√¥mes** :

```sql
Slave_IO_Running: Yes
Slave_SQL_Running: Yes
Seconds_Behind_Master: 600  -- 10 minutes et augmente
Relay_Log_Space: 10737418240  -- 10 GB
```

**Diagnostic** : Le thread SQL ne suit pas le rythme du thread I/O.

**Causes possibles** :
- CPU/RAM insuffisant sur le Replica
- Disque lent (I/O satur√©)
- Index manquants sur le Replica
- Transactions lourdes
- R√©plication mono-thread (parall√©lisation d√©sactiv√©e)

**Solutions** :

```sql
-- 1. Activer la r√©plication parall√®le
SET GLOBAL slave_parallel_threads = 8;
SET GLOBAL slave_parallel_mode = 'optimistic';

-- 2. V√©rifier les slow queries sur le Replica
SELECT * FROM mysql.slow_log ORDER BY query_time DESC LIMIT 10;

-- 3. Identifier les index manquants
-- Comparer les index entre Primary et Replica
```

### Sc√©nario 2 : I/O thread d√©connect√©

**Sympt√¥mes** :

```sql
Slave_IO_Running: No
Slave_SQL_Running: Yes
Slave_IO_State: 
Last_IO_Errno: 2003
Last_IO_Error: Can't connect to MySQL server on '192.168.1.100' (111)
```

**Diagnostic** : Probl√®me de connexion r√©seau ou Primary down.

**Solutions** :

```bash
# 1. V√©rifier connectivit√© r√©seau
ping 192.168.1.100
telnet 192.168.1.100 3306

# 2. V√©rifier firewall
sudo iptables -L -n | grep 3306

# 3. V√©rifier que Primary est up
mariadb -h 192.168.1.100 -u repl_user -p

# 4. Red√©marrer la r√©plication si connectivit√© OK
mariadb -e "START REPLICA IO_THREAD"
```

### Sc√©nario 3 : SQL thread erreur 1062 (duplicate key)

**Sympt√¥mes** :

```sql
Slave_IO_Running: Yes
Slave_SQL_Running: No
Last_SQL_Errno: 1062
Last_SQL_Error: Error 'Duplicate entry '123' for key 'PRIMARY'' on query...
Exec_Master_Log_Pos: 67850
```

**Diagnostic** : Tentative d'insertion d'une cl√© d√©j√† existante.

**Causes possibles** :
- √âcriture manuelle sur le Replica (super_read_only = OFF)
- √âv√©nement d√©j√† appliqu√© (replay)
- Corruption

**Solutions** :

```sql
-- 1. V√©rifier si la ligne existe vraiment
SELECT * FROM table_name WHERE id = 123;

-- 2. Option A : Supprimer la ligne conflictuelle
DELETE FROM table_name WHERE id = 123;
START REPLICA SQL_THREAD;

-- 3. Option B : Sauter l'√©v√©nement (DANGEREUX)
STOP REPLICA;
SET GLOBAL sql_slave_skip_counter = 1;
START REPLICA;

-- 4. Option C : Avec GTID, sauter un GTID sp√©cifique
-- Incr√©menter manuellement la position
SET GLOBAL gtid_slave_pos = '0-1-67851';  -- Position suivante
START REPLICA;
```

‚ö†Ô∏è **Pr√©vention** : Toujours activer `super_read_only = ON` sur les Replicas.

### Sc√©nario 4 : GTID position not found

**Sympt√¥mes** :

```sql
Slave_IO_Running: No
Last_IO_Errno: 1236
Last_IO_Error: Got fatal error 1236 from master: 
  'The slave is connecting using GTID, it requested events starting with GTID 0-1-1000,
   which is not in the master's binlog'
```

**Diagnostic** : Le binlog demand√© a √©t√© purg√© sur le Primary.

**Solutions** :

```sql
-- Option 1 : Utiliser current_pos pour sauter au binlog actuel
STOP REPLICA;
CHANGE REPLICATION SOURCE TO SOURCE_USE_GTID = current_pos;
START REPLICA;
-- ‚ö†Ô∏è Risque de perte de donn√©es si lag important

-- Option 2 : Refaire un snapshot complet (recommand√©)
-- 1. Sur Primary : Dump avec position GTID
-- 2. Sur Replica : Restaurer et reconfigurer GTID
```

---

## Diff√©rences SHOW SLAVE STATUS vs SHOW REPLICA STATUS

### Changement de nomenclature

| MariaDB < 10.5 | MariaDB ‚â• 10.5 | Notes |
|----------------|----------------|-------|
| `SHOW SLAVE STATUS` | `SHOW REPLICA STATUS` | ‚úÖ Nouvelle syntaxe |
| `SHOW SLAVE 'name' STATUS` | `SHOW REPLICA 'name' STATUS` | Multi-source |
| `SHOW ALL SLAVES STATUS` | `SHOW ALL REPLICAS STATUS` | Toutes connexions |
| - | - | Les deux syntaxes restent compatibles |

### Noms de champs

La plupart des champs restent identiques, mais certains ont chang√© :

| Ancien nom | Nouveau nom (MariaDB 10.5+) |
|------------|----------------------------|
| `Slave_IO_State` | Identique |
| `Slave_IO_Running` | Identique |
| `Slave_SQL_Running` | Identique |
| `Seconds_Behind_Master` | Identique (pas renomm√©) |

üí° **Compatibilit√©** : Les anciens noms de champs restent valides, mais utilisez la nouvelle syntaxe pour le futur.

---

## Nouveaut√©s MariaDB 11.8

### Support am√©lior√© Optimistic ALTER TABLE

```sql
-- Nouveau champ (hypoth√©tique pour 11.8)
Optimistic_DDL_Active: Yes
Optimistic_DDL_Table: huge_orders
Optimistic_DDL_Progress: 45%

-- Si un ALTER optimistic est en cours, cela pourrait appara√Ætre dans :
Slave_SQL_Running_State: Applying optimistic ALTER TABLE...
```

üÜï **Impact** : Pendant un ALTER lourd, `Seconds_Behind_Master` pour les autres tables reste faible gr√¢ce √† Optimistic ALTER.

### M√©triques de performance am√©lior√©es

```sql
-- Nouveaux compteurs de performance (11.8)
Slave_Parallel_Workers_Active: 8
Slave_Parallel_Queue_Size: 1024
Slave_Compression_Ratio: 65.4  -- % compression
```

---

## ‚úÖ Points cl√©s √† retenir

- **SHOW REPLICA STATUS** est la commande essentielle pour monitorer la r√©plication
- **Slave_IO_Running** et **Slave_SQL_Running** doivent toujours √™tre **Yes**
- **Seconds_Behind_Master** est la m√©trique principale du lag (0 = parfait)
- **Last_IO_Error** et **Last_SQL_Error** indiquent les probl√®mes de r√©plication
- **Using_Gtid** devrait √™tre **Slave_Pos** en production moderne
- **Gtid_Slave_Pos** montre la position d'ex√©cution avec GTID
- La requ√™te via **information_schema.SLAVE_STATUS** permet le monitoring automatis√©
- **Multi-source** : `SHOW ALL REPLICAS STATUS` affiche toutes les connexions
- **Relay_Log_Space** croissant indique que le Replica ne suit pas le rythme
- üÜï **MariaDB 11.8** : Support Optimistic ALTER r√©duit le lag durant DDL lourds
- Int√©gration facile avec **Prometheus, Grafana, Nagios** pour alerting
- **NULL** dans Seconds_Behind_Master = r√©plication arr√™t√©e ou d√©marrage

---

## üîó Ressources et r√©f√©rences

- [üìñ SHOW REPLICA STATUS Documentation](https://mariadb.com/kb/en/show-replica-status/)
- [üìñ Replication Monitoring](https://mariadb.com/kb/en/replication-monitoring/)
- [üìñ INFORMATION_SCHEMA.SLAVE_STATUS](https://mariadb.com/kb/en/information-schema-slave_status-table/)
- [üìñ Troubleshooting Replication](https://mariadb.com/kb/en/troubleshooting-replication/)
- [üìÑ Blog : Monitoring MariaDB Replication](https://mariadb.com/resources/blog/monitoring-mariadb-replication/)

---

## ‚û°Ô∏è Section suivante

**13.7.2 Seconds_Behind_Master et lag** : Nous allons approfondir la m√©trique Seconds_Behind_Master, ses limitations, ses alternatives, et comment mesurer pr√©cis√©ment le lag de r√©plication.

---


‚è≠Ô∏è [Seconds_Behind_Master et lag](/13-replication/07.2-seconds-behind-master.md)
