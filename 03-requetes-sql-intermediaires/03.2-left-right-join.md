üîù Retour au [Sommaire](/SOMMAIRE.md)

# 3.3.2 LEFT/RIGHT JOIN : Jointures externes

> **Niveau** : Interm√©diaire
> **Dur√©e estim√©e** : 2-3 heures
> **Pr√©requis** : Section 3.3.1 (INNER JOIN), compr√©hension de NULL

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre la diff√©rence fondamentale entre jointures internes et externes
- Ma√Ætriser LEFT JOIN pour pr√©server toutes les lignes de la table de gauche
- Utiliser RIGHT JOIN et comprendre pourquoi il est moins utilis√©
- Diff√©rencier l'impact de ON vs WHERE sur les jointures externes
- D√©tecter les valeurs manquantes et les orphelins avec IS NULL
- Appliquer les jointures externes √† des cas d'usage m√©tier r√©els
- Combiner LEFT JOIN avec agr√©gations pour des analyses compl√®tes
- Optimiser les performances des jointures externes

---

## Introduction

Les **jointures externes** (OUTER JOIN) pr√©servent **toutes les lignes** d'un c√¥t√© de la jointure, m√™me s'il n'y a **pas de correspondance** de l'autre c√¥t√©. Les colonnes sans correspondance sont remplies avec **NULL**.

### Diff√©rence fondamentale : INNER vs OUTER JOIN

```
INNER JOIN (intersection)          LEFT JOIN (tout gauche + correspondances)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   A   ‚îÇ                           ‚îÇ   A   ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                     ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ‚îÇ AAA ‚îÇ  B  ‚îÇ                     ‚îÇ ‚îÇ AAA ‚îÇ  B  ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                     ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ       ‚îÇ                           ‚îÇ AAA   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
R√©sultat : AAA                      R√©sultat : AAA (avec B) + AAA (sans B, NULL)
Exclut ce qui n'a pas de match     Pr√©serve tout A, NULL si pas de match
```

### Quand utiliser les jointures externes ?

| Situation | Type de jointure | Exemple |
|-----------|------------------|---------|
| "Donne-moi seulement ce qui existe des deux c√¥t√©s" | **INNER JOIN** | Clients ayant command√© |
| "Donne-moi TOUS les clients, avec ou sans commandes" | **LEFT JOIN** | Tous les clients + d√©tection inactifs |
| "Donne-moi TOUS les produits, m√™me non vendus" | **LEFT JOIN** | Inventaire complet + analyse ventes |
| "Trouve ce qui manque" (orphelins) | **LEFT JOIN + IS NULL** | Clients sans commandes, produits non vendus |

üí° **En r√©sum√©** :
- **INNER JOIN** = Seulement les correspondances ‚úÖ‚úÖ
- **LEFT JOIN** = Tout √† gauche + correspondances √† droite ‚úÖ(‚úÖ ou NULL)

---

## LEFT JOIN : Pr√©server la table de gauche

### Syntaxe

```sql
SELECT colonnes
FROM table_gauche
LEFT JOIN table_droite
    ON table_gauche.colonne = table_droite.colonne
[WHERE conditions];
```

**Alias** : `LEFT JOIN` = `LEFT OUTER JOIN` (OUTER est optionnel)

### Principe de fonctionnement

1. **Toutes les lignes de la table de gauche** sont incluses dans le r√©sultat
2. Pour chaque ligne de gauche, MariaDB cherche les correspondances √† droite
3. **Si correspondance trouv√©e** : colonnes de droite remplies avec valeurs
4. **Si aucune correspondance** : colonnes de droite remplies avec **NULL**

### Exemple 1 : LEFT JOIN basique

**Question m√©tier** : *Liste de TOUS les clients avec leurs commandes (s'ils en ont)*

```sql
-- Donn√©es de test
-- clients : Alice (id=1), Bob (id=2), Charlie (id=3)
-- commandes : Alice a 2 commandes, Bob a 1 commande, Charlie a 0 commande

-- LEFT JOIN : Tous les clients apparaissent
SELECT
    c.id_client,
    c.nom,
    cmd.id_commande,
    cmd.montant_total
FROM clients c
LEFT JOIN commandes cmd
    ON c.id_client = cmd.id_client
ORDER BY c.nom;
```

**R√©sultat attendu** :
```
+------------+----------------+--------------+---------------+
| id_client  | nom            | id_commande  | montant_total |
+------------+----------------+--------------+---------------+
|          1 | Alice Martin   |         1001 |        289.95 |
|          1 | Alice Martin   |         1002 |        149.99 |
|          2 | Bob Dupont     |         1003 |         89.99 |
|          3 | Charlie Durand |         NULL |          NULL |  ‚Üê Pas de commande
+------------+----------------+--------------+---------------+
```

**Explication** :
- **Alice et Bob** : Ont des commandes ‚Üí colonnes de droite remplies
- **Charlie** : N'a **aucune commande** ‚Üí `id_commande` et `montant_total` = **NULL**
- Charlie **appara√Æt quand m√™me** (contrairement √† INNER JOIN)

**Comparaison avec INNER JOIN** :

```sql
-- INNER JOIN : Charlie n'appara√Æt PAS
SELECT c.nom, cmd.id_commande
FROM clients c
INNER JOIN commandes cmd ON c.id_client = cmd.id_client;

-- R√©sultat : 3 lignes (Alice 2x, Bob 1x, Charlie 0x)
```

### Exemple 2 : Compter les commandes par client (tous les clients)

**Question m√©tier** : *Nombre de commandes par client, incluant ceux qui n'ont jamais command√©*

```sql
-- Comptage avec LEFT JOIN
SELECT
    c.id_client,
    c.nom,
    c.email,
    COUNT(cmd.id_commande) AS nb_commandes,  -- COUNT ignore les NULL
    COALESCE(SUM(cmd.montant_total), 0) AS ca_total
FROM clients c
LEFT JOIN commandes cmd
    ON c.id_client = cmd.id_client
WHERE cmd.statut IN ('confirm√©e', 'exp√©di√©e', 'livr√©e')
   OR cmd.statut IS NULL  -- Important : inclure les clients sans commande
GROUP BY c.id_client, c.nom, c.email
ORDER BY nb_commandes DESC;
```

**R√©sultat attendu** :
```
+------------+----------------+-------------------+--------------+----------+
| id_client  | nom            | email             | nb_commandes | ca_total |
+------------+----------------+-------------------+--------------+----------+
|       1847 | Alice Martin   | alice@email.com   |           47 | 14283.45 |
|       2934 | Bob Dupont     | bob@email.com     |           38 | 12847.92 |
|        892 | Charlie Durand | charlie@email.com |            0 |     0.00 |
|       1245 | Diana Lopez    | diana@email.com   |            0 |     0.00 |
+------------+----------------+-------------------+--------------+----------+
```

**Points cl√©s** :
- ‚úÖ **Tous les clients** apparaissent (LEFT JOIN)
- ‚úÖ `COUNT(cmd.id_commande)` retourne **0** pour clients sans commandes (COUNT ignore NULL)
- ‚úÖ `COALESCE(SUM(...), 0)` transforme NULL en 0 pour l'affichage
- ‚ö†Ô∏è WHERE doit inclure `OR cmd.statut IS NULL` pour ne pas exclure les clients sans commande

### Exemple 3 : D√©tecter les clients inactifs

**Question m√©tier** : *Quels clients n'ont JAMAIS command√© ?*

```sql
-- Clients sans aucune commande
SELECT
    c.id_client,
    c.nom,
    c.email,
    c.date_inscription
FROM clients c
LEFT JOIN commandes cmd
    ON c.id_client = cmd.id_client
WHERE cmd.id_commande IS NULL  -- Aucune correspondance dans commandes
ORDER BY c.date_inscription;
```

**R√©sultat attendu** :
```
+------------+----------------+-------------------+---------------------+
| id_client  | nom            | email             | date_inscription    |
+------------+----------------+-------------------+---------------------+
|        892 | Charlie Durand | charlie@email.com | 2025-01-15 10:23:00 |
|       1245 | Diana Lopez    | diana@email.com   | 2025-02-20 14:47:00 |
|       2847 | √âric Moreau    | eric@email.com    | 2025-03-10 09:12:00 |
+------------+----------------+-------------------+---------------------+
```

**Explication** :
- LEFT JOIN pr√©serve tous les clients
- `WHERE cmd.id_commande IS NULL` filtre seulement ceux **sans correspondance**
- **Pattern classique** : `LEFT JOIN ... WHERE colonne_droite IS NULL` = trouver les orphelins

**Cas d'usage** :
- Campagnes de r√©activation
- Identification de leads froids
- Nettoyage de base de donn√©es

### Exemple 4 : Produits jamais vendus

**Question m√©tier** : *Quels produits n'ont jamais √©t√© command√©s ?*

```sql
-- Produits sans aucune vente
SELECT
    p.id_produit,
    p.nom_produit,
    p.categorie,
    p.prix_unitaire,
    p.stock
FROM produits p
LEFT JOIN details_commande dc
    ON p.id_produit = dc.id_produit
WHERE dc.id_detail IS NULL  -- Jamais dans une commande
ORDER BY p.categorie, p.nom_produit;
```

**R√©sultat attendu** :
```
+------------+-------------------------+---------------+---------------+-------+
| id_produit | nom_produit             | categorie     | prix_unitaire | stock |
+------------+-------------------------+---------------+---------------+-------+
|       2847 | Livre ancien rare       | Livres        |        189.99 |     3 |
|       3194 | Gadget inutile          | Divers        |         12.99 |   247 |
|       4721 | D√©coration vintage      | Maison        |         89.95 |    12 |
+------------+-------------------------+---------------+---------------+-------+
```

**Cas d'usage** :
- Identification de produits √† promouvoir
- R√©vision de l'assortiment
- D√©tection de produits obsol√®tes
- Gestion des stocks dormants

---

## LEFT JOIN avec agr√©gations

### Exemple 5 : Tous les clients avec statistiques de commandes

**Question m√©tier** : *Vue compl√®te : tous les clients avec leurs m√©triques de commande*

```sql
-- Statistiques compl√®tes par client
SELECT
    c.id_client,
    c.nom,
    c.ville,
    c.pays,
    COUNT(cmd.id_commande) AS nb_commandes,
    COALESCE(MIN(cmd.date_commande), 'Jamais') AS premiere_commande,
    COALESCE(MAX(cmd.date_commande), 'Jamais') AS derniere_commande,
    ROUND(COALESCE(SUM(cmd.montant_total), 0), 2) AS ca_total,
    ROUND(COALESCE(AVG(cmd.montant_total), 0), 2) AS panier_moyen
FROM clients c
LEFT JOIN commandes cmd
    ON c.id_client = cmd.id_client
    AND cmd.statut IN ('confirm√©e', 'exp√©di√©e', 'livr√©e')  -- Condition dans ON
GROUP BY c.id_client, c.nom, c.ville, c.pays
ORDER BY ca_total DESC;
```

**R√©sultat attendu** :
```
+------------+----------------+-------------+---------+--------------+---------------------+---------------------+----------+--------------+
| id_client  | nom            | ville       | pays    | nb_commandes | premiere_commande   | derniere_commande   | ca_total | panier_moyen |
+------------+----------------+-------------+---------+--------------+---------------------+---------------------+----------+--------------+
|       1847 | Alice Martin   | Paris       | France  |           47 | 2024-02-15 10:23:00 | 2025-12-08 15:42:00 | 14283.45 |       303.90 |
|       2934 | Bob Dupont     | Lyon        | France  |           38 | 2023-11-20 08:15:00 | 2025-11-30 19:23:00 | 12847.92 |       338.10 |
|        892 | Charlie Durand | Bruxelles   | Belgique|            0 | Jamais              | Jamais              |     0.00 |         0.00 |
+------------+----------------+-------------+---------+--------------+---------------------+---------------------+----------+--------------+
```

**Points techniques** :
- `COUNT(cmd.id_commande)` = 0 pour clients sans commandes (COUNT ignore NULL)
- `COALESCE(..., 0)` ou `COALESCE(..., 'Jamais')` g√®re l'affichage des NULL
- Condition `AND cmd.statut IN (...)` dans ON (nous y reviendrons)

### Exemple 6 : Produits avec volume de ventes

**Question m√©tier** : *Tous les produits avec quantit√©s vendues (y compris 0)*

```sql
-- Inventaire complet avec ventes
SELECT
    p.id_produit,
    p.nom_produit,
    p.categorie,
    p.stock AS stock_actuel,
    COUNT(dc.id_detail) AS nb_ventes,
    COALESCE(SUM(dc.quantite), 0) AS quantite_vendue,
    ROUND(COALESCE(SUM(dc.quantite * dc.prix_unitaire), 0), 2) AS ca_produit
FROM produits p
LEFT JOIN details_commande dc
    ON p.id_produit = dc.id_produit
LEFT JOIN commandes cmd
    ON dc.id_commande = cmd.id_commande
    AND cmd.statut IN ('confirm√©e', 'exp√©di√©e', 'livr√©e')
GROUP BY p.id_produit, p.nom_produit, p.categorie, p.stock
ORDER BY quantite_vendue DESC;
```

**R√©sultat attendu** :
```
+------------+----------------------+---------------+---------------+-----------+-----------------+------------+
| id_produit | nom_produit          | categorie     | stock_actuel  | nb_ventes | quantite_vendue | ca_produit |
+------------+----------------------+---------------+---------------+-----------+-----------------+------------+
|       2001 | Laptop Pro           | √âlectronique  |           42  |       847 |            1247 | 1621847.53 |
|       2002 | Souris sans fil      | √âlectronique  |          284  |       623 |            2847 |   85382.53 |
|       2847 | Livre ancien rare    | Livres        |            3  |         0 |               0 |       0.00 |
+------------+----------------------+---------------+---------------+-----------+-----------------+------------+
```

**Cas d'usage** :
- Analyse ABC (classification des produits)
- D√©tection de slow movers vs fast movers
- Optimisation des stocks

---

## ON vs WHERE : La diff√©rence critique

C'est l'un des points **les plus importants** et **les plus mal compris** des jointures externes.

### Principe de base

Pour **LEFT JOIN**, l'emplacement d'une condition (ON vs WHERE) change **radicalement** le r√©sultat :

| Clause | Moment d'application | Effet sur LEFT JOIN |
|--------|---------------------|---------------------|
| **ON** | **Pendant** la jointure | Filtre **avant** de cr√©er les NULL ‚Üí pr√©serve lignes gauche |
| **WHERE** | **Apr√®s** la jointure | Filtre **apr√®s** avoir cr√©√© les NULL ‚Üí peut exclure lignes gauche |

### Exemple 7 : D√©monstration ON vs WHERE

**Sc√©nario** : Tous les clients avec leurs commandes livr√©es

```sql
-- VERSION 1 : Condition dans ON (‚úÖ CORRECT pour LEFT JOIN)
SELECT
    c.nom,
    cmd.id_commande,
    cmd.statut
FROM clients c
LEFT JOIN commandes cmd
    ON c.id_client = cmd.id_client
    AND cmd.statut = 'livr√©e'  -- Dans ON
ORDER BY c.nom;
```

**R√©sultat VERSION 1** :
```
+----------------+--------------+---------+
| nom            | id_commande  | statut  |
+----------------+--------------+---------+
| Alice Martin   |         1001 | livr√©e  |  ‚Üê Commandes livr√©es d'Alice
| Alice Martin   |         1002 | livr√©e  |
| Bob Dupont     |         NULL | NULL    |  ‚Üê Bob a des commandes, mais aucune livr√©e
| Charlie Durand |         NULL | NULL    |  ‚Üê Charlie n'a aucune commande
+----------------+--------------+---------+
```

‚úÖ **Comportement** : **TOUS** les clients apparaissent, avec leurs commandes livr√©es (ou NULL si aucune livr√©e)

```sql
-- VERSION 2 : Condition dans WHERE (‚ùå MAUVAIS pour LEFT JOIN)
SELECT
    c.nom,
    cmd.id_commande,
    cmd.statut
FROM clients c
LEFT JOIN commandes cmd
    ON c.id_client = cmd.id_client
WHERE cmd.statut = 'livr√©e'  -- Dans WHERE
ORDER BY c.nom;
```

**R√©sultat VERSION 2** :
```
+----------------+--------------+---------+
| nom            | id_commande  | statut  |
+----------------+--------------+---------+
| Alice Martin   |         1001 | livr√©e  |
| Alice Martin   |         1002 | livr√©e  |
+----------------+--------------+---------+
```

‚ùå **Comportement** : Bob et Charlie **disparaissent** ! LEFT JOIN se comporte comme INNER JOIN.

### Explication d√©taill√©e du flux

**VERSION 1 (condition dans ON)** :
1. LEFT JOIN commence
2. Pour Alice : `cmd.statut = 'livr√©e'` ? ‚Üí OUI ‚Üí Jointure cr√©√©e avec commandes livr√©es
3. Pour Bob : `cmd.statut = 'livr√©e'` ? ‚Üí NON (a des commandes mais non livr√©es) ‚Üí NULL
4. Pour Charlie : Aucune commande ‚Üí NULL
5. **R√©sultat** : 3 clients (Alice, Bob, Charlie) apparaissent

**VERSION 2 (condition dans WHERE)** :
1. LEFT JOIN cr√©e toutes les correspondances (sans filtrage statut)
2. WHERE filtre **apr√®s** : `cmd.statut = 'livr√©e'`
3. Bob : `cmd.statut = NULL` ‚Üí WHERE √©limine (NULL ‚â† 'livr√©e')
4. Charlie : `cmd.statut = NULL` ‚Üí WHERE √©limine
5. **R√©sultat** : Seulement Alice

### R√®gle d'or ON vs WHERE

```sql
-- ‚úÖ CORRECT : Conditions de filtrage sur table de DROITE dans ON
LEFT JOIN table_droite
    ON table_gauche.id = table_droite.id
    AND table_droite.colonne = 'valeur'  -- Filtre droite dans ON

-- ‚úÖ CORRECT : Conditions sur table de GAUCHE dans WHERE
LEFT JOIN table_droite ON ...
WHERE table_gauche.colonne = 'valeur'    -- Filtre gauche dans WHERE

-- ‚ö†Ô∏è ATTENTION : Conditions sur table de DROITE dans WHERE
LEFT JOIN table_droite ON ...
WHERE table_droite.colonne = 'valeur'    -- Transforme LEFT en INNER !
-- SAUF si vous ajoutez : OR table_droite.colonne IS NULL
```

### Exemple 8 : Corriger une requ√™te avec WHERE

**Si vous devez filtrer la table de droite ET garder toutes les lignes de gauche** :

```sql
-- ‚ùå PROBL√àME : Clients sans commande livr√©e disparaissent
SELECT c.nom, cmd.id_commande
FROM clients c
LEFT JOIN commandes cmd ON c.id_client = cmd.id_client
WHERE cmd.statut = 'livr√©e';

-- ‚úÖ SOLUTION 1 : Condition dans ON
SELECT c.nom, cmd.id_commande
FROM clients c
LEFT JOIN commandes cmd
    ON c.id_client = cmd.id_client
    AND cmd.statut = 'livr√©e';

-- ‚úÖ SOLUTION 2 : WHERE avec OR IS NULL
SELECT c.nom, cmd.id_commande
FROM clients c
LEFT JOIN commandes cmd ON c.id_client = cmd.id_client
WHERE cmd.statut = 'livr√©e'
   OR cmd.statut IS NULL;  -- R√©inclut les clients sans commande
```

---

## RIGHT JOIN : Le sym√©trique de LEFT JOIN

**RIGHT JOIN** pr√©serve toutes les lignes de la **table de droite**.

### Syntaxe

```sql
SELECT colonnes
FROM table_gauche
RIGHT JOIN table_droite
    ON table_gauche.colonne = table_droite.colonne;
```

### Exemple 9 : RIGHT JOIN basique

```sql
-- Toutes les commandes, m√™me si le client n'existe plus
SELECT
    c.nom,
    cmd.id_commande,
    cmd.montant_total
FROM clients c
RIGHT JOIN commandes cmd
    ON c.id_client = cmd.id_client
ORDER BY cmd.id_commande;
```

**R√©sultat** : Toutes les commandes apparaissent, avec `c.nom = NULL` si le client a √©t√© supprim√© (rare).

### Pourquoi RIGHT JOIN est peu utilis√© ?

**RIGHT JOIN** est rarement utilis√© car :
1. ‚ùå **Moins intuitif** : On lit de gauche √† droite, pr√©server la droite est contre-intuitif
2. ‚úÖ **LEFT JOIN √©quivalent** : On peut toujours inverser l'ordre des tables

```sql
-- Ces deux requ√™tes sont √âQUIVALENTES :

-- Avec RIGHT JOIN
SELECT c.nom, cmd.id_commande
FROM clients c
RIGHT JOIN commandes cmd ON c.id_client = cmd.id_client;

-- Avec LEFT JOIN (PR√âF√âR√â)
SELECT c.nom, cmd.id_commande
FROM commandes cmd
LEFT JOIN clients c ON cmd.id_client = c.id_client;
```

üí° **Recommandation** : **Utilisez toujours LEFT JOIN** et ajustez l'ordre des tables. C'est plus clair et plus maintenable.

---

## Cas d'usage m√©tier avanc√©s

### Cas 1 : Rapport de compl√©tude des profils clients

**Question m√©tier** : *Quels clients ont des informations manquantes ?*

```sql
-- Audit de compl√©tude
SELECT
    c.id_client,
    c.nom,
    c.email,
    CASE WHEN c.telephone IS NULL THEN '‚ùå' ELSE '‚úÖ' END AS telephone_ok,
    CASE WHEN c.adresse IS NULL THEN '‚ùå' ELSE '‚úÖ' END AS adresse_ok,
    CASE WHEN cmd.id_commande IS NULL THEN '‚ùå' ELSE '‚úÖ' END AS a_commande,
    COUNT(cmd.id_commande) AS nb_commandes
FROM clients c
LEFT JOIN commandes cmd ON c.id_client = cmd.id_client
GROUP BY c.id_client, c.nom, c.email, c.telephone, c.adresse
HAVING telephone_ok = '‚ùå' OR adresse_ok = '‚ùå' OR a_commande = '‚ùå'
ORDER BY c.id_client;
```

**Application** : Campagnes de compl√©tion de profils, scoring de qualit√© de donn√©es.

### Cas 2 : Analyse de r√©tention client

**Question m√©tier** : *Clients n'ayant pas command√© depuis 90 jours*

```sql
-- Clients √† risque de churn
SELECT
    c.id_client,
    c.nom,
    c.email,
    MAX(cmd.date_commande) AS derniere_commande,
    DATEDIFF(CURDATE(), MAX(cmd.date_commande)) AS jours_inactivite,
    COUNT(cmd.id_commande) AS nb_commandes_total
FROM clients c
LEFT JOIN commandes cmd
    ON c.id_client = cmd.id_client
    AND cmd.statut IN ('confirm√©e', 'exp√©di√©e', 'livr√©e')
GROUP BY c.id_client, c.nom, c.email
HAVING derniere_commande IS NULL  -- Jamais command√©
    OR DATEDIFF(CURDATE(), MAX(cmd.date_commande)) > 90  -- >90 jours
ORDER BY jours_inactivite DESC NULLS LAST;
```

**R√©sultat attendu** :
```
+------------+----------------+-------------------+---------------------+-------------------+---------------------+
| id_client  | nom            | email             | derniere_commande   | jours_inactivite  | nb_commandes_total  |
+------------+----------------+-------------------+---------------------+-------------------+---------------------+
|        892 | Charlie Durand | charlie@email.com | NULL                | NULL              |                   0 |
|       3847 | Diana Lopez    | diana@email.com   | 2025-06-10 14:23:00 |                183|                   8 |
|       5621 | √âric Moreau    | eric@email.com    | 2025-08-20 09:15:00 |                112|                  14 |
+------------+----------------+-------------------+---------------------+-------------------+---------------------+
```

**Application** :
- Campagnes de r√©activation cibl√©es
- Scoring de risque de churn
- Programmes de r√©tention

### Cas 3 : Analyse d'√©cart entre stock et ventes

**Question m√©tier** : *Produits avec fort stock mais peu de ventes (sur 30 jours)*

```sql
-- Dead stock detection
SELECT
    p.id_produit,
    p.nom_produit,
    p.categorie,
    p.stock,
    COALESCE(SUM(dc.quantite), 0) AS quantite_vendue_30j,
    p.stock - COALESCE(SUM(dc.quantite), 0) AS stock_net
FROM produits p
LEFT JOIN details_commande dc
    ON p.id_produit = dc.id_produit
LEFT JOIN commandes cmd
    ON dc.id_commande = cmd.id_commande
    AND cmd.date_commande >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
    AND cmd.statut IN ('confirm√©e', 'exp√©di√©e', 'livr√©e')
WHERE p.stock > 0
GROUP BY p.id_produit, p.nom_produit, p.categorie, p.stock
HAVING quantite_vendue_30j = 0  -- Aucune vente sur 30 jours
   AND p.stock > 20  -- Mais stock important
ORDER BY p.stock DESC;
```

**Application** :
- Identification de stocks dormants
- Promotions pour √©couler stocks
- D√©cisions d'approvisionnement

### Cas 4 : Tous les jours du mois avec CA (m√™me si 0)

**Question m√©tier** : *CA quotidien du mois, avec 0 pour les jours sans vente*

```sql
-- G√©n√©rer tous les jours du mois
WITH RECURSIVE tous_les_jours AS (
    SELECT DATE('2025-12-01') AS jour
    UNION ALL
    SELECT DATE_ADD(jour, INTERVAL 1 DAY)
    FROM tous_les_jours
    WHERE jour < '2025-12-31'
)
-- Joindre avec les ventes
SELECT
    tj.jour,
    DAYNAME(tj.jour) AS jour_semaine,
    COUNT(DISTINCT cmd.id_commande) AS nb_commandes,
    COALESCE(SUM(cmd.montant_total), 0) AS ca_jour
FROM tous_les_jours tj
LEFT JOIN commandes cmd
    ON DATE(cmd.date_commande) = tj.jour
    AND cmd.statut IN ('confirm√©e', 'exp√©di√©e', 'livr√©e')
GROUP BY tj.jour
ORDER BY tj.jour;
```

**R√©sultat attendu** :
```
+------------+--------------+--------------+----------+
| jour       | jour_semaine | nb_commandes | ca_jour  |
+------------+--------------+--------------+----------+
| 2025-12-01 | Sunday       |           12 |  1847.93 |
| 2025-12-02 | Monday       |           23 |  3428.45 |
| 2025-12-03 | Tuesday      |            0 |     0.00 |  ‚Üê Aucune vente
| 2025-12-04 | Wednesday    |           18 |  2739.21 |
+------------+--------------+--------------+----------+
```

**Application** :
- Graphiques sans trous (tous les jours affich√©s)
- Analyse de saisonnalit√© compl√®te
- D√©tection de jours atypiques

---

## Jointures externes multiples

### Exemple 10 : Cha√Æner plusieurs LEFT JOIN

**Question m√©tier** : *Vue compl√®te client avec toutes les relations*

```sql
-- Cha√Æne de LEFT JOIN
SELECT
    c.nom AS client,
    COUNT(DISTINCT cmd.id_commande) AS nb_commandes,
    COUNT(DISTINCT adr.id_adresse) AS nb_adresses,
    COUNT(DISTINCT pref.id_preference) AS nb_preferences
FROM clients c
LEFT JOIN commandes cmd ON c.id_client = cmd.id_client
LEFT JOIN adresses adr ON c.id_client = adr.id_client
LEFT JOIN preferences pref ON c.id_client = pref.id_client
GROUP BY c.id_client, c.nom
ORDER BY c.nom;
```

**R√©sultat attendu** :
```
+----------------+--------------+--------------+-----------------+
| client         | nb_commandes | nb_adresses  | nb_preferences  |
+----------------+--------------+--------------+-----------------+
| Alice Martin   |           47 |            2 |               5 |
| Bob Dupont     |           38 |            1 |               3 |
| Charlie Durand |            0 |            0 |               0 |  ‚Üê Aucune relation
+----------------+--------------+--------------+-----------------+
```

‚ö†Ô∏è **Attention** : COUNT DISTINCT est essentiel ici pour √©viter la multiplication des lignes.

---

## Optimisation et performance

### Index pour LEFT JOIN

Les m√™mes r√®gles d'indexation que pour INNER JOIN s'appliquent :

```sql
-- Index sur colonnes de jointure
CREATE INDEX idx_commandes_client ON commandes(id_client);
CREATE INDEX idx_details_commande ON details_commande(id_commande);
```

### Performance LEFT JOIN vs INNER JOIN

LEFT JOIN est **l√©g√®rement plus lent** que INNER JOIN car :
1. Doit pr√©server toutes les lignes de gauche
2. Doit cr√©er des NULL pour non-correspondances
3. Ne peut pas optimiser certains cas (early termination)

**Diff√©rence en pratique** : 5-10% plus lent, g√©n√©ralement n√©gligeable avec index appropri√©s.

### EXPLAIN avec LEFT JOIN

```sql
EXPLAIN
SELECT c.nom, cmd.id_commande
FROM clients c
LEFT JOIN commandes cmd ON c.id_client = cmd.id_client;
```

**Points √† v√©rifier** :
- `type: ref` sur table de droite (commandes) ‚Üí Index utilis√© ‚úÖ
- `rows` : Estimation raisonnable
- Pas de `Using temporary` ou `Using filesort` si possible

### Optimisation avec sous-requ√™tes

Pour de tr√®s grandes tables, parfois une sous-requ√™te est plus performante :

```sql
-- Moins optimal avec LEFT JOIN direct
SELECT c.nom, COUNT(cmd.id_commande)
FROM clients c
LEFT JOIN commandes cmd ON c.id_client = cmd.id_client
GROUP BY c.nom;

-- Plus optimal avec sous-requ√™te agr√©g√©e
SELECT
    c.nom,
    COALESCE(stats.nb_commandes, 0) AS nb_commandes
FROM clients c
LEFT JOIN (
    SELECT id_client, COUNT(*) AS nb_commandes
    FROM commandes
    GROUP BY id_client
) AS stats ON c.id_client = stats.id_client;
```

La sous-requ√™te agr√®ge **avant** la jointure, r√©duisant le nombre de lignes trait√©es.

---

## Pi√®ges courants et solutions

### Pi√®ge 1 : WHERE d√©truit le LEFT JOIN

```sql
-- ‚ùå ERREUR : Oubli que WHERE filtre APR√àS la jointure
SELECT c.nom, cmd.id_commande
FROM clients c
LEFT JOIN commandes cmd ON c.id_client = cmd.id_client
WHERE cmd.montant_total > 100;
-- Clients sans commande disparaissent (cmd.montant_total = NULL)

-- ‚úÖ SOLUTION : Condition dans ON
SELECT c.nom, cmd.id_commande
FROM clients c
LEFT JOIN commandes cmd
    ON c.id_client = cmd.id_client
    AND cmd.montant_total > 100;
```

### Pi√®ge 2 : Confusion COUNT(*) vs COUNT(colonne)

```sql
-- ‚ö†Ô∏è ATTENTION aux diff√©rences de comptage
SELECT
    c.nom,
    COUNT(*) AS total_lignes,              -- Compte TOUTES les lignes
    COUNT(cmd.id_commande) AS nb_commandes -- Compte seulement les non-NULL
FROM clients c
LEFT JOIN commandes cmd ON c.id_client = cmd.id_client
GROUP BY c.nom;

-- Pour Charlie (sans commande) :
-- total_lignes = 1 (la ligne du client existe)
-- nb_commandes = 0 (cmd.id_commande = NULL, COUNT l'ignore)
```

üí° **R√®gle** : Avec LEFT JOIN, utilisez `COUNT(colonne_table_droite)` pour compter les correspondances.

### Pi√®ge 3 : Multiplication involontaire des lignes

```sql
-- ‚ùå PROBL√àME : Deux LEFT JOIN cr√©ent un produit cart√©sien
SELECT c.nom, cmd.id_commande, eval.note
FROM clients c
LEFT JOIN commandes cmd ON c.id_client = cmd.id_client
LEFT JOIN evaluations eval ON c.id_client = eval.id_client;
-- Si Alice a 3 commandes et 2 √©valuations ‚Üí 3 √ó 2 = 6 lignes !

-- ‚úÖ SOLUTION : Sous-requ√™tes agr√©g√©es
SELECT
    c.nom,
    (SELECT COUNT(*) FROM commandes WHERE id_client = c.id_client) AS nb_cmd,
    (SELECT COUNT(*) FROM evaluations WHERE id_client = c.id_client) AS nb_eval
FROM clients c;
```

### Pi√®ge 4 : Agr√©gation incorrecte avec NULL

```sql
-- ‚ùå PROBL√àME : SUM retourne NULL pour clients sans commandes
SELECT c.nom, SUM(cmd.montant_total) AS ca_total
FROM clients c
LEFT JOIN commandes cmd ON c.id_client = cmd.id_client
GROUP BY c.nom;
-- Charlie : ca_total = NULL (pas esth√©tique)

-- ‚úÖ SOLUTION : COALESCE pour transformer NULL en 0
SELECT c.nom, COALESCE(SUM(cmd.montant_total), 0) AS ca_total
FROM clients c
LEFT JOIN commandes cmd ON c.id_client = cmd.id_client
GROUP BY c.nom;
-- Charlie : ca_total = 0
```

---

## Combiner INNER et LEFT JOIN

Vous pouvez m√©langer diff√©rents types de jointures dans une m√™me requ√™te.

### Exemple 11 : INNER + LEFT JOIN

**Question m√©tier** : *Commandes avec client (obligatoire) et adresse de livraison (optionnelle)*

```sql
-- INNER JOIN pour client (doit exister)
-- LEFT JOIN pour adresse (peut ne pas exister)
SELECT
    cmd.id_commande,
    c.nom AS client,           -- INNER : toujours rempli
    adr.adresse AS livraison,  -- LEFT : peut √™tre NULL
    cmd.montant_total
FROM commandes cmd
INNER JOIN clients c
    ON cmd.id_client = c.id_client  -- Client DOIT exister
LEFT JOIN adresses adr
    ON cmd.id_adresse_livraison = adr.id_adresse  -- Adresse PEUT ne pas exister
WHERE cmd.statut IN ('en_attente', 'confirm√©e')
ORDER BY cmd.date_commande DESC;
```

**Logique** :
- INNER JOIN garantit l'int√©grit√© (commande sans client = erreur)
- LEFT JOIN permet les valeurs optionnelles (adresse manquante = OK)

---

## ‚úÖ Points cl√©s √† retenir

1. **LEFT JOIN pr√©serve toutes les lignes de gauche** ‚Äì m√™me sans correspondance √† droite (NULL cr√©√©s)

2. **RIGHT JOIN = LEFT JOIN invers√©** ‚Äì rarement utilis√©, pr√©f√©rer LEFT avec tables invers√©es

3. **LEFT JOIN + WHERE IS NULL = trouver les orphelins** ‚Äì pattern classique pour d√©tecter ce qui manque

4. **ON vs WHERE : diff√©rence CRITIQUE** ‚Äì condition sur table droite dans ON pr√©serve gauche, dans WHERE transforme en INNER JOIN

5. **COUNT(colonne_droite) pour compter correspondances** ‚Äì COUNT(*) compte toutes lignes y compris NULL

6. **COALESCE pour affichage des NULL** ‚Äì transforme NULL en 0 ou valeur par d√©faut

7. **Filtrage table droite : mettre dans ON** ‚Äì ou ajouter `OR colonne IS NULL` dans WHERE

8. **Cha√Æner plusieurs LEFT JOIN possible** ‚Äì attention √† la multiplication des lignes, utiliser COUNT DISTINCT

9. **Performance similaire √† INNER JOIN** ‚Äì avec index appropri√©s, diff√©rence n√©gligeable

10. **Analyser avec EXPLAIN** ‚Äì v√©rifier utilisation des index, type=ref sur table droite

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB
- [üìñ LEFT JOIN Syntax](https://mariadb.com/kb/en/join-syntax/#left-outer-join) ‚Äì Documentation compl√®te
- [üìñ NULL Values](https://mariadb.com/kb/en/null-values/) ‚Äì Comportement de NULL
- [üìñ COALESCE Function](https://mariadb.com/kb/en/coalesce/) ‚Äì Gestion des NULL

### Articles approfondis
- [LEFT JOIN vs INNER JOIN](https://modern-sql.com/feature/left-join) ‚Äì Diff√©rences conceptuelles
- [ON vs WHERE in LEFT JOIN](https://explainextended.com/2009/07/13/left-join-on-vs-where/) ‚Äì Explication d√©taill√©e

---

## ‚û°Ô∏è Section suivante

**[3.3.3 CROSS JOIN : Produit cart√©sien](./03.3-cross-join.md)**

Apr√®s les jointures qui pr√©servent ou matchent les donn√©es, la prochaine section explore **CROSS JOIN** :
- Produit cart√©sien : toutes les combinaisons possibles
- Quand l'utiliser (cas sp√©cifiques : matrices, calendriers)
- Dangers et pr√©cautions (explosion combinatoire)
- Cas d'usage : g√©n√©ration de plages horaires, tests combinatoires
- Alternative avec JOIN + condition toujours vraie

CROSS JOIN est rare mais puissant pour des cas sp√©cifiques ! üéØ

---


‚è≠Ô∏è [CROSS JOIN : Produit cart√©sien](/03-requetes-sql-intermediaires/03.3-cross-join.md)
