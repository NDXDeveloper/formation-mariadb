üîù Retour au [Sommaire](/SOMMAIRE.md)

# 3.3.4 Self-Join : Joindre une table √† elle-m√™me

> **Niveau** : Interm√©diaire √† Avanc√©
> **Dur√©e estim√©e** : 2-3 heures
> **Pr√©requis** : Sections 3.3.1 √† 3.3.3, ma√Ætrise des alias, compr√©hension des hi√©rarchies

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre le principe de Self-Join et son utilit√©
- Ma√Ætriser l'utilisation d'alias pour distinguer les "instances" de la table
- Mod√©liser et requ√™ter des hi√©rarchies (employ√©s/managers, cat√©gories imbriqu√©es)
- Comparer des lignes au sein d'une m√™me table
- D√©tecter des doublons et anomalies
- Identifier des s√©quences et relations de voisinage
- Optimiser les performances des Self-Joins
- Choisir entre Self-Join et CTE r√©cursives

---

## Introduction

Un **Self-Join** est une jointure d'une table **avec elle-m√™me**. C'est une technique puissante mais souvent m√©connue qui permet de r√©soudre des probl√®mes complexes impliquant des **relations au sein d'une m√™me table**.

### Le principe

```
Table : employes
+------------+-----------------+-------------+
| id_employe | nom             | id_manager  |
+------------+-----------------+-------------+
|          1 | Alice Directrice| NULL        |
|          2 | Bob Manager     |          1  |
|          3 | Charlie Dev     |          2  |
|          4 | Diana Dev       |          2  |
+------------+-----------------+-------------+

Question : "Qui est le manager de chaque employ√© ?"

Self-Join : employes AS e1 JOIN employes AS e2
            ON e1.id_manager = e2.id_employe

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ employes e1 ‚îÇ  JOIN   ‚îÇ employes e2 ‚îÇ
‚îÇ (employ√©s)  ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ (managers)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     M√™me table physique, deux "r√¥les" logiques
```

### Caract√©ristiques

| Caract√©ristique | Description |
|-----------------|-------------|
| **Tables jointes** | Une seule table physique, r√©f√©renc√©e deux fois (ou plus) |
| **Alias obligatoires** | TOUJOURS utiliser des alias diff√©rents (e1, e2, etc.) |
| **Types de jointure** | Peut √™tre INNER, LEFT, RIGHT selon le besoin |
| **Cas d'usage** | Hi√©rarchies, comparaisons, doublons, s√©quences |
| **Alternative** | CTE r√©cursives (section 4.1) pour hi√©rarchies profondes |

üí° **Analogie** : C'est comme avoir **deux photocopies** de la m√™me table et les joindre entre elles. Chaque copie joue un r√¥le diff√©rent.

---

## Syntaxe et alias

### Syntaxe de base

```sql
SELECT colonnes
FROM table AS alias1
[INNER|LEFT|RIGHT] JOIN table AS alias2
    ON alias1.colonne = alias2.colonne
WHERE conditions;
```

‚ö†Ô∏è **R√®gle absolue** : Les alias sont **OBLIGATOIRES** pour distinguer les deux "instances" de la table.

### Exemple minimal

```sql
-- ‚ùå ERREUR : Sans alias, impossible de distinguer
SELECT *
FROM employes
JOIN employes ON employes.id_manager = employes.id_employe;
-- Erreur : "Not unique table/alias: 'employes'"

-- ‚úÖ CORRECT : Avec alias
SELECT
    e1.nom AS employe,
    e2.nom AS manager
FROM employes e1
JOIN employes e2 ON e1.id_manager = e2.id_employe;
```

---

## Cas d'usage 1 : Hi√©rarchies et organigrammes

### Exemple 1 : Employ√©s et leurs managers

**Question m√©tier** : *Afficher chaque employ√© avec son manager direct*

```sql
-- Structure hi√©rarchique simple (1 niveau)
SELECT
    e1.id_employe,
    e1.nom AS employe,
    e1.poste,
    e2.nom AS manager,
    e2.poste AS poste_manager
FROM employes e1
LEFT JOIN employes e2
    ON e1.id_manager = e2.id_employe
ORDER BY e2.nom NULLS FIRST, e1.nom;
```

**R√©sultat attendu** :
```
+------------+------------------+----------------+------------------+----------------+
| id_employe | employe          | poste          | manager          | poste_manager  |
+------------+------------------+----------------+------------------+----------------+
|          1 | Alice Dupont     | Directrice     | NULL             | NULL           |  ‚Üê Pas de manager
|          2 | Bob Martin       | Manager Dev    | Alice Dupont     | Directrice     |
|          3 | Charlie Durand   | D√©veloppeur    | Bob Martin       | Manager Dev    |
|          4 | Diana Lopez      | D√©veloppeur    | Bob Martin       | Manager Dev    |
|          5 | √âric Bernard     | Manager RH     | Alice Dupont     | Directrice     |
|          6 | Fanny Moreau     | RH             | √âric Bernard     | Manager RH     |
+------------+------------------+----------------+------------------+----------------+
```

**Explication** :
- **e1** repr√©sente les employ√©s
- **e2** repr√©sente les managers (m√™me table)
- **LEFT JOIN** : Pr√©serve Alice (directrice sans manager)
- `e1.id_manager = e2.id_employe` : Relie employ√© √† son manager

**Cas d'usage** : Organigramme, annuaire d'entreprise, hi√©rarchie de reporting.

### Exemple 2 : Trouver tous les subordonn√©s directs d'un manager

**Question m√©tier** : *Qui travaille directement sous Bob ?*

```sql
-- √âquipe directe d'un manager
SELECT
    mgr.nom AS manager,
    emp.nom AS subordonnes,
    emp.poste,
    emp.email
FROM employes mgr
INNER JOIN employes emp
    ON mgr.id_employe = emp.id_manager
WHERE mgr.nom = 'Bob Martin'
ORDER BY emp.nom;
```

**R√©sultat attendu** :
```
+--------------+------------------+----------------+----------------------+
| manager      | subordonnes      | poste          | email                |
+--------------+------------------+----------------+----------------------+
| Bob Martin   | Charlie Durand   | D√©veloppeur    | charlie@company.com  |
| Bob Martin   | Diana Lopez      | D√©veloppeur    | diana@company.com    |
+--------------+------------------+----------------+----------------------+
```

**Application** : Gestion d'√©quipes, calcul de charge manag√©riale, permissions hi√©rarchiques.

### Exemple 3 : Hi√©rarchie sur 2 niveaux (employ√© + manager + grand-manager)

**Question m√©tier** : *Afficher l'employ√©, son manager ET le manager de son manager*

```sql
-- Cha√Æne hi√©rarchique sur 2 niveaux
SELECT
    e1.nom AS employe,
    e2.nom AS manager_direct,
    e3.nom AS grand_manager
FROM employes e1
LEFT JOIN employes e2 ON e1.id_manager = e2.id_employe
LEFT JOIN employes e3 ON e2.id_manager = e3.id_employe
ORDER BY e3.nom NULLS FIRST, e2.nom NULLS FIRST, e1.nom;
```

**R√©sultat attendu** :
```
+------------------+------------------+------------------+
| employe          | manager_direct   | grand_manager    |
+------------------+------------------+------------------+
| Alice Dupont     | NULL             | NULL             |  ‚Üê Directrice (sommet)
| Bob Martin       | Alice Dupont     | NULL             |
| √âric Bernard     | Alice Dupont     | NULL             |
| Charlie Durand   | Bob Martin       | Alice Dupont     |  ‚Üê 2 niveaux
| Diana Lopez      | Bob Martin       | Alice Dupont     |
| Fanny Moreau     | √âric Bernard     | Alice Dupont     |
+------------------+------------------+------------------+
```

**Limite** : Pour des hi√©rarchies profondes (> 2-3 niveaux), utilisez **CTE r√©cursives** (section 4.1).

### Exemple 4 : Compter le nombre de subordonn√©s directs

**Question m√©tier** : *Combien de personnes chaque manager supervise-t-il directement ?*

```sql
-- Nombre de subordonn√©s par manager
SELECT
    mgr.id_employe,
    mgr.nom AS manager,
    mgr.poste,
    COUNT(emp.id_employe) AS nb_subordonnes
FROM employes mgr
LEFT JOIN employes emp
    ON mgr.id_employe = emp.id_manager
GROUP BY mgr.id_employe, mgr.nom, mgr.poste
HAVING COUNT(emp.id_employe) > 0  -- Seulement ceux qui ont des subordonn√©s
ORDER BY nb_subordonnes DESC;
```

**R√©sultat attendu** :
```
+------------+------------------+----------------+-----------------+
| id_employe | manager          | poste          | nb_subordonnes  |
+------------+------------------+----------------+-----------------+
|          1 | Alice Dupont     | Directrice     |               2 |
|          2 | Bob Martin       | Manager Dev    |               2 |
|          5 | √âric Bernard     | Manager RH     |               1 |
+------------+------------------+----------------+-----------------+
```

**Application** : Calcul de charge manag√©riale, identification de surcharge, √©quilibrage d'√©quipes.

---

## Cas d'usage 2 : Comparaisons intra-table

### Exemple 5 : Produits plus chers qu'un autre dans la m√™me cat√©gorie

**Question m√©tier** : *Pour chaque produit, trouver les produits plus chers dans sa cat√©gorie*

```sql
-- Comparaison de prix intra-cat√©gorie
SELECT
    p1.nom_produit AS produit,
    p1.categorie,
    p1.prix_unitaire AS prix,
    p2.nom_produit AS produit_plus_cher,
    p2.prix_unitaire AS prix_plus_eleve,
    (p2.prix_unitaire - p1.prix_unitaire) AS ecart_prix
FROM produits p1
INNER JOIN produits p2
    ON p1.categorie = p2.categorie
    AND p1.id_produit != p2.id_produit  -- Exclure le produit lui-m√™me
    AND p2.prix_unitaire > p1.prix_unitaire  -- Seulement les plus chers
WHERE p1.nom_produit = 'Souris sans fil'
ORDER BY p2.prix_unitaire;
```

**R√©sultat attendu** :
```
+------------------+---------------+--------+----------------------+------------------+------------+
| produit          | categorie     | prix   | produit_plus_cher    | prix_plus_eleve  | ecart_prix |
+------------------+---------------+--------+----------------------+------------------+------------+
| Souris sans fil  | √âlectronique  |  29.99 | Clavier m√©canique    |            89.99 |      60.00 |
| Souris sans fil  | √âlectronique  |  29.99 | √âcran 27"            |           389.99 |     360.00 |
| Souris sans fil  | √âlectronique  |  29.99 | Laptop Pro           |          1299.99 |    1270.00 |
+------------------+---------------+--------+----------------------+------------------+------------+
```

**Application** : Upselling, analyse concurrentielle, positionnement produit.

### Exemple 6 : Clients de la m√™me ville

**Question m√©tier** : *Trouver les clients habitant dans la m√™me ville (r√©seautage, livraisons group√©es)*

```sql
-- Clients voisins g√©ographiquement
SELECT
    c1.nom AS client_1,
    c2.nom AS client_2,
    c1.ville,
    c1.code_postal
FROM clients c1
INNER JOIN clients c2
    ON c1.ville = c2.ville
    AND c1.code_postal = c2.code_postal
    AND c1.id_client < c2.id_client  -- √âvite doublons (A,B) et (B,A) + exclut (A,A)
WHERE c1.ville = 'Paris'
ORDER BY c1.code_postal, c1.nom;
```

**R√©sultat attendu** :
```
+----------------+------------------+-------+--------------+
| client_1       | client_2         | ville | code_postal  |
+----------------+------------------+-------+--------------+
| Alice Martin   | Bob Dupont       | Paris | 75001        |
| Alice Martin   | Charlie Durand   | Paris | 75001        |
| Bob Dupont     | Charlie Durand   | Paris | 75001        |
| Diana Lopez    | √âric Bernard     | Paris | 75015        |
+----------------+------------------+-------+--------------+
```

**Explication** :
- `c1.id_client < c2.id_client` : Astuce pour √©viter :
  - Les doublons invers√©s (A,B) et (B,A)
  - Les auto-correspondances (A,A)

**Application** : Livraisons group√©es, r√©seautage clients, covoiturage, programmes de parrainage.

### Exemple 7 : D√©tection de doublons potentiels

**Question m√©tier** : *Trouver les clients ayant le m√™me nom (possibles doublons)*

```sql
-- D√©tection de doublons suspects
SELECT
    c1.id_client AS id_1,
    c2.id_client AS id_2,
    c1.nom,
    c1.email AS email_1,
    c2.email AS email_2,
    c1.date_inscription AS inscrit_1,
    c2.date_inscription AS inscrit_2
FROM clients c1
INNER JOIN clients c2
    ON LOWER(c1.nom) = LOWER(c2.nom)  -- Nom identique (insensible casse)
    AND c1.id_client < c2.id_client   -- √âvite doublons
WHERE c1.email != c2.email  -- Emails diff√©rents (sinon m√™me personne)
ORDER BY c1.nom, c1.date_inscription;
```

**R√©sultat attendu** :
```
+------+------+----------------+---------------------+---------------------+---------------------+---------------------+
| id_1 | id_2 | nom            | email_1             | email_2             | inscrit_1           | inscrit_2           |
+------+------+----------------+---------------------+---------------------+---------------------+---------------------+
|  847 | 2934 | Martin Dupont  | martin1@email.com   | martin.d@email.com  | 2024-03-15 10:23:00 | 2025-01-20 14:47:00 |
| 1245 | 3847 | Sophie Bernard | sophie@email.com    | s.bernard@email.com | 2023-11-10 08:15:00 | 2024-06-05 16:32:00 |
+------+------+----------------+---------------------+---------------------+---------------------+---------------------+
```

**Application** : Nettoyage de base de donn√©es, fusion de comptes, pr√©vention de fraude, conformit√© RGPD.

---

## Cas d'usage 3 : S√©quences et voisinage

### Exemple 8 : Lignes cons√©cutives et diff√©rences

**Question m√©tier** : *Calculer l'√©volution du stock entre chaque inventaire*

```sql
-- √âvolution temporelle avec ligne pr√©c√©dente
SELECT
    i1.date_inventaire AS date_actuelle,
    i1.quantite AS stock_actuel,
    i2.date_inventaire AS date_precedente,
    i2.quantite AS stock_precedent,
    (i1.quantite - i2.quantite) AS variation,
    ROUND(100.0 * (i1.quantite - i2.quantite) / i2.quantite, 2) AS variation_pct
FROM inventaires i1
LEFT JOIN inventaires i2
    ON i1.id_produit = i2.id_produit
    AND i2.date_inventaire = (
        -- Trouver la date pr√©c√©dente
        SELECT MAX(date_inventaire)
        FROM inventaires
        WHERE id_produit = i1.id_produit
          AND date_inventaire < i1.date_inventaire
    )
WHERE i1.id_produit = 2001  -- Produit sp√©cifique
ORDER BY i1.date_inventaire;
```

**R√©sultat attendu** :
```
+---------------------+--------------+---------------------+------------------+-----------+--------------+
| date_actuelle       | stock_actuel | date_precedente     | stock_precedent  | variation | variation_pct|
+---------------------+--------------+---------------------+------------------+-----------+--------------+
| 2025-01-01 00:00:00 |          500 | NULL                | NULL             | NULL      | NULL         |
| 2025-02-01 00:00:00 |          437 | 2025-01-01 00:00:00 |              500 |       -63 |       -12.60 |
| 2025-03-01 00:00:00 |          512 | 2025-02-01 00:00:00 |              437 |        75 |        17.16 |
+---------------------+--------------+---------------------+------------------+-----------+--------------+
```

**Note** : En MariaDB 10.2+, les **Window Functions** (LAG/LEAD) sont plus efficaces pour ce cas (section 4.2).

**Application** : Analyses de tendances, pr√©visions, d√©tection d'anomalies, rapports d'√©volution.

### Exemple 9 : Trouver des s√©quences (valeurs cons√©cutives)

**Question m√©tier** : *Identifier les commandes pass√©es le m√™me jour par le m√™me client*

```sql
-- Commandes multiples le m√™me jour
SELECT
    c.nom AS client,
    cmd1.id_commande AS commande_1,
    cmd2.id_commande AS commande_2,
    DATE(cmd1.date_commande) AS date_commande,
    cmd1.montant_total AS montant_1,
    cmd2.montant_total AS montant_2,
    (cmd1.montant_total + cmd2.montant_total) AS montant_total_jour
FROM commandes cmd1
INNER JOIN commandes cmd2
    ON cmd1.id_client = cmd2.id_client
    AND DATE(cmd1.date_commande) = DATE(cmd2.date_commande)
    AND cmd1.id_commande < cmd2.id_commande  -- √âvite doublons
INNER JOIN clients c ON cmd1.id_client = c.id_client
ORDER BY c.nom, cmd1.date_commande DESC;
```

**R√©sultat attendu** :
```
+----------------+-------------+-------------+---------------+-----------+-----------+--------------------+
| client         | commande_1  | commande_2  | date_commande | montant_1 | montant_2 | montant_total_jour |
+----------------+-------------+-------------+---------------+-----------+-----------+--------------------+
| Alice Martin   |        1847 |        1848 | 2025-12-10    |    289.95 |    149.99 |             439.94 |
| Bob Dupont     |        1723 |        1724 | 2025-11-05    |     89.99 |     45.50 |             135.49 |
+----------------+-------------+-------------+---------------+-----------+-----------+--------------------+
```

**Application** : D√©tection de comportements suspects, fraude, optimisation d'exp√©dition, analyse de panier.

---

## Cas d'usage 4 : Structures de cat√©gories imbriqu√©es

### Exemple 10 : Arbre de cat√©gories (1 niveau)

**Question m√©tier** : *Afficher les cat√©gories avec leur cat√©gorie parent*

```sql
-- Structure hi√©rarchique de cat√©gories
SELECT
    c1.id_categorie,
    c1.nom AS categorie,
    c1.niveau,
    c2.nom AS categorie_parente
FROM categories c1
LEFT JOIN categories c2
    ON c1.id_parent = c2.id_categorie
ORDER BY c2.nom NULLS FIRST, c1.nom;
```

**R√©sultat attendu** :
```
+---------------+------------------+--------+---------------------+
| id_categorie  | categorie        | niveau | categorie_parente   |
+---------------+------------------+--------+---------------------+
|             1 | √âlectronique     |      1 | NULL                |  ‚Üê Racine
|             2 | Mode             |      1 | NULL                |
|             3 | Ordinateurs      |      2 | √âlectronique        |
|             4 | Smartphones      |      2 | √âlectronique        |
|             5 | V√™tements Homme  |      2 | Mode                |
|             6 | V√™tements Femme  |      2 | Mode                |
+---------------+------------------+--------+---------------------+
```

**Application** : Menus d√©roulants, fils d'Ariane (breadcrumb), filtres de recherche.

### Exemple 11 : Lister toutes les sous-cat√©gories d'une cat√©gorie

**Question m√©tier** : *Tous les produits de la cat√©gorie "√âlectronique" et ses sous-cat√©gories*

```sql
-- Produits dans une cat√©gorie et ses enfants
SELECT
    p.id_produit,
    p.nom_produit,
    c1.nom AS categorie_directe,
    c2.nom AS categorie_parent
FROM produits p
INNER JOIN categories c1 ON p.id_categorie = c1.id_categorie
LEFT JOIN categories c2 ON c1.id_parent = c2.id_categorie
WHERE c1.nom = 'Ordinateurs'
   OR c2.nom = '√âlectronique'
ORDER BY c1.nom, p.nom_produit;
```

**Limite** : Pour des arbres profonds (> 2-3 niveaux), utilisez **CTE r√©cursives**.

---

## Self-Join vs CTE r√©cursives

### Quand utiliser chacun ?

| Crit√®re | Self-Join | CTE R√©cursives (WITH RECURSIVE) |
|---------|-----------|----------------------------------|
| **Profondeur hi√©rarchie** | 1-2 niveaux | Illimit√©e (jusqu'√† max_recursive_iterations) |
| **Complexit√© SQL** | Simple, direct | Plus complexe |
| **Performance** | Rapide pour niveaux fixes | Peut √™tre lent sur hi√©rarchies profondes |
| **Lisibilit√©** | Bonne pour cas simples | Meilleure pour hi√©rarchies complexes |
| **Flexibilit√©** | Limit√©e | Tr√®s flexible |

### Exemple comparatif : Hi√©rarchie compl√®te

```sql
-- Approche 1 : Self-Join (limit√© √† 2 niveaux)
SELECT
    e1.nom AS employe,
    e2.nom AS manager_n1,
    e3.nom AS manager_n2
FROM employes e1
LEFT JOIN employes e2 ON e1.id_manager = e2.id_employe
LEFT JOIN employes e3 ON e2.id_manager = e3.id_employe;
-- Probl√®me : Pour niveau 4, 5, 6... il faut ajouter e4, e5, e6...

-- Approche 2 : CTE R√©cursive (tous niveaux)
WITH RECURSIVE hierarchie AS (
    -- Ancre : employ√©s sans manager
    SELECT id_employe, nom, id_manager, 1 AS niveau
    FROM employes
    WHERE id_manager IS NULL

    UNION ALL

    -- R√©cursion : employ√©s avec manager
    SELECT e.id_employe, e.nom, e.id_manager, h.niveau + 1
    FROM employes e
    INNER JOIN hierarchie h ON e.id_manager = h.id_employe
)
SELECT * FROM hierarchie ORDER BY niveau, nom;
-- ‚úÖ Fonctionne pour toute profondeur
```

üí° **Recommandation** :
- **Self-Join** : Hi√©rarchies peu profondes (1-2 niveaux), comparaisons simples
- **CTE R√©cursives** : Hi√©rarchies profondes ou profondeur inconnue

---

## Optimisation et performance

### Index pour Self-Join

Les Self-Joins b√©n√©ficient des m√™mes optimisations que les jointures classiques.

```sql
-- Index essentiels pour hi√©rarchies
CREATE INDEX idx_employes_manager ON employes(id_manager);

-- Index pour comparaisons sur attributs
CREATE INDEX idx_clients_ville_cp ON clients(ville, code_postal);
CREATE INDEX idx_produits_categorie_prix ON produits(categorie, prix_unitaire);
```

### EXPLAIN avec Self-Join

```sql
EXPLAIN
SELECT e1.nom, e2.nom AS manager
FROM employes e1
LEFT JOIN employes e2 ON e1.id_manager = e2.id_employe;
```

**Points √† v√©rifier** :
- `type: ref` sur e2 (utilise l'index sur id_manager)
- `key: idx_employes_manager`
- `rows: 1` (ou petit nombre)

### Performance : Self-Join vs sous-requ√™tes

```sql
-- Approche 1 : Self-Join (g√©n√©ralement plus rapide)
SELECT e1.nom, e2.nom AS manager
FROM employes e1
LEFT JOIN employes e2 ON e1.id_manager = e2.id_employe;

-- Approche 2 : Sous-requ√™te corr√©l√©e (plus lent)
SELECT
    e.nom,
    (SELECT nom FROM employes WHERE id_employe = e.id_manager) AS manager
FROM employes e;
```

üí° **R√®gle** : Self-Join est g√©n√©ralement **plus performant** que les sous-requ√™tes corr√©l√©es.

---

## Pi√®ges courants et solutions

### Pi√®ge 1 : Oublier les alias

```sql
-- ‚ùå ERREUR : Pas d'alias
SELECT *
FROM employes
JOIN employes ON employes.id_manager = employes.id_employe;
-- Erreur : "Not unique table/alias"

-- ‚úÖ CORRECT
SELECT *
FROM employes e1
JOIN employes e2 ON e1.id_manager = e2.id_employe;
```

### Pi√®ge 2 : Doublons dans les comparaisons

```sql
-- ‚ùå PROBL√àME : Doublons (A,B) et (B,A) + auto-match (A,A)
SELECT p1.nom, p2.nom
FROM produits p1
JOIN produits p2 ON p1.categorie = p2.categorie;
-- Inclut : (Laptop, Souris), (Souris, Laptop), (Laptop, Laptop)

-- ‚úÖ SOLUTION : Condition pour √©viter doublons
SELECT p1.nom, p2.nom
FROM produits p1
JOIN produits p2
    ON p1.categorie = p2.categorie
    AND p1.id_produit < p2.id_produit;  -- √âvite doublons et auto-match
```

### Pi√®ge 3 : Cycles dans les hi√©rarchies

Si votre structure contient des **cycles** (A ‚Üí B ‚Üí C ‚Üí A), le Self-Join peut cr√©er des boucles infinies.

```sql
-- V√©rifier l'absence de cycles
SELECT
    e1.id_employe,
    e1.nom,
    e1.id_manager,
    e2.id_manager AS manager_de_manager
FROM employes e1
JOIN employes e2 ON e1.id_manager = e2.id_employe
WHERE e2.id_manager = e1.id_employe;  -- Cycle d√©tect√© !
```

**Solution** : Ajouter des contraintes CHECK ou des triggers pour emp√™cher les cycles.

### Pi√®ge 4 : NULL dans les jointures hi√©rarchiques

```sql
-- ‚ö†Ô∏è ATTENTION : INNER JOIN exclut les n≈ìuds racine
SELECT e1.nom, e2.nom AS manager
FROM employes e1
INNER JOIN employes e2 ON e1.id_manager = e2.id_employe;
-- La directrice (id_manager = NULL) n'appara√Æt PAS

-- ‚úÖ CORRECT : LEFT JOIN pr√©serve tout
SELECT e1.nom, e2.nom AS manager
FROM employes e1
LEFT JOIN employes e2 ON e1.id_manager = e2.id_employe;
-- La directrice appara√Æt avec manager = NULL
```

---

## Cas d'usage avanc√©s

### Exemple 12 : Cha√Æne de recommandations (parrainage)

**Question m√©tier** : *Suivre la cha√Æne de parrainage sur 3 niveaux*

```sql
-- Programme de parrainage multi-niveaux
SELECT
    c1.nom AS client,
    c2.nom AS parrain_n1,
    c3.nom AS parrain_n2,
    c4.nom AS parrain_n3
FROM clients c1
LEFT JOIN clients c2 ON c1.id_parrain = c2.id_client
LEFT JOIN clients c3 ON c2.id_parrain = c3.id_client
LEFT JOIN clients c4 ON c3.id_parrain = c4.id_client
WHERE c1.date_inscription >= '2025-01-01'
ORDER BY c1.date_inscription DESC;
```

**Application** : Programmes de parrainage, MLM, calcul de commissions multi-niveaux.

### Exemple 13 : Graphe de relations (r√©seaux sociaux)

**Question m√©tier** : *Trouver les amis communs entre deux utilisateurs*

```sql
-- Amis en commun
SELECT
    u.nom AS utilisateur,
    ami_commun.nom AS ami_commun
FROM utilisateurs u
-- Amis de l'utilisateur 1
INNER JOIN amities a1
    ON u.id_utilisateur = a1.id_utilisateur
    AND a1.id_ami = 1001
-- Amis de l'utilisateur 2
INNER JOIN amities a2
    ON u.id_utilisateur = a2.id_utilisateur
    AND a2.id_ami = 2002
-- R√©cup√©rer le nom de l'ami commun
INNER JOIN utilisateurs ami_commun
    ON u.id_utilisateur = ami_commun.id_utilisateur
WHERE u.id_utilisateur NOT IN (1001, 2002);  -- Exclure les deux utilisateurs
```

**Application** : Suggestions d'amis, analyses de r√©seaux, graphes sociaux.

---

## ‚úÖ Points cl√©s √† retenir

1. **Self-Join = joindre une table √† elle-m√™me** ‚Äì avec alias diff√©rents obligatoires

2. **Alias OBLIGATOIRES** ‚Äì pour distinguer les diff√©rentes "instances" logiques de la table

3. **Types de jointure applicables** ‚Äì INNER, LEFT, RIGHT selon le besoin (comme jointures classiques)

4. **Cas d'usage principaux** ‚Äì hi√©rarchies, comparaisons intra-table, doublons, s√©quences, voisinage

5. **Condition id1 < id2 √©vite doublons** ‚Äì √©limine (A,B)+(B,A) et (A,A) dans les comparaisons

6. **LEFT JOIN pour hi√©rarchies** ‚Äì pr√©serve les n≈ìuds racine (NULL dans colonne parent)

7. **Limit√© √† 2-3 niveaux en pratique** ‚Äì au-del√†, pr√©f√©rer CTE r√©cursives

8. **Index sur colonnes de jointure critiques** ‚Äì surtout id_parent, id_manager

9. **Plus performant que sous-requ√™tes corr√©l√©es** ‚Äì Self-Join optimis√© par MariaDB

10. **Attention aux cycles hi√©rarchiques** ‚Äì peuvent cr√©er des r√©sultats incoh√©rents ou boucles

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB
- [üìñ JOIN Syntax](https://mariadb.com/kb/en/join-syntax/) ‚Äì Toutes les jointures incluant Self-Join
- [üìñ Recursive CTE](https://mariadb.com/kb/en/recursive-common-table-expressions-overview/) ‚Äì Alternative pour hi√©rarchies profondes
- [üìñ Window Functions](https://mariadb.com/kb/en/window-functions/) ‚Äì LAG/LEAD pour s√©quences

### Articles approfondis
- [Self-Joins Explained](https://modern-sql.com/feature/self-join) ‚Äì Concepts et patterns
- [Hierarchical Data](https://explainextended.com/2009/03/17/hierarchical-data-in-mysql-parents-and-children-in-one-query/) ‚Äì Gestion de hi√©rarchies

---

## üéì Conclusion du chapitre 3.3 Jointures

Vous avez maintenant ma√Ætris√© les **5 types de jointures** :

1. ‚úÖ **INNER JOIN** (3.3.1) ‚Äì Intersection, correspondances des deux c√¥t√©s
2. ‚úÖ **LEFT/RIGHT JOIN** (3.3.2) ‚Äì Jointures externes, pr√©servation d'un c√¥t√©
3. ‚úÖ **CROSS JOIN** (3.3.3) ‚Äì Produit cart√©sien, toutes combinaisons
4. ‚úÖ **SELF JOIN** (3.3.4) ‚Äì Joindre une table √† elle-m√™me

Ces techniques sont **fondamentales** pour exploiter pleinement le mod√®le relationnel. Combin√©es avec GROUP BY (3.2) et les agr√©gations (3.1), vous pouvez maintenant r√©soudre des probl√®mes d'analyse de donn√©es tr√®s complexes.

---

## ‚û°Ô∏è Chapitre suivant

**Chapitre 4 : Concepts Avanc√©s SQL**

Le prochain chapitre vous fera passer au niveau **Avanc√©** avec :
- **Requ√™tes r√©cursives (WITH RECURSIVE)** ‚Äì Hi√©rarchies compl√®tes, arbres, graphes
- **Window Functions** ‚Äì ROW_NUMBER, RANK, LAG, LEAD, moyennes mobiles
- **CTE (Common Table Expressions)** ‚Äì Requ√™tes modulaires et lisibles
- **JSON avanc√©** ‚Äì Manipulation, path expressions, sch√©ma validation
- **Et bien plus** ‚Äì Pour devenir un expert SQL !

F√©licitations pour avoir compl√©t√© les jointures ! üöÄ

---


‚è≠Ô∏è [Sous-requ√™tes et requ√™tes imbriqu√©es](/03-requetes-sql-intermediaires/04-sous-requetes.md)
