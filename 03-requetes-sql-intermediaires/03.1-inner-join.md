üîù Retour au [Sommaire](/SOMMAIRE.md)

# 3.3.1 INNER JOIN : Intersection

> **Niveau** : Interm√©diaire
> **Dur√©e estim√©e** : 2-3 heures
> **Pr√©requis** : Section 3.3 (Introduction aux jointures), ma√Ætrise de GROUP BY (3.2)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre le principe d'intersection d'INNER JOIN
- Ma√Ætriser la syntaxe INNER JOIN avec ses variantes
- Joindre efficacement 2, 3, 4 tables ou plus
- Distinguer √©qui-join et non-√©qui-join
- Combiner INNER JOIN avec GROUP BY et agr√©gations
- Identifier les cas d'usage appropri√©s pour INNER JOIN
- Optimiser les performances des jointures internes
- √âviter les pi√®ges courants

---

## Introduction

**INNER JOIN** (ou simplement **JOIN**) est le type de jointure **le plus utilis√©** en SQL. Il retourne uniquement les lignes o√π il existe une **correspondance dans les deux tables**.

### Le principe d'intersection

Imaginez deux ensembles :
- **Ensemble A** : clients
- **Ensemble B** : commandes

**INNER JOIN** ne retourne que les √©l√©ments pr√©sents **dans les deux ensembles** :

```
Clients                 Commandes
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Alice     ‚îÇ          ‚îÇ Commande 1 ‚îÇ ‚Üê Alice
‚îÇ  Bob       ‚îÇ          ‚îÇ Commande 2 ‚îÇ ‚Üê Alice
‚îÇ  Charlie   ‚îÇ          ‚îÇ Commande 3 ‚îÇ ‚Üê Bob
‚îÇ  Diana     ‚îÇ          ‚îÇ Commande 4 ‚îÇ ‚Üê √âric (n'existe pas)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

INNER JOIN clients ‚Üî commandes :
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Alice    + Commande 1  ‚îÇ  ‚úÖ Correspondance
‚îÇ Alice    + Commande 2  ‚îÇ  ‚úÖ Correspondance
‚îÇ Bob      + Commande 3  ‚îÇ  ‚úÖ Correspondance
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚ùå Charlie n'appara√Æt PAS (pas de commande)
‚ùå Diana n'appara√Æt PAS (pas de commande)
‚ùå Commande 4 n'appara√Æt PAS (client inexistant)
```

### Caract√©ristiques cl√©s

| Caract√©ristique | Comportement |
|-----------------|--------------|
| **Lignes retourn√©es** | Uniquement celles avec correspondance des **deux c√¥t√©s** |
| **Lignes sans match** | **Exclues** du r√©sultat |
| **NULL** | Aucune ligne avec NULL dans les colonnes jointes (sauf si recherche explicite) |
| **Performance** | G√©n√©ralement rapide avec index appropri√©s |
| **Cas d'usage** | Combiner des donn√©es existantes, analyses sur correspondances |

üí° **En r√©sum√©** : INNER JOIN = "Donne-moi seulement ce qui existe des **deux c√¥t√©s**"

---

## Syntaxe et variantes

### Syntaxe standard

```sql
SELECT colonnes
FROM table1
INNER JOIN table2
    ON table1.colonne = table2.colonne
[WHERE conditions]
[ORDER BY colonnes];
```

### Variantes syntaxiques

```sql
-- Syntaxe 1 : INNER JOIN explicite (recommand√©)
FROM clients c
INNER JOIN commandes cmd ON c.id_client = cmd.id_client

-- Syntaxe 2 : JOIN seul (INNER est implicite)
FROM clients c
JOIN commandes cmd ON c.id_client = cmd.id_client

-- Syntaxe 3 : USING (si colonnes ont le m√™me nom)
FROM clients c
JOIN commandes cmd USING (id_client)
-- √âquivalent √† : ON c.id_client = cmd.id_client
```

üí° **Recommandation** : Utilisez `INNER JOIN` explicite pour la clart√©, surtout si votre requ√™te m√©lange plusieurs types de jointures.

---

## Exemples progressifs

### Exemple 1 : Jointure simple sur deux tables

**Question m√©tier** : *Liste des commandes avec le nom du client*

```sql
-- Joindre clients et commandes
SELECT
    c.nom AS client,
    c.email,
    cmd.id_commande,
    cmd.date_commande,
    cmd.montant_total,
    cmd.statut
FROM clients c
INNER JOIN commandes cmd
    ON c.id_client = cmd.id_client
ORDER BY cmd.date_commande DESC
LIMIT 10;
```

**R√©sultat attendu** :
```
+----------------+-------------------+--------------+---------------------+---------------+-----------+
| client         | email             | id_commande  | date_commande       | montant_total | statut    |
+----------------+-------------------+--------------+---------------------+---------------+-----------+
| Alice Martin   | alice@email.com   |         1847 | 2025-12-10 14:23:00 |        289.95 | livr√©e    |
| Bob Dupont     | bob@email.com     |         1846 | 2025-12-10 11:42:00 |        149.99 | exp√©di√©e  |
| Alice Martin   | alice@email.com   |         1845 | 2025-12-09 18:15:00 |         89.97 | livr√©e    |
| Sophie Bernard | sophie@email.com  |         1844 | 2025-12-09 09:28:00 |        459.50 | confirm√©e |
+----------------+-------------------+--------------+---------------------+---------------+-----------+
```

**Explication** :
- Chaque ligne r√©sultat combine les colonnes de `clients` et `commandes`
- Seuls les clients **ayant au moins une commande** apparaissent
- Si Charlie n'a aucune commande, il n'appara√Æt **pas** dans le r√©sultat
- Une m√™me cliente (Alice) peut appara√Ætre plusieurs fois si elle a plusieurs commandes

**Cas d'usage** : Liste de commandes pour un dashboard, export CSV, email de confirmation.

### Exemple 2 : INNER JOIN avec filtrage WHERE

**Question m√©tier** : *Commandes livr√©es de plus de 100‚Ç¨ avec infos client*

```sql
-- Jointure + filtrage
SELECT
    c.nom,
    c.ville,
    cmd.id_commande,
    cmd.montant_total,
    cmd.date_commande
FROM clients c
INNER JOIN commandes cmd
    ON c.id_client = cmd.id_client
WHERE cmd.statut = 'livr√©e'           -- Filtre sur statut
  AND cmd.montant_total > 100          -- Filtre sur montant
  AND cmd.date_commande >= '2025-01-01'  -- Filtre sur date
ORDER BY cmd.montant_total DESC;
```

**R√©sultat attendu** :
```
+----------------+-------------+--------------+---------------+---------------------+
| nom            | ville       | id_commande  | montant_total | date_commande       |
+----------------+-------------+--------------+---------------+---------------------+
| Sophie Bernard | Marseille   |         1823 |        842.50 | 2025-11-28 10:15:00 |
| Alice Martin   | Paris       |         1809 |        624.99 | 2025-10-15 16:42:00 |
| Bob Dupont     | Lyon        |         1798 |        389.95 | 2025-09-22 11:23:00 |
+----------------+-------------+--------------+---------------+---------------------+
```

**Explication** :
- **Ordre d'ex√©cution** : JOIN d'abord, puis WHERE filtre les r√©sultats
- Les trois conditions WHERE se cumulent (AND)
- Seules les lignes passant **tous les filtres** sont retourn√©es

**Optimisation** : Avec un index sur `(statut, montant_total, date_commande)`, cette requ√™te sera tr√®s rapide.

### Exemple 3 : Jointure de 3 tables

**Question m√©tier** : *D√©tail des commandes avec client et produit*

```sql
-- Joindre clients, commandes et produits via details_commande
SELECT
    c.nom AS client,
    cmd.id_commande,
    cmd.date_commande,
    p.nom_produit,
    p.categorie,
    dc.quantite,
    dc.prix_unitaire,
    (dc.quantite * dc.prix_unitaire) AS sous_total
FROM clients c
INNER JOIN commandes cmd
    ON c.id_client = cmd.id_client
INNER JOIN details_commande dc
    ON cmd.id_commande = dc.id_commande
INNER JOIN produits p
    ON dc.id_produit = p.id_produit
WHERE cmd.date_commande >= DATE_SUB(CURDATE(), INTERVAL 7 DAY)
ORDER BY cmd.date_commande DESC, cmd.id_commande, p.nom_produit;
```

**R√©sultat attendu** :
```
+----------------+--------------+---------------------+--------------------+---------------+----------+---------------+------------+
| client         | id_commande  | date_commande       | nom_produit        | categorie     | quantite | prix_unitaire | sous_total |
+----------------+--------------+---------------------+--------------------+---------------+----------+---------------+------------+
| Alice Martin   |         1847 | 2025-12-10 14:23:00 | Laptop Pro         | √âlectronique  |        1 |       1299.99 |    1299.99 |
| Alice Martin   |         1847 | 2025-12-10 14:23:00 | Souris sans fil    | √âlectronique  |        2 |         29.99 |      59.98 |
| Bob Dupont     |         1846 | 2025-12-10 11:42:00 | Clavier m√©canique  | √âlectronique  |        1 |         89.99 |      89.99 |
+----------------+--------------+---------------------+--------------------+---------------+----------+---------------+------------+
```

**Explication** :
- **Flux de jointures** :
  1. `clients` JOIN `commandes` ‚Üí clients avec leurs commandes
  2. R√©sultat JOIN `details_commande` ‚Üí ajout des lignes de d√©tail par commande
  3. R√©sultat JOIN `produits` ‚Üí ajout des infos produit
- Une commande avec **N produits** g√©n√®re **N lignes** dans le r√©sultat
- Chaque INNER JOIN ne garde que les correspondances
- Le calcul `(quantite * prix_unitaire)` cr√©e une colonne d√©riv√©e

**Cas d'usage** : Facture d√©taill√©e, historique d'achat, analyse produit par client.

### Exemple 4 : Jointure de 4 tables avec agr√©gation

**Question m√©tier** : *CA par client et par cat√©gorie de produit*

```sql
-- Jointure multiple + agr√©gation
SELECT
    c.nom AS client,
    p.categorie,
    COUNT(DISTINCT cmd.id_commande) AS nb_commandes,
    SUM(dc.quantite) AS quantite_totale,
    ROUND(SUM(dc.quantite * dc.prix_unitaire), 2) AS ca_total
FROM clients c
INNER JOIN commandes cmd
    ON c.id_client = cmd.id_client
INNER JOIN details_commande dc
    ON cmd.id_commande = dc.id_commande
INNER JOIN produits p
    ON dc.id_produit = p.id_produit
WHERE cmd.statut IN ('confirm√©e', 'exp√©di√©e', 'livr√©e')
GROUP BY c.nom, p.categorie
HAVING ca_total > 100  -- Seulement si CA > 100‚Ç¨
ORDER BY ca_total DESC;
```

**R√©sultat attendu** :
```
+----------------+---------------+--------------+-----------------+----------+
| client         | categorie     | nb_commandes | quantite_totale | ca_total |
+----------------+---------------+--------------+-----------------+----------+
| Alice Martin   | √âlectronique  |           12 |              28 | 4847.92  |
| Sophie Bernard | √âlectronique  |            8 |              15 | 3293.45  |
| Bob Dupont     | V√™tements     |            5 |              23 | 1847.38  |
| Alice Martin   | Livres        |            7 |              34 |  847.25  |
+----------------+---------------+--------------+-----------------+----------+
```

**Explication** :
- **Combinaison puissante** : Jointures multiples + GROUP BY + HAVING
- GROUP BY sur `(client, categorie)` ‚Üí une ligne par combinaison
- `COUNT(DISTINCT cmd.id_commande)` √©vite de compter plusieurs fois la m√™me commande
- HAVING filtre **apr√®s agr√©gation** (impossible avec WHERE)

**Cas d'usage** : Segmentation client, analyse de panier, recommandations produits.

### Exemple 5 : USING pour simplifier la syntaxe

**Quand les colonnes ont le m√™me nom dans les deux tables** :

```sql
-- Avec ON (syntaxe standard)
SELECT c.nom, cmd.id_commande
FROM clients c
INNER JOIN commandes cmd
    ON c.id_client = cmd.id_client;

-- Avec USING (syntaxe abr√©g√©e)
SELECT c.nom, cmd.id_commande
FROM clients c
INNER JOIN commandes cmd
    USING (id_client);
```

**R√©sultat** : Identique dans les deux cas.

**Avantage de USING** :
- ‚úÖ Plus concis
- ‚úÖ √âvite de r√©p√©ter le nom de colonne
- ‚úÖ Dans le SELECT, `id_client` n'est plus ambigu (une seule colonne dans le r√©sultat)

**Limitation de USING** :
- ‚ùå Fonctionne uniquement si les colonnes ont **exactement le m√™me nom**
- ‚ùå Ne permet pas de conditions complexes (ex : `ON A.col1 = B.col2 AND A.col3 > B.col4`)

üí° **Conseil** : Utilisez USING pour les jointures simples sur cl√©s √©trang√®res, ON pour les cas complexes.

---

## √âqui-join vs Non-√©qui-join

### √âqui-join (le plus courant)

Un **√©qui-join** utilise l'op√©rateur d'**√©galit√©** (=) dans la condition ON.

```sql
-- √âqui-join : √©galit√© entre cl√©s
FROM clients c
INNER JOIN commandes cmd
    ON c.id_client = cmd.id_client  -- Op√©rateur =
```

**C'est le cas √† 95%** des jointures en production.

### Non-√©qui-join

Un **non-√©qui-join** utilise d'autres op√©rateurs (<, >, <=, >=, !=, BETWEEN, etc.).

#### Exemple 6 : Non-√©qui-join avec op√©rateur de comparaison

**Question m√©tier** : *Trouver les produits plus chers que le panier moyen du client*

```sql
-- Non-√©qui-join avec >
SELECT
    c.nom AS client,
    stats.panier_moyen,
    p.nom_produit,
    p.prix_unitaire
FROM clients c
INNER JOIN (
    -- Sous-requ√™te : panier moyen par client
    SELECT
        id_client,
        AVG(montant_total) AS panier_moyen
    FROM commandes
    WHERE statut IN ('confirm√©e', 'exp√©di√©e', 'livr√©e')
    GROUP BY id_client
) AS stats ON c.id_client = stats.id_client
INNER JOIN produits p
    ON p.prix_unitaire > stats.panier_moyen  -- NON-√âQUI-JOIN
WHERE p.categorie = '√âlectronique'
ORDER BY c.nom, p.prix_unitaire DESC;
```

**R√©sultat attendu** :
```
+----------------+---------------+--------------------+---------------+
| client         | panier_moyen  | nom_produit        | prix_unitaire |
+----------------+---------------+--------------------+---------------+
| Alice Martin   |        148.50 | Laptop Pro         |       1299.99 |
| Alice Martin   |        148.50 | Tablette Premium   |        649.99 |
| Alice Martin   |        148.50 | √âcran 27"          |        389.99 |
| Bob Dupont     |         89.30 | Laptop Pro         |       1299.99 |
+----------------+---------------+--------------------+---------------+
```

**Explication** :
- Jointure `c.id_client = stats.id_client` ‚Üí √©qui-join classique
- Jointure `p.prix_unitaire > stats.panier_moyen` ‚Üí **non-√©qui-join**
- Chaque produit dont le prix d√©passe le panier moyen du client est retourn√©
- Utile pour proposer des **upsells** (mont√©e en gamme)

**Cas d'usage** : Recommandations premium, segmentation tarifaire, analyses de propension.

#### Exemple 7 : Non-√©qui-join avec BETWEEN

**Question m√©tier** : *Historique des prix : quel prix √©tait en vigueur lors de chaque commande ?*

Supposons une table `historique_prix` avec des p√©riodes de validit√© :

```sql
CREATE TABLE historique_prix (
    id_historique INT PRIMARY KEY,
    id_produit INT,
    prix DECIMAL(10,2),
    date_debut DATE,
    date_fin DATE  -- NULL si toujours valide
);

-- Trouver le prix applicable pour chaque ligne de commande
SELECT
    cmd.id_commande,
    cmd.date_commande,
    p.nom_produit,
    hp.prix AS prix_en_vigueur,
    dc.prix_unitaire AS prix_facture
FROM commandes cmd
INNER JOIN details_commande dc
    ON cmd.id_commande = dc.id_commande
INNER JOIN produits p
    ON dc.id_produit = p.id_produit
INNER JOIN historique_prix hp
    ON p.id_produit = hp.id_produit
    AND DATE(cmd.date_commande) BETWEEN hp.date_debut
        AND COALESCE(hp.date_fin, '9999-12-31')  -- NON-√âQUI-JOIN
ORDER BY cmd.date_commande DESC;
```

**Cas d'usage** : Audit de prix, d√©tection de remises, conformit√© tarifaire.

---

## Conditions de jointure multiples

Vous pouvez combiner plusieurs conditions dans la clause ON avec AND/OR.

### Exemple 8 : Jointure avec conditions multiples

**Question m√©tier** : *Commandes avec produits en stock uniquement*

```sql
-- Conditions multiples dans ON
SELECT
    cmd.id_commande,
    p.nom_produit,
    p.stock,
    dc.quantite
FROM commandes cmd
INNER JOIN details_commande dc
    ON cmd.id_commande = dc.id_commande
INNER JOIN produits p
    ON dc.id_produit = p.id_produit
    AND p.stock > 0  -- Condition suppl√©mentaire dans ON
WHERE cmd.statut = 'en_attente'
ORDER BY cmd.id_commande;
```

**‚ö†Ô∏è Important** : Pour INNER JOIN, mettre `p.stock > 0` dans ON ou dans WHERE donne le **m√™me r√©sultat**. Mais pour LEFT/RIGHT JOIN, l'emplacement change tout (nous verrons cela en section 3.3.2).

**Par convention** :
- **ON** : Conditions de **relation** entre tables (cl√©s √©trang√®res, crit√®res de jointure)
- **WHERE** : Conditions de **filtrage** sur le r√©sultat final

```sql
-- ‚úÖ PR√âF√âR√â : S√©paration claire
INNER JOIN produits p
    ON dc.id_produit = p.id_produit  -- Relation
WHERE p.stock > 0  -- Filtrage
```

---

## INNER JOIN avec agr√©gations : Cas avanc√©s

### Exemple 9 : Comptage de commandes par client

**Question m√©tier** : *Nombre de commandes par client (uniquement ceux qui ont command√©)*

```sql
-- Agr√©gation apr√®s jointure
SELECT
    c.id_client,
    c.nom,
    c.email,
    COUNT(cmd.id_commande) AS nb_commandes,
    ROUND(SUM(cmd.montant_total), 2) AS ca_total,
    ROUND(AVG(cmd.montant_total), 2) AS panier_moyen,
    MIN(cmd.date_commande) AS premiere_commande,
    MAX(cmd.date_commande) AS derniere_commande
FROM clients c
INNER JOIN commandes cmd
    ON c.id_client = cmd.id_client
WHERE cmd.statut IN ('confirm√©e', 'exp√©di√©e', 'livr√©e')
GROUP BY c.id_client, c.nom, c.email
HAVING nb_commandes >= 5  -- Au moins 5 commandes
ORDER BY ca_total DESC;
```

**R√©sultat attendu** :
```
+------------+----------------+-------------------+--------------+----------+--------------+---------------------+---------------------+
| id_client  | nom            | email             | nb_commandes | ca_total | panier_moyen | premiere_commande   | derniere_commande   |
+------------+----------------+-------------------+--------------+----------+--------------+---------------------+---------------------+
|       1847 | Alice Martin   | alice@email.com   |           47 | 14283.45 |       303.90 | 2024-02-15 10:23:00 | 2025-12-08 15:42:00 |
|       2934 | Bob Dupont     | bob@email.com     |           38 | 12847.92 |       338.10 | 2023-11-20 08:15:00 | 2025-11-30 19:23:00 |
|       5621 | Sophie Bernard | sophie@email.com  |           29 | 11293.18 |       389.42 | 2024-05-10 14:38:00 | 2025-12-10 11:05:00 |
+------------+----------------+-------------------+--------------+----------+--------------+---------------------+---------------------+
```

**Points cl√©s** :
- ‚ùå Les clients **sans commandes** n'apparaissent PAS (INNER JOIN)
- ‚úÖ GROUP BY inclut toutes les colonnes non agr√©g√©es du SELECT
- ‚úÖ HAVING filtre sur les agr√©gations (apr√®s GROUP BY)

**Cas d'usage** : Segmentation RFM, identification VIP, programmes de fid√©lit√©.

### Exemple 10 : CA par cat√©gorie avec pourcentage du total

**Question m√©tier** : *Contribution de chaque cat√©gorie au CA total*

```sql
-- CA par cat√©gorie avec pourcentage
SELECT
    p.categorie,
    COUNT(DISTINCT cmd.id_commande) AS nb_commandes,
    SUM(dc.quantite) AS quantite_vendue,
    ROUND(SUM(dc.quantite * dc.prix_unitaire), 2) AS ca_categorie,
    ROUND(
        100.0 * SUM(dc.quantite * dc.prix_unitaire) / (
            SELECT SUM(quantite * prix_unitaire)
            FROM details_commande dc2
            JOIN commandes cmd2 ON dc2.id_commande = cmd2.id_commande
            WHERE cmd2.statut IN ('confirm√©e', 'exp√©di√©e', 'livr√©e')
        ),
        2
    ) AS pct_ca_total
FROM produits p
INNER JOIN details_commande dc
    ON p.id_produit = dc.id_produit
INNER JOIN commandes cmd
    ON dc.id_commande = cmd.id_commande
WHERE cmd.statut IN ('confirm√©e', 'exp√©di√©e', 'livr√©e')
GROUP BY p.categorie
ORDER BY ca_categorie DESC;
```

**R√©sultat attendu** :
```
+------------------+--------------+-----------------+--------------+--------------+
| categorie        | nb_commandes | quantite_vendue | ca_categorie | pct_ca_total |
+------------------+--------------+-----------------+--------------+--------------+
| √âlectronique     |         8472 |           15847 |   847293.45  |        45.87 |
| V√™tements        |         6234 |           28392 |   492847.92  |        26.69 |
| Alimentation     |         5821 |           42983 |   284729.38  |        15.42 |
| Livres           |         3847 |           18472 |   223847.18  |        12.12 |
+------------------+--------------+-----------------+--------------+--------------+
```

**Cas d'usage** : Analyse ABC, mix produit, d√©cisions d'assortiment.

### Exemple 11 : Top 5 clients par cat√©gorie

**Question m√©tier** : *Pour chaque cat√©gorie, qui sont les 5 meilleurs clients ?*

```sql
-- Utilisation de variables (window functions pr√©f√©rable en 4.2)
SELECT
    categorie,
    client,
    ca_client_categorie
FROM (
    SELECT
        p.categorie,
        c.nom AS client,
        SUM(dc.quantite * dc.prix_unitaire) AS ca_client_categorie,
        ROW_NUMBER() OVER (
            PARTITION BY p.categorie
            ORDER BY SUM(dc.quantite * dc.prix_unitaire) DESC
        ) AS rang
    FROM clients c
    INNER JOIN commandes cmd ON c.id_client = cmd.id_client
    INNER JOIN details_commande dc ON cmd.id_commande = dc.id_commande
    INNER JOIN produits p ON dc.id_produit = p.id_produit
    WHERE cmd.statut IN ('confirm√©e', 'exp√©di√©e', 'livr√©e')
    GROUP BY p.categorie, c.nom
) AS classement
WHERE rang <= 5
ORDER BY categorie, rang;
```

**Note** : Cet exemple utilise les **window functions** (ROW_NUMBER) que nous d√©taillerons en section 4.2. Mais il montre la puissance de combiner INNER JOIN avec des techniques avanc√©es.

---

## Cas d'usage m√©tier r√©els

### Cas 1 : Rapport de ventes d√©taill√© pour facturation

```sql
-- Facture compl√®te d'une commande
SELECT
    -- En-t√™te facture
    cmd.id_commande AS numero_facture,
    cmd.date_commande AS date_facture,
    c.nom AS client_nom,
    c.email AS client_email,
    CONCAT(c.adresse, ', ', c.code_postal, ' ', c.ville) AS client_adresse,

    -- Lignes de d√©tail
    p.nom_produit,
    p.reference_produit,
    dc.quantite,
    dc.prix_unitaire,
    (dc.quantite * dc.prix_unitaire) AS montant_ligne,

    -- Pied de page
    cmd.montant_total,
    cmd.statut
FROM commandes cmd
INNER JOIN clients c ON cmd.id_client = c.id_client
INNER JOIN details_commande dc ON cmd.id_commande = dc.id_commande
INNER JOIN produits p ON dc.id_produit = p.id_produit
WHERE cmd.id_commande = 1847  -- Commande sp√©cifique
ORDER BY dc.id_detail;
```

**Application** : G√©n√©ration de factures PDF, emails de confirmation, exports comptables.

### Cas 2 : Analyse de panier (Market Basket Analysis)

**Question m√©tier** : *Quels produits sont souvent achet√©s ensemble ?*

```sql
-- Produits fr√©quemment achet√©s ensemble
SELECT
    p1.nom_produit AS produit_1,
    p2.nom_produit AS produit_2,
    COUNT(DISTINCT dc1.id_commande) AS nb_commandes_communes
FROM details_commande dc1
INNER JOIN details_commande dc2
    ON dc1.id_commande = dc2.id_commande
    AND dc1.id_produit < dc2.id_produit  -- √âvite les doublons (A,B) et (B,A)
INNER JOIN produits p1 ON dc1.id_produit = p1.id_produit
INNER JOIN produits p2 ON dc2.id_produit = p2.id_produit
GROUP BY p1.nom_produit, p2.nom_produit
HAVING nb_commandes_communes >= 10  -- Au moins 10 fois ensemble
ORDER BY nb_commandes_communes DESC
LIMIT 20;
```

**R√©sultat attendu** :
```
+---------------------+---------------------+------------------------+
| produit_1           | produit_2           | nb_commandes_communes  |
+---------------------+---------------------+------------------------+
| Laptop Pro          | Souris sans fil     |                    847 |
| Laptop Pro          | Housse ordinateur   |                    623 |
| Clavier m√©canique   | Souris sans fil     |                    412 |
+---------------------+---------------------+------------------------+
```

**Application** : Recommandations produits, placement en magasin, promotions crois√©es.

### Cas 3 : Analyse de coh√©rence des donn√©es

**Question m√©tier** : *D√©tecter les incoh√©rences entre quantit√© command√©e et stock*

```sql
-- Commandes dont la quantit√© d√©passe le stock actuel
SELECT
    cmd.id_commande,
    cmd.date_commande,
    c.nom AS client,
    p.nom_produit,
    dc.quantite AS quantite_commandee,
    p.stock AS stock_actuel,
    (dc.quantite - p.stock) AS deficit
FROM commandes cmd
INNER JOIN clients c ON cmd.id_client = c.id_client
INNER JOIN details_commande dc ON cmd.id_commande = dc.id_commande
INNER JOIN produits p ON dc.id_produit = p.id_produit
WHERE dc.quantite > p.stock
  AND cmd.statut IN ('en_attente', 'confirm√©e')
ORDER BY deficit DESC;
```

**Application** : Alerte stock, r√©approvisionnement prioritaire, ajustement commandes.

### Cas 4 : Tableau de bord commercial

```sql
-- KPI journaliers pour dashboard
SELECT
    DATE(cmd.date_commande) AS date_vente,
    COUNT(DISTINCT cmd.id_commande) AS nb_commandes,
    COUNT(DISTINCT cmd.id_client) AS nb_clients_actifs,
    SUM(dc.quantite) AS unites_vendues,
    COUNT(DISTINCT dc.id_produit) AS nb_produits_distincts,
    ROUND(SUM(dc.quantite * dc.prix_unitaire), 2) AS ca_jour,
    ROUND(AVG(cmd.montant_total), 2) AS panier_moyen
FROM commandes cmd
INNER JOIN details_commande dc ON cmd.id_commande = dc.id_commande
WHERE cmd.statut IN ('confirm√©e', 'exp√©di√©e', 'livr√©e')
  AND cmd.date_commande >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
GROUP BY DATE(cmd.date_commande)
ORDER BY date_vente DESC;
```

**Application** : Dashboard temps r√©el, suivi objectifs, alertes automatiques.

---

## Optimisation et performance

### Index : La cl√© de la performance

Les index sur les colonnes de jointure sont **critiques** pour la performance.

#### Sans index (‚ùå LENT)

```sql
-- Configuration sans index
EXPLAIN
SELECT c.nom, cmd.id_commande
FROM clients c
INNER JOIN commandes cmd ON c.id_client = cmd.id_client;

-- R√©sultat EXPLAIN :
-- type: ALL (scan complet de table)
-- rows: 12463 (examine toutes les lignes)
-- Extra: Using where; Using join buffer
```

**Temps d'ex√©cution** : 2.3 secondes sur 50 000 commandes

#### Avec index (‚úÖ RAPIDE)

```sql
-- Cr√©er l'index sur la cl√© √©trang√®re
CREATE INDEX idx_commandes_client ON commandes(id_client);

-- M√™me requ√™te
EXPLAIN
SELECT c.nom, cmd.id_commande
FROM clients c
INNER JOIN commandes cmd ON c.id_client = cmd.id_client;

-- R√©sultat EXPLAIN :
-- type: ref (utilise l'index)
-- rows: 3 (moyenne par client)
-- key: idx_commandes_client
```

**Temps d'ex√©cution** : 0.02 secondes (115x plus rapide !)

### R√®gles d'indexation pour INNER JOIN

‚úÖ **Toujours indexer** :
- Les cl√©s √©trang√®res (colonnes dans ON)
- Les colonnes fr√©quemment utilis√©es dans WHERE apr√®s jointure

```sql
-- Index recommand√©s pour notre sch√©ma
CREATE INDEX idx_commandes_client ON commandes(id_client);
CREATE INDEX idx_commandes_statut ON commandes(statut);
CREATE INDEX idx_commandes_date ON commandes(date_commande);
CREATE INDEX idx_details_commande ON details_commande(id_commande);
CREATE INDEX idx_details_produit ON details_commande(id_produit);
```

### Index composites pour requ√™tes complexes

Si vous filtrez souvent sur plusieurs colonnes :

```sql
-- Index composite sur (statut, date_commande)
CREATE INDEX idx_commandes_statut_date
ON commandes(statut, date_commande);

-- Requ√™te b√©n√©ficiant de cet index
SELECT ...
FROM commandes
WHERE statut = 'livr√©e'
  AND date_commande >= '2025-01-01';
```

### Analyser les performances avec EXPLAIN

```sql
-- Analyser une jointure complexe
EXPLAIN
SELECT c.nom, p.nom_produit, SUM(dc.quantite)
FROM clients c
INNER JOIN commandes cmd ON c.id_client = cmd.id_client
INNER JOIN details_commande dc ON cmd.id_commande = dc.id_commande
INNER JOIN produits p ON dc.id_produit = p.id_produit
GROUP BY c.nom, p.nom_produit;
```

**Points √† v√©rifier dans EXPLAIN** :
- **type** : `ref` ou `eq_ref` = bon, `ALL` = mauvais (scan complet)
- **key** : Nom de l'index utilis√© (NULL = aucun index)
- **rows** : Nombre estim√© de lignes examin√©es (moins = mieux)
- **Extra** : `Using index` = tr√®s bon (covering index)

### EXPLAIN ANALYZE (MariaDB 10.6+)

```sql
-- Version d√©taill√©e avec temps r√©els
EXPLAIN ANALYZE
SELECT ...;
```

Affiche les **temps d'ex√©cution r√©els** pour chaque √©tape de la requ√™te.

---

## Pi√®ges courants et solutions

### Pi√®ge 1 : Multiplication des lignes (Effet "explosion")

**Probl√®me** : Joindre deux tables avec relations 1:N peut multiplier les lignes de fa√ßon inattendue.

```sql
-- Commandes avec leurs d√©tails ET √©valuations
SELECT
    cmd.id_commande,
    dc.id_produit,
    eval.note
FROM commandes cmd
INNER JOIN details_commande dc ON cmd.id_commande = dc.id_commande
INNER JOIN evaluations eval ON cmd.id_commande = eval.id_commande;

-- Si commande a 3 produits ET 2 √©valuations
-- R√©sultat : 3 √ó 2 = 6 lignes !
```

**Solution** : Utilisez `COUNT(DISTINCT ...)` ou des sous-requ√™tes s√©par√©es.

```sql
-- ‚úÖ Correct avec COUNT DISTINCT
SELECT
    cmd.id_commande,
    COUNT(DISTINCT dc.id_produit) AS nb_produits,
    COUNT(DISTINCT eval.id_evaluation) AS nb_evaluations
FROM commandes cmd
LEFT JOIN details_commande dc ON cmd.id_commande = dc.id_commande
LEFT JOIN evaluations eval ON cmd.id_commande = eval.id_commande
GROUP BY cmd.id_commande;
```

### Pi√®ge 2 : Confusion entre INNER et LEFT JOIN

```sql
-- ‚ùå ERREUR : Utiliser INNER JOIN pour compter
SELECT c.nom, COUNT(cmd.id_commande) AS nb_commandes
FROM clients c
INNER JOIN commandes cmd ON c.id_client = cmd.id_client
GROUP BY c.nom;
-- Les clients SANS commande n'apparaissent PAS !

-- ‚úÖ CORRECT : Utiliser LEFT JOIN
SELECT c.nom, COUNT(cmd.id_commande) AS nb_commandes
FROM clients c
LEFT JOIN commandes cmd ON c.id_client = cmd.id_client
GROUP BY c.nom;
-- Tous les clients apparaissent, m√™me ceux avec 0 commande
```

üí° **R√®gle** : Si vous voulez **tous les √©l√©ments d'un c√¥t√©**, utilisez LEFT JOIN (section 3.3.2).

### Pi√®ge 3 : Oublier de filtrer les statuts

```sql
-- ‚ùå INCLUT les commandes annul√©es !
SELECT SUM(montant_total)
FROM commandes cmd
INNER JOIN clients c ON cmd.id_client = c.id_client;

-- ‚úÖ CORRECT : Filtrer les statuts
SELECT SUM(montant_total)
FROM commandes cmd
INNER JOIN clients c ON cmd.id_client = c.id_client
WHERE cmd.statut IN ('confirm√©e', 'exp√©di√©e', 'livr√©e');
```

### Pi√®ge 4 : Produit cart√©sien accidentel

```sql
-- ‚ùå OUBLI de condition de jointure
SELECT c.nom, p.nom_produit
FROM clients c
INNER JOIN produits p;  -- Pas de ON !
-- R√©sultat : 1000 clients √ó 500 produits = 500 000 lignes !

-- ‚úÖ CORRECT : Avec condition appropri√©e
SELECT c.nom, p.nom_produit
FROM clients c
INNER JOIN commandes cmd ON c.id_client = cmd.id_client
INNER JOIN details_commande dc ON cmd.id_commande = dc.id_commande
INNER JOIN produits p ON dc.id_produit = p.id_produit;
```

---

## ‚úÖ Points cl√©s √† retenir

1. **INNER JOIN retourne uniquement les correspondances** ‚Äì les lignes sans match sont exclues des deux c√¥t√©s

2. **Syntaxe recommand√©e : INNER JOIN ... ON** ‚Äì plus claire que l'ancienne syntaxe √† virgule

3. **USING simplifie les jointures** sur colonnes de m√™me nom ‚Äì mais ON est plus flexible

4. **√âqui-join (=) repr√©sente 95% des cas** ‚Äì non-√©qui-join (<, >, BETWEEN) pour cas sp√©cifiques

5. **ON d√©finit la relation, WHERE filtre** ‚Äì distinction importante m√™me si r√©sultat souvent identique pour INNER JOIN

6. **Jointures multiples s'encha√Ænent s√©quentiellement** ‚Äì 3, 4, 5 tables ou plus sont courants en production

7. **INDEX sur colonnes de jointure = obligatoire** ‚Äì diff√©rence entre millisecondes et secondes

8. **EXPLAIN r√©v√®le les probl√®mes de performance** ‚Äì v√©rifiez type=ref et key=index_name

9. **Combinaison avec GROUP BY tr√®s puissante** ‚Äì agr√©gations sur donn√©es jointes pour analyses complexes

10. **Attention √† l'effet "explosion"** ‚Äì relations 1:N peuvent multiplier les lignes, utiliser COUNT(DISTINCT)

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB
- [üìñ JOIN Syntax](https://mariadb.com/kb/en/join-syntax/) ‚Äì Syntaxe d√©taill√©e
- [üìñ Index Optimization](https://mariadb.com/kb/en/optimization-and-indexes/) ‚Äì Guide d'indexation
- [üìñ EXPLAIN](https://mariadb.com/kb/en/explain/) ‚Äì Analyse des plans d'ex√©cution

### Articles approfondis
- [SQL INNER JOIN Explained](https://modern-sql.com/feature/inner-join) ‚Äì Guide conceptuel
- [Join Performance](https://use-the-index-luke.com/sql/join) ‚Äì Optimisation avanc√©e

---

## ‚û°Ô∏è Section suivante

**[3.3.2 LEFT/RIGHT JOIN : Jointures externes](./03.2-left-right-join.md)**

Maintenant que vous ma√Ætrisez INNER JOIN (intersection), la prochaine section couvre les **jointures externes** :
- **LEFT JOIN** : Pr√©server **toutes les lignes de gauche** + correspondances de droite (NULL si pas de match)
- **RIGHT JOIN** : Sym√©trique de LEFT JOIN
- **Diff√©rence ON vs WHERE** critique pour LEFT/RIGHT JOIN
- D√©tection des valeurs manquantes et analyse d'√©carts
- Cas d'usage : clients sans commande, produits non vendus, audits de compl√©tude

Les jointures externes compl√®tent INNER JOIN pour couvrir 100% des besoins m√©tier ! üéØ

---


‚è≠Ô∏è [LEFT/RIGHT JOIN : Jointures externes](/03-requetes-sql-intermediaires/03.2-left-right-join.md)
