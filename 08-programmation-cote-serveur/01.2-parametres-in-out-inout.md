üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.1.2 Param√®tres IN, OUT, INOUT

> **Niveau** : Interm√©diaire √† Avanc√©
> **Dur√©e estim√©e** : 2.5 heures
> **Pr√©requis** : Section 8.1.1 (Syntaxe CREATE PROCEDURE), compr√©hension des variables SQL

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre les trois modes de passage de param√®tres (IN, OUT, INOUT)
- Choisir le type de param√®tre appropri√© selon le contexte
- Utiliser les param√®tres OUT pour retourner des valeurs multiples
- Impl√©menter des proc√©dures complexes avec des param√®tres mixtes
- Appliquer les bonnes pratiques de gestion des param√®tres

---

## Introduction

Les **param√®tres** constituent le m√©canisme de communication entre l'appelant et la proc√©dure stock√©e. MariaDB propose trois modes de passage de param√®tres, chacun ayant un r√¥le sp√©cifique dans le flux de donn√©es.

### Pourquoi trois types de param√®tres ?

La distinction entre IN, OUT et INOUT permet de :
- **Clarifier l'intention** : Le d√©veloppeur comprend imm√©diatement le r√¥le de chaque param√®tre
- **Optimiser les performances** : Le serveur traite diff√©remment les param√®tres selon leur mode
- **Renforcer la s√©curit√©** : Les param√®tres IN ne peuvent pas √™tre modifi√©s par la proc√©dure
- **Retourner plusieurs valeurs** : Contrairement aux fonctions (une seule valeur de retour)

üí° **Analogie** : Pensez aux param√®tres comme des "canaux de communication" :
- **IN** : Canal en lecture seule (entr√©e seulement)
- **OUT** : Canal en √©criture seule (sortie seulement)
- **INOUT** : Canal bidirectionnel (entr√©e et sortie)

---

## Param√®tres IN (Entr√©e)

### Syntaxe et comportement

Les param√®tres **IN** transmettent des valeurs **vers** la proc√©dure. Ils sont en **lecture seule** √† l'int√©rieur de la proc√©dure.

```sql
CREATE PROCEDURE nom_procedure(
    IN param1 type_donnees,
    IN param2 type_donnees
)
BEGIN
    -- param1 et param2 peuvent √™tre lus mais pas modifi√©s
END;
```

### Caract√©ristiques des param√®tres IN

- **Mode par d√©faut** : Si aucun mode n'est sp√©cifi√©, IN est implicite
- **Valeur d'entr√©e** : Transmise par l'appelant
- **Lecture seule** : La proc√©dure ne peut pas modifier la valeur (comportement logique, mais MariaDB autorise techniquement la modification locale sans effet sur l'appelant)
- **Pas de retour** : Les modifications internes ne sont pas visibles √† l'ext√©rieur

### Exemple 1 : Param√®tres IN simples

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE calculer_prix_ttc(
    IN p_prix_ht DECIMAL(10,2),
    IN p_taux_tva DECIMAL(5,2)
)
    COMMENT 'Calcule et affiche le prix TTC'
BEGIN
    DECLARE v_prix_ttc DECIMAL(10,2);

    -- Calcul bas√© sur les param√®tres IN
    SET v_prix_ttc = p_prix_ht * (1 + p_taux_tva / 100);

    -- Affichage du r√©sultat
    SELECT
        p_prix_ht AS prix_ht,
        p_taux_tva AS taux_tva,
        v_prix_ttc AS prix_ttc;
END//

DELIMITER ;

-- Appels avec diff√©rentes valeurs
CALL calculer_prix_ttc(100.00, 20.00);  -- Prix HT: 100‚Ç¨, TVA: 20%
CALL calculer_prix_ttc(250.50, 5.50);   -- Prix HT: 250.50‚Ç¨, TVA: 5.5%
```

**Explications** :
- `p_prix_ht` et `p_taux_tva` sont en lecture seule
- Les valeurs sont pass√©es lors de l'appel avec `CALL`
- La proc√©dure calcule mais ne modifie pas les param√®tres d'origine

### Exemple 2 : Recherche avec param√®tres IN

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE rechercher_produits(
    IN p_categorie VARCHAR(50),
    IN p_prix_min DECIMAL(10,2),
    IN p_prix_max DECIMAL(10,2)
)
    COMMENT 'Recherche des produits selon crit√®res'
BEGIN
    -- Validation des param√®tres
    IF p_prix_min < 0 OR p_prix_max < 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Les prix doivent √™tre positifs';
    END IF;

    IF p_prix_min > p_prix_max THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Prix minimum sup√©rieur au prix maximum';
    END IF;

    -- Requ√™te de recherche
    SELECT
        id,
        nom,
        categorie,
        prix,
        stock_disponible
    FROM produits
    WHERE
        categorie = p_categorie
        AND prix BETWEEN p_prix_min AND p_prix_max
        AND stock_disponible > 0
    ORDER BY prix ASC;
END//

DELIMITER ;

-- Utilisation
CALL rechercher_produits('√âlectronique', 100.00, 500.00);
```

‚ö†Ô∏è **Attention** : MariaDB permet techniquement de modifier un param√®tre IN √† l'int√©rieur de la proc√©dure, mais cette modification reste locale et n'affecte pas la variable de l'appelant. C'est une mauvaise pratique √† √©viter.

```sql
-- Mauvaise pratique (√† √©viter)
CREATE PROCEDURE mauvais_exemple(IN p_valeur INT)
BEGIN
    SET p_valeur = p_valeur + 10;  -- Modification locale uniquement
    SELECT p_valeur;  -- Affiche la valeur modifi√©e
END;
-- Apr√®s l'appel, la variable externe reste inchang√©e !
```

---

## Param√®tres OUT (Sortie)

### Syntaxe et comportement

Les param√®tres **OUT** permettent √† la proc√©dure de **retourner des valeurs** √† l'appelant. Ils sont en **√©criture** depuis la proc√©dure.

```sql
CREATE PROCEDURE nom_procedure(
    OUT param1 type_donnees,
    OUT param2 type_donnees
)
BEGIN
    -- param1 et param2 peuvent √™tre modifi√©s
    SET param1 = valeur1;
    SET param2 = valeur2;
END;
```

### Caract√©ristiques des param√®tres OUT

- **Valeur initiale** : `NULL` au d√©but de la proc√©dure (la valeur pass√©e est ignor√©e)
- **√âcriture seule** : Destin√©s √† retourner des r√©sultats
- **Retour multiple** : Permet de retourner plusieurs valeurs (contrairement aux fonctions)
- **Variables obligatoires** : L'appelant doit passer des variables (pas de litt√©raux)

### Exemple 1 : Calcul avec retour OUT

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE calculer_statistiques_commande(
    IN p_commande_id INT,
    OUT p_nombre_lignes INT,
    OUT p_montant_total DECIMAL(10,2),
    OUT p_montant_moyen DECIMAL(10,2)
)
    COMMENT 'Calcule les statistiques d''une commande'
BEGIN
    -- Calcul du nombre de lignes
    SELECT COUNT(*)
    INTO p_nombre_lignes
    FROM lignes_commande
    WHERE commande_id = p_commande_id;

    -- Calcul du montant total
    SELECT COALESCE(SUM(quantite * prix_unitaire), 0)
    INTO p_montant_total
    FROM lignes_commande
    WHERE commande_id = p_commande_id;

    -- Calcul du montant moyen
    IF p_nombre_lignes > 0 THEN
        SET p_montant_moyen = p_montant_total / p_nombre_lignes;
    ELSE
        SET p_montant_moyen = 0;
    END IF;
END//

DELIMITER ;

-- Utilisation avec variables de session
SET @nb_lignes = 0;
SET @total = 0;
SET @moyenne = 0;

CALL calculer_statistiques_commande(12345, @nb_lignes, @total, @moyenne);

-- Affichage des r√©sultats
SELECT
    @nb_lignes AS nombre_lignes,
    @total AS montant_total,
    @moyenne AS montant_moyen;
```

**Points cl√©s** :
- Les param√®tres OUT retournent trois valeurs diff√©rentes
- L'appelant utilise des variables de session (`@variable`)
- `SELECT ... INTO` affecte les valeurs aux param√®tres OUT
- `COALESCE` g√®re les cas NULL

### Exemple 2 : Validation et code d'erreur

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE verifier_stock_produit(
    IN p_produit_id INT,
    IN p_quantite_demandee INT,
    OUT p_stock_disponible INT,
    OUT p_stock_suffisant BOOLEAN,
    OUT p_code_erreur VARCHAR(20),
    OUT p_message_erreur VARCHAR(255)
)
    COMMENT 'V√©rifie la disponibilit√© d''un produit'
BEGIN
    -- Initialisation des codes de retour
    SET p_code_erreur = 'SUCCESS';
    SET p_message_erreur = '';

    -- V√©rification existence du produit
    IF NOT EXISTS (SELECT 1 FROM produits WHERE id = p_produit_id) THEN
        SET p_stock_disponible = 0;
        SET p_stock_suffisant = FALSE;
        SET p_code_erreur = 'ERR_NOT_FOUND';
        SET p_message_erreur = 'Produit inexistant';
        -- On quitte pr√©matur√©ment
        LEAVE procedure_body;  -- N√©cessite un label
    END IF;

    -- R√©cup√©ration du stock
    SELECT stock_disponible
    INTO p_stock_disponible
    FROM produits
    WHERE id = p_produit_id;

    -- V√©rification suffisance
    IF p_stock_disponible >= p_quantite_demandee THEN
        SET p_stock_suffisant = TRUE;
        SET p_message_erreur = 'Stock suffisant';
    ELSE
        SET p_stock_suffisant = FALSE;
        SET p_code_erreur = 'ERR_INSUFFICIENT';
        SET p_message_erreur = CONCAT(
            'Stock insuffisant : ',
            p_stock_disponible,
            ' disponible(s), ',
            p_quantite_demandee,
            ' demand√©(s)'
        );
    END IF;
END//

DELIMITER ;

-- Utilisation
CALL verifier_stock_produit(
    101,           -- ID produit
    5,             -- Quantit√© demand√©e
    @stock,        -- Stock disponible (OUT)
    @suffisant,    -- Bool√©en suffisant (OUT)
    @code,         -- Code erreur (OUT)
    @message       -- Message (OUT)
);

SELECT @stock, @suffisant, @code, @message;
```

**Pattern utile** : Retourner un code d'erreur et un message permet √† l'application de g√©rer les cas d'erreur m√©tier proprement.

### Exemple 3 : G√©n√©ration d'identifiant unique

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE generer_numero_commande(
    OUT p_numero_commande VARCHAR(20)
)
    COMMENT 'G√©n√®re un num√©ro de commande unique'
BEGIN
    DECLARE v_compteur INT;
    DECLARE v_date_format VARCHAR(8);

    -- Format : CMD-YYYYMMDD-XXXXX
    SET v_date_format = DATE_FORMAT(NOW(), '%Y%m%d');

    -- R√©cup√©ration du compteur du jour
    SELECT COALESCE(MAX(CAST(SUBSTRING(numero_commande, -5) AS UNSIGNED)), 0) + 1
    INTO v_compteur
    FROM commandes
    WHERE DATE(date_creation) = CURDATE();

    -- Construction du num√©ro
    SET p_numero_commande = CONCAT(
        'CMD-',
        v_date_format,
        '-',
        LPAD(v_compteur, 5, '0')
    );
END//

DELIMITER ;

-- G√©n√©ration de num√©ros
CALL generer_numero_commande(@numero1);
SELECT @numero1;  -- CMD-20251212-00001

CALL generer_numero_commande(@numero2);
SELECT @numero2;  -- CMD-20251212-00002
```

üí° **Conseil** : Les param√®tres OUT sont id√©aux pour retourner des identifiants g√©n√©r√©s, des codes de statut, ou des m√©tadonn√©es sur l'op√©ration effectu√©e.

---

## Param√®tres INOUT (Entr√©e-Sortie)

### Syntaxe et comportement

Les param√®tres **INOUT** combinent les deux modes : ils re√ßoivent une valeur en **entr√©e** et peuvent la **modifier** pour la retourner.

```sql
CREATE PROCEDURE nom_procedure(
    INOUT param1 type_donnees
)
BEGIN
    -- param1 peut √™tre lu et modifi√©
    SET param1 = nouvelle_valeur;
END;
```

### Caract√©ristiques des param√®tres INOUT

- **Bidirectionnel** : Valeur en entr√©e ET en sortie
- **Modification** : La proc√©dure peut lire la valeur initiale et la modifier
- **√âconomie de param√®tres** : Un seul param√®tre au lieu de deux (IN + OUT)
- **Variables obligatoires** : Comme OUT, n√©cessite des variables, pas de litt√©raux

### Exemple 1 : Modification de valeur INOUT

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE appliquer_remise(
    INOUT p_prix DECIMAL(10,2),
    IN p_pourcentage_remise DECIMAL(5,2)
)
    COMMENT 'Applique une remise au prix fourni'
BEGIN
    -- Validation
    IF p_pourcentage_remise < 0 OR p_pourcentage_remise > 100 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Pourcentage de remise invalide (0-100)';
    END IF;

    -- Application de la remise sur le prix existant
    SET p_prix = p_prix * (1 - p_pourcentage_remise / 100);

    -- Arrondi √† 2 d√©cimales
    SET p_prix = ROUND(p_prix, 2);
END//

DELIMITER ;

-- Utilisation
SET @prix_article = 150.00;
SELECT @prix_article AS prix_avant;  -- 150.00

CALL appliquer_remise(@prix_article, 20);  -- Remise de 20%
SELECT @prix_article AS prix_apres;   -- 120.00

CALL appliquer_remise(@prix_article, 10);  -- Remise additionnelle de 10%
SELECT @prix_article AS prix_final;   -- 108.00
```

**Avantage INOUT** : Le prix est modifi√© "en place", permettant d'appliquer des remises successives.

### Exemple 2 : Compteur avec INOUT

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE incrementer_compteur(
    INOUT p_compteur INT,
    IN p_increment INT
)
    COMMENT 'Incr√©mente un compteur de la valeur sp√©cifi√©e'
BEGIN
    -- Validation
    IF p_compteur IS NULL THEN
        SET p_compteur = 0;
    END IF;

    -- Incr√©mentation
    SET p_compteur = p_compteur + p_increment;

    -- Log de l'op√©ration
    INSERT INTO historique_compteurs (
        valeur_avant,
        increment,
        valeur_apres,
        date_operation
    ) VALUES (
        p_compteur - p_increment,
        p_increment,
        p_compteur,
        NOW()
    );
END//

DELIMITER ;

-- Utilisation pour suivre des √©v√©nements
SET @nb_connexions = 0;

CALL incrementer_compteur(@nb_connexions, 1);  -- 1
CALL incrementer_compteur(@nb_connexions, 1);  -- 2
CALL incrementer_compteur(@nb_connexions, 5);  -- 7

SELECT @nb_connexions AS total_connexions;  -- 7
```

### Exemple 3 : Normalisation de donn√©es INOUT

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE normaliser_telephone(
    INOUT p_telephone VARCHAR(20)
)
    COMMENT 'Normalise un num√©ro de t√©l√©phone au format international'
BEGIN
    -- Suppression des espaces, tirets, points, parenth√®ses
    SET p_telephone = REPLACE(p_telephone, ' ', '');
    SET p_telephone = REPLACE(p_telephone, '-', '');
    SET p_telephone = REPLACE(p_telephone, '.', '');
    SET p_telephone = REPLACE(p_telephone, '(', '');
    SET p_telephone = REPLACE(p_telephone, ')', '');

    -- Ajout du pr√©fixe international si absent
    IF NOT p_telephone LIKE '+%' THEN
        -- Supposons num√©ros fran√ßais
        IF LENGTH(p_telephone) = 10 AND LEFT(p_telephone, 1) = '0' THEN
            SET p_telephone = CONCAT('+33', SUBSTRING(p_telephone, 2));
        ELSE
            SET p_telephone = CONCAT('+33', p_telephone);
        END IF;
    END IF;

    -- Validation finale
    IF LENGTH(p_telephone) < 10 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Num√©ro de t√©l√©phone invalide';
    END IF;
END//

DELIMITER ;

-- Normalisation de diff√©rents formats
SET @tel1 = '01 23 45 67 89';
CALL normaliser_telephone(@tel1);
SELECT @tel1;  -- +33123456789

SET @tel2 = '06-12-34-56-78';
CALL normaliser_telephone(@tel2);
SELECT @tel2;  -- +33612345678

SET @tel3 = '+33 7 89 01 23 45';
CALL normaliser_telephone(@tel3);
SELECT @tel3;  -- +33789012345
```

**Cas d'usage INOUT** : Parfait pour les fonctions de normalisation, validation, ou transformation o√π la valeur doit √™tre modifi√©e sur place.

---

## Combinaison de param√®tres IN, OUT et INOUT

### Exemple : Proc√©dure de traitement de commande

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE traiter_commande_complete(
    IN p_client_id INT,
    IN p_produit_id INT,
    IN p_quantite INT,
    INOUT p_montant_panier DECIMAL(10,2),
    OUT p_commande_id INT,
    OUT p_stock_restant INT,
    OUT p_statut VARCHAR(20),
    OUT p_message VARCHAR(255)
)
    COMMENT 'Traite une commande compl√®te avec gestion de stock'
BEGIN
    DECLARE v_prix_unitaire DECIMAL(10,2);
    DECLARE v_stock_actuel INT;
    DECLARE v_montant_ligne DECIMAL(10,2);

    -- Handler pour les erreurs
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        SET p_statut = 'ERREUR';
        SET p_message = 'Erreur lors du traitement de la commande';
        ROLLBACK;
    END;

    -- Initialisation
    START TRANSACTION;

    -- 1. V√©rification du client
    IF NOT EXISTS (SELECT 1 FROM clients WHERE id = p_client_id) THEN
        SET p_statut = 'ERREUR';
        SET p_message = 'Client inexistant';
        ROLLBACK;
        LEAVE procedure_body;
    END IF;

    -- 2. R√©cup√©ration du prix et du stock
    SELECT prix, stock_disponible
    INTO v_prix_unitaire, v_stock_actuel
    FROM produits
    WHERE id = p_produit_id;

    IF v_prix_unitaire IS NULL THEN
        SET p_statut = 'ERREUR';
        SET p_message = 'Produit inexistant';
        ROLLBACK;
        LEAVE procedure_body;
    END IF;

    -- 3. V√©rification du stock
    IF v_stock_actuel < p_quantite THEN
        SET p_statut = 'STOCK_INSUFFISANT';
        SET p_message = CONCAT('Stock insuffisant : ', v_stock_actuel, ' disponible(s)');
        SET p_stock_restant = v_stock_actuel;
        ROLLBACK;
        LEAVE procedure_body;
    END IF;

    -- 4. Calcul du montant
    SET v_montant_ligne = v_prix_unitaire * p_quantite;

    -- 5. Mise √† jour du panier (INOUT : on cumule)
    SET p_montant_panier = p_montant_panier + v_montant_ligne;

    -- 6. Cr√©ation de la commande
    INSERT INTO commandes (client_id, date_commande, montant_total, statut)
    VALUES (p_client_id, NOW(), v_montant_ligne, 'EN_COURS');

    SET p_commande_id = LAST_INSERT_ID();

    -- 7. Ajout de la ligne de commande
    INSERT INTO lignes_commande (commande_id, produit_id, quantite, prix_unitaire)
    VALUES (p_commande_id, p_produit_id, p_quantite, v_prix_unitaire);

    -- 8. Mise √† jour du stock
    UPDATE produits
    SET stock_disponible = stock_disponible - p_quantite
    WHERE id = p_produit_id;

    -- 9. R√©cup√©ration du stock restant
    SELECT stock_disponible
    INTO p_stock_restant
    FROM produits
    WHERE id = p_produit_id;

    -- 10. Finalisation
    COMMIT;
    SET p_statut = 'SUCCES';
    SET p_message = 'Commande cr√©√©e avec succ√®s';
END//

DELIMITER ;

-- Utilisation compl√®te
SET @montant_panier = 0.00;  -- INOUT : montant cumul√©

-- Premi√®re commande
CALL traiter_commande_complete(
    1001,              -- Client ID (IN)
    5001,              -- Produit ID (IN)
    3,                 -- Quantit√© (IN)
    @montant_panier,   -- Montant panier (INOUT)
    @cmd_id1,          -- ID commande (OUT)
    @stock1,           -- Stock restant (OUT)
    @statut1,          -- Statut (OUT)
    @message1          -- Message (OUT)
);

SELECT @montant_panier, @cmd_id1, @stock1, @statut1, @message1;

-- Deuxi√®me commande (le panier cumule)
CALL traiter_commande_complete(
    1001,              -- M√™me client
    5002,              -- Autre produit
    2,                 -- Quantit√©
    @montant_panier,   -- Panier mis √† jour (INOUT)
    @cmd_id2,          -- Nouvelle commande (OUT)
    @stock2,           -- Stock restant (OUT)
    @statut2,          -- Statut (OUT)
    @message2          -- Message (OUT)
);

SELECT @montant_panier AS panier_total, @cmd_id2, @stock2, @statut2, @message2;
```

**Points d'apprentissage** :
1. **IN** : Client, produit, quantit√© (donn√©es d'entr√©e)
2. **INOUT** : Montant du panier cumul√© entre appels
3. **OUT** : ID commande g√©n√©r√©, stock restant, statut, message
4. **Transaction** : COMMIT si succ√®s, ROLLBACK si erreur
5. **Handler** : Gestion centralis√©e des erreurs

---

## Tableau comparatif des types de param√®tres

| Caract√©ristique | IN | OUT | INOUT |
|----------------|----|----|-------|
| **Direction** | Entr√©e ‚Üí Proc√©dure | Proc√©dure ‚Üí Sortie | Bidirectionnel |
| **Valeur initiale** | Fournie par l'appelant | `NULL` | Fournie par l'appelant |
| **Lecture** | ‚úÖ Oui | ‚ö†Ô∏è Possible mais NULL | ‚úÖ Oui |
| **Modification** | ‚ö†Ô∏è Locale uniquement | ‚úÖ Oui | ‚úÖ Oui |
| **Retour √† l'appelant** | ‚ùå Non | ‚úÖ Oui | ‚úÖ Oui |
| **Type d'argument requis** | Litt√©ral ou variable | Variable obligatoire | Variable obligatoire |
| **Cas d'usage typique** | Filtres, crit√®res | R√©sultats, statuts | Compteurs, cumuls |
| **Par d√©faut** | ‚úÖ Oui (si non sp√©cifi√©) | ‚ùå Non | ‚ùå Non |

---

## Bonnes pratiques de gestion des param√®tres

### 1. Pr√©fixage et nommage coh√©rent

```sql
-- ‚úÖ BON : Pr√©fixes clairs
CREATE PROCEDURE exemple_bonnes_pratiques(
    IN p_client_id INT,           -- p_ pour param√®tre IN
    IN p_date_debut DATE,         -- p_ pour param√®tre IN
    OUT p_nb_commandes INT,       -- p_ pour param√®tre OUT
    OUT p_montant_total DECIMAL(10,2),  -- p_ pour param√®tre OUT
    INOUT p_compteur INT          -- p_ pour param√®tre INOUT
)

-- ‚ùå MAUVAIS : Noms ambigus
CREATE PROCEDURE exemple_mauvais(
    IN id INT,                    -- Quel ID ?
    IN d DATE,                    -- Abr√©viation obscure
    OUT x INT,                    -- Signification ?
    OUT tot DECIMAL(10,2)         -- Abr√©viation
)
```

**Convention recommand√©e** :
- `p_nom_parametre` : Tous les param√®tres
- Noms descriptifs et explicites
- snake_case coh√©rent

### 2. Validation des param√®tres IN

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE creer_utilisateur_valide(
    IN p_nom VARCHAR(100),
    IN p_email VARCHAR(255),
    IN p_age INT,
    OUT p_user_id INT,
    OUT p_erreur VARCHAR(255)
)
BEGIN
    -- Initialisation
    SET p_erreur = NULL;
    SET p_user_id = NULL;

    -- Validation 1 : Nom non vide
    IF p_nom IS NULL OR TRIM(p_nom) = '' THEN
        SET p_erreur = 'Le nom est obligatoire';
        LEAVE procedure_body;
    END IF;

    -- Validation 2 : Email format valide (simple)
    IF p_email NOT LIKE '%@%.%' THEN
        SET p_erreur = 'Format d''email invalide';
        LEAVE procedure_body;
    END IF;

    -- Validation 3 : √Çge coh√©rent
    IF p_age < 18 OR p_age > 120 THEN
        SET p_erreur = '√Çge invalide (18-120 ans)';
        LEAVE procedure_body;
    END IF;

    -- Validation 4 : Email unique
    IF EXISTS (SELECT 1 FROM utilisateurs WHERE email = p_email) THEN
        SET p_erreur = 'Cet email existe d√©j√†';
        LEAVE procedure_body;
    END IF;

    -- Insertion si toutes validations pass√©es
    INSERT INTO utilisateurs (nom, email, age, date_creation)
    VALUES (p_nom, p_email, p_age, NOW());

    SET p_user_id = LAST_INSERT_ID();
END//

DELIMITER ;

-- Utilisation
CALL creer_utilisateur_valide('Dupont', 'dupont@example.com', 35, @id, @err);
SELECT @id, @err;
```

üí° **Meilleure pratique** : Toujours valider les param√®tres IN en d√©but de proc√©dure pour √©chouer rapidement en cas de donn√©es invalides.

### 3. Initialisation des param√®tres OUT

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE initialiser_sorties(
    IN p_operation VARCHAR(50),
    OUT p_resultat INT,
    OUT p_code_retour VARCHAR(20),
    OUT p_message VARCHAR(255)
)
BEGIN
    -- ‚úÖ BON : Initialisation explicite des OUT
    SET p_resultat = 0;
    SET p_code_retour = 'PENDING';
    SET p_message = '';

    -- Logique de traitement
    IF p_operation = 'test' THEN
        SET p_resultat = 100;
        SET p_code_retour = 'SUCCESS';
        SET p_message = 'Test r√©ussi';
    ELSE
        SET p_code_retour = 'ERROR';
        SET p_message = 'Op√©ration inconnue';
    END IF;
END//

DELIMITER ;
```

‚ö†Ô∏è **Attention** : Les param√®tres OUT sont NULL par d√©faut. Initialisez-les toujours pour √©viter les comportements inattendus.

### 4. Documentation des param√®tres

```sql
DELIMITER //

/*
 * Proc√©dure : calculer_remise_client
 * Description : Calcule la remise applicable √† un client selon son historique
 *
 * Param√®tres :
 *   IN p_client_id         : Identifiant unique du client
 *   IN p_montant_achat     : Montant de l'achat en cours (HT)
 *   OUT p_taux_remise      : Taux de remise applicable en % (0-100)
 *   OUT p_montant_remise   : Montant de la remise en euros
 *   OUT p_categorie_client : Cat√©gorie du client (BRONZE/SILVER/GOLD/PLATINUM)
 *
 * Retour :
 *   - p_taux_remise : 0% √† 25% selon la cat√©gorie
 *   - p_montant_remise : Montant calcul√© de la remise
 *   - p_categorie_client : Cat√©gorie d√©termin√©e
 *
 * R√®gles m√©tier :
 *   - BRONZE (0-1000‚Ç¨) : 0% de remise
 *   - SILVER (1000-5000‚Ç¨) : 5% de remise
 *   - GOLD (5000-10000‚Ç¨) : 10% de remise
 *   - PLATINUM (>10000‚Ç¨) : 15% de remise + bonus
 */
CREATE OR REPLACE PROCEDURE calculer_remise_client(
    IN p_client_id INT,
    IN p_montant_achat DECIMAL(10,2),
    OUT p_taux_remise DECIMAL(5,2),
    OUT p_montant_remise DECIMAL(10,2),
    OUT p_categorie_client VARCHAR(20)
)
    COMMENT 'Calcule la remise client selon historique d''achats'
BEGIN
    DECLARE v_total_achats DECIMAL(10,2);

    -- Calcul du total des achats historiques
    SELECT COALESCE(SUM(montant_total), 0)
    INTO v_total_achats
    FROM commandes
    WHERE client_id = p_client_id
      AND statut = 'VALIDEE';

    -- D√©termination de la cat√©gorie et du taux
    CASE
        WHEN v_total_achats >= 10000 THEN
            SET p_categorie_client = 'PLATINUM';
            SET p_taux_remise = 15.00;
        WHEN v_total_achats >= 5000 THEN
            SET p_categorie_client = 'GOLD';
            SET p_taux_remise = 10.00;
        WHEN v_total_achats >= 1000 THEN
            SET p_categorie_client = 'SILVER';
            SET p_taux_remise = 5.00;
        ELSE
            SET p_categorie_client = 'BRONZE';
            SET p_taux_remise = 0.00;
    END CASE;

    -- Calcul du montant de remise
    SET p_montant_remise = p_montant_achat * (p_taux_remise / 100);
END//

DELIMITER ;
```

### 5. Gestion des valeurs NULL

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE traiter_valeurs_null(
    IN p_valeur_optionnelle VARCHAR(100),
    OUT p_resultat VARCHAR(100)
)
BEGIN
    -- ‚úÖ BON : Gestion explicite de NULL
    IF p_valeur_optionnelle IS NULL THEN
        SET p_resultat = 'Valeur par d√©faut';
    ELSE
        SET p_resultat = UPPER(p_valeur_optionnelle);
    END IF;

    -- Alternative avec COALESCE
    SET p_resultat = COALESCE(
        UPPER(p_valeur_optionnelle),
        'Valeur par d√©faut'
    );
END//

DELIMITER ;

-- Test avec NULL
CALL traiter_valeurs_null(NULL, @res);
SELECT @res;  -- 'Valeur par d√©faut'

-- Test avec valeur
CALL traiter_valeurs_null('test', @res);
SELECT @res;  -- 'TEST'
```

### 6. Limitation du nombre de param√®tres

```sql
-- ‚ùå MAUVAIS : Trop de param√®tres (>10)
CREATE PROCEDURE trop_de_parametres(
    IN p1 INT, IN p2 INT, IN p3 INT, IN p4 INT, IN p5 INT,
    IN p6 VARCHAR(50), IN p7 VARCHAR(50), IN p8 DATE, IN p9 DATE,
    OUT p10 INT, OUT p11 DECIMAL, OUT p12 VARCHAR(100), OUT p13 TEXT
)

-- ‚úÖ BON : Regrouper en table temporaire ou JSON
CREATE PROCEDURE avec_table_temp(
    IN p_parametres_json JSON,
    OUT p_resultats_json JSON
)
BEGIN
    -- Extraction des param√®tres JSON
    DECLARE v_param1 INT DEFAULT JSON_VALUE(p_parametres_json, '$.param1');
    DECLARE v_param2 VARCHAR(50) DEFAULT JSON_VALUE(p_parametres_json, '$.param2');

    -- Traitement...

    -- Construction du r√©sultat JSON
    SET p_resultats_json = JSON_OBJECT(
        'resultat1', valeur1,
        'resultat2', valeur2
    );
END;
```

üí° **R√®gle empirique** : Maximum 7-8 param√®tres. Au-del√†, envisager JSON ou tables temporaires.

---

## Erreurs courantes et pi√®ges √† √©viter

### Erreur 1 : Oublier les variables pour OUT/INOUT

```sql
-- ‚ùå MAUVAIS : Litt√©ral avec OUT
CALL ma_procedure_out(123);  -- ERREUR : OUT requiert une variable

-- ‚úÖ BON : Variable de session
SET @resultat = 0;
CALL ma_procedure_out(@resultat);
```

### Erreur 2 : Confondre IN et INOUT

```sql
-- ‚ùå MAUVAIS : Attendre une modification avec IN
SET @prix = 100;
CALL appliquer_remise_in(@prix, 10);  -- Si IN, @prix reste 100

-- ‚úÖ BON : Utiliser INOUT pour modification
CREATE PROCEDURE appliquer_remise_inout(INOUT p_prix DECIMAL, IN p_remise DECIMAL)
BEGIN
    SET p_prix = p_prix * (1 - p_remise / 100);
END;

SET @prix = 100;
CALL appliquer_remise_inout(@prix, 10);  -- @prix devient 90
```

### Erreur 3 : Ne pas v√©rifier les param√®tres NULL

```sql
-- ‚ùå MAUVAIS : Pas de gestion NULL
CREATE PROCEDURE diviser(IN p_a INT, IN p_b INT, OUT p_resultat DECIMAL)
BEGIN
    SET p_resultat = p_a / p_b;  -- Division par z√©ro si p_b = 0 !
END;

-- ‚úÖ BON : Validation
CREATE PROCEDURE diviser_safe(IN p_a INT, IN p_b INT, OUT p_resultat DECIMAL)
BEGIN
    IF p_b = 0 OR p_b IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Division par z√©ro';
    END IF;
    SET p_resultat = p_a / p_b;
END;
```

### Erreur 4 : Modifier un param√®tre IN (mauvaise pratique)

```sql
-- ‚ö†Ô∏è MAUVAISE PRATIQUE (m√™me si techniquement possible)
CREATE PROCEDURE modifier_in(IN p_valeur INT)
BEGIN
    SET p_valeur = p_valeur + 10;  -- Modification locale, non persistante
    SELECT p_valeur;  -- Affiche valeur+10
END;
-- L'appelant ne verra PAS la modification !

-- ‚úÖ BON : Utiliser INOUT ou OUT
CREATE PROCEDURE modifier_inout(INOUT p_valeur INT)
BEGIN
    SET p_valeur = p_valeur + 10;  -- Modification persistante
END;
```

---

## ‚úÖ Points cl√©s √† retenir

- **IN** : Mode par d√©faut, entr√©e seule, lecture pour la proc√©dure, pas de retour modifi√©
- **OUT** : Sortie seule, valeur initiale NULL, doit √™tre une variable, retour vers l'appelant
- **INOUT** : Bidirectionnel, combine IN et OUT, id√©al pour modifications sur place
- **Variables obligatoires** : OUT et INOUT n√©cessitent des variables (`@var`), pas de litt√©raux
- **Pr√©fixage** : Utilisez `p_` pour tous les param√®tres pour √©viter les ambigu√Øt√©s
- **Validation** : Toujours valider les param√®tres IN en d√©but de proc√©dure
- **Initialisation** : Initialisez explicitement les param√®tres OUT
- **Documentation** : Documentez chaque param√®tre avec son r√¥le et ses contraintes
- **Limitation** : Maximum 7-8 param√®tres, sinon envisager JSON ou tables temporaires
- **Gestion NULL** : G√©rez explicitement les valeurs NULL avec `IS NULL` ou `COALESCE`

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation officielle MariaDB - CREATE PROCEDURE](https://mariadb.com/kb/en/create-procedure/)
- [üìñ Stored Procedure Parameters](https://mariadb.com/kb/en/stored-routine-parameters/)
- [üìñ Variables - User-Defined](https://mariadb.com/kb/en/user-defined-variables/)
- [üìñ SELECT INTO Statement](https://mariadb.com/kb/en/select-into/)
- [üí° Blog : Best Practices for Procedure Parameters](https://mariadb.com/resources/blog/)

---

## ‚û°Ô∏è Section suivante

**[8.1.3 Appel avec CALL](./01.3-appel-call.md)** : D√©couvrez les diff√©rentes m√©thodes d'appel de proc√©dures stock√©es, la gestion des r√©sultats multiples, et l'int√©gration dans les applications.

---


‚è≠Ô∏è [Appel avec CALL](/08-programmation-cote-serveur/01.3-appel-call.md)
