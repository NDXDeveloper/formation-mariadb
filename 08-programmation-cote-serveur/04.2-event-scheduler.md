üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.4.2 Event Scheduler

> **Niveau** : Avanc√©
> **Dur√©e estim√©e** : 2 heures
> **Pr√©requis** : Section 8.4.1 (CREATE EVENT et planification), compr√©hension de l'administration MariaDB

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Configurer et administrer l'Event Scheduler de mani√®re optimale
- Comprendre le fonctionnement interne du scheduler
- Monitorer et diagnostiquer les probl√®mes d'ex√©cution des events
- G√©rer la performance et la charge du scheduler
- S√©curiser l'acc√®s et l'ex√©cution des events
- Impl√©menter des strat√©gies de haute disponibilit√© pour les events

---

## Introduction

L'**Event Scheduler** est le composant de MariaDB responsable de l'ex√©cution automatique des events. C'est un **thread d√©di√©** qui surveille en permanence les events planifi√©s et d√©clenche leur ex√©cution au moment appropri√©.

### Architecture de l'Event Scheduler

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         MariaDB Server                  ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ   Event Scheduler Thread          ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   - Surveillance des events       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   - D√©clenchement des ex√©cutions  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   - Gestion de la file d'attente  ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                ‚Üì                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ   Event Worker Threads            ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   - Thread 1 (event A)            ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   - Thread 2 (event B)            ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   - Thread 3 (event C)            ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

üí° **Principe** : Un thread principal surveille, plusieurs threads workers ex√©cutent en parall√®le.

---

## Configuration de l'Event Scheduler

### Variable event_scheduler

```sql
-- Consultation de la configuration actuelle
SHOW VARIABLES LIKE 'event_scheduler';

-- Valeurs possibles :
-- ON       : Scheduler actif et fonctionnel
-- OFF      : Scheduler arr√™t√© (peut √™tre red√©marr√© dynamiquement)
-- DISABLED : Scheduler d√©sactiv√© au niveau syst√®me (n√©cessite red√©marrage)
```

### Activation dynamique (sans red√©marrage)

```sql
-- D√©marrer l'Event Scheduler
SET GLOBAL event_scheduler = ON;

-- V√©rification : un thread "event_scheduler" doit appara√Ætre
SHOW PROCESSLIST;

/*
+----+-----------------+-----------+------+---------+------+----------------------------+
| Id | User            | Host      | db   | Command | Time | State                      |
+----+-----------------+-----------+------+---------+------+----------------------------+
|  1 | event_scheduler | localhost | NULL | Daemon  |  120 | Waiting for next activation|
+----+-----------------+-----------+------+---------+------+----------------------------+
*/
```

### Arr√™t dynamique

```sql
-- Arr√™ter l'Event Scheduler
SET GLOBAL event_scheduler = OFF;

-- Les events en cours d'ex√©cution se terminent
-- Mais aucun nouvel event n'est d√©clench√©

-- V√©rification : le thread "event_scheduler" dispara√Æt
SHOW PROCESSLIST;
```

‚ö†Ô∏è **Attention** : Arr√™ter le scheduler n'arr√™te pas imm√©diatement les events en cours d'ex√©cution. Il attend qu'ils se terminent.

### Configuration permanente

```ini
# Dans my.cnf ou my.ini
[mysqld]
event_scheduler = ON

# D√©sactivation permanente (n√©cessite red√©marrage)
[mysqld]
event_scheduler = DISABLED
```

**Diff√©rence ON vs DISABLED** :
- `ON/OFF` : Peut √™tre modifi√© dynamiquement avec SET GLOBAL
- `DISABLED` : Bloque toute activation, n√©cessite modification my.cnf + red√©marrage

### Variables de configuration associ√©es

```sql
-- Nombre de threads event worker (consultation uniquement)
SHOW STATUS LIKE 'Com_create_event';
SHOW STATUS LIKE 'Com_alter_event';
SHOW STATUS LIKE 'Com_drop_event';

-- Variables de performance
SHOW VARIABLES LIKE '%event%';
SHOW VARIABLES LIKE '%scheduler%';
```

---

## Monitoring de l'Event Scheduler

### V√©rification du statut du scheduler

```sql
-- M√©thode 1 : Variable globale
SELECT @@global.event_scheduler;

-- M√©thode 2 : Processlist
SELECT * FROM information_schema.PROCESSLIST
WHERE USER = 'event_scheduler';

-- M√©thode 3 : SHOW PROCESSLIST
SHOW PROCESSLIST\G
```

### √âtat des events

```sql
-- Vue d'ensemble des events
SELECT
    EVENT_SCHEMA AS base,
    EVENT_NAME AS event,
    STATUS AS statut,
    EVENT_TYPE AS type,
    INTERVAL_VALUE AS intervalle,
    INTERVAL_FIELD AS unite,
    LAST_EXECUTED AS derniere_exec,
    EXECUTE_AT AS exec_planifiee,
    STARTS AS debut,
    ENDS AS fin,
    ON_COMPLETION AS preservation
FROM information_schema.EVENTS
ORDER BY EVENT_SCHEMA, LAST_EXECUTED DESC;
```

### Events actifs et leur fr√©quence

```sql
-- Events actifs par fr√©quence d'ex√©cution
SELECT
    EVENT_NAME,
    STATUS,
    INTERVAL_VALUE,
    INTERVAL_FIELD,
    CASE
        WHEN INTERVAL_FIELD = 'SECOND' THEN INTERVAL_VALUE
        WHEN INTERVAL_FIELD = 'MINUTE' THEN INTERVAL_VALUE * 60
        WHEN INTERVAL_FIELD = 'HOUR' THEN INTERVAL_VALUE * 3600
        WHEN INTERVAL_FIELD = 'DAY' THEN INTERVAL_VALUE * 86400
        ELSE 999999
    END AS secondes_entre_exec,
    LAST_EXECUTED,
    TIMESTAMPDIFF(SECOND, LAST_EXECUTED, NOW()) AS secondes_depuis_derniere_exec
FROM information_schema.EVENTS
WHERE EVENT_SCHEMA = DATABASE()
  AND STATUS = 'ENABLED'
ORDER BY secondes_entre_exec ASC;
```

### D√©tection d'events probl√©matiques

```sql
-- Events qui ne se sont pas ex√©cut√©s r√©cemment
SELECT
    EVENT_NAME,
    INTERVAL_VALUE,
    INTERVAL_FIELD,
    LAST_EXECUTED,
    TIMESTAMPDIFF(MINUTE, LAST_EXECUTED, NOW()) AS minutes_depuis,
    CASE
        WHEN INTERVAL_FIELD = 'MINUTE' THEN INTERVAL_VALUE
        WHEN INTERVAL_FIELD = 'HOUR' THEN INTERVAL_VALUE * 60
        WHEN INTERVAL_FIELD = 'DAY' THEN INTERVAL_VALUE * 1440
        ELSE 999999
    END AS minutes_attendues
FROM information_schema.EVENTS
WHERE
    EVENT_SCHEMA = DATABASE()
    AND STATUS = 'ENABLED'
    AND LAST_EXECUTED IS NOT NULL
    AND TIMESTAMPDIFF(MINUTE, LAST_EXECUTED, NOW()) >
        CASE
            WHEN INTERVAL_FIELD = 'MINUTE' THEN INTERVAL_VALUE * 2
            WHEN INTERVAL_FIELD = 'HOUR' THEN INTERVAL_VALUE * 60 * 2
            WHEN INTERVAL_FIELD = 'DAY' THEN INTERVAL_VALUE * 1440 * 2
            ELSE 999999
        END;
```

### Events en cours d'ex√©cution

```sql
-- Threads d'events actifs
SELECT
    ID,
    USER,
    HOST,
    DB,
    COMMAND,
    TIME,
    STATE,
    INFO
FROM information_schema.PROCESSLIST
WHERE
    INFO LIKE 'CREATE EVENT%'
    OR INFO LIKE 'ALTER EVENT%'
    OR USER = 'event_scheduler'
    OR COMMAND = 'Daemon';
```

---

## Performance et optimisation

### Charge du scheduler

```sql
-- Nombre total d'events actifs
SELECT
    COUNT(*) AS total_events,
    SUM(CASE WHEN STATUS = 'ENABLED' THEN 1 ELSE 0 END) AS events_actifs,
    SUM(CASE WHEN STATUS = 'DISABLED' THEN 1 ELSE 0 END) AS events_inactifs
FROM information_schema.EVENTS
WHERE EVENT_SCHEMA = DATABASE();

-- Distribution par fr√©quence
SELECT
    INTERVAL_FIELD AS frequence,
    COUNT(*) AS nb_events,
    GROUP_CONCAT(EVENT_NAME ORDER BY EVENT_NAME SEPARATOR ', ') AS liste_events
FROM information_schema.EVENTS
WHERE
    EVENT_SCHEMA = DATABASE()
    AND STATUS = 'ENABLED'
GROUP BY INTERVAL_FIELD
ORDER BY
    CASE INTERVAL_FIELD
        WHEN 'SECOND' THEN 1
        WHEN 'MINUTE' THEN 2
        WHEN 'HOUR' THEN 3
        WHEN 'DAY' THEN 4
        WHEN 'WEEK' THEN 5
        WHEN 'MONTH' THEN 6
        ELSE 7
    END;
```

### Optimisation : R√©duire la fr√©quence

```sql
-- ‚ùå PROBL√àME : Event trop fr√©quent
CREATE EVENT verification_trop_frequente
ON SCHEDULE EVERY 1 SECOND  -- Charge excessive !
DO
BEGIN
    -- V√©rification qui pourrait √™tre moins fr√©quente
END;

-- ‚úÖ SOLUTION : Augmenter l'intervalle
ALTER EVENT verification_trop_frequente
ON SCHEDULE EVERY 1 MINUTE;  -- Plus raisonnable
```

### Optimisation : Ex√©cution par batch

```sql
DELIMITER //

-- ‚ùå PROBL√àME : Event qui traite toutes les lignes
CREATE EVENT purge_non_optimisee
ON SCHEDULE EVERY 1 HOUR
DO
BEGIN
    -- Peut bloquer longtemps sur grandes tables
    DELETE FROM logs_application
    WHERE date_log < DATE_SUB(NOW(), INTERVAL 90 DAY);
END//

-- ‚úÖ SOLUTION : Traitement par lots
CREATE EVENT purge_optimisee
ON SCHEDULE EVERY 5 MINUTE
DO
BEGIN
    -- Traitement limit√© pour r√©duire l'impact
    DELETE FROM logs_application
    WHERE date_log < DATE_SUB(NOW(), INTERVAL 90 DAY)
    LIMIT 1000;  -- Par lots de 1000

    -- Log si traitement complet
    IF ROW_COUNT() < 1000 THEN
        INSERT INTO logs_maintenance (action, message, date_exec)
        VALUES ('PURGE_LOGS', 'Purge compl√®te termin√©e', NOW());
    END IF;
END//

DELIMITER ;
```

### Table de monitoring des performances

```sql
-- Table pour tracker la performance des events
CREATE TABLE IF NOT EXISTS performance_events (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    event_name VARCHAR(64) NOT NULL,
    date_debut DATETIME NOT NULL,
    date_fin DATETIME,
    duree_ms INT,
    nb_lignes_traitees INT,
    memoire_utilisee_mb DECIMAL(10,2),
    cpu_pct DECIMAL(5,2),
    statut VARCHAR(20),
    message_erreur TEXT,
    INDEX idx_event_date (event_name, date_debut)
) ENGINE=InnoDB;

DELIMITER //

-- Event avec tracking de performance
CREATE EVENT event_avec_perf_tracking
ON SCHEDULE EVERY 1 HOUR
DO
BEGIN
    DECLARE v_start DATETIME;
    DECLARE v_nb_lignes INT;
    DECLARE v_event_id BIGINT;

    -- D√©but du tracking
    SET v_start = NOW();
    INSERT INTO performance_events (event_name, date_debut, statut)
    VALUES ('event_avec_perf_tracking', v_start, 'RUNNING');
    SET v_event_id = LAST_INSERT_ID();

    -- Handler pour erreurs
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        UPDATE performance_events
        SET
            date_fin = NOW(),
            duree_ms = TIMESTAMPDIFF(MICROSECOND, v_start, NOW()) / 1000,
            statut = 'ERROR',
            message_erreur = 'Exception SQL lors de l\'ex√©cution'
        WHERE id = v_event_id;
    END;

    -- Traitement
    DELETE FROM sessions_expirees
    WHERE last_activity < DATE_SUB(NOW(), INTERVAL 1 DAY);

    SET v_nb_lignes = ROW_COUNT();

    -- Fin du tracking
    UPDATE performance_events
    SET
        date_fin = NOW(),
        duree_ms = TIMESTAMPDIFF(MICROSECOND, v_start, NOW()) / 1000,
        nb_lignes_traitees = v_nb_lignes,
        statut = 'SUCCESS'
    WHERE id = v_event_id;
END//

DELIMITER ;

-- Analyse des performances
SELECT
    event_name,
    COUNT(*) AS nb_executions,
    AVG(duree_ms) AS duree_moy_ms,
    MAX(duree_ms) AS duree_max_ms,
    MIN(duree_ms) AS duree_min_ms,
    SUM(nb_lignes_traitees) AS total_lignes,
    SUM(CASE WHEN statut = 'ERROR' THEN 1 ELSE 0 END) AS nb_erreurs
FROM performance_events
WHERE date_debut >= DATE_SUB(NOW(), INTERVAL 7 DAY)
GROUP BY event_name
ORDER BY duree_moy_ms DESC;
```

---

## Gestion des erreurs et logging

### Log des erreurs dans le error log

Les erreurs d'events sont enregistr√©es dans le fichier error log de MariaDB :

```bash
# Localisation du error log
mysql> SHOW VARIABLES LIKE 'log_error';
+---------------+---------------------+
| Variable_name | Value               |
+---------------+---------------------+
| log_error     | /var/log/mysql/error.log |
+---------------+---------------------+

# Recherche des erreurs d'events
tail -f /var/log/mysql/error.log | grep -i event
grep "Event Scheduler" /var/log/mysql/error.log
```

### Table de log personnalis√©e

```sql
-- Table centralis√©e de logs d'events
CREATE TABLE IF NOT EXISTS logs_events (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    event_name VARCHAR(64) NOT NULL,
    niveau VARCHAR(10) NOT NULL,  -- INFO, WARNING, ERROR, CRITICAL
    message TEXT NOT NULL,
    contexte JSON,
    date_log DATETIME NOT NULL DEFAULT NOW(),
    INDEX idx_event_date (event_name, date_log),
    INDEX idx_niveau (niveau, date_log)
) ENGINE=InnoDB;

DELIMITER //

-- Proc√©dure de log r√©utilisable
CREATE PROCEDURE log_event(
    IN p_event_name VARCHAR(64),
    IN p_niveau VARCHAR(10),
    IN p_message TEXT,
    IN p_contexte JSON
)
BEGIN
    INSERT INTO logs_events (event_name, niveau, message, contexte)
    VALUES (p_event_name, p_niveau, p_message, p_contexte);

    -- Purge automatique des logs > 90 jours
    DELETE FROM logs_events
    WHERE date_log < DATE_SUB(NOW(), INTERVAL 90 DAY)
    LIMIT 1000;
END//

-- Event utilisant le syst√®me de log
CREATE EVENT event_avec_logging
ON SCHEDULE EVERY 1 HOUR
DO
BEGIN
    DECLARE v_nb_traite INT;
    DECLARE v_debut DATETIME;

    SET v_debut = NOW();

    CALL log_event(
        'event_avec_logging',
        'INFO',
        'D√©but de l\'ex√©cution',
        JSON_OBJECT('date_debut', v_debut)
    );

    -- Handler d'erreur
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        CALL log_event(
            'event_avec_logging',
            'ERROR',
            'Erreur lors de l\'ex√©cution',
            JSON_OBJECT(
                'date_debut', v_debut,
                'duree_ms', TIMESTAMPDIFF(MICROSECOND, v_debut, NOW()) / 1000
            )
        );
    END;

    -- Traitement
    DELETE FROM table_temp WHERE date_expiration < NOW();
    SET v_nb_traite = ROW_COUNT();

    -- Log de succ√®s
    CALL log_event(
        'event_avec_logging',
        'INFO',
        CONCAT('Ex√©cution termin√©e - ', v_nb_traite, ' ligne(s) trait√©e(s)'),
        JSON_OBJECT(
            'date_debut', v_debut,
            'date_fin', NOW(),
            'duree_ms', TIMESTAMPDIFF(MICROSECOND, v_debut, NOW()) / 1000,
            'nb_lignes', v_nb_traite
        )
    );
END//

DELIMITER ;
```

### Syst√®me d'alertes

```sql
DELIMITER //

-- Event de monitoring avec alertes
CREATE EVENT monitoring_events_avec_alertes
ON SCHEDULE EVERY 10 MINUTE
DO
BEGIN
    -- 1. V√©rifier events qui n'ont pas tourn√© depuis trop longtemps
    INSERT INTO alertes_systeme (type, severite, message, details, date_alerte)
    SELECT
        'EVENT_NOT_RUNNING',
        'WARNING',
        CONCAT('Event "', EVENT_NAME, '" ne s\'est pas ex√©cut√© depuis longtemps'),
        JSON_OBJECT(
            'event_name', EVENT_NAME,
            'last_executed', LAST_EXECUTED,
            'minutes_since', TIMESTAMPDIFF(MINUTE, LAST_EXECUTED, NOW()),
            'expected_interval', CONCAT(INTERVAL_VALUE, ' ', INTERVAL_FIELD)
        ),
        NOW()
    FROM information_schema.EVENTS
    WHERE
        EVENT_SCHEMA = DATABASE()
        AND STATUS = 'ENABLED'
        AND LAST_EXECUTED IS NOT NULL
        AND TIMESTAMPDIFF(HOUR, LAST_EXECUTED, NOW()) > 24;

    -- 2. V√©rifier √©v√©nements en erreur dans les logs
    INSERT INTO alertes_systeme (type, severite, message, date_alerte)
    SELECT
        'EVENT_ERROR',
        'CRITICAL',
        CONCAT('Erreurs d√©tect√©es pour event "', event_name, '"'),
        NOW()
    FROM logs_events
    WHERE
        niveau = 'ERROR'
        AND date_log > DATE_SUB(NOW(), INTERVAL 1 HOUR)
    GROUP BY event_name
    HAVING COUNT(*) >= 3;  -- Au moins 3 erreurs dans l'heure

    -- 3. V√©rifier performance d√©grad√©e
    INSERT INTO alertes_systeme (type, severite, message, details, date_alerte)
    SELECT
        'EVENT_SLOW',
        'WARNING',
        CONCAT('Event "', event_name, '" ralenti d√©tect√©'),
        JSON_OBJECT(
            'event_name', event_name,
            'duree_moy_recente_ms', AVG(duree_ms),
            'duree_moy_historique_ms', (
                SELECT AVG(duree_ms)
                FROM performance_events p2
                WHERE p2.event_name = p1.event_name
                  AND p2.date_debut < DATE_SUB(NOW(), INTERVAL 7 DAY)
            )
        ),
        NOW()
    FROM performance_events p1
    WHERE
        date_debut > DATE_SUB(NOW(), INTERVAL 1 HOUR)
        AND statut = 'SUCCESS'
    GROUP BY event_name
    HAVING AVG(duree_ms) > (
        SELECT AVG(duree_ms) * 2  -- 2x plus lent que la moyenne
        FROM performance_events p3
        WHERE
            p3.event_name = p1.event_name
            AND p3.date_debut < DATE_SUB(NOW(), INTERVAL 7 DAY)
    );
END//

DELIMITER ;
```

---

## S√©curit√© de l'Event Scheduler

### Privil√®ges requis

```sql
-- Privil√®ges pour cr√©er/modifier/supprimer des events
GRANT EVENT ON database_name.* TO 'user_events'@'localhost';

-- Privil√®ge global (tous les events de toutes les bases)
GRANT EVENT ON *.* TO 'dba'@'localhost';

-- V√©rification des privil√®ges
SHOW GRANTS FOR 'user_events'@'localhost';
```

### DEFINER et contexte d'ex√©cution

```sql
DELIMITER //

-- Event s'ex√©cutant avec les privil√®ges du cr√©ateur
CREATE DEFINER = 'admin'@'localhost'
EVENT event_admin_privileges
ON SCHEDULE EVERY 1 DAY
DO
BEGIN
    -- S'ex√©cute avec les privil√®ges de admin@localhost
    -- Peut acc√©der √† des tables sensibles
    OPTIMIZE TABLE sensitive_data;
    DELETE FROM logs_admin WHERE date < DATE_SUB(NOW(), INTERVAL 30 DAY);
END//

DELIMITER ;

-- Consultation du DEFINER
SELECT
    EVENT_NAME,
    DEFINER,
    EVENT_DEFINITION
FROM information_schema.EVENTS
WHERE EVENT_SCHEMA = DATABASE();
```

‚ö†Ô∏è **Risque de s√©curit√©** : Un event DEFINER avec des privil√®ges √©lev√©s peut √™tre une faille si mal configur√©.

### Audit des events sensibles

```sql
-- Identifier les events avec privil√®ges √©lev√©s
SELECT
    EVENT_SCHEMA,
    EVENT_NAME,
    DEFINER,
    STATUS,
    LAST_EXECUTED,
    EVENT_COMMENT
FROM information_schema.EVENTS
WHERE
    DEFINER LIKE 'root%'
    OR DEFINER LIKE 'admin%'
ORDER BY LAST_EXECUTED DESC;

-- V√©rifier les events modifiant des donn√©es sensibles
SELECT
    EVENT_NAME,
    DEFINER,
    EVENT_DEFINITION
FROM information_schema.EVENTS
WHERE
    EVENT_SCHEMA = DATABASE()
    AND (
        EVENT_DEFINITION LIKE '%DELETE%'
        OR EVENT_DEFINITION LIKE '%DROP%'
        OR EVENT_DEFINITION LIKE '%TRUNCATE%'
    );
```

### Isolation des events par utilisateur

```sql
-- Cr√©er un utilisateur d√©di√© aux events
CREATE USER 'event_worker'@'localhost' IDENTIFIED BY 'secure_password';

-- Privil√®ges minimaux n√©cessaires
GRANT SELECT, INSERT, UPDATE, DELETE ON app_database.* TO 'event_worker'@'localhost';
GRANT EVENT ON app_database.* TO 'event_worker'@'localhost';
GRANT EXECUTE ON PROCEDURE app_database.* TO 'event_worker'@'localhost';

-- Events cr√©√©s par event_worker s'ex√©cuteront avec ces privil√®ges limit√©s
```

---

## Haute disponibilit√© et r√©plication

### Comportement sur les replicas

```sql
-- D√©sactiver automatiquement sur les replicas
CREATE EVENT event_master_only
ON SCHEDULE EVERY 1 HOUR
DISABLE ON SLAVE  -- Ne s'ex√©cute PAS sur les replicas
DO
BEGIN
    -- Op√©ration lourde uniquement sur le master
    CALL procedure_maintenance_master();
END;
```

### Pattern : Event avec d√©tection master/replica

```sql
DELIMITER //

CREATE EVENT event_intelligent
ON SCHEDULE EVERY 1 HOUR
DO
BEGIN
    DECLARE v_is_slave BOOLEAN;

    -- D√©tection si on est un replica
    SET v_is_slave = (
        SELECT COUNT(*) > 0
        FROM information_schema.PROCESSLIST
        WHERE USER = 'system user'
    );

    IF NOT v_is_slave THEN
        -- Code uniquement sur master
        CALL maintenance_intensive();
    ELSE
        -- Code l√©ger sur replica (ou rien)
        CALL maintenance_legere();
    END IF;
END//

DELIMITER ;
```

### Strat√©gie de basculement (failover)

Lors d'un failover master ‚Üí replica, les events doivent √™tre g√©r√©s :

```sql
-- Sur le nouveau master (ancien replica)
-- Activer les events qui √©taient DISABLE ON SLAVE
ALTER EVENT event_master_only ENABLE;

-- V√©rifier et activer tous les events critiques
UPDATE mysql.event
SET status = 'ENABLED'
WHERE status = 'SLAVESIDE_DISABLED';

-- Red√©marrer le scheduler si n√©cessaire
SET GLOBAL event_scheduler = OFF;
SET GLOBAL event_scheduler = ON;
```

### Documentation des events critiques

```sql
-- Identifier les events critiques n√©cessitant une attention lors du failover
SELECT
    EVENT_NAME,
    STATUS,
    ON_COMPLETION,
    DEFINER,
    EVENT_COMMENT
FROM information_schema.EVENTS
WHERE
    EVENT_SCHEMA = DATABASE()
    AND (
        EVENT_COMMENT LIKE '%CRITICAL%'
        OR EVENT_COMMENT LIKE '%FAILOVER%'
        OR EVENT_NAME LIKE '%critical%'
    );
```

---

## Troubleshooting avanc√©

### Probl√®me 1 : Scheduler ne d√©marre pas

```sql
-- Diagnostic
SHOW VARIABLES LIKE 'event_scheduler';
-- Si 'DISABLED', v√©rifier my.cnf

-- V√©rification des logs
-- grep -i "event scheduler" /var/log/mysql/error.log

-- Solution
-- Modifier my.cnf : event_scheduler = ON
-- Red√©marrer MariaDB
```

### Probl√®me 2 : Event ne s'ex√©cute pas

```sql
-- V√©rifier le statut de l'event
SELECT
    EVENT_NAME,
    STATUS,
    LAST_EXECUTED,
    STARTS,
    ENDS,
    ON_COMPLETION
FROM information_schema.EVENTS
WHERE EVENT_NAME = 'nom_event';

-- Causes possibles :
-- 1. Event DISABLED
ALTER EVENT nom_event ENABLE;

-- 2. Date ENDS d√©pass√©e
ALTER EVENT nom_event
ON SCHEDULE EVERY 1 HOUR
STARTS NOW();

-- 3. Event √† ex√©cution unique (AT) d√©j√† pass√©
-- Recr√©er ou modifier pour nouvelle date

-- 4. Erreur dans le code de l'event
-- Consulter error log
SHOW CREATE EVENT nom_event\G
-- Tester le code manuellement
```

### Probl√®me 3 : Event s'ex√©cute plusieurs fois simultan√©ment

```sql
-- Cause : Event prend plus de temps que son intervalle
-- Exemple : Event EVERY 5 MINUTE qui prend 10 minutes

-- Solution 1 : Augmenter l'intervalle
ALTER EVENT event_trop_long
ON SCHEDULE EVERY 15 MINUTE;  -- Plus que la dur√©e d'ex√©cution

-- Solution 2 : Ajouter un verrou applicatif
DELIMITER //

CREATE EVENT event_avec_verrou
ON SCHEDULE EVERY 5 MINUTE
DO
BEGIN
    DECLARE v_lock_acquired INT;

    -- Tenter d'acqu√©rir un verrou
    SELECT GET_LOCK('event_lock', 0) INTO v_lock_acquired;

    IF v_lock_acquired = 1 THEN
        -- Verrou acquis, ex√©cution
        BEGIN
            -- Code de l'event
            CALL traitement_long();

            -- Lib√©ration du verrou
            DO RELEASE_LOCK('event_lock');
        END;
    ELSE
        -- Verrou non acquis (event d√©j√† en cours)
        INSERT INTO logs_events (event_name, niveau, message)
        VALUES ('event_avec_verrou', 'WARNING', 'Event d√©j√† en cours, ex√©cution ignor√©e');
    END IF;
END//

DELIMITER ;
```

### Probl√®me 4 : Performance d√©grad√©e

```sql
-- Identifier les events gourmands
SELECT
    p.event_name,
    COUNT(*) AS nb_exec_recentes,
    AVG(p.duree_ms) AS duree_moy_ms,
    MAX(p.duree_ms) AS duree_max_ms,
    SUM(p.nb_lignes_traitees) AS total_lignes
FROM performance_events p
WHERE p.date_debut > DATE_SUB(NOW(), INTERVAL 1 HOUR)
GROUP BY p.event_name
ORDER BY duree_moy_ms DESC
LIMIT 10;

-- Analyser l'event probl√©matique
SHOW CREATE EVENT event_lent\G

-- Solutions :
-- 1. Optimiser le code SQL (index, LIMIT)
-- 2. R√©duire la fr√©quence
-- 3. Diviser en plusieurs events plus petits
-- 4. D√©placer vers un batch nocturne
```

---

## Strat√©gies de maintenance

### Audit p√©riodique des events

```sql
DELIMITER //

-- Event d'audit des events (m√©ta-event)
CREATE EVENT audit_events_systeme
ON SCHEDULE EVERY 1 DAY
STARTS TIMESTAMP(CURDATE() + INTERVAL 1 DAY, '00:00:00')
DO
BEGIN
    -- Rapport des events
    INSERT INTO rapports_events (
        date_rapport,
        nb_events_total,
        nb_events_actifs,
        nb_events_inactifs,
        nb_events_sans_execution,
        events_details
    )
    SELECT
        NOW(),
        COUNT(*),
        SUM(CASE WHEN STATUS = 'ENABLED' THEN 1 ELSE 0 END),
        SUM(CASE WHEN STATUS = 'DISABLED' THEN 1 ELSE 0 END),
        SUM(CASE WHEN LAST_EXECUTED IS NULL THEN 1 ELSE 0 END),
        JSON_ARRAYAGG(
            JSON_OBJECT(
                'name', EVENT_NAME,
                'status', STATUS,
                'last_executed', LAST_EXECUTED,
                'interval', CONCAT(INTERVAL_VALUE, ' ', INTERVAL_FIELD)
            )
        )
    FROM information_schema.EVENTS
    WHERE EVENT_SCHEMA = DATABASE();
END//

DELIMITER ;
```

### Nettoyage automatique

```sql
DELIMITER //

-- Suppression des events obsol√®tes
CREATE EVENT nettoyage_events_obsoletes
ON SCHEDULE EVERY 1 WEEK
DO
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_event_name VARCHAR(64);
    DECLARE cur CURSOR FOR
        SELECT EVENT_NAME
        FROM information_schema.EVENTS
        WHERE
            EVENT_SCHEMA = DATABASE()
            AND STATUS = 'DISABLED'
            AND LAST_EXECUTED < DATE_SUB(NOW(), INTERVAL 6 MONTH);

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    OPEN cur;

    read_loop: LOOP
        FETCH cur INTO v_event_name;
        IF done THEN
            LEAVE read_loop;
        END IF;

        -- Log avant suppression
        INSERT INTO logs_events (event_name, niveau, message)
        VALUES (v_event_name, 'INFO', 'Event obsol√®te supprim√© automatiquement');

        -- Suppression
        SET @sql = CONCAT('DROP EVENT IF EXISTS ', v_event_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END LOOP;

    CLOSE cur;
END//

DELIMITER ;
```

---

## Bonnes pratiques d'administration

### 1. Documenter tous les events

```sql
-- ‚úÖ BON : Documentation compl√®te
CREATE EVENT evt_maintenance_quotidienne
ON SCHEDULE EVERY 1 DAY
STARTS '2026-01-01 03:00:00'
COMMENT 'Maintenance quotidienne: purge logs + optimisation tables. Cr√©√© 2025-12-12 par DBA Team. Contact: dba@company.com'
DO ...

-- ‚ùå MAUVAIS : Pas de documentation
CREATE EVENT e1
ON SCHEDULE EVERY 1 DAY
DO ...
```

### 2. Centraliser les logs

```sql
-- Toujours utiliser la m√™me table de logs
-- Permet analyse centralis√©e et alertes globales
CALL log_event('nom_event', 'INFO', 'Message', NULL);
```

### 3. Monitoring proactif

```sql
-- Dashboard de monitoring des events
CREATE OR REPLACE VIEW v_dashboard_events AS
SELECT
    COUNT(*) AS total_events,
    SUM(CASE WHEN STATUS = 'ENABLED' THEN 1 ELSE 0 END) AS actifs,
    SUM(CASE WHEN STATUS = 'DISABLED' THEN 1 ELSE 0 END) AS inactifs,
    SUM(CASE WHEN LAST_EXECUTED IS NULL THEN 1 ELSE 0 END) AS jamais_executes,
    SUM(CASE
        WHEN LAST_EXECUTED < DATE_SUB(NOW(), INTERVAL 24 HOUR)
        AND STATUS = 'ENABLED'
        THEN 1 ELSE 0
    END) AS potentiellement_bloques
FROM information_schema.EVENTS
WHERE EVENT_SCHEMA = DATABASE();

-- Consultation rapide
SELECT * FROM v_dashboard_events;
```

### 4. Tester avant production

```sql
-- Cr√©er en mode DISABLE pour tests
CREATE EVENT evt_nouveau_test
ON SCHEDULE EVERY 1 HOUR
DISABLE  -- D√©sactiv√© pour tests
DO ...

-- Tester manuellement le code
-- (copier le code du BEGIN...END et ex√©cuter)

-- Activer apr√®s validation
ALTER EVENT evt_nouveau_test ENABLE;
```

### 5. Proc√©dure de d√©ploiement

```sql
-- 1. Sauvegarde des events existants
mysqldump --events --no-data --no-create-info ma_base > events_backup.sql

-- 2. D√©ploiement du nouvel event
CREATE OR REPLACE EVENT ...

-- 3. V√©rification
SHOW EVENTS;
SHOW CREATE EVENT nom_event;

-- 4. Monitoring pendant 24h
SELECT * FROM logs_events WHERE event_name = 'nom_event';
```

---

## ‚úÖ Points cl√©s √† retenir

- **Activation** : `SET GLOBAL event_scheduler = ON` (ou my.cnf)
- **Thread d√©di√©** : event_scheduler visible dans PROCESSLIST
- **Monitoring** : INFORMATION_SCHEMA.EVENTS pour l'√©tat des events
- **Performance** : √âviter events < 5 minutes, traiter par batch
- **Logs** : Centraliser dans tables d√©di√©es + error log syst√®me
- **S√©curit√©** : DEFINER appropri√©, privil√®ges minimaux
- **R√©plication** : DISABLE ON SLAVE pour events master-only
- **Alertes** : Monitoring proactif des events qui ne s'ex√©cutent pas
- **Documentation** : COMMENT obligatoire, logs d√©taill√©s
- **Tests** : Cr√©er en mode DISABLE, valider, puis ENABLE

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation officielle MariaDB - Event Scheduler](https://mariadb.com/kb/en/events/)
- [üìñ Event Scheduler Status Variables](https://mariadb.com/kb/en/server-status-variables/#event-scheduler)
- [üìñ INFORMATION_SCHEMA.EVENTS](https://mariadb.com/kb/en/information-schema-events-table/)
- [üìñ Event Scheduler Thread States](https://mariadb.com/kb/en/thread-states/)
- [üí° Blog : Managing Event Scheduler in Production](https://mariadb.com/resources/blog/)

---

## ‚û°Ô∏è Section suivante

**[8.5 Curseurs](./05-curseurs.md)** : D√©couvrez les curseurs qui permettent de parcourir les r√©sultats d'une requ√™te ligne par ligne dans les proc√©dures stock√©es.

---


‚è≠Ô∏è [Curseurs](/08-programmation-cote-serveur/05-curseurs.md)
