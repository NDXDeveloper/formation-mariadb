üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.2.1 Syntaxe CREATE FUNCTION

> **Niveau** : Interm√©diaire √† Avanc√©
> **Dur√©e estim√©e** : 2.5 heures
> **Pr√©requis** : Sections 8.1.x (Proc√©dures stock√©es), ma√Ætrise des types de donn√©es MariaDB

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre la syntaxe compl√®te de CREATE FUNCTION dans MariaDB
- Diff√©rencier les fonctions stock√©es des proc√©dures stock√©es
- Cr√©er des fonctions d√©terministes et non-d√©terministes
- Utiliser les caract√©ristiques appropri√©es (NO SQL, READS SQL DATA, etc.)
- Appliquer les bonnes pratiques de cr√©ation de fonctions
- Int√©grer les fonctions dans des requ√™tes SQL complexes

---

## Introduction

Les **fonctions stock√©es** (stored functions) sont des blocs de code SQL qui **retournent une valeur unique** et peuvent √™tre utilis√©es directement dans les expressions SQL. Contrairement aux proc√©dures, elles se comportent comme les fonctions natives de MariaDB (UPPER(), COUNT(), SUM(), etc.).

### Fonctions vs Proc√©dures : Diff√©rences fondamentales

| Caract√©ristique | Fonction | Proc√©dure |
|----------------|----------|-----------|
| **Appel** | Directement dans SELECT, WHERE | Instruction CALL s√©par√©e |
| **Retour** | Une seule valeur (RETURNS) | Aucune ou plusieurs (OUT) |
| **Param√®tres** | IN uniquement | IN, OUT, INOUT |
| **SELECT multiple** | ‚ùå Non autoris√© | ‚úÖ Autoris√© |
| **Transactions** | ‚ö†Ô∏è Limit√©es | ‚úÖ Compl√®tes |
| **Modification donn√©es** | ‚ö†Ô∏è D√©conseill√© | ‚úÖ Recommand√© |
| **Utilisation** | Calculs, transformations | Logique m√©tier complexe |

üí° **Principe directeur** : Les fonctions servent √† **calculer et retourner une valeur**, les proc√©dures servent √† **ex√©cuter des op√©rations**.

### Quand utiliser une fonction ?

- **Calculs r√©utilisables** : Formules complexes (TVA, remises, conversions)
- **Transformations de donn√©es** : Formatage, normalisation
- **Logique conditionnelle simple** : Cat√©gorisation, classification
- **Agr√©gations personnalis√©es** : Calculs m√©tier sp√©cifiques
- **Encapsulation de r√®gles m√©tier** : Centralisation de la logique

‚ö†Ô∏è **Quand √©viter les fonctions** : Modifications de donn√©es (INSERT/UPDATE/DELETE), transactions complexes, traitement par lots ‚Üí utilisez des proc√©dures.

---

## Syntaxe de base CREATE FUNCTION

### Structure g√©n√©rale

```sql
CREATE [OR REPLACE]
    [DEFINER = utilisateur]
    FUNCTION nom_fonction ([parametres])
    RETURNS type_retour
    [caracteristiques]
BEGIN
    -- Corps de la fonction
    -- D√©clarations et logique
    RETURN valeur;
END
```

### √âl√©ments obligatoires

**1. FUNCTION nom_fonction** : Identifiant unique de la fonction

```sql
-- Noms valides
CREATE FUNCTION calculer_tva(...) ...
CREATE FUNCTION get_customer_category(...) ...
CREATE FUNCTION format_telephone(...) ...

-- Convention : verbes ou noms descriptifs en snake_case
```

**2. RETURNS type_retour** : Type de donn√©es de la valeur retourn√©e

```sql
RETURNS INT              -- Nombre entier
RETURNS DECIMAL(10,2)    -- Montant avec 2 d√©cimales
RETURNS VARCHAR(100)     -- Cha√Æne de caract√®res
RETURNS DATE             -- Date
RETURNS JSON             -- Document JSON
```

**3. RETURN valeur** : Instruction de retour dans le corps

```sql
BEGIN
    DECLARE v_resultat INT;
    SET v_resultat = calcul;
    RETURN v_resultat;  -- Obligatoire
END
```

‚ö†Ô∏è **Important** : L'absence de `RETURN` provoque une erreur √† l'ex√©cution de la fonction.

---

## Exemple minimal : Premi√®re fonction

```sql
DELIMITER //

-- Fonction simple sans param√®tre
CREATE OR REPLACE FUNCTION obtenir_version_db()
RETURNS VARCHAR(50)
DETERMINISTIC
NO SQL
BEGIN
    RETURN VERSION();
END//

DELIMITER ;

-- Utilisation directe dans SELECT
SELECT obtenir_version_db() AS version;
```

**Sortie** :
```
+---------------------------+
| version                   |
+---------------------------+
| 11.8.0-MariaDB-LTS        |
+---------------------------+
```

---

## Param√®tres de fonction

### Syntaxe des param√®tres

Les fonctions acceptent **uniquement des param√®tres IN** (implicites, pas besoin de sp√©cifier IN).

```sql
CREATE FUNCTION nom_fonction(
    param1 type1,
    param2 type2,
    param3 type3
)
RETURNS type_retour
```

‚ö†Ô∏è **Restriction** : Les fonctions ne peuvent pas avoir de param√®tres OUT ou INOUT.

### Exemple avec param√®tres

```sql
DELIMITER //

CREATE OR REPLACE FUNCTION calculer_prix_ttc(
    prix_ht DECIMAL(10,2),
    taux_tva DECIMAL(5,2)
)
RETURNS DECIMAL(10,2)
DETERMINISTIC
NO SQL
BEGIN
    DECLARE prix_ttc DECIMAL(10,2);

    -- Calcul
    SET prix_ttc = prix_ht * (1 + taux_tva / 100);

    -- Arrondi √† 2 d√©cimales
    RETURN ROUND(prix_ttc, 2);
END//

DELIMITER ;

-- Utilisation dans SELECT
SELECT
    100.00 AS prix_ht,
    20.00 AS tva,
    calculer_prix_ttc(100.00, 20.00) AS prix_ttc;

-- Utilisation avec donn√©es de table
SELECT
    nom_produit,
    prix,
    calculer_prix_ttc(prix, 20.00) AS prix_ttc
FROM produits
WHERE categorie = '√âlectronique';
```

**Avantage** : La logique de calcul est centralis√©e dans la fonction, garantissant la coh√©rence.

---

## Caract√©ristiques des fonctions

Les caract√©ristiques d√©finissent le comportement et les contraintes de la fonction.

### DETERMINISTIC vs NOT DETERMINISTIC

**DETERMINISTIC** : La fonction retourne toujours le m√™me r√©sultat pour les m√™mes param√®tres.

```sql
-- ‚úÖ DETERMINISTIC : R√©sultat constant pour les m√™mes entr√©es
CREATE FUNCTION calculer_carre(n INT)
RETURNS INT
DETERMINISTIC
NO SQL
BEGIN
    RETURN n * n;
END;

-- Toujours le m√™me r√©sultat
SELECT calculer_carre(5);  -- 25
SELECT calculer_carre(5);  -- 25 (toujours identique)
```

**NOT DETERMINISTIC** : La fonction peut retourner des r√©sultats diff√©rents (utilise date/heure, al√©atoire, donn√©es externes).

```sql
-- ‚úÖ NOT DETERMINISTIC : R√©sultat variable
CREATE FUNCTION obtenir_timestamp_actuel()
RETURNS DATETIME
NOT DETERMINISTIC
NO SQL
BEGIN
    RETURN NOW();
END;

-- R√©sultats diff√©rents
SELECT obtenir_timestamp_actuel();  -- 2025-12-12 10:30:45
SELECT obtenir_timestamp_actuel();  -- 2025-12-12 10:31:12 (diff√©rent)
```

üí° **Conseil** : D√©clarez `DETERMINISTIC` chaque fois que possible, cela permet √† l'optimiseur de mettre en cache les r√©sultats.

‚ö†Ô∏è **Pi√®ge fr√©quent** : Utiliser NOW(), RAND(), CURRENT_USER() dans une fonction DETERMINISTIC est **incoh√©rent logiquement** (m√™me si MariaDB le permet).

### NO SQL, READS SQL DATA, MODIFIES SQL DATA

Ces caract√©ristiques indiquent le niveau d'interaction avec la base de donn√©es.

**NO SQL** : La fonction n'acc√®de pas aux donn√©es de la base

```sql
CREATE FUNCTION convertir_celsius_fahrenheit(celsius DECIMAL(5,2))
RETURNS DECIMAL(5,2)
DETERMINISTIC
NO SQL  -- Aucune lecture/√©criture de donn√©es
BEGIN
    RETURN (celsius * 9/5) + 32;
END;
```

**READS SQL DATA** : La fonction lit des donn√©es (SELECT)

```sql
CREATE FUNCTION obtenir_prix_produit(produit_id INT)
RETURNS DECIMAL(10,2)
READS SQL DATA  -- Lit des donn√©es
BEGIN
    DECLARE prix DECIMAL(10,2);

    SELECT prix_unitaire INTO prix
    FROM produits
    WHERE id = produit_id;

    RETURN COALESCE(prix, 0);
END;
```

**MODIFIES SQL DATA** : La fonction modifie des donn√©es (INSERT/UPDATE/DELETE)

```sql
-- ‚ö†Ô∏è D√âCONSEILL√â : Modifier des donn√©es dans une fonction
CREATE FUNCTION incrementer_compteur()
RETURNS INT
MODIFIES SQL DATA
BEGIN
    UPDATE compteurs SET valeur = valeur + 1 WHERE nom = 'global';
    RETURN (SELECT valeur FROM compteurs WHERE nom = 'global');
END;
```

‚ö†Ô∏è **Attention** : Modifier des donn√©es dans une fonction est une **mauvaise pratique** car :
- Effets de bord non √©vidents dans les requ√™tes
- Impossible de rollback si utilis√© dans SELECT
- Probl√®mes de coh√©rence transactionnelle

üí° **Recommandation** : Utilisez des proc√©dures stock√©es pour les modifications de donn√©es.

### CONTAINS SQL

Caract√©ristique g√©n√©rique indiquant que la fonction contient du SQL (sans pr√©ciser lequel).

```sql
CREATE FUNCTION ma_fonction(param INT)
RETURNS INT
CONTAINS SQL  -- Contient du SQL mais on ne pr√©cise pas le type
BEGIN
    -- Logique SQL
    RETURN param * 2;
END;
```

üí° **Conseil** : Pr√©f√©rez les caract√©ristiques sp√©cifiques (NO SQL, READS SQL DATA) pour une meilleure documentation.

---

## Exemples progressifs de fonctions

### Exemple 1 : Fonction de calcul simple

```sql
DELIMITER //

-- Calcul de remise selon un pourcentage
CREATE OR REPLACE FUNCTION appliquer_remise(
    montant DECIMAL(10,2),
    pourcentage_remise DECIMAL(5,2)
)
RETURNS DECIMAL(10,2)
DETERMINISTIC
NO SQL
COMMENT 'Applique un pourcentage de remise au montant'
BEGIN
    DECLARE montant_remise DECIMAL(10,2);

    -- Validation
    IF pourcentage_remise < 0 OR pourcentage_remise > 100 THEN
        RETURN montant;  -- Pas de remise si pourcentage invalide
    END IF;

    -- Calcul
    SET montant_remise = montant * (1 - pourcentage_remise / 100);

    RETURN ROUND(montant_remise, 2);
END//

DELIMITER ;

-- Tests
SELECT appliquer_remise(100.00, 20) AS prix_remise_20;    -- 80.00
SELECT appliquer_remise(250.00, 15) AS prix_remise_15;    -- 212.50
SELECT appliquer_remise(100.00, -5) AS prix_invalide;     -- 100.00 (pas de remise)
```

### Exemple 2 : Fonction avec logique conditionnelle

```sql
DELIMITER //

-- Cat√©gorisation d'un client selon son chiffre d'affaires
CREATE OR REPLACE FUNCTION categoriser_client(
    total_achats DECIMAL(10,2)
)
RETURNS VARCHAR(20)
DETERMINISTIC
NO SQL
COMMENT 'Retourne la cat√©gorie du client selon ses achats'
BEGIN
    DECLARE categorie VARCHAR(20);

    CASE
        WHEN total_achats >= 50000 THEN
            SET categorie = 'PLATINUM';
        WHEN total_achats >= 10000 THEN
            SET categorie = 'GOLD';
        WHEN total_achats >= 5000 THEN
            SET categorie = 'SILVER';
        WHEN total_achats >= 1000 THEN
            SET categorie = 'BRONZE';
        ELSE
            SET categorie = 'STANDARD';
    END CASE;

    RETURN categorie;
END//

DELIMITER ;

-- Utilisation dans une requ√™te
SELECT
    nom,
    prenom,
    total_achats,
    categoriser_client(total_achats) AS categorie
FROM clients
ORDER BY total_achats DESC;
```

**Sortie** :
```
+-----------+---------+--------------+-----------+
| nom       | prenom  | total_achats | categorie |
+-----------+---------+--------------+-----------+
| Dupont    | Jean    |     75000.00 | PLATINUM  |
| Martin    | Sophie  |     12500.00 | GOLD      |
| Durand    | Paul    |      6800.00 | SILVER    |
| Bernard   | Marie   |      2500.00 | BRONZE    |
| Petit     | Luc     |       450.00 | STANDARD  |
+-----------+---------+--------------+-----------+
```

### Exemple 3 : Fonction avec lecture de donn√©es

```sql
DELIMITER //

-- R√©cup√©ration du nom complet d'un client
CREATE OR REPLACE FUNCTION obtenir_nom_complet_client(
    client_id INT
)
RETURNS VARCHAR(200)
READS SQL DATA
COMMENT 'Retourne le nom complet format√© du client'
BEGIN
    DECLARE nom VARCHAR(100);
    DECLARE prenom VARCHAR(100);
    DECLARE civilite VARCHAR(10);
    DECLARE nom_complet VARCHAR(200);

    -- Lecture des donn√©es
    SELECT c.civilite, c.nom, c.prenom
    INTO civilite, nom, prenom
    FROM clients c
    WHERE c.id = client_id;

    -- Gestion du cas NULL (client inexistant)
    IF nom IS NULL THEN
        RETURN 'Client inconnu';
    END IF;

    -- Construction du nom complet
    SET nom_complet = CONCAT(
        COALESCE(civilite, ''),
        ' ',
        UPPER(nom),
        ' ',
        CONCAT(UPPER(LEFT(prenom, 1)), LOWER(SUBSTRING(prenom, 2)))
    );

    RETURN TRIM(nom_complet);
END//

DELIMITER ;

-- Utilisation
SELECT obtenir_nom_complet_client(101) AS client;
-- R√©sultat : "M. DUPONT Jean"

-- Dans une requ√™te complexe
SELECT
    c.numero_commande,
    obtenir_nom_complet_client(c.client_id) AS client,
    c.montant_total
FROM commandes c
WHERE c.statut = 'EN_COURS';
```

### Exemple 4 : Fonction avec calcul d'agr√©gation

```sql
DELIMITER //

-- Calcul du montant total des commandes d'un client
CREATE OR REPLACE FUNCTION calculer_ca_client(
    client_id INT
)
RETURNS DECIMAL(10,2)
READS SQL DATA
COMMENT 'Calcule le chiffre d''affaires total d''un client'
BEGIN
    DECLARE ca_total DECIMAL(10,2);

    SELECT COALESCE(SUM(montant_total), 0)
    INTO ca_total
    FROM commandes
    WHERE
        client_id_fk = client_id
        AND statut IN ('VALIDEE', 'LIVREE');

    RETURN ca_total;
END//

DELIMITER ;

-- Utilisation pour trier les meilleurs clients
SELECT
    id,
    nom,
    prenom,
    calculer_ca_client(id) AS chiffre_affaires,
    categoriser_client(calculer_ca_client(id)) AS categorie
FROM clients
ORDER BY calculer_ca_client(id) DESC
LIMIT 10;
```

üí° **Composition** : Une fonction peut appeler une autre fonction (ici `categoriser_client`).

### Exemple 5 : Fonction avec transformation de texte

```sql
DELIMITER //

-- Normalisation d'un num√©ro de t√©l√©phone fran√ßais
CREATE OR REPLACE FUNCTION normaliser_telephone_fr(
    telephone VARCHAR(20)
)
RETURNS VARCHAR(20)
DETERMINISTIC
NO SQL
COMMENT 'Normalise un num√©ro de t√©l√©phone au format +33...'
BEGIN
    DECLARE tel_clean VARCHAR(20);

    -- Nettoyage : suppression des espaces, tirets, points, parenth√®ses
    SET tel_clean = telephone;
    SET tel_clean = REPLACE(tel_clean, ' ', '');
    SET tel_clean = REPLACE(tel_clean, '-', '');
    SET tel_clean = REPLACE(tel_clean, '.', '');
    SET tel_clean = REPLACE(tel_clean, '(', '');
    SET tel_clean = REPLACE(tel_clean, ')', '');

    -- Gestion des cas sp√©ciaux
    IF tel_clean IS NULL OR LENGTH(tel_clean) < 10 THEN
        RETURN NULL;
    END IF;

    -- Si commence par +33, on garde
    IF LEFT(tel_clean, 3) = '+33' THEN
        RETURN tel_clean;
    END IF;

    -- Si commence par 0, on remplace par +33
    IF LEFT(tel_clean, 1) = '0' THEN
        RETURN CONCAT('+33', SUBSTRING(tel_clean, 2));
    END IF;

    -- Sinon, on ajoute +33
    RETURN CONCAT('+33', tel_clean);
END//

DELIMITER ;

-- Tests
SELECT normaliser_telephone_fr('01 23 45 67 89') AS tel1;  -- +33123456789
SELECT normaliser_telephone_fr('06-12-34-56-78') AS tel2;  -- +33612345678
SELECT normaliser_telephone_fr('+33 7 89 01 23 45') AS tel3; -- +33789012345
SELECT normaliser_telephone_fr('123') AS tel_invalide;      -- NULL

-- Mise √† jour de donn√©es avec la fonction
UPDATE clients
SET telephone = normaliser_telephone_fr(telephone)
WHERE telephone IS NOT NULL;
```

---

## Variables locales dans les fonctions

### D√©claration avec DECLARE

```sql
DELIMITER //

CREATE OR REPLACE FUNCTION exemple_variables(param INT)
RETURNS VARCHAR(100)
NO SQL
BEGIN
    -- D√©clarations en d√©but de fonction
    DECLARE v_resultat INT;
    DECLARE v_message VARCHAR(100);
    DECLARE v_facteur DECIMAL(5,2) DEFAULT 1.5;

    -- Utilisation des variables
    SET v_resultat = param * v_facteur;
    SET v_message = CONCAT('R√©sultat : ', v_resultat);

    RETURN v_message;
END//

DELIMITER ;
```

**R√®gles** :
- Les `DECLARE` doivent √™tre **en d√©but de bloc** (avant toute instruction)
- Les variables sont **locales** au bloc BEGIN...END
- Une valeur DEFAULT peut √™tre sp√©cifi√©e

### Port√©e des variables

```sql
DELIMITER //

CREATE OR REPLACE FUNCTION demo_portee(param INT)
RETURNS INT
NO SQL
BEGIN
    DECLARE v_outer INT DEFAULT 10;

    -- Bloc interne
    BEGIN
        DECLARE v_inner INT DEFAULT 20;
        -- v_outer et v_inner accessibles ici
        RETURN v_outer + v_inner + param;  -- 10 + 20 + param
    END;

    -- v_inner n'est plus accessible ici
    -- Seul v_outer est disponible
END//

DELIMITER ;
```

---

## Gestion des erreurs dans les fonctions

### Validation des param√®tres

```sql
DELIMITER //

CREATE OR REPLACE FUNCTION diviser_securise(
    numerateur DECIMAL(10,2),
    denominateur DECIMAL(10,2)
)
RETURNS DECIMAL(10,2)
DETERMINISTIC
NO SQL
BEGIN
    -- Validation : division par z√©ro
    IF denominateur = 0 OR denominateur IS NULL THEN
        RETURN NULL;  -- Ou lever une erreur
    END IF;

    RETURN ROUND(numerateur / denominateur, 2);
END//

DELIMITER ;

-- Tests
SELECT diviser_securise(100, 5);   -- 20.00
SELECT diviser_securise(100, 0);   -- NULL
SELECT diviser_securise(100, NULL); -- NULL
```

### Utilisation de SIGNAL pour erreurs m√©tier

```sql
DELIMITER //

CREATE OR REPLACE FUNCTION calculer_age(
    date_naissance DATE
)
RETURNS INT
DETERMINISTIC
NO SQL
BEGIN
    DECLARE age INT;

    -- Validation
    IF date_naissance IS NULL THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Date de naissance requise';
    END IF;

    IF date_naissance > CURDATE() THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Date de naissance dans le futur';
    END IF;

    -- Calcul de l'√¢ge
    SET age = TIMESTAMPDIFF(YEAR, date_naissance, CURDATE());

    RETURN age;
END//

DELIMITER ;

-- Tests
SELECT calculer_age('1990-05-15');  -- 35 (en 2025)
SELECT calculer_age(NULL);          -- ERROR 1644: Date de naissance requise
SELECT calculer_age('2030-01-01');  -- ERROR 1644: Date de naissance dans le futur
```

‚ö†Ô∏è **Attention** : SIGNAL interrompt l'ex√©cution de la requ√™te enti√®re. Utilisez avec pr√©caution.

---

## Utilisation avanc√©e des fonctions

### Dans les clauses WHERE

```sql
-- Filtrage avec fonction personnalis√©e
SELECT *
FROM clients
WHERE categoriser_client(total_achats) IN ('GOLD', 'PLATINUM');

-- √âquivalent de HAVING avec fonction
SELECT
    client_id,
    SUM(montant_total) AS total
FROM commandes
GROUP BY client_id
HAVING categoriser_client(SUM(montant_total)) = 'PLATINUM';
```

### Dans les ORDER BY

```sql
-- Tri personnalis√© avec fonction
SELECT
    nom,
    prenom,
    date_naissance,
    calculer_age(date_naissance) AS age
FROM clients
ORDER BY calculer_age(date_naissance) DESC;
```

### Dans les JOIN

```sql
-- Join bas√© sur une fonction
SELECT
    c.nom,
    c.prenom,
    cat.remise_applicable
FROM clients c
INNER JOIN categories_remise cat
    ON cat.code = categoriser_client(c.total_achats);
```

### Dans les vues

```sql
-- Vue utilisant des fonctions
CREATE OR REPLACE VIEW v_clients_enrichis AS
SELECT
    id,
    nom,
    prenom,
    obtenir_nom_complet_client(id) AS nom_complet,
    total_achats,
    categoriser_client(total_achats) AS categorie,
    calculer_ca_client(id) AS chiffre_affaires
FROM clients;

-- Requ√™te sur la vue
SELECT * FROM v_clients_enrichis WHERE categorie = 'GOLD';
```

### Dans les index (colonnes g√©n√©r√©es)

```sql
-- Colonne g√©n√©r√©e avec fonction, index√©e pour performance
ALTER TABLE clients
ADD COLUMN categorie VARCHAR(20)
    AS (categoriser_client(total_achats)) STORED;

-- Index sur la colonne g√©n√©r√©e
CREATE INDEX idx_client_categorie ON clients(categorie);

-- Requ√™te optimis√©e gr√¢ce √† l'index
SELECT * FROM clients WHERE categorie = 'PLATINUM';
```

üí° **Performance** : Les colonnes g√©n√©r√©es STORED calculent la fonction une fois et stockent le r√©sultat, √©vitant le recalcul √† chaque requ√™te.

---

## Bonnes pratiques de cr√©ation de fonctions

### 1. Nommage coh√©rent et explicite

```sql
-- ‚úÖ BON : Nom descriptif
CREATE FUNCTION calculer_montant_ttc(...) ...
CREATE FUNCTION obtenir_statut_commande(...) ...
CREATE FUNCTION verifier_stock_disponible(...) ...

-- ‚ùå MAUVAIS : Nom ambigu
CREATE FUNCTION calc(...) ...
CREATE FUNCTION func1(...) ...
CREATE FUNCTION f(...) ...
```

**Convention recommand√©e** :
- Verbes d'action : `calculer_`, `obtenir_`, `verifier_`, `formater_`, `convertir_`
- Noms descriptifs complets en snake_case
- √âviter les abr√©viations

### 2. Documentation avec COMMENT

```sql
DELIMITER //

CREATE OR REPLACE FUNCTION calculer_frais_livraison(
    poids_kg DECIMAL(6,2),
    distance_km INT,
    express BOOLEAN
)
RETURNS DECIMAL(10,2)
DETERMINISTIC
NO SQL
COMMENT 'Calcule les frais de livraison selon poids, distance et urgence'
BEGIN
    /*
     * Fonction : calculer_frais_livraison
     * Description : Calcule les frais de livraison selon bar√®me
     *
     * Param√®tres :
     *   - poids_kg : Poids du colis en kg (max 30kg)
     *   - distance_km : Distance de livraison en km
     *   - express : Livraison express (majoration 50%)
     *
     * Retour : Montant des frais en euros
     *
     * R√®gles :
     *   - Base : 5‚Ç¨ + 0.10‚Ç¨/kg + 0.05‚Ç¨/km
     *   - Majoration express : +50%
     *   - Minimum : 8‚Ç¨
     *   - Maximum : 150‚Ç¨
     */

    DECLARE frais DECIMAL(10,2);
    DECLARE base DECIMAL(10,2) DEFAULT 5.00;

    -- Calcul de base
    SET frais = base + (poids_kg * 0.10) + (distance_km * 0.05);

    -- Majoration express
    IF express THEN
        SET frais = frais * 1.5;
    END IF;

    -- Application min/max
    IF frais < 8.00 THEN
        SET frais = 8.00;
    ELSEIF frais > 150.00 THEN
        SET frais = 150.00;
    END IF;

    RETURN ROUND(frais, 2);
END//

DELIMITER ;
```

### 3. Validation des param√®tres

```sql
DELIMITER //

CREATE OR REPLACE FUNCTION calculer_imc(
    poids_kg DECIMAL(5,2),
    taille_m DECIMAL(3,2)
)
RETURNS DECIMAL(4,1)
DETERMINISTIC
NO SQL
BEGIN
    -- Validation des param√®tres
    IF poids_kg IS NULL OR poids_kg <= 0 THEN
        RETURN NULL;
    END IF;

    IF taille_m IS NULL OR taille_m <= 0 THEN
        RETURN NULL;
    END IF;

    -- Validation des plages r√©alistes
    IF poids_kg < 20 OR poids_kg > 300 THEN
        RETURN NULL;  -- Poids irr√©aliste
    END IF;

    IF taille_m < 0.5 OR taille_m > 2.5 THEN
        RETURN NULL;  -- Taille irr√©aliste
    END IF;

    -- Calcul IMC = poids / taille¬≤
    RETURN ROUND(poids_kg / (taille_m * taille_m), 1);
END//

DELIMITER ;
```

### 4. Gestion explicite des NULL

```sql
DELIMITER //

CREATE OR REPLACE FUNCTION concatener_securise(
    chaine1 VARCHAR(100),
    chaine2 VARCHAR(100),
    separateur VARCHAR(10)
)
RETURNS VARCHAR(210)
DETERMINISTIC
NO SQL
BEGIN
    -- ‚úÖ BON : Gestion explicite des NULL
    SET chaine1 = COALESCE(chaine1, '');
    SET chaine2 = COALESCE(chaine2, '');
    SET separateur = COALESCE(separateur, ' ');

    -- Si les deux cha√Ænes sont vides, retourner NULL
    IF chaine1 = '' AND chaine2 = '' THEN
        RETURN NULL;
    END IF;

    -- Si une seule cha√Æne non vide
    IF chaine1 = '' THEN
        RETURN chaine2;
    END IF;

    IF chaine2 = '' THEN
        RETURN chaine1;
    END IF;

    -- Concat√©nation normale
    RETURN CONCAT(chaine1, separateur, chaine2);
END//

DELIMITER ;

-- Tests
SELECT concatener_securise('Jean', 'Dupont', ' ');  -- "Jean Dupont"
SELECT concatener_securise('Jean', NULL, ' ');      -- "Jean"
SELECT concatener_securise(NULL, NULL, ' ');        -- NULL
```

### 5. D√©terminisme appropri√©

```sql
-- ‚úÖ BON : DETERMINISTIC pour calcul pur
CREATE FUNCTION carre(n INT)
RETURNS INT
DETERMINISTIC  -- Toujours le m√™me r√©sultat
NO SQL
BEGIN
    RETURN n * n;
END;

-- ‚úÖ BON : NOT DETERMINISTIC pour donn√©es variables
CREATE FUNCTION obtenir_prix_actuel(produit_id INT)
RETURNS DECIMAL(10,2)
NOT DETERMINISTIC  -- Prix peut changer
READS SQL DATA
BEGIN
    DECLARE prix DECIMAL(10,2);
    SELECT prix_unitaire INTO prix FROM produits WHERE id = produit_id;
    RETURN prix;
END;

-- ‚ùå MAUVAIS : DETERMINISTIC avec NOW()
CREATE FUNCTION horodatage()
RETURNS DATETIME
DETERMINISTIC  -- ‚ùå Incoh√©rent : NOW() varie !
NO SQL
BEGIN
    RETURN NOW();
END;
```

### 6. √âviter les effets de bord

```sql
-- ‚ùå MAUVAIS : Modification de donn√©es dans une fonction
CREATE FUNCTION mauvaise_fonction(val INT)
RETURNS INT
MODIFIES SQL DATA
BEGIN
    UPDATE compteurs SET valeur = valeur + 1;  -- ‚ùå Effet de bord
    RETURN val * 2;
END;

-- ‚úÖ BON : Fonction pure sans effet de bord
CREATE FUNCTION bonne_fonction(val INT)
RETURNS INT
DETERMINISTIC
NO SQL
BEGIN
    RETURN val * 2;  -- ‚úÖ Pas d'effet de bord
END;

-- ‚úÖ BON : Utiliser une proc√©dure pour les modifications
CREATE PROCEDURE incrementer_et_calculer(
    IN val INT,
    OUT resultat INT
)
BEGIN
    UPDATE compteurs SET valeur = valeur + 1;
    SET resultat = val * 2;
END;
```

### 7. Performance : √âviter les fonctions dans WHERE sur grandes tables

```sql
-- ‚ö†Ô∏è LENT : Fonction appel√©e pour chaque ligne (pas d'index)
SELECT * FROM clients
WHERE calculer_ca_client(id) > 10000;

-- ‚úÖ MIEUX : Sous-requ√™te ou colonne g√©n√©r√©e
-- Option 1 : Sous-requ√™te
SELECT c.* FROM clients c
WHERE (
    SELECT SUM(montant_total)
    FROM commandes
    WHERE client_id_fk = c.id
) > 10000;

-- Option 2 : Colonne g√©n√©r√©e avec index (meilleure performance)
ALTER TABLE clients
ADD COLUMN ca_total DECIMAL(10,2)
    AS (SELECT SUM(montant_total) FROM commandes WHERE client_id_fk = id) STORED;

CREATE INDEX idx_ca_total ON clients(ca_total);

SELECT * FROM clients WHERE ca_total > 10000;
```

üí° **Optimisation** : Les fonctions dans WHERE emp√™chent l'utilisation d'index. Privil√©giez les colonnes g√©n√©r√©es pour les calculs fr√©quents.

---

## Restrictions et limitations des fonctions

### 1. Pas de param√®tres OUT/INOUT

```sql
-- ‚ùå INTERDIT
CREATE FUNCTION invalide(IN a INT, OUT b INT)  -- ‚ùå OUT non autoris√©
RETURNS INT
BEGIN
    SET b = a * 2;
    RETURN a;
END;

-- ‚úÖ SOLUTION : Utiliser une proc√©dure
CREATE PROCEDURE valid_procedure(IN a INT, OUT b INT)
BEGIN
    SET b = a * 2;
END;
```

### 2. Pas de SELECT multiple

```sql
-- ‚ùå INTERDIT
CREATE FUNCTION invalide()
RETURNS INT
READS SQL DATA
BEGIN
    SELECT * FROM table1;  -- ‚ùå SELECT non captur√©
    SELECT * FROM table2;  -- ‚ùå SELECT non captur√©
    RETURN 1;
END;

-- ‚úÖ SOLUTION : SELECT INTO uniquement
CREATE FUNCTION valide()
RETURNS INT
READS SQL DATA
BEGIN
    DECLARE val INT;
    SELECT COUNT(*) INTO val FROM table1;  -- ‚úÖ SELECT INTO
    RETURN val;
END;
```

### 3. Transactions limit√©es

```sql
-- ‚ùå INTERDIT : Contr√¥le explicite de transaction
CREATE FUNCTION invalide()
RETURNS INT
MODIFIES SQL DATA
BEGIN
    START TRANSACTION;  -- ‚ùå Non autoris√©
    UPDATE table1 SET col = 1;
    COMMIT;  -- ‚ùå Non autoris√©
    RETURN 1;
END;

-- ‚úÖ SOLUTION : Utiliser une proc√©dure
CREATE PROCEDURE valid_procedure()
BEGIN
    START TRANSACTION;
    UPDATE table1 SET col = 1;
    COMMIT;
END;
```

### 4. Pas de CALL de proc√©dures

```sql
-- ‚ùå INTERDIT
CREATE FUNCTION invalide()
RETURNS INT
BEGIN
    CALL ma_procedure();  -- ‚ùå CALL non autoris√© dans une fonction
    RETURN 1;
END;

-- ‚úÖ SOLUTION : Appeler d'autres fonctions uniquement
CREATE FUNCTION valide()
RETURNS INT
BEGIN
    RETURN autre_fonction(10);  -- ‚úÖ Appel de fonction OK
END;
```

### 5. Restrictions avec binary logs

Si le serveur utilise la r√©plication bas√©e sur les instructions (binlog_format = STATEMENT), les fonctions **NON DETERMINISTIC** qui modifient des donn√©es peuvent √™tre probl√©matiques.

```sql
-- Configuration pour permettre la cr√©ation
SET GLOBAL log_bin_trust_function_creators = 1;

-- Ou ajouter dans my.cnf
[mysqld]
log_bin_trust_function_creators = 1
```

‚ö†Ô∏è **Attention** : Cette configuration peut affecter la s√©curit√© et la r√©plication.

---

## ‚úÖ Points cl√©s √† retenir

- **RETURNS obligatoire** : Toujours sp√©cifier le type de retour de la fonction
- **RETURN requis** : Le corps doit contenir au moins une instruction RETURN
- **Param√®tres IN uniquement** : Pas de OUT ou INOUT dans les fonctions
- **DETERMINISTIC vs NOT DETERMINISTIC** : D√©clarez correctement selon la logique
- **Caract√©ristiques SQL** : NO SQL, READS SQL DATA, MODIFIES SQL DATA (√©viter ce dernier)
- **Utilisation directe** : Les fonctions s'utilisent comme les fonctions natives dans SELECT, WHERE, etc.
- **Pas d'effets de bord** : √âvitez INSERT/UPDATE/DELETE dans les fonctions
- **Performance** : Attention aux fonctions dans WHERE sur grandes tables
- **Restrictions** : Pas de transactions explicites, pas de SELECT multiple, pas de CALL
- **Documentation** : Utilisez COMMENT et commentaires internes

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation officielle MariaDB - CREATE FUNCTION](https://mariadb.com/kb/en/create-function/)
- [üìñ Stored Function Characteristics](https://mariadb.com/kb/en/stored-function-overview/)
- [üìñ DETERMINISTIC Functions](https://mariadb.com/kb/en/stored-routine-privileges/)
- [üìñ Function Return Types](https://mariadb.com/kb/en/data-types/)
- [üí° Blog : Best Practices for Stored Functions](https://mariadb.com/resources/blog/)

---

## ‚û°Ô∏è Section suivante

**[8.2.2 Caract√©ristiques (DETERMINISTIC, NO SQL, etc.)](./02.2-caracteristiques-fonction.md)** : Approfondissez les caract√©ristiques des fonctions pour optimiser leurs performances et leur int√©gration dans l'√©cosyst√®me MariaDB.

---


‚è≠Ô∏è [Caract√©ristiques (DETERMINISTIC, NO SQL, etc.)](/08-programmation-cote-serveur/02.2-caracteristiques-fonction.md)
