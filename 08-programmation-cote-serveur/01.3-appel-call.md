üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.1.3 Appel avec CALL

> **Niveau** : Interm√©diaire √† Avanc√©
> **Dur√©e estim√©e** : 2 heures
> **Pr√©requis** : Sections 8.1.1 et 8.1.2 (Syntaxe CREATE PROCEDURE et Param√®tres)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Ma√Ætriser la syntaxe de l'instruction CALL pour invoquer des proc√©dures stock√©es
- G√©rer les r√©sultats multiples retourn√©s par une proc√©dure
- Utiliser les variables de session pour r√©cup√©rer les valeurs OUT/INOUT
- Appeler des proc√©dures depuis diff√©rents contextes (CLI, applications, triggers)
- G√©rer les erreurs lors de l'ex√©cution de proc√©dures
- Int√©grer les proc√©dures stock√©es dans des applications r√©elles

---

## Introduction

L'instruction **CALL** est le m√©canisme permettant d'**ex√©cuter une proc√©dure stock√©e** dans MariaDB. C'est l'√©quivalent de l'appel de fonction dans les langages de programmation, mais avec des sp√©cificit√©s propres au SQL.

### Pourquoi ma√Ætriser CALL ?

Une proc√©dure stock√©e n'a de valeur que si elle peut √™tre appel√©e efficacement :
- **Depuis le CLI** : Tests et d√©bogage
- **Depuis les applications** : Int√©gration m√©tier
- **Depuis d'autres proc√©dures** : Composition et r√©utilisation
- **Depuis les triggers** : Automatisation

üí° **Principe fondamental** : CALL est une instruction SQL comme SELECT ou UPDATE, mais elle d√©clenche l'ex√©cution d'un bloc de code pr√©compil√©.

---

## Syntaxe de base CALL

### Structure g√©n√©rale

```sql
CALL nom_procedure([liste_arguments]);
```

### Caract√©ristiques

- **Mot-cl√© obligatoire** : `CALL` doit toujours √™tre utilis√© (contrairement aux fonctions appel√©es directement dans SELECT)
- **Nom de proc√©dure** : Peut √™tre qualifi√© avec le nom de la base (`database_name.procedure_name`)
- **Parenth√®ses obligatoires** : M√™me sans param√®tres, les parenth√®ses `()` sont requises
- **Arguments** : Doivent correspondre en nombre et type aux param√®tres d√©clar√©s

### Exemple minimal

```sql
-- Proc√©dure sans param√®tres
DELIMITER //
CREATE OR REPLACE PROCEDURE afficher_heure()
BEGIN
    SELECT NOW() AS heure_actuelle;
END//
DELIMITER ;

-- Appel simple
CALL afficher_heure();
```

**R√©sultat** :
```
+---------------------+
| heure_actuelle      |
+---------------------+
| 2025-12-12 14:30:45 |
+---------------------+
```

---

## Appel avec param√®tres IN

### Passage de valeurs litt√©rales

Les param√®tres IN acceptent des valeurs litt√©rales directement dans CALL.

```sql
DELIMITER //
CREATE OR REPLACE PROCEDURE calculer_tva(
    IN p_montant_ht DECIMAL(10,2),
    IN p_taux_tva DECIMAL(5,2)
)
BEGIN
    DECLARE v_montant_ttc DECIMAL(10,2);
    SET v_montant_ttc = p_montant_ht * (1 + p_taux_tva / 100);

    SELECT
        p_montant_ht AS montant_ht,
        p_taux_tva AS taux_tva,
        v_montant_ttc AS montant_ttc;
END//
DELIMITER ;

-- Appels avec valeurs litt√©rales
CALL calculer_tva(100.00, 20.00);
CALL calculer_tva(250.50, 5.50);
CALL calculer_tva(1000, 10);  -- Types compatibles
```

### Passage de variables

Les variables de session peuvent √™tre utilis√©es comme arguments IN.

```sql
-- D√©finition de variables
SET @prix = 150.00;
SET @tva = 20.00;

-- Appel avec variables
CALL calculer_tva(@prix, @tva);

-- Variables issues de requ√™tes
SELECT prix INTO @prix_produit FROM produits WHERE id = 101;
CALL calculer_tva(@prix_produit, 20.00);
```

### Passage d'expressions

Les expressions sont √©valu√©es avant l'appel.

```sql
-- Expressions arithm√©tiques
CALL calculer_tva(100 * 1.5, 20);

-- Fonctions SQL
CALL calculer_tva(ROUND(123.456, 2), FLOOR(20.7));

-- Sous-requ√™tes
CALL calculer_tva(
    (SELECT AVG(prix) FROM produits),
    20.00
);
```

üí° **Conseil** : Les expressions complexes peuvent impacter les performances. Pr√©f√©rez calculer dans des variables pour plus de lisibilit√©.

---

## Appel avec param√®tres OUT

### Utilisation de variables de session

Les param√®tres OUT **n√©cessitent obligatoirement** des variables de session (pr√©fix√©es par `@`).

```sql
DELIMITER //
CREATE OR REPLACE PROCEDURE obtenir_stats_db(
    OUT p_nb_tables INT,
    OUT p_nb_procedures INT,
    OUT p_taille_mb DECIMAL(10,2)
)
BEGIN
    -- Nombre de tables
    SELECT COUNT(*) INTO p_nb_tables
    FROM information_schema.TABLES
    WHERE TABLE_SCHEMA = DATABASE();

    -- Nombre de proc√©dures
    SELECT COUNT(*) INTO p_nb_procedures
    FROM information_schema.ROUTINES
    WHERE ROUTINE_SCHEMA = DATABASE()
      AND ROUTINE_TYPE = 'PROCEDURE';

    -- Taille de la base
    SELECT ROUND(SUM(DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2)
    INTO p_taille_mb
    FROM information_schema.TABLES
    WHERE TABLE_SCHEMA = DATABASE();
END//
DELIMITER ;

-- D√©claration des variables de r√©ception
SET @tables = 0;
SET @procedures = 0;
SET @taille = 0;

-- Appel avec variables OUT
CALL obtenir_stats_db(@tables, @procedures, @taille);

-- Consultation des r√©sultats
SELECT
    @tables AS nombre_tables,
    @procedures AS nombre_procedures,
    @taille AS taille_mb;
```

**Sortie** :
```
+---------------+--------------------+-----------+
| nombre_tables | nombre_procedures  | taille_mb |
+---------------+--------------------+-----------+
|            15 |                  8 |     45.23 |
+---------------+--------------------+-----------+
```

### R√©cup√©ration et utilisation imm√©diate

```sql
-- Appel et utilisation dans une requ√™te
CALL obtenir_stats_db(@t, @p, @s);

SELECT
    CONCAT('La base contient ', @t, ' tables et ', @p, ' proc√©dures') AS resume,
    IF(@s > 100, 'Grande base', 'Petite base') AS categorie;
```

### R√©initialisation des variables

```sql
-- Bonnes pratiques : initialiser avant l'appel
SET @resultat = NULL;
SET @erreur = NULL;

CALL ma_procedure_out(@resultat, @erreur);

-- V√©rification
IF @erreur IS NOT NULL THEN
    SELECT CONCAT('Erreur : ', @erreur) AS message;
ELSE
    SELECT @resultat AS resultat_operation;
END IF;
```

‚ö†Ô∏è **Attention** : Les variables de session persistent entre les appels. R√©initialisez-les si n√©cessaire pour √©viter des valeurs r√©siduelles.

---

## Appel avec param√®tres INOUT

### Modification de valeurs en place

Les param√®tres INOUT permettent de passer une valeur et de la r√©cup√©rer modifi√©e.

```sql
DELIMITER //
CREATE OR REPLACE PROCEDURE incrementer(
    INOUT p_compteur INT
)
BEGIN
    SET p_compteur = p_compteur + 1;
END//
DELIMITER ;

-- Utilisation
SET @compteur = 0;

CALL incrementer(@compteur);
SELECT @compteur;  -- 1

CALL incrementer(@compteur);
SELECT @compteur;  -- 2

CALL incrementer(@compteur);
SELECT @compteur;  -- 3
```

### Exemple complexe : Cumul de montants

```sql
DELIMITER //
CREATE OR REPLACE PROCEDURE ajouter_au_panier(
    IN p_produit_id INT,
    IN p_quantite INT,
    INOUT p_montant_total DECIMAL(10,2)
)
BEGIN
    DECLARE v_prix_unitaire DECIMAL(10,2);
    DECLARE v_montant_ligne DECIMAL(10,2);

    -- R√©cup√©ration du prix
    SELECT prix INTO v_prix_unitaire
    FROM produits
    WHERE id = p_produit_id;

    -- Calcul de la ligne
    SET v_montant_ligne = v_prix_unitaire * p_quantite;

    -- Ajout au total (INOUT permet le cumul)
    SET p_montant_total = p_montant_total + v_montant_ligne;

    -- Log de l'op√©ration
    SELECT
        p_produit_id AS produit,
        p_quantite AS quantite,
        v_prix_unitaire AS prix_unitaire,
        v_montant_ligne AS montant_ligne,
        p_montant_total AS total_panier;
END//
DELIMITER ;

-- Simulation d'un panier
SET @total_panier = 0.00;

CALL ajouter_au_panier(101, 2, @total_panier);  -- 50.00‚Ç¨
CALL ajouter_au_panier(102, 1, @total_panier);  -- +25.00‚Ç¨ = 75.00‚Ç¨
CALL ajouter_au_panier(103, 3, @total_panier);  -- +45.00‚Ç¨ = 120.00‚Ç¨

SELECT @total_panier AS montant_final;  -- 120.00
```

**Points cl√©s** :
- `@total_panier` est initialis√© √† 0
- Chaque appel **lit** la valeur actuelle et l'**incr√©mente**
- Le param√®tre INOUT permet le cumul entre appels successifs

---

## Appel avec param√®tres mixtes (IN + OUT + INOUT)

### Exemple complet : Traitement de transaction

```sql
DELIMITER //
CREATE OR REPLACE PROCEDURE effectuer_virement(
    IN p_compte_source INT,
    IN p_compte_dest INT,
    IN p_montant DECIMAL(10,2),
    INOUT p_solde_source DECIMAL(10,2),
    OUT p_solde_dest DECIMAL(10,2),
    OUT p_statut VARCHAR(20),
    OUT p_message VARCHAR(255)
)
BEGIN
    DECLARE v_solde_source_actuel DECIMAL(10,2);

    -- Handler d'erreur
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_statut = 'ERREUR';
        SET p_message = 'Transaction √©chou√©e';
    END;

    START TRANSACTION;

    -- Validation montant
    IF p_montant <= 0 THEN
        SET p_statut = 'ERREUR';
        SET p_message = 'Montant invalide';
        ROLLBACK;
        LEAVE procedure_body;
    END IF;

    -- V√©rification solde source
    SELECT solde INTO v_solde_source_actuel
    FROM comptes
    WHERE id = p_compte_source
    FOR UPDATE;

    IF v_solde_source_actuel < p_montant THEN
        SET p_statut = 'INSUFFISANT';
        SET p_message = 'Solde insuffisant';
        ROLLBACK;
        LEAVE procedure_body;
    END IF;

    -- D√©bit du compte source
    UPDATE comptes
    SET solde = solde - p_montant
    WHERE id = p_compte_source;

    -- Cr√©dit du compte destination
    UPDATE comptes
    SET solde = solde + p_montant
    WHERE id = p_compte_dest;

    -- R√©cup√©ration des nouveaux soldes
    SELECT solde INTO p_solde_source
    FROM comptes WHERE id = p_compte_source;

    SELECT solde INTO p_solde_dest
    FROM comptes WHERE id = p_compte_dest;

    COMMIT;

    SET p_statut = 'SUCCES';
    SET p_message = 'Virement effectu√©';
END//
DELIMITER ;

-- Utilisation compl√®te
SET @solde_source = 1000.00;  -- INOUT : valeur initiale connue

CALL effectuer_virement(
    101,              -- Compte source (IN)
    102,              -- Compte destination (IN)
    250.00,           -- Montant (IN)
    @solde_source,    -- Solde source (INOUT)
    @solde_dest,      -- Solde destination (OUT)
    @statut,          -- Statut (OUT)
    @message          -- Message (OUT)
);

-- Affichage des r√©sultats
SELECT
    @solde_source AS nouveau_solde_source,
    @solde_dest AS nouveau_solde_dest,
    @statut AS statut_operation,
    @message AS message_retour;
```

üí° **Avantage** : Un seul appel retourne toutes les informations n√©cessaires (soldes mis √† jour, statut, message).

---

## Gestion des r√©sultats multiples

### Proc√©dure avec plusieurs SELECT

Les proc√©dures peuvent retourner **plusieurs jeux de r√©sultats** via des SELECT successifs.

```sql
DELIMITER //
CREATE OR REPLACE PROCEDURE rapport_ventes_complet(
    IN p_annee INT
)
BEGIN
    -- R√©sultat 1 : Ventes par mois
    SELECT
        MONTH(date_vente) AS mois,
        COUNT(*) AS nb_ventes,
        SUM(montant) AS total
    FROM ventes
    WHERE YEAR(date_vente) = p_annee
    GROUP BY MONTH(date_vente)
    ORDER BY mois;

    -- R√©sultat 2 : Top 5 produits
    SELECT
        p.nom AS produit,
        COUNT(*) AS nb_ventes,
        SUM(v.montant) AS total
    FROM ventes v
    INNER JOIN produits p ON v.produit_id = p.id
    WHERE YEAR(v.date_vente) = p_annee
    GROUP BY p.nom
    ORDER BY total DESC
    LIMIT 5;

    -- R√©sultat 3 : Statistiques globales
    SELECT
        COUNT(*) AS total_ventes,
        SUM(montant) AS chiffre_affaires,
        AVG(montant) AS panier_moyen,
        MIN(montant) AS vente_min,
        MAX(montant) AS vente_max
    FROM ventes
    WHERE YEAR(date_vente) = p_annee;
END//
DELIMITER ;

-- Appel
CALL rapport_ventes_complet(2025);
```

**R√©sultat** : Trois tables distinctes sont affich√©es successivement dans le CLI.

### Traitement dans les applications

```python
# Python avec mysql-connector
import mysql.connector

conn = mysql.connector.connect(
    host="localhost",
    user="user",
    password="pass",
    database="ma_base"
)

cursor = conn.cursor()
cursor.callproc('rapport_ventes_complet', [2025])

# R√©cup√©ration des multiples r√©sultats
for result in cursor.stored_results():
    rows = result.fetchall()
    print(f"R√©sultat : {len(rows)} lignes")
    for row in rows:
        print(row)
    print("---")

cursor.close()
conn.close()
```

```php
// PHP avec mysqli
$mysqli = new mysqli("localhost", "user", "pass", "ma_base");

$stmt = $mysqli->prepare("CALL rapport_ventes_complet(?)");
$annee = 2025;
$stmt->bind_param("i", $annee);
$stmt->execute();

// Premier r√©sultat
$result = $stmt->get_result();
while ($row = $result->fetch_assoc()) {
    print_r($row);
}

// R√©sultats suivants
while ($stmt->more_results()) {
    $stmt->next_result();
    $result = $stmt->get_result();
    if ($result) {
        while ($row = $result->fetch_assoc()) {
            print_r($row);
        }
    }
}
```

‚ö†Ô∏è **Important** : Les applications doivent g√©rer explicitement les r√©sultats multiples avec `more_results()` et `next_result()` (ou √©quivalent selon le langage).

---

## Appel depuis diff√©rents contextes

### 1. Depuis le CLI MariaDB

```sql
-- Connexion
mariadb -u user -p ma_base

-- Appel direct
CALL ma_procedure(123, 'test');

-- Avec variables
SET @var1 = 10;
CALL ma_procedure(@var1);
SELECT @var1;

-- Avec affichage format√©
CALL ma_procedure()\G  -- Format vertical (utile pour colonnes larges)
```

### 2. Depuis une autre proc√©dure

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE procedure_appelante()
BEGIN
    DECLARE v_resultat INT;

    -- Appel d'une autre proc√©dure
    CALL procedure_appelee(100, v_resultat);

    SELECT CONCAT('R√©sultat : ', v_resultat) AS message;
END//

CREATE OR REPLACE PROCEDURE procedure_appelee(
    IN p_valeur INT,
    OUT p_resultat INT
)
BEGIN
    SET p_resultat = p_valeur * 2;
END//

DELIMITER ;

-- Test
CALL procedure_appelante();  -- Affiche "R√©sultat : 200"
```

üí° **Composition** : Les proc√©dures peuvent s'appeler entre elles pour cr√©er des traitements complexes modulaires.

### 3. Depuis un trigger

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE enregistrer_audit(
    IN p_table VARCHAR(50),
    IN p_action VARCHAR(20),
    IN p_id INT
)
BEGIN
    INSERT INTO audit_log (table_name, action, record_id, date_action)
    VALUES (p_table, p_action, p_id, NOW());
END//

CREATE TRIGGER after_product_update
AFTER UPDATE ON produits
FOR EACH ROW
BEGIN
    -- Appel de proc√©dure depuis un trigger
    CALL enregistrer_audit('produits', 'UPDATE', NEW.id);
END//

DELIMITER ;

-- Test
UPDATE produits SET prix = 99.99 WHERE id = 101;
-- La proc√©dure enregistrer_audit est appel√©e automatiquement
```

### 4. Depuis un event planifi√©

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE purge_anciennes_logs()
BEGIN
    DELETE FROM logs_application
    WHERE date_log < DATE_SUB(NOW(), INTERVAL 90 DAY);

    SELECT ROW_COUNT() AS lignes_supprimees;
END//

-- Event qui appelle la proc√©dure
CREATE EVENT IF NOT EXISTS purge_mensuelle
ON SCHEDULE EVERY 1 MONTH
STARTS '2025-01-01 00:00:00'
DO
BEGIN
    CALL purge_anciennes_logs();
END//

DELIMITER ;
```

### 5. Depuis une application (exemples multi-langages)

#### PHP (mysqli)

```php
<?php
$mysqli = new mysqli("localhost", "user", "password", "database");

// Proc√©dure avec OUT
$stmt = $mysqli->prepare("CALL obtenir_stats_db(@t, @p, @s)");
$stmt->execute();
$stmt->close();

// R√©cup√©ration des variables OUT
$result = $mysqli->query("SELECT @t AS tables, @p AS procedures, @s AS size");
$row = $result->fetch_assoc();

echo "Tables: {$row['tables']}, Proc√©dures: {$row['procedures']}, Taille: {$row['size']} MB";
?>
```

#### Python (mysql-connector)

```python
import mysql.connector

conn = mysql.connector.connect(
    host="localhost",
    user="user",
    password="password",
    database="database"
)

cursor = conn.cursor()

# Proc√©dure avec IN
cursor.callproc('calculer_tva', [100.00, 20.00])
for result in cursor.stored_results():
    print(result.fetchall())

# Proc√©dure avec OUT
args = [0, 0, 0]  # Valeurs initiales pour OUT
result_args = cursor.callproc('obtenir_stats_db', args)
print(f"Tables: {result_args[0]}, Proc√©dures: {result_args[1]}, Taille: {result_args[2]}")

cursor.close()
conn.close()
```

#### Node.js (mysql2)

```javascript
const mysql = require('mysql2');

const connection = mysql.createConnection({
    host: 'localhost',
    user: 'user',
    password: 'password',
    database: 'database'
});

// Proc√©dure avec IN et OUT
connection.execute(
    'CALL effectuer_virement(?, ?, ?, @s, @d, @st, @msg)',
    [101, 102, 250.00],
    (err, results) => {
        if (err) throw err;

        // R√©cup√©ration des variables OUT
        connection.query(
            'SELECT @s AS solde_source, @d AS solde_dest, @st AS statut, @msg AS message',
            (err, rows) => {
                console.log(rows[0]);
            }
        );
    }
);
```

#### Java (JDBC)

```java
import java.sql.*;

public class CallProcedure {
    public static void main(String[] args) throws SQLException {
        Connection conn = DriverManager.getConnection(
            "jdbc:mariadb://localhost:3306/database",
            "user",
            "password"
        );

        // Proc√©dure avec OUT
        CallableStatement stmt = conn.prepareCall("{CALL obtenir_stats_db(?, ?, ?)}");
        stmt.registerOutParameter(1, Types.INTEGER);  // tables
        stmt.registerOutParameter(2, Types.INTEGER);  // procedures
        stmt.registerOutParameter(3, Types.DECIMAL);  // size

        stmt.execute();

        System.out.println("Tables: " + stmt.getInt(1));
        System.out.println("Proc√©dures: " + stmt.getInt(2));
        System.out.println("Taille: " + stmt.getBigDecimal(3) + " MB");

        stmt.close();
        conn.close();
    }
}
```

---

## Gestion des erreurs lors de l'appel

### Erreurs de syntaxe

```sql
-- ‚ùå Erreur : proc√©dure inexistante
CALL procedure_inexistante();
-- ERROR 1305 (42000): PROCEDURE database.procedure_inexistante does not exist

-- ‚ùå Erreur : nombre de param√®tres incorrect
CALL ma_procedure(1, 2);  -- Si la proc√©dure attend 3 param√®tres
-- ERROR 1318 (42000): Incorrect number of arguments for PROCEDURE

-- ‚ùå Erreur : type de param√®tre incorrect
CALL ma_procedure('texte');  -- Si elle attend un INT
-- ERROR 1366 (HY000): Incorrect integer value
```

### Gestion avec code d'erreur OUT

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE operation_securisee(
    IN p_valeur INT,
    OUT p_succes BOOLEAN,
    OUT p_code_erreur VARCHAR(20),
    OUT p_message_erreur VARCHAR(255)
)
BEGIN
    -- Initialisation
    SET p_succes = FALSE;
    SET p_code_erreur = '';
    SET p_message_erreur = '';

    -- Validation
    IF p_valeur < 0 THEN
        SET p_code_erreur = 'ERR_NEGATIVE';
        SET p_message_erreur = 'La valeur ne peut pas √™tre n√©gative';
        LEAVE procedure_body;
    END IF;

    IF p_valeur > 1000 THEN
        SET p_code_erreur = 'ERR_TOO_LARGE';
        SET p_message_erreur = 'La valeur ne peut pas d√©passer 1000';
        LEAVE procedure_body;
    END IF;

    -- Traitement
    -- ... logique m√©tier ...

    -- Succ√®s
    SET p_succes = TRUE;
    SET p_message_erreur = 'Op√©ration r√©ussie';
END//

DELIMITER ;

-- Utilisation avec gestion d'erreur
CALL operation_securisee(-5, @ok, @code, @msg);

IF @ok THEN
    SELECT 'Succ√®s' AS statut;
ELSE
    SELECT
        'Erreur' AS statut,
        @code AS code_erreur,
        @msg AS message;
END IF;
```

### Gestion dans les applications

```python
# Python : gestion des erreurs
import mysql.connector
from mysql.connector import Error

try:
    conn = mysql.connector.connect(
        host="localhost",
        user="user",
        password="password",
        database="database"
    )

    cursor = conn.cursor()

    # Appel de la proc√©dure
    args = [False, '', '']
    result = cursor.callproc('operation_securisee', [-5] + args)

    # V√©rification du r√©sultat
    if result[1]:  # p_succes
        print("Op√©ration r√©ussie")
    else:
        print(f"Erreur {result[2]}: {result[3]}")

except Error as e:
    print(f"Erreur MySQL : {e}")

finally:
    if conn.is_connected():
        cursor.close()
        conn.close()
```

---

## Bonnes pratiques d'appel

### 1. Toujours initialiser les variables OUT/INOUT

```sql
-- ‚úÖ BON : Initialisation avant appel
SET @resultat = NULL;
SET @erreur = NULL;
CALL ma_procedure(@resultat, @erreur);

-- V√©rification
IF @erreur IS NOT NULL THEN
    -- Gestion d'erreur
END IF;

-- ‚ùå MAUVAIS : Variables non initialis√©es
CALL ma_procedure(@res, @err);  -- Peuvent contenir des valeurs r√©siduelles
```

### 2. Nommer explicitement les variables

```sql
-- ‚úÖ BON : Noms explicites
SET @nb_lignes_affectees = 0;
SET @code_erreur = NULL;
SET @message_erreur = NULL;

CALL traiter_donnees(@nb_lignes_affectees, @code_erreur, @message_erreur);

-- ‚ùå MAUVAIS : Noms cryptiques
SET @n = 0;
SET @c = NULL;
SET @m = NULL;
CALL traiter_donnees(@n, @c, @m);
```

### 3. V√©rifier les codes de retour

```sql
-- Pattern recommand√©
CALL operation_avec_erreurs(@ok, @code, @msg);

SELECT
    CASE
        WHEN @ok = TRUE THEN 'Traitement r√©ussi'
        WHEN @code = 'ERR_NOT_FOUND' THEN 'Enregistrement introuvable'
        WHEN @code = 'ERR_DUPLICATE' THEN 'Doublon d√©tect√©'
        ELSE CONCAT('Erreur inconnue : ', @msg)
    END AS resultat;
```

### 4. Utiliser des transactions explicites si n√©cessaire

```sql
-- Si la proc√©dure modifie des donn√©es
START TRANSACTION;

CALL ma_procedure_critique(@resultat);

IF @resultat = 'SUCCES' THEN
    COMMIT;
    SELECT 'Transaction valid√©e' AS statut;
ELSE
    ROLLBACK;
    SELECT 'Transaction annul√©e' AS statut;
END IF;
```

### 5. Logger les appels de proc√©dures

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE procedure_avec_log(
    IN p_param INT,
    OUT p_resultat VARCHAR(100)
)
BEGIN
    -- Log du d√©but
    INSERT INTO procedure_logs (procedure_name, parametres, debut)
    VALUES ('procedure_avec_log', CONCAT('p_param=', p_param), NOW());

    SET @log_id = LAST_INSERT_ID();

    -- Traitement
    -- ... logique m√©tier ...
    SET p_resultat = 'Traitement effectu√©';

    -- Log de fin
    UPDATE procedure_logs
    SET fin = NOW(), resultat = p_resultat
    WHERE id = @log_id;
END//

DELIMITER ;
```

### 6. Documentation des appels complexes

```sql
-- ‚úÖ BON : Appel document√©
-- Traitement d'une commande client
-- Param√®tres : client_id, montant, validation_manager
-- Retour : commande_id, statut_validation, message
SET @cmd_id = NULL;
SET @statut = NULL;
SET @msg = NULL;

CALL traiter_commande_client(
    1001,       -- ID client
    2500.00,    -- Montant
    TRUE,       -- Validation manager requise
    @cmd_id,    -- OUT : ID commande cr√©√©e
    @statut,    -- OUT : Statut de validation
    @msg        -- OUT : Message de retour
);

SELECT @cmd_id, @statut, @msg;
```

### 7. Tester les proc√©dures isol√©ment

```sql
-- Script de test d√©di√©
-- test_procedure_virement.sql

-- Pr√©paration : donn√©es de test
TRUNCATE TABLE comptes_test;
INSERT INTO comptes_test (id, solde) VALUES (1, 1000), (2, 500);

-- Test 1 : Virement normal
SET @solde1 = 1000, @solde2 = NULL, @st = NULL, @msg = NULL;
CALL effectuer_virement(1, 2, 200, @solde1, @solde2, @st, @msg);
SELECT 'Test 1' AS test, @st AS statut, @msg AS message;

-- Test 2 : Solde insuffisant
SET @solde1 = 800, @solde2 = NULL, @st = NULL, @msg = NULL;
CALL effectuer_virement(1, 2, 1000, @solde1, @solde2, @st, @msg);
SELECT 'Test 2' AS test, @st AS statut, @msg AS message;

-- Test 3 : Montant n√©gatif
SET @solde1 = 800, @solde2 = NULL, @st = NULL, @msg = NULL;
CALL effectuer_virement(1, 2, -50, @solde1, @solde2, @st, @msg);
SELECT 'Test 3' AS test, @st AS statut, @msg AS message;

-- Nettoyage
TRUNCATE TABLE comptes_test;
```

---

## D√©bogage des appels de proc√©dures

### Affichage de valeurs interm√©diaires

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE debug_procedure(
    IN p_valeur INT,
    OUT p_resultat INT
)
BEGIN
    DECLARE v_temp INT;

    -- Affichage pour debug
    SELECT 'D√©but' AS etape, p_valeur AS valeur_entree;

    SET v_temp = p_valeur * 2;
    SELECT 'Calcul 1' AS etape, v_temp AS valeur_intermediaire;

    SET v_temp = v_temp + 10;
    SELECT 'Calcul 2' AS etape, v_temp AS valeur_intermediaire;

    SET p_resultat = v_temp;
    SELECT 'Fin' AS etape, p_resultat AS valeur_sortie;
END//

DELIMITER ;

-- Appel pour debug
CALL debug_procedure(5, @res);
-- Affiche 4 tables montrant la progression
```

### Utilisation de tables temporaires pour le debug

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE debug_avec_table(IN p_valeur INT)
BEGIN
    -- Table temporaire de debug
    CREATE TEMPORARY TABLE IF NOT EXISTS debug_trace (
        step INT AUTO_INCREMENT PRIMARY KEY,
        timestamp DATETIME DEFAULT NOW(),
        message VARCHAR(255),
        valeur VARCHAR(100)
    );

    INSERT INTO debug_trace (message, valeur)
    VALUES ('D√©but de proc√©dure', p_valeur);

    -- Traitement avec logging
    -- ...

    INSERT INTO debug_trace (message, valeur)
    VALUES ('Fin de proc√©dure', 'Succ√®s');

    -- Affichage de la trace
    SELECT * FROM debug_trace ORDER BY step;
END//

DELIMITER ;
```

### Gestion des WARNINGS

```sql
-- Apr√®s l'appel d'une proc√©dure
CALL ma_procedure_complexe(@res);

-- V√©rification des warnings
SHOW WARNINGS;

-- Affichage d√©taill√©
SELECT @@warning_count AS nb_warnings;
```

---

## Performance et optimisation des appels

### Cache des proc√©dures

Les proc√©dures sont compil√©es et mises en cache par MariaDB :

```sql
-- V√©rification du cache
SHOW STATUS LIKE 'Com_call_procedure';

-- Apr√®s plusieurs appels
CALL ma_procedure(100);
CALL ma_procedure(200);
CALL ma_procedure(300);

-- Le compteur augmente
SHOW STATUS LIKE 'Com_call_procedure';
```

### R√©utilisation des connexions

```python
# ‚úÖ BON : Pool de connexions
from mysql.connector import pooling

pool = pooling.MySQLConnectionPool(
    pool_name="mypool",
    pool_size=5,
    host="localhost",
    user="user",
    password="password",
    database="database"
)

# R√©utilisation
for i in range(100):
    conn = pool.get_connection()
    cursor = conn.cursor()
    cursor.callproc('ma_procedure', [i])
    cursor.close()
    conn.close()  # Retourne au pool
```

### Batch d'appels

```sql
-- Au lieu de boucler c√¥t√© application
-- Utiliser une proc√©dure qui boucle c√¥t√© serveur
DELIMITER //

CREATE OR REPLACE PROCEDURE traiter_batch(
    IN p_id_debut INT,
    IN p_id_fin INT
)
BEGIN
    DECLARE v_id INT DEFAULT p_id_debut;

    WHILE v_id <= p_id_fin DO
        -- Traitement
        CALL traiter_element(v_id);
        SET v_id = v_id + 1;
    END WHILE;
END//

DELIMITER ;

-- Un seul appel r√©seau au lieu de N
CALL traiter_batch(1, 1000);
```

---

## ‚úÖ Points cl√©s √† retenir

- **CALL obligatoire** : Seule fa√ßon d'ex√©cuter une proc√©dure stock√©e (pas comme les fonctions)
- **Parenth√®ses requises** : M√™me sans param√®tres, `CALL proc()` et non `CALL proc`
- **Variables de session** : Obligatoires pour OUT/INOUT, pr√©fix√©es par `@`
- **R√©sultats multiples** : Les proc√©dures peuvent retourner plusieurs SELECT successifs
- **Initialisation** : Toujours initialiser les variables avant l'appel
- **Composition** : Les proc√©dures peuvent s'appeler entre elles
- **Contextes vari√©s** : Appel depuis CLI, applications, triggers, events, autres proc√©dures
- **Gestion d'erreurs** : Utiliser des param√®tres OUT pour les codes d'erreur et messages
- **Performance** : Les proc√©dures sont compil√©es et mises en cache
- **Multi-langages** : Chaque langage a sa syntaxe sp√©cifique pour l'appel de proc√©dures

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation officielle MariaDB - CALL Statement](https://mariadb.com/kb/en/call/)
- [üìñ Stored Procedure Overview](https://mariadb.com/kb/en/stored-procedures/)
- [üìñ User-Defined Variables](https://mariadb.com/kb/en/user-defined-variables/)
- [üìñ Multiple Result Sets](https://mariadb.com/kb/en/multiple-result-sets/)
- [üí° Blog : Calling Stored Procedures from Applications](https://mariadb.com/resources/blog/)

---

## ‚û°Ô∏è Section suivante

**[8.2 Fonctions stock√©es](./02-fonctions-stockees.md)** : D√©couvrez les fonctions stock√©es qui, contrairement aux proc√©dures, retournent une valeur unique et peuvent √™tre utilis√©es directement dans les requ√™tes SELECT.

---


‚è≠Ô∏è [Fonctions stock√©es](/08-programmation-cote-serveur/02-fonctions-stockees.md)
