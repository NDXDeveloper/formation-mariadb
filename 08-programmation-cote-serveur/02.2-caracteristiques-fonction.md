üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.2.2 Caract√©ristiques (DETERMINISTIC, NO SQL, etc.)

> **Niveau** : Interm√©diaire √† Avanc√©
> **Dur√©e estim√©e** : 2 heures
> **Pr√©requis** : Section 8.2.1 (Syntaxe CREATE FUNCTION), compr√©hension de la r√©plication MariaDB

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre l'impact de chaque caract√©ristique sur le comportement des fonctions
- Choisir les caract√©ristiques appropri√©es selon le contexte
- Optimiser les performances gr√¢ce √† DETERMINISTIC
- G√©rer la s√©curit√© avec SQL SECURITY
- R√©soudre les probl√®mes li√©s aux binary logs et √† la r√©plication
- Appliquer les bonnes pratiques de d√©claration des caract√©ristiques

---

## Introduction

Les **caract√©ristiques** (characteristics) des fonctions stock√©es ne sont pas de simples m√©tadonn√©es. Elles influencent directement :
- **Les performances** : Cache des r√©sultats, optimisation des requ√™tes
- **La s√©curit√©** : Contexte d'ex√©cution et privil√®ges
- **La r√©plication** : Compatibilit√© avec les binary logs
- **La maintenabilit√©** : Documentation et compr√©hension du code

üí° **Principe fondamental** : Les caract√©ristiques sont un **contrat** entre le d√©veloppeur et le serveur MariaDB. D√©clarer correctement ces caract√©ristiques permet au serveur d'optimiser l'ex√©cution.

‚ö†Ô∏è **Important** : MariaDB ne v√©rifie pas automatiquement que vos d√©clarations sont exactes. Une fonction d√©clar√©e DETERMINISTIC qui ne l'est pas r√©ellement peut causer des bugs subtils.

---

## DETERMINISTIC vs NOT DETERMINISTIC

### D√©finition et comportement

**DETERMINISTIC** : La fonction retourne **toujours le m√™me r√©sultat** pour les m√™mes param√®tres d'entr√©e.

**NOT DETERMINISTIC** : La fonction peut retourner des **r√©sultats diff√©rents** m√™me avec les m√™mes param√®tres.

### Impact sur l'optimiseur de requ√™tes

```sql
DELIMITER //

-- Fonction d√©terministe : R√©sultat constant
CREATE OR REPLACE FUNCTION calculer_tva_deterministe(
    montant_ht DECIMAL(10,2)
)
RETURNS DECIMAL(10,2)
DETERMINISTIC  -- ‚úÖ Le r√©sultat est toujours le m√™me
NO SQL
BEGIN
    RETURN montant_ht * 1.20;
END//

-- Fonction non-d√©terministe : R√©sultat variable
CREATE OR REPLACE FUNCTION generer_reference_commande()
RETURNS VARCHAR(50)
NOT DETERMINISTIC  -- ‚úÖ Le r√©sultat change √† chaque appel
NO SQL
BEGIN
    -- Combine timestamp + UUID
    RETURN CONCAT(
        DATE_FORMAT(NOW(), '%Y%m%d%H%i%s'),
        '-',
        UUID_SHORT()
    );
END//

DELIMITER ;
```

### Avantages de DETERMINISTIC : Cache et optimisation

```sql
-- Exemple avec fonction DETERMINISTIC
SELECT
    produit_id,
    prix_ht,
    calculer_tva_deterministe(prix_ht) AS prix_ttc
FROM produits
WHERE calculer_tva_deterministe(prix_ht) > 100;  -- ‚úÖ Optimisable

-- MariaDB peut :
-- 1. Mettre en cache le r√©sultat pour chaque valeur unique de prix_ht
-- 2. √âvaluer la fonction une seule fois par valeur distincte
-- 3. R√©utiliser le r√©sultat dans WHERE et SELECT
```

**Impact performance** :
- Sur 1 000 lignes avec 50 prix distincts, la fonction d√©terministe sera appel√©e **50 fois** au lieu de 2000 (WHERE + SELECT)
- Gain de performance : jusqu'√† **40x** sur grandes tables

### Exemple : Fonction math√©matique (DETERMINISTIC)

```sql
DELIMITER //

CREATE OR REPLACE FUNCTION puissance(
    base DECIMAL(10,2),
    exposant INT
)
RETURNS DECIMAL(20,4)
DETERMINISTIC  -- ‚úÖ 2^3 = 8 toujours
NO SQL
COMMENT 'Calcule base^exposant'
BEGIN
    RETURN POWER(base, exposant);
END//

DELIMITER ;

-- Test
SELECT puissance(2, 3);   -- 8.0000
SELECT puissance(5, 2);   -- 25.0000

-- Dans une requ√™te
SELECT
    produit,
    volume_m3,
    puissance(volume_m3, 3) AS volume_cube
FROM entrepots;
```

### Exemple : Fonction avec date/heure (NOT DETERMINISTIC)

```sql
DELIMITER //

-- ‚ùå ERREUR CONCEPTUELLE : DETERMINISTIC avec NOW()
CREATE OR REPLACE FUNCTION jours_depuis_creation_mauvais(
    date_creation DATE
)
RETURNS INT
DETERMINISTIC  -- ‚ùå FAUX : NOW() change constamment !
NO SQL
BEGIN
    RETURN DATEDIFF(NOW(), date_creation);
END//

-- ‚úÖ CORRECT : NOT DETERMINISTIC avec NOW()
CREATE OR REPLACE FUNCTION jours_depuis_creation_correct(
    date_creation DATE
)
RETURNS INT
NOT DETERMINISTIC  -- ‚úÖ R√©sultat d√©pend de la date actuelle
NO SQL
BEGIN
    RETURN DATEDIFF(CURDATE(), date_creation);
END//

DELIMITER ;

-- Test : Les r√©sultats changent au fil du temps
SELECT jours_depuis_creation_correct('2025-01-01');  -- 346 (au 12/12/2025)
-- Demain, ce sera 347
```

### Fonctions natives et d√©terminisme

**Fonctions DETERMINISTIC** (r√©sultat constant) :
- Math√©matiques : `ABS()`, `ROUND()`, `POWER()`, `SQRT()`
- Cha√Ænes : `UPPER()`, `LOWER()`, `CONCAT()`, `LENGTH()`
- Conversion : `CAST()`, `CONVERT()`

**Fonctions NOT DETERMINISTIC** (r√©sultat variable) :
- Date/heure : `NOW()`, `CURDATE()`, `CURTIME()`, `UNIX_TIMESTAMP()`
- Al√©atoire : `RAND()`, `UUID()`
- Session : `USER()`, `DATABASE()`, `CONNECTION_ID()`
- R√©plication : `LAST_INSERT_ID()` (peut varier selon contexte)

### Cas limite : Fonctions avec acc√®s base de donn√©es

```sql
DELIMITER //

-- Fonction qui lit des donn√©es : NOT DETERMINISTIC ou DETERMINISTIC ?
CREATE OR REPLACE FUNCTION obtenir_prix_produit(
    produit_id INT
)
RETURNS DECIMAL(10,2)
NOT DETERMINISTIC  -- ‚úÖ Les prix peuvent changer dans la table
READS SQL DATA
BEGIN
    DECLARE prix DECIMAL(10,2);

    SELECT prix_unitaire INTO prix
    FROM produits
    WHERE id = produit_id;

    RETURN COALESCE(prix, 0);
END//

DELIMITER ;
```

üí° **R√®gle pratique** : Si votre fonction lit des donn√©es de tables qui peuvent √™tre modifi√©es, d√©clarez-la `NOT DETERMINISTIC` sauf si vous avez une garantie absolue d'immutabilit√© (tables de r√©f√©rence fig√©es).

### Quiz de d√©terminisme

```sql
-- Question 1 : D√©terministe ou non ?
CREATE FUNCTION calcul_remise(montant DECIMAL(10,2))
RETURNS DECIMAL(10,2)
-- DETERMINISTIC ou NOT DETERMINISTIC ?
BEGIN
    RETURN montant * 0.9;  -- Remise fixe 10%
END;
-- R√©ponse : DETERMINISTIC ‚úÖ

-- Question 2 : D√©terministe ou non ?
CREATE FUNCTION est_jour_ouvrable()
RETURNS BOOLEAN
-- DETERMINISTIC ou NOT DETERMINISTIC ?
BEGIN
    RETURN DAYOFWEEK(CURDATE()) NOT IN (1, 7);  -- Pas samedi/dimanche
END;
-- R√©ponse : NOT DETERMINISTIC ‚úÖ (d√©pend de la date actuelle)

-- Question 3 : D√©terministe ou non ?
CREATE FUNCTION formater_numero(numero INT)
RETURNS VARCHAR(20)
-- DETERMINISTIC ou NOT DETERMINISTIC ?
BEGIN
    RETURN LPAD(numero, 8, '0');  -- Padding avec des z√©ros
END;
-- R√©ponse : DETERMINISTIC ‚úÖ
```

---

## NO SQL, CONTAINS SQL, READS SQL DATA, MODIFIES SQL DATA

Ces caract√©ristiques d√©crivent le **niveau d'interaction** de la fonction avec la base de donn√©es.

### Hi√©rarchie des niveaux d'acc√®s

```
NO SQL                  -- Aucun acc√®s aux donn√©es
    ‚Üì
CONTAINS SQL            -- Contient du SQL mais n'acc√®de pas aux donn√©es
    ‚Üì
READS SQL DATA          -- Lit des donn√©es (SELECT INTO)
    ‚Üì
MODIFIES SQL DATA       -- Modifie des donn√©es (INSERT/UPDATE/DELETE)
```

### NO SQL : Fonctions pures

**Utilisation** : Calculs math√©matiques, transformations de cha√Ænes, logique pure

```sql
DELIMITER //

-- Fonction pure sans acc√®s base de donn√©es
CREATE OR REPLACE FUNCTION celsius_vers_fahrenheit(
    celsius DECIMAL(5,2)
)
RETURNS DECIMAL(5,2)
DETERMINISTIC
NO SQL  -- ‚úÖ Aucun acc√®s SQL
COMMENT 'Convertit Celsius en Fahrenheit'
BEGIN
    RETURN (celsius * 9/5) + 32;
END//

CREATE OR REPLACE FUNCTION formater_code_postal(
    code VARCHAR(10)
)
RETURNS VARCHAR(10)
DETERMINISTIC
NO SQL  -- ‚úÖ Manipulation de cha√Æne uniquement
BEGIN
    -- Supprime espaces et tirets
    SET code = REPLACE(REPLACE(code, ' ', ''), '-', '');

    -- Format fran√ßais : 5 chiffres
    IF LENGTH(code) = 5 AND code REGEXP '^[0-9]+$' THEN
        RETURN code;
    END IF;

    RETURN NULL;
END//

DELIMITER ;

-- Tests
SELECT celsius_vers_fahrenheit(20);      -- 68.00
SELECT formater_code_postal('75-001');   -- 75001
```

**Avantages NO SQL** :
- Performance maximale (pas d'acc√®s disque)
- R√©utilisable dans tout contexte
- S√ªr pour la r√©plication

### CONTAINS SQL : SQL minimal

**Utilisation** : Variables, contr√¥le de flux, pas d'acc√®s aux tables

```sql
DELIMITER //

CREATE OR REPLACE FUNCTION categorie_age(
    age INT
)
RETURNS VARCHAR(20)
DETERMINISTIC
CONTAINS SQL  -- Contient du SQL (IF, CASE) mais pas de SELECT
BEGIN
    DECLARE categorie VARCHAR(20);

    -- Logique SQL conditionnelle
    CASE
        WHEN age < 18 THEN
            SET categorie = 'MINEUR';
        WHEN age < 25 THEN
            SET categorie = 'JEUNE';
        WHEN age < 65 THEN
            SET categorie = 'ADULTE';
        ELSE
            SET categorie = 'SENIOR';
    END CASE;

    RETURN categorie;
END//

DELIMITER ;
```

üí° **Note** : En pratique, `CONTAINS SQL` et `NO SQL` sont souvent interchangeables pour les fonctions sans acc√®s table. Pr√©f√©rez `NO SQL` pour plus de clart√©.

### READS SQL DATA : Lecture de donn√©es

**Utilisation** : SELECT INTO, requ√™tes de lecture

```sql
DELIMITER //

CREATE OR REPLACE FUNCTION obtenir_nom_client(
    client_id INT
)
RETURNS VARCHAR(200)
NOT DETERMINISTIC  -- Les donn√©es peuvent changer
READS SQL DATA  -- ‚úÖ Lit depuis la table clients
COMMENT 'Retourne le nom complet du client'
BEGIN
    DECLARE nom_complet VARCHAR(200);

    -- Lecture de donn√©es
    SELECT CONCAT(prenom, ' ', nom) INTO nom_complet
    FROM clients
    WHERE id = client_id;

    RETURN COALESCE(nom_complet, 'Inconnu');
END//

CREATE OR REPLACE FUNCTION compter_commandes_client(
    client_id INT
)
RETURNS INT
NOT DETERMINISTIC
READS SQL DATA  -- ‚úÖ Agr√©gation sur la table commandes
BEGIN
    DECLARE nb_commandes INT;

    SELECT COUNT(*) INTO nb_commandes
    FROM commandes
    WHERE client_id_fk = client_id
      AND statut != 'ANNULEE';

    RETURN nb_commandes;
END//

DELIMITER ;

-- Utilisation
SELECT
    id,
    obtenir_nom_client(id) AS nom,
    compter_commandes_client(id) AS nb_commandes
FROM clients
LIMIT 10;
```

### MODIFIES SQL DATA : Modification de donn√©es

‚ö†Ô∏è **AVERTISSEMENT** : Modifier des donn√©es dans une fonction est une **mauvaise pratique** g√©n√©ralis√©e.

```sql
DELIMITER //

-- ‚ùå ANTI-PATTERN : Modification dans une fonction
CREATE OR REPLACE FUNCTION incrementer_compteur_global()
RETURNS INT
NOT DETERMINISTIC
MODIFIES SQL DATA  -- ‚ö†Ô∏è Modification de donn√©es
BEGIN
    -- Effet de bord : modification silencieuse
    UPDATE compteurs
    SET valeur = valeur + 1
    WHERE nom = 'global';

    RETURN (SELECT valeur FROM compteurs WHERE nom = 'global');
END//

DELIMITER ;

-- Probl√®me : Effet de bord cach√©
SELECT
    id,
    nom,
    incrementer_compteur_global() AS compteur  -- ‚ùå Incr√©mente pour chaque ligne !
FROM clients;
-- Si 100 clients, le compteur est incr√©ment√© 100 fois !
```

**Probl√®mes avec MODIFIES SQL DATA** :
1. **Effets de bord non √©vidents** : Lecture d'une donn√©e modifie la base
2. **Impossible √† rollback** : Si utilis√© dans SELECT, pas de transaction
3. **Comportement impr√©visible** : Ordre d'√©valuation non garanti
4. **R√©plication probl√©matique** : Peut causer des divergences

### Solution recommand√©e : Utiliser une proc√©dure

```sql
DELIMITER //

-- ‚úÖ BON : Proc√©dure pour modification
CREATE OR REPLACE PROCEDURE incrementer_compteur(
    OUT nouvelle_valeur INT
)
BEGIN
    UPDATE compteurs
    SET valeur = valeur + 1
    WHERE nom = 'global';

    SELECT valeur INTO nouvelle_valeur
    FROM compteurs
    WHERE nom = 'global';
END//

DELIMITER ;

-- Utilisation explicite
CALL incrementer_compteur(@compteur);
SELECT @compteur;
```

### Tableau r√©capitulatif des niveaux SQL

| Niveau | Acc√®s donn√©es | Cas d'usage | Exemple |
|--------|---------------|-------------|---------|
| **NO SQL** | ‚ùå Aucun | Calculs purs, transformations | Conversion temp√©rature, formatage |
| **CONTAINS SQL** | ‚ö†Ô∏è Minimal | Logique conditionnelle | Cat√©gorisation, classification |
| **READS SQL DATA** | ‚úÖ Lecture | Consultation, agr√©gation | R√©cup√©ration prix, comptage |
| **MODIFIES SQL DATA** | ‚ö†Ô∏è √âcriture | **√Ä √âVITER** | (Utiliser proc√©dure √† la place) |

---

## SQL SECURITY : DEFINER vs INVOKER

### D√©finition

**SQL SECURITY** contr√¥le le **contexte d'ex√©cution** de la fonction : avec quels privil√®ges s'ex√©cute-t-elle ?

**DEFINER** (d√©faut) : La fonction s'ex√©cute avec les privil√®ges du cr√©ateur
**INVOKER** : La fonction s'ex√©cute avec les privil√®ges de l'appelant

### DEFINER : Ex√©cution avec privil√®ges du cr√©ateur

```sql
DELIMITER //

-- Fonction cr√©√©e par un DBA avec privil√®ges √©lev√©s
CREATE OR REPLACE FUNCTION obtenir_salaire_moyen()
RETURNS DECIMAL(10,2)
SQL SECURITY DEFINER  -- Privil√®ges du cr√©ateur (DBA)
READS SQL DATA
BEGIN
    DECLARE salaire_moy DECIMAL(10,2);

    -- Acc√®s √† une table sensible (salaires)
    SELECT AVG(salaire) INTO salaire_moy
    FROM employes_salaires;  -- Table restreinte

    RETURN salaire_moy;
END//

DELIMITER ;

-- Attribution du privil√®ge EXECUTE √† un utilisateur standard
GRANT EXECUTE ON FUNCTION ma_base.obtenir_salaire_moyen TO 'user_std'@'localhost';
```

**Sc√©nario** :
1. `user_std` n'a **pas** acc√®s direct √† la table `employes_salaires`
2. Mais il peut **appeler** la fonction `obtenir_salaire_moyen()`
3. La fonction s'ex√©cute avec les privil√®ges du DBA (cr√©ateur)
4. R√©sultat : `user_std` obtient le salaire moyen **sans** acc√©der directement √† la table

üí° **Avantage** : Encapsulation de l'acc√®s aux donn√©es sensibles, contr√¥le granulaire.

### INVOKER : Ex√©cution avec privil√®ges de l'appelant

```sql
DELIMITER //

CREATE OR REPLACE FUNCTION obtenir_mes_commandes()
RETURNS INT
SQL SECURITY INVOKER  -- Privil√®ges de l'appelant
READS SQL DATA
BEGIN
    -- CURRENT_USER() retourne l'utilisateur qui ex√©cute
    RETURN (
        SELECT COUNT(*)
        FROM commandes
        WHERE utilisateur = CURRENT_USER()
    );
END//

DELIMITER ;
```

**Sc√©nario** :
1. Chaque utilisateur appelle `obtenir_mes_commandes()`
2. La fonction s'ex√©cute avec **ses propres privil√®ges**
3. `CURRENT_USER()` identifie l'appelant
4. R√©sultat : Chaque utilisateur voit ses propres donn√©es

üí° **Avantage** : Respect du mod√®le de s√©curit√© existant, pas d'escalade de privil√®ges.

### Exemple comparatif : DEFINER vs INVOKER

```sql
DELIMITER //

-- Table sensible
CREATE TABLE audit_securite (
    id INT PRIMARY KEY AUTO_INCREMENT,
    utilisateur VARCHAR(100),
    action VARCHAR(100),
    timestamp DATETIME
);

-- Acc√®s restreint
REVOKE ALL ON audit_securite FROM 'user_app'@'%';

-- Fonction DEFINER : L'application peut logger
CREATE OR REPLACE FUNCTION logger_action_definer(action VARCHAR(100))
RETURNS INT
SQL SECURITY DEFINER  -- Privil√®ges du cr√©ateur (admin)
MODIFIES SQL DATA
BEGIN
    INSERT INTO audit_securite (utilisateur, action, timestamp)
    VALUES (USER(), action, NOW());
    RETURN LAST_INSERT_ID();
END//

-- Fonction INVOKER : √âchoue si l'appelant n'a pas les droits
CREATE OR REPLACE FUNCTION logger_action_invoker(action VARCHAR(100))
RETURNS INT
SQL SECURITY INVOKER  -- Privil√®ges de l'appelant
MODIFIES SQL DATA
BEGIN
    INSERT INTO audit_securite (utilisateur, action, timestamp)
    VALUES (USER(), action, NOW());
    RETURN LAST_INSERT_ID();
END//

DELIMITER ;

-- Test avec user_app (pas de privil√®ge sur audit_securite)
-- En tant que 'user_app'@'%'
SELECT logger_action_definer('LOGIN');  -- ‚úÖ Fonctionne
SELECT logger_action_invoker('LOGIN');  -- ‚ùå Erreur : INSERT denied
```

### Bonnes pratiques SQL SECURITY

**Utilisez DEFINER quand** :
- La fonction acc√®de √† des donn√©es restreintes (audit, salaires)
- Vous voulez contr√¥ler l'acc√®s de mani√®re centralis√©e
- La fonction effectue des op√©rations sensibles (logging, m√©triques)

**Utilisez INVOKER quand** :
- La fonction doit respecter les privil√®ges de l'utilisateur
- Les donn√©es manipul√©es sont sp√©cifiques √† l'appelant
- Vous voulez √©viter l'escalade de privil√®ges

‚ö†Ô∏è **Attention** : DEFINER peut √™tre un risque de s√©curit√© si mal utilis√©. Une fonction DEFINER cr√©√©e par root donne un acc√®s root √† n'importe qui ayant EXECUTE.

---

## COMMENT : Documentation des fonctions

### Syntaxe et utilisation

```sql
DELIMITER //

CREATE OR REPLACE FUNCTION calculer_frais_port(
    poids_kg DECIMAL(6,2),
    pays_destination VARCHAR(2)
)
RETURNS DECIMAL(10,2)
DETERMINISTIC
NO SQL
COMMENT 'Calcule les frais de port selon poids et destination (v2.1 - 2025-12-12)'
BEGIN
    /*
     * DOCUMENTATION INTERNE
     *
     * Fonction : calculer_frais_port
     * Version : 2.1
     * Auteur : √âquipe Logistique
     * Date : 2025-12-12
     *
     * Description :
     *   Calcule les frais de port selon bar√®me 2025
     *
     * Param√®tres :
     *   - poids_kg : Poids du colis (max 30kg)
     *   - pays_destination : Code ISO 2 lettres
     *
     * Retour : Montant en euros (EUR)
     *
     * R√®gles m√©tier :
     *   - France (FR) : 5‚Ç¨ + 0.20‚Ç¨/kg
     *   - UE : 10‚Ç¨ + 0.50‚Ç¨/kg
     *   - International : 20‚Ç¨ + 1.00‚Ç¨/kg
     *   - Minimum : 8‚Ç¨
     *   - Maximum : 200‚Ç¨
     *
     * D√©pendances : Aucune
     *
     * Changelog :
     *   v2.1 (2025-12-12) : Ajout plafond 200‚Ç¨
     *   v2.0 (2025-06-01) : Nouveau bar√®me 2025
     *   v1.0 (2024-01-01) : Version initiale
     */

    DECLARE frais DECIMAL(10,2);
    DECLARE pays_ue VARCHAR(100) DEFAULT 'AT,BE,BG,HR,CY,CZ,DK,EE,FI,FR,DE,GR,HU,IE,IT,LV,LT,LU,MT,NL,PL,PT,RO,SK,SI,ES,SE';

    -- Calcul selon destination
    IF pays_destination = 'FR' THEN
        SET frais = 5.00 + (poids_kg * 0.20);
    ELSEIF FIND_IN_SET(pays_destination, pays_ue) THEN
        SET frais = 10.00 + (poids_kg * 0.50);
    ELSE
        SET frais = 20.00 + (poids_kg * 1.00);
    END IF;

    -- Application min/max
    IF frais < 8.00 THEN
        SET frais = 8.00;
    ELSEIF frais > 200.00 THEN
        SET frais = 200.00;
    END IF;

    RETURN ROUND(frais, 2);
END//

DELIMITER ;
```

### Consultation du COMMENT

```sql
-- Voir le commentaire d'une fonction
SHOW CREATE FUNCTION calculer_frais_port\G

-- Ou via INFORMATION_SCHEMA
SELECT
    ROUTINE_NAME,
    ROUTINE_COMMENT,
    CREATED,
    LAST_ALTERED
FROM information_schema.ROUTINES
WHERE
    ROUTINE_SCHEMA = DATABASE()
    AND ROUTINE_NAME = 'calculer_frais_port';
```

üí° **Bonne pratique** : Utilisez le COMMENT pour les m√©tadonn√©es courtes (version, auteur, date) et les commentaires internes `/* */` pour la documentation d√©taill√©e.

---

## Impact sur la r√©plication et binary logs

### Probl√©matique avec STATEMENT-based replication

Avec `binlog_format = STATEMENT`, MariaDB enregistre les **instructions SQL** dans les binary logs, pas les donn√©es modifi√©es.

**Probl√®me** : Les fonctions NON-DETERMINISTIC peuvent produire des r√©sultats diff√©rents sur master et replicas.

```sql
-- Fonction probl√©matique pour la r√©plication
CREATE FUNCTION generer_id_commande()
RETURNS VARCHAR(50)
NOT DETERMINISTIC
NO SQL
BEGIN
    -- UUID() et NOW() donnent des valeurs diff√©rentes
    RETURN CONCAT(UUID(), '-', NOW());
END;

-- Sur le master
INSERT INTO commandes (ref, client_id)
VALUES (generer_id_commande(), 101);
-- ref = '550e8400-e29b-41d4-a716-446655440000-2025-12-12 10:30:00'

-- Sur le replica (binlog rejou√©)
-- ref = '660f9500-f39c-52e5-b827-557766551111-2025-12-12 10:35:15'
-- ‚ùå DIFF√âRENT : Divergence master/replica !
```

### Solution 1 : ROW-based replication

```sql
-- Configuration serveur (my.cnf)
[mysqld]
binlog_format = ROW  -- Enregistre les donn√©es, pas les instructions
```

Avec `ROW`, les valeurs **apr√®s ex√©cution** sont r√©pliqu√©es, pas les fonctions elles-m√™mes.

### Solution 2 : log_bin_trust_function_creators

```sql
-- Autoriser la cr√©ation de fonctions non-d√©terministes
SET GLOBAL log_bin_trust_function_creators = 1;

-- Ou dans my.cnf
[mysqld]
log_bin_trust_function_creators = 1
```

‚ö†Ô∏è **Attention** : Cette configuration d√©sactive les v√©rifications de s√©curit√©. Utilisez avec pr√©caution.

### Solution 3 : D√©clarer correctement les fonctions

```sql
-- ‚úÖ BON : Fonction d√©terministe s√ªre pour r√©plication
CREATE FUNCTION calculer_hash_deterministe(data VARCHAR(255))
RETURNS VARCHAR(64)
DETERMINISTIC  -- Garantie de reproductibilit√©
NO SQL
BEGIN
    RETURN SHA2(data, 256);
END;

-- ‚úÖ BON : Fonction non-d√©terministe mais READ-only
CREATE FUNCTION obtenir_prix_actuel(produit_id INT)
RETURNS DECIMAL(10,2)
NOT DETERMINISTIC
READS SQL DATA  -- Pas de modification, s√ªr
BEGIN
    DECLARE prix DECIMAL(10,2);
    SELECT prix_unitaire INTO prix FROM produits WHERE id = produit_id;
    RETURN prix;
END;
```

### Tableau de compatibilit√© r√©plication

| Caract√©ristiques | STATEMENT | ROW | Remarques |
|------------------|-----------|-----|-----------|
| DETERMINISTIC + NO SQL | ‚úÖ S√ªr | ‚úÖ S√ªr | Id√©al |
| DETERMINISTIC + READS | ‚ö†Ô∏è Risque | ‚úÖ S√ªr | Donn√©es peuvent diff√©rer |
| NOT DETERMINISTIC + READS | ‚ö†Ô∏è Risque | ‚úÖ S√ªr | Lecture acceptable |
| NOT DETERMINISTIC + MODIFIES | ‚ùå Dangereux | ‚ö†Ô∏è Risque | √Ä √©viter absolument |

---

## Bonnes pratiques de d√©claration

### 1. Toujours d√©clarer explicitement les caract√©ristiques

```sql
-- ‚ùå MAUVAIS : Caract√©ristiques implicites (comportement par d√©faut)
CREATE FUNCTION mauvais_exemple(x INT)
RETURNS INT
BEGIN
    RETURN x * 2;
END;

-- ‚úÖ BON : D√©claration explicite
CREATE FUNCTION bon_exemple(x INT)
RETURNS INT
DETERMINISTIC      -- ‚úÖ Explicite
NO SQL             -- ‚úÖ Explicite
SQL SECURITY DEFINER  -- ‚úÖ Explicite (m√™me si c'est le d√©faut)
COMMENT 'Double la valeur'  -- ‚úÖ Documentation
BEGIN
    RETURN x * 2;
END;
```

### 2. √ätre honn√™te avec DETERMINISTIC

```sql
-- ‚ùå MAUVAIS : Mensonge sur le d√©terminisme
CREATE FUNCTION menteur(x INT)
RETURNS INT
DETERMINISTIC  -- ‚ùå FAUX : utilise RAND()
NO SQL
BEGIN
    RETURN x + FLOOR(RAND() * 10);  -- R√©sultat al√©atoire !
END;

-- ‚úÖ BON : D√©claration honn√™te
CREATE FUNCTION honnete(x INT)
RETURNS INT
NOT DETERMINISTIC  -- ‚úÖ VRAI : r√©sultat al√©atoire
NO SQL
BEGIN
    RETURN x + FLOOR(RAND() * 10);
END;
```

### 3. Choisir le niveau SQL appropri√©

```sql
-- ‚ùå TROP PERMISSIF : MODIFIES SQL DATA alors qu'on lit seulement
CREATE FUNCTION trop_permissif(id INT)
RETURNS VARCHAR(100)
MODIFIES SQL DATA  -- ‚ùå Overkill, on lit seulement
BEGIN
    DECLARE nom VARCHAR(100);
    SELECT nom_client INTO nom FROM clients WHERE client_id = id;
    RETURN nom;
END;

-- ‚úÖ BON : Niveau appropri√©
CREATE FUNCTION niveau_approprie(id INT)
RETURNS VARCHAR(100)
NOT DETERMINISTIC
READS SQL DATA  -- ‚úÖ Pr√©cis : lecture seulement
BEGIN
    DECLARE nom VARCHAR(100);
    SELECT nom_client INTO nom FROM clients WHERE client_id = id;
    RETURN nom;
END;
```

### 4. Documenter avec COMMENT

```sql
-- ‚ùå MAUVAIS : Pas de documentation
CREATE FUNCTION mystere(a INT, b INT)
RETURNS INT
DETERMINISTIC
NO SQL
BEGIN
    RETURN (a * b) / 2;
END;

-- ‚úÖ BON : Documentation claire
CREATE FUNCTION calculer_surface_triangle(base INT, hauteur INT)
RETURNS INT
DETERMINISTIC
NO SQL
COMMENT 'Calcule la surface d''un triangle : (base √ó hauteur) / 2'
BEGIN
    RETURN (base * hauteur) / 2;
END;
```

### 5. Consid√©rer SQL SECURITY selon le contexte

```sql
-- ‚úÖ BON : DEFINER pour fonction sensible (audit)
CREATE FUNCTION logger_acces(page VARCHAR(100))
RETURNS INT
SQL SECURITY DEFINER  -- Admin cr√©ateur peut √©crire dans logs
MODIFIES SQL DATA
BEGIN
    INSERT INTO logs_acces (utilisateur, page, timestamp)
    VALUES (USER(), page, NOW());
    RETURN LAST_INSERT_ID();
END;

-- ‚úÖ BON : INVOKER pour fonction utilisateur
CREATE FUNCTION mes_donnees_personnelles()
RETURNS TEXT
SQL SECURITY INVOKER  -- Chaque utilisateur voit ses donn√©es
READS SQL DATA
BEGIN
    RETURN (
        SELECT donnees
        FROM utilisateurs
        WHERE username = CURRENT_USER()
    );
END;
```

### 6. Checklist avant cr√©ation

```sql
/*
 * CHECKLIST CR√âATION DE FONCTION
 *
 * [ ] Nom descriptif et coh√©rent avec conventions
 * [ ] DETERMINISTIC correctement √©valu√©
 * [ ] Niveau SQL appropri√© (NO SQL / READS / MODIFIES)
 * [ ] SQL SECURITY adapt√© au contexte
 * [ ] COMMENT avec version et description
 * [ ] Documentation interne compl√®te
 * [ ] Gestion des NULL et erreurs
 * [ ] Test√©e avec diff√©rentes entr√©es
 * [ ] Compatible avec la r√©plication (si applicable)
 * [ ] Performance √©valu√©e sur grandes donn√©es
 */
```

---

## Modification des caract√©ristiques

### Recr√©ation avec CREATE OR REPLACE

```sql
-- Modification compl√®te d'une fonction
CREATE OR REPLACE FUNCTION ma_fonction(x INT)
RETURNS INT
DETERMINISTIC  -- Nouvelle caract√©ristique
NO SQL
COMMENT 'Version 2.0 - Optimis√©e'  -- Nouveau commentaire
BEGIN
    RETURN x * 3;  -- Nouvelle logique
END;
```

### Impossible de modifier uniquement les caract√©ristiques

‚ö†Ô∏è **Limitation** : MariaDB ne permet pas de modifier uniquement les caract√©ristiques sans recr√©er la fonction enti√®re.

```sql
-- ‚ùå N'EXISTE PAS : ALTER FUNCTION pour changer caract√©ristiques
ALTER FUNCTION ma_fonction DETERMINISTIC;  -- ‚ùå Syntaxe invalide

-- ‚úÖ SOLUTION : CREATE OR REPLACE
CREATE OR REPLACE FUNCTION ma_fonction(x INT)
RETURNS INT
DETERMINISTIC  -- Caract√©ristique modifi√©e
NO SQL
BEGIN
    RETURN x * 2;  -- M√™me logique
END;
```

---

## Exemples complets avec caract√©ristiques optimales

### Exemple 1 : Fonction de calcul pur

```sql
DELIMITER //

CREATE OR REPLACE FUNCTION calculer_imc(
    poids_kg DECIMAL(5,2),
    taille_m DECIMAL(3,2)
)
RETURNS DECIMAL(4,1)
DETERMINISTIC      -- ‚úÖ R√©sultat constant pour m√™mes entr√©es
NO SQL             -- ‚úÖ Calcul pur, pas d'acc√®s BDD
SQL SECURITY DEFINER  -- Pas critique ici
COMMENT 'Calcule l''IMC : poids / taille¬≤ (v1.0)'
BEGIN
    -- Validation
    IF poids_kg <= 0 OR taille_m <= 0 THEN
        RETURN NULL;
    END IF;

    -- Calcul IMC
    RETURN ROUND(poids_kg / (taille_m * taille_m), 1);
END//

DELIMITER ;
```

### Exemple 2 : Fonction avec lecture donn√©es

```sql
DELIMITER //

CREATE OR REPLACE FUNCTION obtenir_statut_commande(
    commande_id INT
)
RETURNS VARCHAR(50)
NOT DETERMINISTIC   -- ‚úÖ Statut peut changer
READS SQL DATA      -- ‚úÖ Lecture de la table commandes
SQL SECURITY INVOKER  -- ‚úÖ Respect des privil√®ges utilisateur
COMMENT 'Retourne le statut actuel d''une commande (v1.2)'
BEGIN
    DECLARE statut VARCHAR(50);

    SELECT c.statut INTO statut
    FROM commandes c
    WHERE c.id = commande_id;

    RETURN COALESCE(statut, 'INCONNU');
END//

DELIMITER ;
```

### Exemple 3 : Fonction de cat√©gorisation

```sql
DELIMITER //

CREATE OR REPLACE FUNCTION evaluer_risque_credit(
    score_credit INT,
    revenus_annuels DECIMAL(10,2),
    endettement_pct DECIMAL(5,2)
)
RETURNS VARCHAR(20)
DETERMINISTIC       -- ‚úÖ R√®gles m√©tier fixes
NO SQL              -- ‚úÖ Logique pure
SQL SECURITY DEFINER  -- R√®gles m√©tier sensibles
COMMENT '√âvalue le risque cr√©dit selon score, revenus et endettement (v3.1)'
BEGIN
    /*
     * Matrice de risque :
     * - Score < 500 OU Endettement > 50% : √âLEV√â
     * - Score < 650 OU Endettement > 35% : MOYEN
     * - Revenus < 20000 : MOYEN (minimum)
     * - Sinon : FAIBLE
     */

    IF score_credit < 500 OR endettement_pct > 50 THEN
        RETURN '√âLEV√â';
    ELSEIF score_credit < 650 OR endettement_pct > 35 THEN
        RETURN 'MOYEN';
    ELSEIF revenus_annuels < 20000 THEN
        RETURN 'MOYEN';
    ELSE
        RETURN 'FAIBLE';
    END IF;
END//

DELIMITER ;
```

---

## ‚úÖ Points cl√©s √† retenir

- **DETERMINISTIC** : Cache et optimisation, d√©clarer quand r√©sultat constant pour m√™mes param√®tres
- **NOT DETERMINISTIC** : R√©sultat variable (NOW(), RAND(), lecture BDD modifiable)
- **NO SQL** : Performance maximale, fonctions pures sans acc√®s base de donn√©es
- **READS SQL DATA** : Lecture seule, s√ªr pour la r√©plication
- **MODIFIES SQL DATA** : √Ä √©viter, utiliser des proc√©dures √† la place
- **SQL SECURITY DEFINER** : Encapsulation de privil√®ges, contr√¥le centralis√©
- **SQL SECURITY INVOKER** : Respect des privil√®ges utilisateur, pas d'escalade
- **COMMENT** : Documentation essentielle, incluez version et description
- **R√©plication** : DETERMINISTIC + NO SQL = S√ªr, NOT DETERMINISTIC + MODIFIES = Dangereux
- **Honn√™tet√©** : D√©clarez correctement, MariaDB fait confiance √† vos d√©clarations

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation officielle MariaDB - Stored Function Characteristics](https://mariadb.com/kb/en/stored-function-overview/)
- [üìñ DETERMINISTIC Functions](https://mariadb.com/kb/en/create-function/#deterministic)
- [üìñ SQL Security](https://mariadb.com/kb/en/stored-routine-privileges/#sql-security)
- [üìñ Binary Log Formats](https://mariadb.com/kb/en/binary-log-formats/)
- [üìñ Replication and Stored Programs](https://mariadb.com/kb/en/replication-and-stored-programs/)
- [üí° Blog : Optimizing Stored Functions](https://mariadb.com/resources/blog/)

---

## ‚û°Ô∏è Section suivante

**[8.3 Triggers (d√©clencheurs)](./03-triggers.md)** : D√©couvrez les triggers qui permettent d'automatiser des actions en r√©ponse aux modifications de donn√©es, avec les variables OLD et NEW.

---


‚è≠Ô∏è [Triggers (d√©clencheurs)](/08-programmation-cote-serveur/03-triggers.md)
