üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.4.1 CREATE EVENT et planification

> **Niveau** : Interm√©diaire √† Avanc√©
> **Dur√©e estim√©e** : 2.5 heures
> **Pr√©requis** : Sections 8.1 √† 8.3 (Proc√©dures, Fonctions, Triggers), compr√©hension du cron

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre le syst√®me d'√©v√©nements planifi√©s de MariaDB
- Cr√©er et g√©rer des √©v√©nements avec diff√©rentes strat√©gies de planification
- Utiliser les syntaxes temporelles (AT, EVERY, ON SCHEDULE)
- Impl√©menter des t√¢ches de maintenance automatis√©es
- G√©rer le cycle de vie des √©v√©nements (activation, d√©sactivation, suppression)
- Appliquer les bonnes pratiques d'administration des events

---

## Introduction

Les **events** (√©v√©nements) sont des objets de base de donn√©es qui ex√©cutent automatiquement du code SQL selon une **planification temporelle**. Ils fonctionnent comme un **scheduler int√©gr√©** similaire au cron Unix/Linux, mais directement dans MariaDB.

### Pourquoi utiliser les events ?

Les events permettent d'automatiser des t√¢ches r√©currentes :
- **Maintenance** : Purge de donn√©es anciennes, optimisation de tables
- **Agr√©gations** : Calcul de statistiques quotidiennes/hebdomadaires
- **Nettoyage** : Suppression de sessions expir√©es, logs temporaires
- **Notifications** : G√©n√©ration de rapports p√©riodiques
- **Monitoring** : V√©rifications de sant√©, alertes

üí° **Avantage cl√©** : Contrairement au cron syst√®me, les events sont **portables** avec la base de donn√©es et b√©n√©ficient du contexte transactionnel SQL.

### Events vs Alternatives

| M√©thode | Avantages | Inconv√©nients |
|---------|-----------|---------------|
| **Events MariaDB** | Portable, transactionnel, int√©gr√© | Limit√© au serveur DB |
| **Cron syst√®me** | Flexible, peut ex√©cuter scripts | Externe, d√©pendance OS |
| **Application scheduler** | Contr√¥le total, logs centralis√©s | Complexit√©, d√©pendance app |

---

## Event Scheduler : Activation et configuration

### V√©rification du status

```sql
-- V√©rifier si l'event scheduler est actif
SHOW VARIABLES LIKE 'event_scheduler';

-- R√©sultat :
-- +------------------+-------+
-- | Variable_name    | Value |
-- +------------------+-------+
-- | event_scheduler  | ON    |
-- +------------------+-------+
```

**Valeurs possibles** :
- `ON` : Event scheduler actif
- `OFF` : Event scheduler d√©sactiv√©
- `DISABLED` : Event scheduler d√©sactiv√© au niveau syst√®me (n√©cessite red√©marrage)

### Activation de l'event scheduler

```sql
-- Activation temporaire (session courante)
SET GLOBAL event_scheduler = ON;

-- V√©rification
SHOW PROCESSLIST;
-- On doit voir un thread "event_scheduler"
```

### Configuration permanente

```ini
# Dans my.cnf ou my.ini
[mysqld]
event_scheduler = ON
```

‚ö†Ô∏è **Important** : Sans event scheduler actif, les events ne s'ex√©cuteront **jamais**, m√™me s'ils sont cr√©√©s et activ√©s.

---

## Syntaxe de base CREATE EVENT

### Structure g√©n√©rale

```sql
CREATE [OR REPLACE]
    [DEFINER = utilisateur]
    EVENT [IF NOT EXISTS] nom_event
    ON SCHEDULE planification
    [ON COMPLETION [NOT] PRESERVE]
    [ENABLE | DISABLE | DISABLE ON SLAVE]
    [COMMENT 'commentaire']
DO
    instruction_sql;
```

### √âl√©ments constitutifs

**ON SCHEDULE** : D√©finit quand et comment l'event s'ex√©cute
- `AT` : Ex√©cution unique √† une date/heure pr√©cise
- `EVERY` : Ex√©cution r√©currente selon un intervalle

**ON COMPLETION** :
- `PRESERVE` : L'event reste apr√®s ex√©cution (d√©faut pour EVERY)
- `NOT PRESERVE` : L'event est supprim√© apr√®s ex√©cution (d√©faut pour AT)

**ENABLE/DISABLE** :
- `ENABLE` : Event actif (d√©faut)
- `DISABLE` : Event inactif
- `DISABLE ON SLAVE` : D√©sactiv√© sur les replicas

### Exemple minimal

```sql
DELIMITER //

-- Event simple s'ex√©cutant toutes les heures
CREATE EVENT purge_logs_temp
ON SCHEDULE EVERY 1 HOUR
DO
BEGIN
    DELETE FROM logs_temporaires
    WHERE date_log < DATE_SUB(NOW(), INTERVAL 24 HOUR);
END//

DELIMITER ;
```

---

## Planification avec AT (ex√©cution unique)

### Syntaxe AT

```sql
AT timestamp [+ INTERVAL interval]
```

### Exemple 1 : Ex√©cution √† une date/heure pr√©cise

```sql
DELIMITER //

-- Event s'ex√©cutant le 31 d√©cembre 2025 √† minuit
CREATE EVENT rapport_annuel_2025
ON SCHEDULE AT '2025-12-31 00:00:00'
ON COMPLETION NOT PRESERVE  -- Supprim√© apr√®s ex√©cution
DO
BEGIN
    -- G√©n√©ration du rapport annuel
    INSERT INTO rapports_annuels (annee, ca_total, nb_commandes)
    SELECT
        2025,
        SUM(montant_total),
        COUNT(*)
    FROM commandes
    WHERE YEAR(date_commande) = 2025;

    -- Notification
    INSERT INTO notifications (type, message, date_envoi)
    VALUES ('RAPPORT', 'Rapport annuel 2025 g√©n√©r√©', NOW());
END//

DELIMITER ;
```

### Exemple 2 : Ex√©cution relative (dans X temps)

```sql
DELIMITER //

-- Event s'ex√©cutant dans 30 minutes
CREATE EVENT rappel_reunion
ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 30 MINUTE
ON COMPLETION NOT PRESERVE
DO
BEGIN
    INSERT INTO notifications (
        type,
        destinataire,
        message,
        date_envoi
    )
    SELECT
        'RAPPEL',
        email,
        CONCAT('R√©union dans 30 minutes : ', titre),
        NOW()
    FROM reunions r
    INNER JOIN participants p ON r.id = p.reunion_id
    WHERE r.date_debut BETWEEN NOW() AND NOW() + INTERVAL 1 HOUR;
END//

DELIMITER ;
```

### Exemple 3 : Planification avec calcul

```sql
DELIMITER //

-- Event s'ex√©cutant le premier jour du mois prochain
CREATE EVENT archivage_mensuel
ON SCHEDULE AT DATE_ADD(
    DATE_FORMAT(CURDATE(), '%Y-%m-01'),
    INTERVAL 1 MONTH
)
DO
BEGIN
    -- Archivage des donn√©es du mois pr√©c√©dent
    INSERT INTO commandes_archives
    SELECT * FROM commandes
    WHERE
        YEAR(date_commande) = YEAR(DATE_SUB(NOW(), INTERVAL 1 MONTH))
        AND MONTH(date_commande) = MONTH(DATE_SUB(NOW(), INTERVAL 1 MONTH));

    -- Suppression des donn√©es archiv√©es
    DELETE FROM commandes
    WHERE
        YEAR(date_commande) = YEAR(DATE_SUB(NOW(), INTERVAL 1 MONTH))
        AND MONTH(date_commande) = MONTH(DATE_SUB(NOW(), INTERVAL 1 MONTH));
END//

DELIMITER ;
```

üí° **Astuce** : Les events AT avec `NOT PRESERVE` sont automatiquement supprim√©s apr√®s ex√©cution, id√©al pour les t√¢ches ponctuelles.

---

## Planification avec EVERY (ex√©cution r√©currente)

### Syntaxe EVERY

```sql
EVERY intervalle [STARTS timestamp] [ENDS timestamp]
```

**Intervalles disponibles** :
- `SECOND`, `MINUTE`, `HOUR`
- `DAY`, `WEEK`, `MONTH`, `QUARTER`, `YEAR`
- Combinaisons : `'1:30' HOUR_MINUTE`, `'2 10' DAY_HOUR`

### Exemple 1 : Intervalle simple

```sql
DELIMITER //

-- Event s'ex√©cutant toutes les 5 minutes
CREATE EVENT purge_sessions_expirees
ON SCHEDULE EVERY 5 MINUTE
DO
BEGIN
    DELETE FROM sessions
    WHERE last_activity < DATE_SUB(NOW(), INTERVAL 30 MINUTE);

    -- Log du nettoyage
    INSERT INTO logs_maintenance (
        action,
        nb_lignes_supprimees,
        date_execution
    ) VALUES (
        'PURGE_SESSIONS',
        ROW_COUNT(),
        NOW()
    );
END//

DELIMITER ;
```

### Exemple 2 : Avec date de d√©but (STARTS)

```sql
DELIMITER //

-- Event d√©marrant demain √† 2h du matin, puis toutes les 24h
CREATE EVENT sauvegarde_quotidienne
ON SCHEDULE EVERY 1 DAY
STARTS TIMESTAMP(CURDATE() + INTERVAL 1 DAY, '02:00:00')
COMMENT 'Sauvegarde quotidienne √† 2h du matin'
DO
BEGIN
    -- Optimisation des tables
    OPTIMIZE TABLE commandes, clients, produits;

    -- Mise √† jour des statistiques
    ANALYZE TABLE commandes, clients, produits;

    -- Log
    INSERT INTO logs_maintenance (action, date_execution)
    VALUES ('MAINTENANCE_QUOTIDIENNE', NOW());
END//

DELIMITER ;
```

### Exemple 3 : Avec date de d√©but et de fin

```sql
DELIMITER //

-- Event actif du 1er janvier au 31 mars 2026, toutes les heures
CREATE EVENT campagne_hiver_2026
ON SCHEDULE EVERY 1 HOUR
STARTS '2026-01-01 00:00:00'
ENDS '2026-03-31 23:59:59'
DO
BEGIN
    -- Mise √† jour des promotions actives
    UPDATE produits
    SET remise_active = TRUE,
        remise_pct = 20
    WHERE categorie = 'HIVER'
      AND stock_disponible > 0;
END//

DELIMITER ;
```

### Exemple 4 : Intervalles complexes

```sql
DELIMITER //

-- Event s'ex√©cutant toutes les 2 heures et 30 minutes
CREATE EVENT verification_stock
ON SCHEDULE EVERY '2:30' HOUR_MINUTE
DO
BEGIN
    -- Alerte pour stock faible
    INSERT INTO alertes_stock (produit_id, stock_actuel, seuil_critique)
    SELECT
        id,
        stock_disponible,
        seuil_alerte
    FROM produits
    WHERE stock_disponible <= seuil_alerte
      AND actif = TRUE;
END//

-- Event s'ex√©cutant tous les 2 jours √† 10h
CREATE EVENT rapport_bihebdomadaire
ON SCHEDULE EVERY '2 10:00:00' DAY_SECOND
DO
BEGIN
    CALL generer_rapport_ventes();
END//

DELIMITER ;
```

---

## Patterns de planification courants

### Pattern 1 : Maintenance nocturne quotidienne

```sql
DELIMITER //

CREATE EVENT maintenance_nocturne
ON SCHEDULE EVERY 1 DAY
STARTS TIMESTAMP(CURDATE() + INTERVAL 1 DAY, '03:00:00')
COMMENT 'Maintenance quotidienne √† 3h du matin'
DO
BEGIN
    -- 1. Purge des anciennes donn√©es
    DELETE FROM logs_application
    WHERE date_log < DATE_SUB(NOW(), INTERVAL 90 DAY);

    DELETE FROM sessions
    WHERE last_activity < DATE_SUB(NOW(), INTERVAL 7 DAY);

    -- 2. Optimisation des tables
    OPTIMIZE TABLE commandes;
    OPTIMIZE TABLE clients;
    OPTIMIZE TABLE produits;

    -- 3. Mise √† jour des statistiques
    ANALYZE TABLE commandes;
    ANALYZE TABLE clients;

    -- 4. V√©rification de l'int√©grit√©
    CHECK TABLE commandes;
    CHECK TABLE clients;

    -- 5. Log de la maintenance
    INSERT INTO logs_maintenance (
        type,
        tables_traitees,
        duree_secondes,
        date_execution
    ) VALUES (
        'MAINTENANCE_NOCTURNE',
        'commandes,clients,produits,logs,sessions',
        TIMESTAMPDIFF(SECOND, @start_time, NOW()),
        NOW()
    );
END//

DELIMITER ;
```

### Pattern 2 : Calcul de statistiques hebdomadaire

```sql
DELIMITER //

-- Event s'ex√©cutant tous les lundis √† 1h du matin
CREATE EVENT stats_hebdomadaires
ON SCHEDULE EVERY 1 WEEK
STARTS TIMESTAMP(
    CURDATE() + INTERVAL (8 - DAYOFWEEK(CURDATE())) % 7 DAY,
    '01:00:00'
)
COMMENT 'Statistiques hebdomadaires - Chaque lundi √† 1h'
DO
BEGIN
    DECLARE v_semaine INT;
    DECLARE v_annee INT;

    -- Semaine et ann√©e (ISO 8601)
    SET v_semaine = WEEK(DATE_SUB(CURDATE(), INTERVAL 1 WEEK), 3);
    SET v_annee = YEAR(DATE_SUB(CURDATE(), INTERVAL 1 WEEK));

    -- Insertion des statistiques
    INSERT INTO stats_hebdomadaires (
        annee,
        semaine,
        nb_commandes,
        ca_total,
        panier_moyen,
        nb_nouveaux_clients,
        date_calcul
    )
    SELECT
        v_annee,
        v_semaine,
        COUNT(DISTINCT c.id),
        SUM(c.montant_total),
        AVG(c.montant_total),
        COUNT(DISTINCT cl.id),
        NOW()
    FROM commandes c
    LEFT JOIN clients cl ON c.client_id = cl.id
        AND DATE(cl.date_creation) BETWEEN
            DATE_SUB(CURDATE(), INTERVAL 1 WEEK)
            AND CURDATE()
    WHERE
        DATE(c.date_commande) BETWEEN
            DATE_SUB(CURDATE(), INTERVAL 1 WEEK)
            AND CURDATE();
END//

DELIMITER ;
```

### Pattern 3 : Purge progressive (par batch)

```sql
DELIMITER //

-- Event s'ex√©cutant toutes les 10 minutes, purge par lots
CREATE EVENT purge_progressive_logs
ON SCHEDULE EVERY 10 MINUTE
DO
BEGIN
    DECLARE v_nb_supprime INT DEFAULT 0;

    -- Suppression par lots de 1000 lignes pour √©viter locks longs
    DELETE FROM logs_application
    WHERE date_log < DATE_SUB(NOW(), INTERVAL 180 DAY)
    LIMIT 1000;

    SET v_nb_supprime = ROW_COUNT();

    -- Log si suppressions effectu√©es
    IF v_nb_supprime > 0 THEN
        INSERT INTO logs_maintenance (
            action,
            nb_lignes_traitees,
            date_execution
        ) VALUES (
            'PURGE_LOGS_BATCH',
            v_nb_supprime,
            NOW()
        );
    END IF;
END//

DELIMITER ;
```

### Pattern 4 : Monitoring avec alertes

```sql
DELIMITER //

-- Event de monitoring toutes les 5 minutes
CREATE EVENT monitoring_systeme
ON SCHEDULE EVERY 5 MINUTE
DO
BEGIN
    -- 1. V√©rification taille base de donn√©es
    DECLARE v_taille_gb DECIMAL(10,2);
    DECLARE v_seuil_gb DECIMAL(10,2) DEFAULT 100.0;

    SELECT
        ROUND(SUM(DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024 / 1024, 2)
    INTO v_taille_gb
    FROM information_schema.TABLES
    WHERE TABLE_SCHEMA = DATABASE();

    IF v_taille_gb > v_seuil_gb THEN
        INSERT INTO alertes_systeme (
            type,
            severite,
            message,
            valeur_actuelle,
            seuil,
            date_alerte
        ) VALUES (
            'TAILLE_DB',
            'WARNING',
            'Taille de la base de donn√©es √©lev√©e',
            v_taille_gb,
            v_seuil_gb,
            NOW()
        );
    END IF;

    -- 2. V√©rification connexions actives
    DECLARE v_nb_connexions INT;
    DECLARE v_seuil_connexions INT DEFAULT 100;

    SELECT COUNT(*) INTO v_nb_connexions
    FROM information_schema.PROCESSLIST;

    IF v_nb_connexions > v_seuil_connexions THEN
        INSERT INTO alertes_systeme (
            type,
            severite,
            message,
            valeur_actuelle,
            seuil,
            date_alerte
        ) VALUES (
            'NB_CONNEXIONS',
            'CRITICAL',
            'Nombre de connexions √©lev√©',
            v_nb_connexions,
            v_seuil_connexions,
            NOW()
        );
    END IF;

    -- 3. V√©rification tables fragment√©es
    INSERT INTO alertes_systeme (
        type,
        severite,
        message,
        details,
        date_alerte
    )
    SELECT
        'FRAGMENTATION',
        'INFO',
        CONCAT('Table ', TABLE_NAME, ' fragment√©e'),
        CONCAT('Data_free: ', ROUND(DATA_FREE / 1024 / 1024, 2), ' MB'),
        NOW()
    FROM information_schema.TABLES
    WHERE
        TABLE_SCHEMA = DATABASE()
        AND DATA_FREE > 100 * 1024 * 1024  -- Plus de 100MB de fragmentation
        AND ENGINE = 'InnoDB';
END//

DELIMITER ;
```

### Pattern 5 : G√©n√©ration de rapports mensuels

```sql
DELIMITER //

-- Event s'ex√©cutant le 1er de chaque mois √† minuit
CREATE EVENT rapport_mensuel
ON SCHEDULE EVERY 1 MONTH
STARTS TIMESTAMP(
    DATE_FORMAT(DATE_ADD(CURDATE(), INTERVAL 1 MONTH), '%Y-%m-01'),
    '00:00:00'
)
COMMENT 'Rapport mensuel - 1er du mois √† minuit'
DO
BEGIN
    DECLARE v_mois INT;
    DECLARE v_annee INT;

    -- Mois et ann√©e pr√©c√©dents
    SET v_mois = MONTH(DATE_SUB(CURDATE(), INTERVAL 1 MONTH));
    SET v_annee = YEAR(DATE_SUB(CURDATE(), INTERVAL 1 MONTH));

    -- G√©n√©ration du rapport
    INSERT INTO rapports_mensuels (
        annee,
        mois,
        nb_commandes,
        ca_total,
        nb_nouveaux_clients,
        nb_produits_vendus,
        top_5_produits,
        date_generation
    )
    SELECT
        v_annee,
        v_mois,
        COUNT(DISTINCT c.id),
        SUM(c.montant_total),
        COUNT(DISTINCT cl.id),
        SUM(lc.quantite),
        (
            SELECT JSON_ARRAYAGG(
                JSON_OBJECT(
                    'produit_id', produit_id,
                    'nom', nom,
                    'quantite_vendue', total_vendu
                )
            )
            FROM (
                SELECT
                    p.id AS produit_id,
                    p.nom,
                    SUM(lc2.quantite) AS total_vendu
                FROM lignes_commande lc2
                INNER JOIN produits p ON lc2.produit_id = p.id
                INNER JOIN commandes c2 ON lc2.commande_id = c2.id
                WHERE
                    YEAR(c2.date_commande) = v_annee
                    AND MONTH(c2.date_commande) = v_mois
                GROUP BY p.id, p.nom
                ORDER BY total_vendu DESC
                LIMIT 5
            ) top_produits
        ),
        NOW()
    FROM commandes c
    LEFT JOIN clients cl ON c.client_id = cl.id
        AND YEAR(cl.date_creation) = v_annee
        AND MONTH(cl.date_creation) = v_mois
    LEFT JOIN lignes_commande lc ON c.id = lc.commande_id
    WHERE
        YEAR(c.date_commande) = v_annee
        AND MONTH(c.date_commande) = v_mois;

    -- Notification de g√©n√©ration
    INSERT INTO notifications (
        type,
        destinataire,
        message,
        date_envoi
    ) VALUES (
        'RAPPORT',
        'admin@example.com',
        CONCAT('Rapport mensuel ', v_mois, '/', v_annee, ' g√©n√©r√©'),
        NOW()
    );
END//

DELIMITER ;
```

---

## Gestion du cycle de vie des events

### Consultation des events existants

```sql
-- Lister tous les events de la base courante
SHOW EVENTS;

-- Lister tous les events (toutes bases)
SHOW EVENTS FROM ma_base;

-- Informations d√©taill√©es
SELECT
    EVENT_NAME,
    EVENT_DEFINITION,
    INTERVAL_VALUE,
    INTERVAL_FIELD,
    STARTS,
    ENDS,
    STATUS,
    ON_COMPLETION,
    LAST_EXECUTED,
    EVENT_COMMENT
FROM information_schema.EVENTS
WHERE EVENT_SCHEMA = DATABASE();
```

### Afficher la d√©finition d'un event

```sql
-- Voir le CREATE EVENT complet
SHOW CREATE EVENT nom_event\G
```

### Modification d'un event existant

```sql
-- Modifier la planification
ALTER EVENT purge_sessions_expirees
ON SCHEDULE EVERY 10 MINUTE;

-- Modifier le corps de l'event
ALTER EVENT purge_sessions_expirees
DO
BEGIN
    DELETE FROM sessions
    WHERE last_activity < DATE_SUB(NOW(), INTERVAL 1 HOUR);
END;

-- Renommer un event
ALTER EVENT ancien_nom
RENAME TO nouveau_nom;

-- Modifier plusieurs propri√©t√©s
ALTER EVENT maintenance_nocturne
ON SCHEDULE EVERY 1 DAY
STARTS '2026-01-01 03:00:00'
ENABLE
COMMENT 'Maintenance quotidienne mise √† jour';
```

### Activation et d√©sactivation

```sql
-- D√©sactiver temporairement un event
ALTER EVENT nom_event DISABLE;

-- R√©activer un event
ALTER EVENT nom_event ENABLE;

-- D√©sactiver sur les replicas uniquement
ALTER EVENT nom_event DISABLE ON SLAVE;
```

### Suppression d'un event

```sql
-- Suppression simple
DROP EVENT nom_event;

-- Suppression s√©curis√©e
DROP EVENT IF EXISTS nom_event;
```

---

## Options avanc√©es et fonctionnalit√©s

### ON COMPLETION PRESERVE vs NOT PRESERVE

```sql
DELIMITER //

-- Event AT avec PRESERVE : reste apr√®s ex√©cution
CREATE EVENT backup_avant_maintenance
ON SCHEDULE AT '2026-01-01 00:00:00'
ON COMPLETION PRESERVE  -- Reste dans la base apr√®s ex√©cution
DO
BEGIN
    CALL procedure_backup_complet();
END//

-- Event AT avec NOT PRESERVE : supprim√© apr√®s ex√©cution
CREATE EVENT tache_ponctuelle
ON SCHEDULE AT '2026-01-01 00:00:00'
ON COMPLETION NOT PRESERVE  -- Supprim√© automatiquement apr√®s
DO
BEGIN
    UPDATE produits SET promotion = FALSE;
END//

DELIMITER ;
```

üí° **D√©faut** :
- `AT` ‚Üí `NOT PRESERVE` (auto-suppression)
- `EVERY` ‚Üí `PRESERVE` (persiste)

### DEFINER : Contexte d'ex√©cution

```sql
DELIMITER //

-- Event s'ex√©cutant avec les privil√®ges de l'utilisateur sp√©cifi√©
CREATE DEFINER = 'admin'@'localhost'
EVENT maintenance_admin
ON SCHEDULE EVERY 1 DAY
DO
BEGIN
    -- S'ex√©cute avec les privil√®ges de admin@localhost
    -- Peut acc√©der √† des tables restreintes
    OPTIMIZE TABLE tables_sensibles;
END//

DELIMITER ;
```

### Event avec gestion d'erreurs

```sql
DELIMITER //

CREATE EVENT event_avec_gestion_erreurs
ON SCHEDULE EVERY 1 HOUR
DO
BEGIN
    -- Handler pour capturer les erreurs
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        -- Log de l'erreur
        INSERT INTO logs_erreurs_events (
            event_name,
            message_erreur,
            date_erreur
        ) VALUES (
            'event_avec_gestion_erreurs',
            'Erreur lors de l\'ex√©cution',
            NOW()
        );
    END;

    -- Code de l'event
    DELETE FROM table_temporaire
    WHERE date_expiration < NOW();

    -- Log de succ√®s
    INSERT INTO logs_events (
        event_name,
        statut,
        date_execution
    ) VALUES (
        'event_avec_gestion_erreurs',
        'SUCCESS',
        NOW()
    );
END//

DELIMITER ;
```

### Event appelant une proc√©dure stock√©e

```sql
DELIMITER //

-- Proc√©dure de maintenance
CREATE PROCEDURE maintenance_hebdomadaire()
BEGIN
    -- Logique de maintenance complexe
    OPTIMIZE TABLE commandes;
    ANALYZE TABLE clients;
    CALL calculer_statistiques();
END//

-- Event appelant la proc√©dure
CREATE EVENT declencheur_maintenance
ON SCHEDULE EVERY 1 WEEK
STARTS TIMESTAMP(CURDATE() + INTERVAL 7 DAY, '02:00:00')
DO
BEGIN
    CALL maintenance_hebdomadaire();
END//

DELIMITER ;
```

üí° **Bonne pratique** : D√©l√©guer la logique complexe √† des proc√©dures stock√©es, les events servent de d√©clencheurs.

---

## Bonnes pratiques de gestion des events

### 1. Nommage coh√©rent

```sql
-- ‚úÖ BON : Noms descriptifs avec pr√©fixe
CREATE EVENT evt_purge_logs_quotidien ...
CREATE EVENT evt_stats_hebdomadaires ...
CREATE EVENT evt_maintenance_mensuelle ...

-- ‚ùå MAUVAIS : Noms cryptiques
CREATE EVENT e1 ...
CREATE EVENT job ...
CREATE EVENT event_temp ...
```

**Convention recommand√©e** :
- Pr√©fixe `evt_` pour identifier facilement les events
- Verbe d'action : `purge_`, `calcul_`, `sauvegarde_`
- Fr√©quence : `quotidien`, `hebdomadaire`, `mensuel`

### 2. Documentation avec COMMENT

```sql
CREATE EVENT evt_archivage_commandes
ON SCHEDULE EVERY 1 MONTH
STARTS '2026-01-01 00:00:00'
COMMENT 'Archive mensuelle des commandes de plus de 2 ans - Cr√©√© le 2025-12-12 par DBA'
DO
BEGIN
    -- ...
END;
```

### 3. Gestion des logs et tra√ßabilit√©

```sql
DELIMITER //

CREATE EVENT evt_maintenance_tracee
ON SCHEDULE EVERY 1 DAY
DO
BEGIN
    DECLARE v_start DATETIME;
    DECLARE v_nb_lignes INT;

    SET v_start = NOW();

    -- Op√©ration
    DELETE FROM logs_application
    WHERE date_log < DATE_SUB(NOW(), INTERVAL 90 DAY);

    SET v_nb_lignes = ROW_COUNT();

    -- Log d√©taill√©
    INSERT INTO historique_events (
        event_name,
        date_execution,
        duree_ms,
        nb_lignes_traitees,
        statut
    ) VALUES (
        'evt_maintenance_tracee',
        v_start,
        TIMESTAMPDIFF(MICROSECOND, v_start, NOW()) / 1000,
        v_nb_lignes,
        'SUCCESS'
    );
END//

DELIMITER ;
```

### 4. √âviter les events trop fr√©quents

```sql
-- ‚ùå MAUVAIS : Event chaque seconde (charge excessive)
CREATE EVENT trop_frequent
ON SCHEDULE EVERY 1 SECOND
DO ...

-- ‚úÖ BON : Minimum 1 minute, id√©alement 5+ minutes
CREATE EVENT frequence_raisonnable
ON SCHEDULE EVERY 5 MINUTE
DO ...
```

üí° **R√®gle empirique** : Event < 1 minute = envisager une autre solution (triggers, application).

### 5. Limiter la dur√©e d'ex√©cution

```sql
DELIMITER //

CREATE EVENT evt_purge_avec_limite
ON SCHEDULE EVERY 10 MINUTE
DO
BEGIN
    -- Purge par lots pour limiter la dur√©e
    DELETE FROM logs_application
    WHERE date_log < DATE_SUB(NOW(), INTERVAL 90 DAY)
    LIMIT 1000;  -- ‚úÖ Limite pour √©viter locks longs
END//

DELIMITER ;
```

### 6. Tester en mode DISABLE d'abord

```sql
-- Cr√©er l'event d√©sactiv√© pour tests
CREATE EVENT evt_nouveau_test
ON SCHEDULE EVERY 1 HOUR
DISABLE  -- ‚úÖ D√©sactiv√© initialement
DO
BEGIN
    -- Nouvelle logique √† tester
END;

-- Tester manuellement
CALL test_logique_event();

-- Activer apr√®s validation
ALTER EVENT evt_nouveau_test ENABLE;
```

### 7. Gestion des √©v√©nements sur replicas

```sql
-- Event √† ne pas ex√©cuter sur les replicas
CREATE EVENT evt_master_only
ON SCHEDULE EVERY 1 DAY
DISABLE ON SLAVE  -- ‚úÖ D√©sactiv√© sur replicas
DO
BEGIN
    -- Op√©ration lourde uniquement sur master
END;
```

---

## Monitoring et troubleshooting

### V√©rification de l'ex√©cution des events

```sql
-- Derni√®re ex√©cution et prochaine planification
SELECT
    EVENT_NAME,
    LAST_EXECUTED,
    INTERVAL_VALUE,
    INTERVAL_FIELD,
    STATUS,
    STARTS,
    ENDS
FROM information_schema.EVENTS
WHERE EVENT_SCHEMA = DATABASE()
ORDER BY LAST_EXECUTED DESC;
```

### D√©sactiver temporairement tous les events

```sql
-- Pour maintenance globale
SET GLOBAL event_scheduler = OFF;

-- R√©activer apr√®s maintenance
SET GLOBAL event_scheduler = ON;
```

### Log des erreurs d'events

Les erreurs d'events sont enregistr√©es dans le **error log** de MariaDB.

```bash
# Recherche dans les logs
grep -i "event" /var/log/mysql/error.log
tail -f /var/log/mysql/error.log | grep -i event
```

### Table de monitoring personnalis√©e

```sql
CREATE TABLE monitoring_events (
    id INT PRIMARY KEY AUTO_INCREMENT,
    event_name VARCHAR(64) NOT NULL,
    date_execution DATETIME NOT NULL,
    duree_ms INT,
    statut VARCHAR(20),
    nb_lignes_traitees INT,
    message TEXT,
    INDEX idx_event_date (event_name, date_execution)
);

-- Utilisation dans les events
INSERT INTO monitoring_events (event_name, date_execution, statut)
VALUES ('nom_event', NOW(), 'SUCCESS');
```

---

## Limites et restrictions

### Limitations techniques

- **Pr√©cision** : Minimum 1 seconde (pas de millisecondes)
- **Ex√©cution s√©quentielle** : Un event ne peut pas s'ex√©cuter si l'instance pr√©c√©dente est toujours en cours
- **Pas de CALL dans EVERY** : Syntaxe limit√©e dans certaines versions
- **Timezone** : Events bas√©s sur le timezone du serveur

### Ce que les events ne peuvent PAS faire

```sql
-- ‚ùå Ne peut pas utiliser LOAD DATA INFILE
-- ‚ùå Ne peut pas cr√©er d'autres events dynamiquement
-- ‚ùå Ne peut pas modifier le event scheduler
-- ‚ùå Ne peut pas utiliser PREPARE (requ√™tes pr√©par√©es)
```

---

## ‚úÖ Points cl√©s √† retenir

- **Event scheduler** : Doit √™tre activ√© (`SET GLOBAL event_scheduler = ON`)
- **AT** : Ex√©cution unique √† une date/heure pr√©cise
- **EVERY** : Ex√©cution r√©currente selon un intervalle
- **STARTS/ENDS** : D√©finir une fen√™tre temporelle d'activit√©
- **PRESERVE** : Event reste apr√®s ex√©cution (d√©faut EVERY)
- **NOT PRESERVE** : Event supprim√© apr√®s ex√©cution (d√©faut AT)
- **DISABLE** : D√©sactiver temporairement sans supprimer
- **DEFINER** : Contexte d'ex√©cution (privil√®ges)
- **Logs** : Tracer l'ex√©cution dans des tables d√©di√©es
- **Performance** : √âviter events < 1 minute, purger par lots

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation officielle MariaDB - CREATE EVENT](https://mariadb.com/kb/en/create-event/)
- [üìñ Event Scheduler](https://mariadb.com/kb/en/events/)
- [üìñ ALTER EVENT](https://mariadb.com/kb/en/alter-event/)
- [üìñ DROP EVENT](https://mariadb.com/kb/en/drop-event/)
- [üìñ INFORMATION_SCHEMA.EVENTS](https://mariadb.com/kb/en/information-schema-events-table/)
- [üí° Blog : Automating Tasks with Events](https://mariadb.com/resources/blog/)

---

## ‚û°Ô∏è Section suivante

**[8.4.2 Event Scheduler](./04.2-event-scheduler.md)** : Approfondissez la configuration et l'administration de l'Event Scheduler pour un contr√¥le total de vos t√¢ches automatis√©es.

---


‚è≠Ô∏è [Event Scheduler](/08-programmation-cote-serveur/04.2-event-scheduler.md)
