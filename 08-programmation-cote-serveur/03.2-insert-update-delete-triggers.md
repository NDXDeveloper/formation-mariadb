üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.3.2 INSERT, UPDATE, DELETE triggers

> **Niveau** : Interm√©diaire √† Avanc√©
> **Dur√©e estim√©e** : 3 heures
> **Pr√©requis** : Section 8.3.1 (BEFORE et AFTER), compr√©hension des variables OLD/NEW

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Ma√Ætriser les sp√©cificit√©s de chaque type de trigger (INSERT, UPDATE, DELETE)
- Impl√©menter des patterns avanc√©s pour chaque op√©ration
- Combiner plusieurs triggers sur une m√™me table de mani√®re coh√©rente
- G√©rer les cas complexes (modifications conditionnelles, cascades)
- Appliquer les bonnes pratiques sp√©cifiques √† chaque type d'√©v√©nement
- √âviter les pi√®ges courants li√©s aux triggers

---

## Introduction

Chaque type d'√©v√©nement (INSERT, UPDATE, DELETE) pr√©sente des **caract√©ristiques et cas d'usage sp√©cifiques**. Comprendre ces nuances permet de cr√©er des triggers efficaces et maintenables.

### R√©capitulatif des disponibilit√©s OLD/NEW

| Type de trigger | OLD disponible | NEW disponible | Modification NEW (BEFORE) |
|-----------------|----------------|----------------|---------------------------|
| **INSERT** | ‚ùå Non | ‚úÖ Oui | ‚úÖ Oui |
| **UPDATE** | ‚úÖ Oui | ‚úÖ Oui | ‚úÖ Oui |
| **DELETE** | ‚úÖ Oui | ‚ùå Non | N/A |

üí° **Principe directeur** :
- **INSERT** : Transformation et validation des nouvelles donn√©es
- **UPDATE** : Comparaison et gestion des changements
- **DELETE** : Archivage et nettoyage des donn√©es supprim√©es

---

## INSERT Triggers

### Caract√©ristiques sp√©cifiques

Les triggers INSERT sont d√©clench√©s lors de l'**ajout de nouvelles lignes**. Ils ont acc√®s uniquement √† **NEW** (les valeurs √† ins√©rer).

**Cas d'usage typiques** :
- Validation des donn√©es avant insertion
- Normalisation et formatage automatique
- G√©n√©ration de valeurs d√©riv√©es
- Enrichissement automatique (timestamps, m√©tadonn√©es)
- V√©rification de contraintes m√©tier complexes

### Pattern 1 : G√©n√©ration d'identifiants m√©tier

```sql
DELIMITER //

-- Table de commandes
CREATE TABLE IF NOT EXISTS commandes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    reference VARCHAR(50) UNIQUE NOT NULL,
    client_id INT NOT NULL,
    montant_total DECIMAL(10,2) NOT NULL,
    statut VARCHAR(20) DEFAULT 'BROUILLON',
    date_creation DATETIME DEFAULT NOW(),
    FOREIGN KEY (client_id) REFERENCES clients(id)
)//

-- BEFORE INSERT : G√©n√©ration automatique de la r√©f√©rence
CREATE TRIGGER before_insert_commande_reference
BEFORE INSERT ON commandes
FOR EACH ROW
BEGIN
    /*
     * G√©n√®re une r√©f√©rence unique au format :
     * CMD-YYYYMMDD-XXXXX
     * o√π XXXXX est un compteur s√©quentiel du jour
     */

    DECLARE v_date_format VARCHAR(8);
    DECLARE v_compteur INT;

    -- Format date du jour
    SET v_date_format = DATE_FORMAT(CURDATE(), '%Y%m%d');

    -- R√©cup√©ration du dernier compteur du jour
    SELECT COALESCE(
        MAX(CAST(SUBSTRING(reference, -5) AS UNSIGNED)),
        0
    ) INTO v_compteur
    FROM commandes
    WHERE DATE(date_creation) = CURDATE()
      AND reference LIKE CONCAT('CMD-', v_date_format, '-%');

    -- Incr√©mentation
    SET v_compteur = v_compteur + 1;

    -- Construction de la r√©f√©rence
    SET NEW.reference = CONCAT(
        'CMD-',
        v_date_format,
        '-',
        LPAD(v_compteur, 5, '0')
    );
END//

-- AFTER INSERT : Audit de cr√©ation
CREATE TRIGGER after_insert_commande_audit
AFTER INSERT ON commandes
FOR EACH ROW
BEGIN
    INSERT INTO audit_commandes (
        operation,
        commande_id,
        reference,
        montant,
        utilisateur,
        date_operation
    ) VALUES (
        'CREATE',
        NEW.id,           -- ‚úÖ ID disponible dans AFTER
        NEW.reference,
        NEW.montant_total,
        USER(),
        NOW()
    );
END//

DELIMITER ;

-- Test
INSERT INTO commandes (client_id, montant_total)
VALUES (1, 250.00);
-- R√©sultat : reference = 'CMD-20251212-00001'

INSERT INTO commandes (client_id, montant_total)
VALUES (2, 150.00);
-- R√©sultat : reference = 'CMD-20251212-00002'
```

**Points cl√©s** :
- BEFORE g√©n√®re la r√©f√©rence **avant** l'insertion
- Le compteur est calcul√© dynamiquement pour √©viter les conflits
- AFTER enregistre l'audit avec l'ID auto-g√©n√©r√©

### Pattern 2 : Validation et enrichissement de donn√©es

```sql
DELIMITER //

-- Table d'utilisateurs
CREATE TABLE IF NOT EXISTS utilisateurs (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    nom VARCHAR(100),
    prenom VARCHAR(100),
    nom_complet VARCHAR(200),  -- Calcul√© automatiquement
    email_verifie BOOLEAN DEFAULT FALSE,
    token_verification VARCHAR(64),
    date_inscription DATETIME,
    derniere_connexion DATETIME,
    nb_connexions INT DEFAULT 0,
    actif BOOLEAN DEFAULT TRUE
)//

-- BEFORE INSERT : Validation et enrichissement
CREATE TRIGGER before_insert_utilisateur
BEFORE INSERT ON utilisateurs
FOR EACH ROW
BEGIN
    -- Validation 1 : Username alphanum√©rique uniquement
    IF NEW.username NOT REGEXP '^[a-zA-Z0-9_-]+$' THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Username invalide : alphanum√©rique uniquement';
    END IF;

    -- Validation 2 : Username longueur minimum
    IF LENGTH(NEW.username) < 3 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Username trop court (minimum 3 caract√®res)';
    END IF;

    -- Validation 3 : Email format valide
    IF NEW.email NOT LIKE '%@%.%' THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Format email invalide';
    END IF;

    -- Validation 4 : Password hash v√©rifi√© (doit √™tre d√©j√† hash√©)
    IF LENGTH(NEW.password_hash) < 32 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Le mot de passe doit √™tre hash√©';
    END IF;

    -- Normalisation 1 : Minuscules pour username et email
    SET NEW.username = LOWER(TRIM(NEW.username));
    SET NEW.email = LOWER(TRIM(NEW.email));

    -- Normalisation 2 : Nom/Pr√©nom format√©s
    IF NEW.nom IS NOT NULL THEN
        SET NEW.nom = UPPER(TRIM(NEW.nom));
    END IF;

    IF NEW.prenom IS NOT NULL THEN
        SET NEW.prenom = CONCAT(
            UPPER(LEFT(TRIM(NEW.prenom), 1)),
            LOWER(SUBSTRING(TRIM(NEW.prenom), 2))
        );
    END IF;

    -- Enrichissement 1 : Nom complet calcul√©
    SET NEW.nom_complet = CONCAT_WS(' ', NEW.prenom, NEW.nom);

    -- Enrichissement 2 : Token de v√©rification
    SET NEW.token_verification = SHA2(CONCAT(NEW.email, NOW(), RAND()), 256);

    -- Enrichissement 3 : Date d'inscription
    SET NEW.date_inscription = NOW();
END//

-- AFTER INSERT : Notification et statistiques
CREATE TRIGGER after_insert_utilisateur
AFTER INSERT ON utilisateurs
FOR EACH ROW
BEGIN
    -- Enregistrement dans table de statistiques
    INSERT INTO stats_inscriptions (
        utilisateur_id,
        date_inscription,
        source_inscription,
        adresse_ip
    ) VALUES (
        NEW.id,
        NEW.date_inscription,
        @inscription_source,  -- Variable de session
        @inscription_ip       -- Variable de session
    );

    -- Log pour envoi d'email de v√©rification (trait√© par application)
    INSERT INTO queue_emails (
        type,
        destinataire,
        data,
        statut
    ) VALUES (
        'VERIFICATION',
        NEW.email,
        JSON_OBJECT(
            'username', NEW.username,
            'token', NEW.token_verification
        ),
        'PENDING'
    );
END//

DELIMITER ;
```

### Pattern 3 : Initialisation de donn√©es li√©es

```sql
DELIMITER //

-- Table de clients avec donn√©es li√©es
CREATE TABLE IF NOT EXISTS clients (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nom VARCHAR(100) NOT NULL,
    type VARCHAR(20) NOT NULL DEFAULT 'PARTICULIER',  -- PARTICULIER ou PROFESSIONNEL
    date_creation DATETIME DEFAULT NOW()
)//

-- Tables li√©es
CREATE TABLE IF NOT EXISTS portefeuilles (
    client_id INT PRIMARY KEY,
    solde DECIMAL(12,2) DEFAULT 0,
    devise VARCHAR(3) DEFAULT 'EUR',
    FOREIGN KEY (client_id) REFERENCES clients(id) ON DELETE CASCADE
)//

CREATE TABLE IF NOT EXISTS preferences_client (
    client_id INT PRIMARY KEY,
    langue VARCHAR(5) DEFAULT 'fr_FR',
    notifications_email BOOLEAN DEFAULT TRUE,
    notifications_sms BOOLEAN DEFAULT FALSE,
    theme VARCHAR(20) DEFAULT 'light',
    FOREIGN KEY (client_id) REFERENCES clients(id) ON DELETE CASCADE
)//

-- AFTER INSERT : Cr√©ation automatique des donn√©es li√©es
CREATE TRIGGER after_insert_client_init
AFTER INSERT ON clients
FOR EACH ROW
BEGIN
    -- Cr√©ation du portefeuille
    INSERT INTO portefeuilles (client_id, solde, devise)
    VALUES (NEW.id, 0.00, 'EUR');

    -- Cr√©ation des pr√©f√©rences par d√©faut
    INSERT INTO preferences_client (
        client_id,
        langue,
        notifications_email,
        notifications_sms
    ) VALUES (
        NEW.id,
        'fr_FR',
        TRUE,
        CASE
            WHEN NEW.type = 'PROFESSIONNEL' THEN TRUE
            ELSE FALSE
        END  -- SMS activ√© par d√©faut pour pros
    );

    -- Offre de bienvenue pour particuliers
    IF NEW.type = 'PARTICULIER' THEN
        INSERT INTO credits_promo (
            client_id,
            montant,
            motif,
            date_expiration
        ) VALUES (
            NEW.id,
            10.00,
            'Bienvenue',
            DATE_ADD(NOW(), INTERVAL 30 DAY)
        );
    END IF;
END//

DELIMITER ;

-- Test
INSERT INTO clients (nom, type) VALUES ('Dupont SARL', 'PROFESSIONNEL');
-- Cr√©e automatiquement : portefeuille, pr√©f√©rences (avec SMS activ√©)

INSERT INTO clients (nom, type) VALUES ('Martin Jean', 'PARTICULIER');
-- Cr√©e automatiquement : portefeuille, pr√©f√©rences, cr√©dit promo 10‚Ç¨
```

üí° **Avantage** : L'initialisation des donn√©es li√©es est **garantie** et **automatique**, √©vitant les oublis applicatifs.

### Pattern 4 : V√©rification de contraintes m√©tier complexes

```sql
DELIMITER //

-- Table de r√©servations
CREATE TABLE IF NOT EXISTS reservations (
    id INT PRIMARY KEY AUTO_INCREMENT,
    salle_id INT NOT NULL,
    date_debut DATETIME NOT NULL,
    date_fin DATETIME NOT NULL,
    utilisateur_id INT NOT NULL,
    statut VARCHAR(20) DEFAULT 'CONFIRMEE',
    FOREIGN KEY (salle_id) REFERENCES salles(id),
    FOREIGN KEY (utilisateur_id) REFERENCES utilisateurs(id)
)//

-- BEFORE INSERT : V√©rification anti-chevauchement
CREATE TRIGGER before_insert_reservation_validation
BEFORE INSERT ON reservations
FOR EACH ROW
BEGIN
    DECLARE v_nb_conflits INT;

    -- Validation 1 : Date fin apr√®s date d√©but
    IF NEW.date_fin <= NEW.date_debut THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'La date de fin doit √™tre apr√®s la date de d√©but';
    END IF;

    -- Validation 2 : Dur√©e maximum 4 heures
    IF TIMESTAMPDIFF(HOUR, NEW.date_debut, NEW.date_fin) > 4 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Dur√©e maximale : 4 heures';
    END IF;

    -- Validation 3 : Pas de r√©servation dans le pass√©
    IF NEW.date_debut < NOW() THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Impossible de r√©server dans le pass√©';
    END IF;

    -- Validation 4 : Pas de chevauchement avec r√©servations existantes
    SELECT COUNT(*) INTO v_nb_conflits
    FROM reservations
    WHERE
        salle_id = NEW.salle_id
        AND statut IN ('CONFIRMEE', 'EN_COURS')
        AND (
            -- Cas 1 : Nouvelle r√©servation commence pendant une existante
            (NEW.date_debut >= date_debut AND NEW.date_debut < date_fin)
            OR
            -- Cas 2 : Nouvelle r√©servation finit pendant une existante
            (NEW.date_fin > date_debut AND NEW.date_fin <= date_fin)
            OR
            -- Cas 3 : Nouvelle r√©servation englobe une existante
            (NEW.date_debut <= date_debut AND NEW.date_fin >= date_fin)
        );

    IF v_nb_conflits > 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Conflit : la salle est d√©j√† r√©serv√©e sur ce cr√©neau';
    END IF;

    -- Validation 5 : Limite de r√©servations simultan√©es par utilisateur
    SELECT COUNT(*) INTO v_nb_conflits
    FROM reservations
    WHERE
        utilisateur_id = NEW.utilisateur_id
        AND statut = 'CONFIRMEE'
        AND date_debut > NOW();

    IF v_nb_conflits >= 3 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Limite de 3 r√©servations actives atteinte';
    END IF;
END//

DELIMITER ;
```

---

## UPDATE Triggers

### Caract√©ristiques sp√©cifiques

Les triggers UPDATE sont d√©clench√©s lors de la **modification de lignes existantes**. Ils ont acc√®s √† **OLD** (valeurs avant) et **NEW** (valeurs apr√®s).

**Cas d'usage typiques** :
- Comparaison des changements (OLD vs NEW)
- Audit des modifications
- Recalcul de valeurs d√©riv√©es
- Gestion de workflow (transitions d'√©tat)
- Propagation de changements √† d'autres tables

### Pattern 1 : Audit d√©taill√© des changements

```sql
DELIMITER //

-- Table d'audit d√©taill√©e
CREATE TABLE IF NOT EXISTS audit_produits_detail (
    id INT PRIMARY KEY AUTO_INCREMENT,
    produit_id INT NOT NULL,
    champ_modifie VARCHAR(50) NOT NULL,
    ancienne_valeur TEXT,
    nouvelle_valeur TEXT,
    utilisateur VARCHAR(100) NOT NULL,
    date_modification DATETIME NOT NULL,
    INDEX idx_produit_date (produit_id, date_modification)
)//

-- AFTER UPDATE : Audit champ par champ
CREATE TRIGGER after_update_produit_audit_detail
AFTER UPDATE ON produits
FOR EACH ROW
BEGIN
    -- Audit du nom
    IF OLD.nom != NEW.nom THEN
        INSERT INTO audit_produits_detail (
            produit_id, champ_modifie, ancienne_valeur, nouvelle_valeur,
            utilisateur, date_modification
        ) VALUES (
            NEW.id, 'nom', OLD.nom, NEW.nom, USER(), NOW()
        );
    END IF;

    -- Audit du prix HT
    IF OLD.prix_ht != NEW.prix_ht THEN
        INSERT INTO audit_produits_detail (
            produit_id, champ_modifie, ancienne_valeur, nouvelle_valeur,
            utilisateur, date_modification
        ) VALUES (
            NEW.id, 'prix_ht',
            CAST(OLD.prix_ht AS CHAR),
            CAST(NEW.prix_ht AS CHAR),
            USER(), NOW()
        );
    END IF;

    -- Audit du taux de TVA
    IF OLD.taux_tva != NEW.taux_tva THEN
        INSERT INTO audit_produits_detail (
            produit_id, champ_modifie, ancienne_valeur, nouvelle_valeur,
            utilisateur, date_modification
        ) VALUES (
            NEW.id, 'taux_tva',
            CAST(OLD.taux_tva AS CHAR),
            CAST(NEW.taux_tva AS CHAR),
            USER(), NOW()
        );
    END IF;

    -- Audit du statut
    IF OLD.statut != NEW.statut THEN
        INSERT INTO audit_produits_detail (
            produit_id, champ_modifie, ancienne_valeur, nouvelle_valeur,
            utilisateur, date_modification
        ) VALUES (
            NEW.id, 'statut', OLD.statut, NEW.statut, USER(), NOW()
        );
    END IF;
END//

DELIMITER ;

-- Test
UPDATE produits SET prix_ht = 899.00, taux_tva = 5.5 WHERE id = 1;

-- R√©sultat dans audit_produits_detail :
-- Ligne 1 : champ='prix_ht', ancienne='800.00', nouvelle='899.00'
-- Ligne 2 : champ='taux_tva', ancienne='20.00', nouvelle='5.50'
```

### Pattern 2 : Gestion de version et changelog

```sql
DELIMITER //

-- Table avec versioning
CREATE TABLE IF NOT EXISTS documents (
    id INT PRIMARY KEY AUTO_INCREMENT,
    titre VARCHAR(200) NOT NULL,
    contenu TEXT,
    version INT DEFAULT 1,
    date_creation DATETIME,
    date_modification DATETIME,
    modifie_par VARCHAR(100)
)//

-- Table d'historique des versions
CREATE TABLE IF NOT EXISTS documents_versions (
    id INT PRIMARY KEY AUTO_INCREMENT,
    document_id INT NOT NULL,
    version INT NOT NULL,
    titre VARCHAR(200) NOT NULL,
    contenu TEXT,
    date_version DATETIME NOT NULL,
    utilisateur VARCHAR(100) NOT NULL,
    commentaire TEXT,
    UNIQUE KEY uk_doc_version (document_id, version),
    FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE
)//

-- BEFORE UPDATE : Incr√©mentation de version
CREATE TRIGGER before_update_document_version
BEFORE UPDATE ON documents
FOR EACH ROW
BEGIN
    -- V√©rifier si le contenu change
    IF OLD.contenu != NEW.contenu OR OLD.titre != NEW.titre THEN
        -- Incr√©menter la version
        SET NEW.version = OLD.version + 1;
        SET NEW.date_modification = NOW();
        SET NEW.modifie_par = USER();
    ELSE
        -- Pas de changement de contenu : conserver version
        SET NEW.version = OLD.version;
        SET NEW.date_modification = OLD.date_modification;
        SET NEW.modifie_par = OLD.modifie_par;
    END IF;
END//

-- AFTER UPDATE : Sauvegarde de la version pr√©c√©dente
CREATE TRIGGER after_update_document_historique
AFTER UPDATE ON documents
FOR EACH ROW
BEGIN
    -- Archiver uniquement si version a chang√©
    IF NEW.version != OLD.version THEN
        INSERT INTO documents_versions (
            document_id,
            version,
            titre,
            contenu,
            date_version,
            utilisateur,
            commentaire
        ) VALUES (
            OLD.id,
            OLD.version,
            OLD.titre,
            OLD.contenu,
            OLD.date_modification,
            OLD.modifie_par,
            @changelog_comment  -- Variable de session pour commentaire
        );
    END IF;
END//

DELIMITER ;

-- Utilisation
SET @changelog_comment = 'Correction orthographique';
UPDATE documents SET contenu = 'Nouveau contenu corrig√©' WHERE id = 1;
-- Version passe de 1 √† 2, ancienne version archiv√©e
```

### Pattern 3 : Recalcul en cascade

```sql
DELIMITER //

-- Table de lignes de commande
CREATE TABLE IF NOT EXISTS lignes_commande (
    id INT PRIMARY KEY AUTO_INCREMENT,
    commande_id INT NOT NULL,
    produit_id INT NOT NULL,
    quantite INT NOT NULL,
    prix_unitaire DECIMAL(10,2) NOT NULL,
    montant_ligne DECIMAL(10,2),  -- Calcul√©
    FOREIGN KEY (commande_id) REFERENCES commandes(id) ON DELETE CASCADE,
    FOREIGN KEY (produit_id) REFERENCES produits(id)
)//

-- BEFORE UPDATE ligne : Recalcul montant ligne
CREATE TRIGGER before_update_ligne_commande
BEFORE UPDATE ON lignes_commande
FOR EACH ROW
BEGIN
    -- Recalcul si quantit√© ou prix change
    IF NEW.quantite != OLD.quantite OR NEW.prix_unitaire != OLD.prix_unitaire THEN
        SET NEW.montant_ligne = NEW.quantite * NEW.prix_unitaire;
    END IF;
END//

-- AFTER UPDATE ligne : Recalcul montant commande
CREATE TRIGGER after_update_ligne_commande_total
AFTER UPDATE ON lignes_commande
FOR EACH ROW
BEGIN
    DECLARE v_nouveau_total DECIMAL(12,2);

    -- Recalcul du total de la commande
    SELECT SUM(montant_ligne) INTO v_nouveau_total
    FROM lignes_commande
    WHERE commande_id = NEW.commande_id;

    -- Mise √† jour de la commande
    UPDATE commandes
    SET
        montant_total = v_nouveau_total,
        date_modification = NOW()
    WHERE id = NEW.commande_id;
END//

DELIMITER ;

-- Test
UPDATE lignes_commande SET quantite = 5 WHERE id = 10;
-- D√©clenche : recalcul montant_ligne, puis recalcul montant_total commande
```

### Pattern 4 : Workflow et transitions d'√©tat

```sql
DELIMITER //

-- Table de tickets support
CREATE TABLE IF NOT EXISTS tickets_support (
    id INT PRIMARY KEY AUTO_INCREMENT,
    titre VARCHAR(200) NOT NULL,
    description TEXT,
    statut VARCHAR(20) NOT NULL DEFAULT 'OUVERT',
    priorite VARCHAR(20) DEFAULT 'NORMALE',
    assigne_a INT,
    date_creation DATETIME DEFAULT NOW(),
    date_fermeture DATETIME,
    duree_resolution_heures INT,
    FOREIGN KEY (assigne_a) REFERENCES utilisateurs(id)
)//

-- Table d'historique des transitions
CREATE TABLE IF NOT EXISTS tickets_transitions (
    id INT PRIMARY KEY AUTO_INCREMENT,
    ticket_id INT NOT NULL,
    statut_precedent VARCHAR(20) NOT NULL,
    statut_nouveau VARCHAR(20) NOT NULL,
    utilisateur VARCHAR(100) NOT NULL,
    commentaire TEXT,
    date_transition DATETIME NOT NULL,
    FOREIGN KEY (ticket_id) REFERENCES tickets_support(id) ON DELETE CASCADE
)//

-- BEFORE UPDATE : Validation des transitions de statut
CREATE TRIGGER before_update_ticket_statut
BEFORE UPDATE ON tickets_support
FOR EACH ROW
BEGIN
    -- V√©rifier si le statut change
    IF NEW.statut != OLD.statut THEN

        -- Transitions autoris√©es depuis OUVERT
        IF OLD.statut = 'OUVERT' THEN
            IF NEW.statut NOT IN ('EN_COURS', 'FERME', 'ANNULE') THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'Transition invalide depuis OUVERT';
            END IF;

            -- EN_COURS requiert une assignation
            IF NEW.statut = 'EN_COURS' AND NEW.assigne_a IS NULL THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'Un ticket EN_COURS doit √™tre assign√©';
            END IF;
        END IF;

        -- Transitions autoris√©es depuis EN_COURS
        IF OLD.statut = 'EN_COURS' THEN
            IF NEW.statut NOT IN ('RESOLU', 'EN_ATTENTE', 'OUVERT') THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'Transition invalide depuis EN_COURS';
            END IF;
        END IF;

        -- Transitions autoris√©es depuis RESOLU
        IF OLD.statut = 'RESOLU' THEN
            IF NEW.statut NOT IN ('FERME', 'ROUVERT') THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'Transition invalide depuis RESOLU';
            END IF;
        END IF;

        -- Transitions autoris√©es depuis FERME
        IF OLD.statut = 'FERME' THEN
            IF NEW.statut != 'ROUVERT' THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'Un ticket ferm√© ne peut √™tre que rouvert';
            END IF;
        END IF;

        -- Tickets ANNULE sont d√©finitifs
        IF OLD.statut = 'ANNULE' THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'Impossible de modifier un ticket annul√©';
        END IF;

        -- Actions automatiques selon nouveau statut
        IF NEW.statut = 'FERME' THEN
            SET NEW.date_fermeture = NOW();
            SET NEW.duree_resolution_heures = TIMESTAMPDIFF(
                HOUR,
                OLD.date_creation,
                NOW()
            );
        END IF;

        IF NEW.statut = 'ROUVERT' THEN
            SET NEW.date_fermeture = NULL;
            SET NEW.duree_resolution_heures = NULL;
        END IF;
    END IF;
END//

-- AFTER UPDATE : Enregistrement des transitions
CREATE TRIGGER after_update_ticket_transitions
AFTER UPDATE ON tickets_support
FOR EACH ROW
BEGIN
    IF NEW.statut != OLD.statut THEN
        INSERT INTO tickets_transitions (
            ticket_id,
            statut_precedent,
            statut_nouveau,
            utilisateur,
            commentaire,
            date_transition
        ) VALUES (
            NEW.id,
            OLD.statut,
            NEW.statut,
            USER(),
            @transition_commentaire,  -- Variable de session
            NOW()
        );
    END IF;
END//

DELIMITER ;
```

### Pattern 5 : Emp√™cher les modifications de champs sp√©cifiques

```sql
DELIMITER //

-- BEFORE UPDATE : Protection de champs immuables
CREATE TRIGGER before_update_commande_protection
BEFORE UPDATE ON commandes
FOR EACH ROW
BEGIN
    -- Champs immuables : ID, r√©f√©rence, date cr√©ation
    IF NEW.id != OLD.id THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'L''ID ne peut pas √™tre modifi√©';
    END IF;

    IF NEW.reference != OLD.reference THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'La r√©f√©rence ne peut pas √™tre modifi√©e';
    END IF;

    -- Forcer la conservation de la date de cr√©ation
    SET NEW.date_creation = OLD.date_creation;

    -- Emp√™cher modification si commande valid√©e (sauf statut)
    IF OLD.statut IN ('VALIDEE', 'EXPEDIEE', 'LIVREE') THEN
        IF NEW.montant_total != OLD.montant_total THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'Impossible de modifier le montant d''une commande valid√©e';
        END IF;

        IF NEW.client_id != OLD.client_id THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'Impossible de changer le client d''une commande valid√©e';
        END IF;
    END IF;
END//

DELIMITER ;
```

---

## DELETE Triggers

### Caract√©ristiques sp√©cifiques

Les triggers DELETE sont d√©clench√©s lors de la **suppression de lignes**. Ils ont acc√®s uniquement √† **OLD** (valeurs supprim√©es).

**Cas d'usage typiques** :
- Archivage avant suppression
- Suppression en cascade personnalis√©e
- V√©rification de contraintes avant suppression
- Nettoyage de donn√©es li√©es
- Audit des suppressions

### Pattern 1 : Archivage automatique avant suppression

```sql
DELIMITER //

-- Table d'archive
CREATE TABLE IF NOT EXISTS clients_archives (
    id INT PRIMARY KEY,  -- M√™me ID que l'original
    nom VARCHAR(100),
    prenom VARCHAR(100),
    email VARCHAR(255),
    telephone VARCHAR(20),
    date_creation DATETIME,
    date_suppression DATETIME NOT NULL,
    supprime_par VARCHAR(100) NOT NULL,
    motif_suppression TEXT
)//

-- BEFORE DELETE : Archivage complet
CREATE TRIGGER before_delete_client_archive
BEFORE DELETE ON clients
FOR EACH ROW
BEGIN
    -- V√©rifier si le client a des commandes en cours
    DECLARE v_nb_commandes_actives INT;

    SELECT COUNT(*) INTO v_nb_commandes_actives
    FROM commandes
    WHERE
        client_id = OLD.id
        AND statut IN ('EN_COURS', 'VALIDEE', 'EXPEDIEE');

    IF v_nb_commandes_actives > 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Impossible de supprimer : commandes actives';
    END IF;

    -- Archiver le client
    INSERT INTO clients_archives (
        id,
        nom,
        prenom,
        email,
        telephone,
        date_creation,
        date_suppression,
        supprime_par,
        motif_suppression
    ) VALUES (
        OLD.id,
        OLD.nom,
        OLD.prenom,
        OLD.email,
        OLD.telephone,
        OLD.date_creation,
        NOW(),
        USER(),
        @motif_suppression  -- Variable de session
    );
END//

DELIMITER ;

-- Utilisation
SET @motif_suppression = 'Demande RGPD du client';
DELETE FROM clients WHERE id = 123;
```

### Pattern 2 : Soft delete (suppression logique)

```sql
DELIMITER //

-- Table avec soft delete
CREATE TABLE IF NOT EXISTS articles (
    id INT PRIMARY KEY AUTO_INCREMENT,
    titre VARCHAR(200) NOT NULL,
    contenu TEXT,
    auteur_id INT NOT NULL,
    publie BOOLEAN DEFAULT FALSE,
    supprime BOOLEAN DEFAULT FALSE,  -- Soft delete flag
    date_suppression DATETIME,
    supprime_par VARCHAR(100),
    date_creation DATETIME DEFAULT NOW()
)//

-- BEFORE DELETE : Transformer en soft delete
CREATE TRIGGER before_delete_article_soft
BEFORE DELETE ON articles
FOR EACH ROW
BEGIN
    -- V√©rifier si d√©j√† soft-deleted
    IF OLD.supprime = TRUE THEN
        -- Autoriser la suppression physique
        -- (ne rien faire, laisser la suppression se faire)
        INSERT INTO audit_suppressions (
            table_name,
            record_id,
            action,
            utilisateur,
            date_action
        ) VALUES (
            'articles',
            OLD.id,
            'HARD_DELETE',
            USER(),
            NOW()
        );
    ELSE
        -- Bloquer la suppression physique et faire soft delete
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Utilisez UPDATE pour soft delete au lieu de DELETE';
    END IF;
END//

-- Alternative : Utiliser UPDATE au lieu de DELETE
-- UPDATE articles SET supprime = TRUE, date_suppression = NOW() WHERE id = X;

DELIMITER ;
```

### Pattern 3 : Nettoyage en cascade personnalis√©

```sql
DELIMITER //

-- AFTER DELETE : Nettoyage manuel des donn√©es li√©es
CREATE TRIGGER after_delete_utilisateur_cleanup
AFTER DELETE ON utilisateurs
FOR EACH ROW
BEGIN
    /*
     * Nettoyage complet des donn√©es de l'utilisateur
     * Alternative √† ON DELETE CASCADE pour un contr√¥le fin
     */

    -- 1. Suppression des sessions
    DELETE FROM sessions WHERE utilisateur_id = OLD.id;

    -- 2. Anonymisation des commentaires (pas suppression)
    UPDATE commentaires
    SET
        auteur_id = NULL,
        auteur_nom = '[Utilisateur supprim√©]'
    WHERE auteur_id = OLD.id;

    -- 3. R√©assignation des tickets support
    UPDATE tickets_support
    SET
        assigne_a = NULL,
        statut = 'OUVERT'
    WHERE assigne_a = OLD.id AND statut = 'EN_COURS';

    -- 4. Suppression des fichiers upload√©s
    DELETE FROM fichiers_uploads WHERE utilisateur_id = OLD.id;

    -- 5. Nettoyage des pr√©f√©rences
    DELETE FROM preferences_utilisateur WHERE utilisateur_id = OLD.id;

    -- 6. Log de la suppression compl√®te
    INSERT INTO audit_suppressions_complete (
        table_principale,
        record_id,
        tables_nettoyees,
        date_suppression
    ) VALUES (
        'utilisateurs',
        OLD.id,
        'sessions,commentaires,tickets,fichiers,preferences',
        NOW()
    );
END//

DELIMITER ;
```

### Pattern 4 : Validation avant suppression

```sql
DELIMITER //

-- BEFORE DELETE : Validations m√©tier
CREATE TRIGGER before_delete_produit_validation
BEFORE DELETE ON produits
FOR EACH ROW
BEGIN
    DECLARE v_nb_commandes INT;
    DECLARE v_stock_valeur DECIMAL(12,2);

    -- Validation 1 : Pas de suppression si commandes en cours
    SELECT COUNT(*) INTO v_nb_commandes
    FROM lignes_commande lc
    INNER JOIN commandes c ON lc.commande_id = c.id
    WHERE
        lc.produit_id = OLD.id
        AND c.statut IN ('EN_COURS', 'VALIDEE', 'EXPEDIEE');

    IF v_nb_commandes > 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = CONCAT(
                'Impossible de supprimer : ',
                v_nb_commandes,
                ' commande(s) en cours avec ce produit'
            );
    END IF;

    -- Validation 2 : Alerter si stock important
    SELECT quantite_disponible * prix_unitaire INTO v_stock_valeur
    FROM stock_produits
    WHERE produit_id = OLD.id;

    IF v_stock_valeur > 1000.00 THEN
        -- Enregistrer un warning (ne pas bloquer)
        INSERT INTO warnings_suppression (
            table_name,
            record_id,
            message,
            valeur_stock,
            date_warning
        ) VALUES (
            'produits',
            OLD.id,
            'Suppression produit avec stock important',
            v_stock_valeur,
            NOW()
        );
    END IF;

    -- Validation 3 : N√©cessite confirmation pour produits strat√©giques
    IF OLD.categorie = 'STRATEGIQUE' THEN
        IF @confirmation_suppression_strategique != OLD.id THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'Confirmation requise pour supprimer un produit strat√©gique';
        END IF;
    END IF;
END//

DELIMITER ;

-- Utilisation avec confirmation
SET @confirmation_suppression_strategique = 42;
DELETE FROM produits WHERE id = 42;
```

### Pattern 5 : Journalisation d√©taill√©e des suppressions

```sql
DELIMITER //

-- Table de journal des suppressions
CREATE TABLE IF NOT EXISTS journal_suppressions (
    id INT PRIMARY KEY AUTO_INCREMENT,
    table_name VARCHAR(64) NOT NULL,
    record_id INT NOT NULL,
    donnees_supprimees JSON NOT NULL,
    utilisateur VARCHAR(100) NOT NULL,
    adresse_ip VARCHAR(45),
    date_suppression DATETIME NOT NULL,
    INDEX idx_table_date (table_name, date_suppression)
)//

-- AFTER DELETE : Journalisation JSON compl√®te
CREATE TRIGGER after_delete_commande_journal
AFTER DELETE ON commandes
FOR EACH ROW
BEGIN
    INSERT INTO journal_suppressions (
        table_name,
        record_id,
        donnees_supprimees,
        utilisateur,
        adresse_ip,
        date_suppression
    ) VALUES (
        'commandes',
        OLD.id,
        JSON_OBJECT(
            'reference', OLD.reference,
            'client_id', OLD.client_id,
            'montant_total', OLD.montant_total,
            'statut', OLD.statut,
            'date_creation', OLD.date_creation,
            'date_commande', OLD.date_commande
        ),
        USER(),
        @client_ip,  -- Variable de session
        NOW()
    );
END//

DELIMITER ;
```

---

## Combinaison de triggers sur une m√™me table

### Ordre d'ex√©cution

Quand plusieurs triggers existent sur la m√™me table pour le m√™me √©v√©nement :
1. Les triggers **BEFORE** s'ex√©cutent **avant** l'op√©ration
2. L'op√©ration sur la table est effectu√©e
3. Les triggers **AFTER** s'ex√©cutent **apr√®s** l'op√©ration

Si plusieurs triggers du m√™me type (ex: 2 BEFORE INSERT), l'ordre d'ex√©cution est **l'ordre de cr√©ation** (non garanti dans toutes les versions).

### Pattern : S√©paration des responsabilit√©s

```sql
DELIMITER //

-- Trigger 1 : Validation (BEFORE)
CREATE TRIGGER before_insert_commande_01_validation
BEFORE INSERT ON commandes
FOR EACH ROW
BEGIN
    -- Uniquement validation
    IF NEW.montant_total < 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Montant n√©gatif';
    END IF;
END//

-- Trigger 2 : Normalisation (BEFORE)
CREATE TRIGGER before_insert_commande_02_normalisation
BEFORE INSERT ON commandes
FOR EACH ROW
BEGIN
    -- Uniquement normalisation
    SET NEW.reference = UPPER(TRIM(NEW.reference));
END//

-- Trigger 3 : Enrichissement (BEFORE)
CREATE TRIGGER before_insert_commande_03_enrichissement
BEFORE INSERT ON commandes
FOR EACH ROW
BEGIN
    -- Uniquement enrichissement
    SET NEW.date_creation = NOW();
END//

-- Trigger 4 : Audit (AFTER)
CREATE TRIGGER after_insert_commande_01_audit
AFTER INSERT ON commandes
FOR EACH ROW
BEGIN
    -- Uniquement audit
    INSERT INTO audit_log VALUES (NEW.id, 'INSERT', NOW());
END//

-- Trigger 5 : Notifications (AFTER)
CREATE TRIGGER after_insert_commande_02_notifications
AFTER INSERT ON commandes
FOR EACH ROW
BEGIN
    -- Uniquement notifications
    INSERT INTO queue_notifications VALUES (NEW.id, 'NOUVELLE_COMMANDE');
END//

DELIMITER ;
```

üí° **Avantage** : Chaque trigger a une **responsabilit√© unique**, facilitant la maintenance et le d√©bogage.

‚ö†Ô∏è **Attention** : Trop de triggers peuvent impacter les performances. Privil√©giez la consolidation quand possible.

---

## Bonnes pratiques sp√©cifiques √† chaque type

### INSERT Triggers

```sql
-- ‚úÖ BON : G√©n√©ration d'identifiants m√©tier
-- ‚úÖ BON : Validation avant insertion
-- ‚úÖ BON : Normalisation de format
-- ‚ùå MAUVAIS : Lecture de donn√©es externes lourdes
-- ‚ùå MAUVAIS : Op√©rations asynchrones longues
```

### UPDATE Triggers

```sql
-- ‚úÖ BON : Comparaison OLD vs NEW avant action
-- ‚úÖ BON : Audit des modifications
-- ‚úÖ BON : Validation des transitions d'√©tat
-- ‚ùå MAUVAIS : Mise √† jour circulaire (boucle infinie)
-- ‚ùå MAUVAIS : Modification de NEW.id ou cl√©s primaires
```

### DELETE Triggers

```sql
-- ‚úÖ BON : Archivage avant suppression
-- ‚úÖ BON : Validation de contraintes m√©tier
-- ‚úÖ BON : Nettoyage en cascade personnalis√©
-- ‚ùå MAUVAIS : Tentative de modification de OLD (lecture seule)
-- ‚ùå MAUVAIS : Bloquer toute suppression (utiliser privil√®ges)
```

### Patterns universels

```sql
-- ‚úÖ BON : Conditions pour √©viter ex√©cutions inutiles
IF NEW.valeur != OLD.valeur THEN
    -- Action
END IF;

-- ‚úÖ BON : Messages d'erreur explicites
SIGNAL SQLSTATE '45000'
    SET MESSAGE_TEXT = 'Description pr√©cise de l'erreur';

-- ‚úÖ BON : Utiliser des variables de session pour contexte
SET @audit_context = 'IMPORT_BATCH';

-- ‚ùå MAUVAIS : Logique m√©tier complexe dans le trigger
-- ‚Üí D√©l√©guer √† des proc√©dures stock√©es
```

---

## D√©bogage des triggers

### Technique 1 : Table de log temporaire

```sql
CREATE TEMPORARY TABLE IF NOT EXISTS trigger_debug_log (
    id INT AUTO_INCREMENT PRIMARY KEY,
    trigger_name VARCHAR(64),
    message TEXT,
    valeur TEXT,
    timestamp DATETIME DEFAULT NOW()
);

-- Dans le trigger
INSERT INTO trigger_debug_log (trigger_name, message, valeur)
VALUES ('before_insert_produit', 'Prix HT', CAST(NEW.prix_ht AS CHAR));
```

### Technique 2 : D√©sactivation s√©lective

```sql
-- D√©sactiver temporairement un trigger
DROP TRIGGER IF EXISTS nom_trigger;

-- R√©activer apr√®s tests
-- (recr√©er le trigger)
```

### Technique 3 : Trace avec variables de session

```sql
-- Dans le trigger
SET @debug_trigger_last_id = NEW.id;
SET @debug_trigger_last_action = 'validation_ok';

-- Consultation apr√®s op√©ration
SELECT @debug_trigger_last_id, @debug_trigger_last_action;
```

---

## ‚úÖ Points cl√©s √† retenir

- **INSERT** : NEW disponible, validation et normalisation avant √©criture
- **UPDATE** : OLD et NEW disponibles, comparaison des changements essentielle
- **DELETE** : OLD disponible, archivage avant suppression d√©finitive
- **Ordre d'ex√©cution** : BEFORE ‚Üí Op√©ration ‚Üí AFTER
- **Responsabilit√© unique** : Un trigger = une t√¢che sp√©cifique
- **Performance** : Conditionner les actions (IF OLD.x != NEW.x)
- **Validation** : BEFORE pour bloquer, AFTER pour enregistrer
- **Archivage** : Toujours avant DELETE, jamais apr√®s
- **√âtat workflow** : Valider les transitions dans BEFORE UPDATE
- **Debugging** : Utiliser logs temporaires et variables de session

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation officielle MariaDB - Trigger Event Types](https://mariadb.com/kb/en/trigger-overview/#trigger-event)
- [üìñ OLD and NEW References](https://mariadb.com/kb/en/trigger-overview/#old-and-new)
- [üìñ Trigger Execution Order](https://mariadb.com/kb/en/trigger-overview/#trigger-execution-order)
- [üìñ Trigger Limitations](https://mariadb.com/kb/en/trigger-limitations/)
- [üí° Blog : Advanced Trigger Patterns](https://mariadb.com/resources/blog/)

---

## ‚û°Ô∏è Section suivante

**[8.3.3 Variables OLD et NEW](./03.3-variables-old-new.md)** : Ma√Ætrisez en profondeur les variables OLD et NEW avec des cas d'usage avanc√©s et des patterns de manipulation complexes.

---


‚è≠Ô∏è [Variables OLD et NEW](/08-programmation-cote-serveur/03.3-variables-old-new.md)
