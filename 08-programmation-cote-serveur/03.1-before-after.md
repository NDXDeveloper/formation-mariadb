üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.3.1 BEFORE et AFTER

> **Niveau** : Interm√©diaire √† Avanc√©
> **Dur√©e estim√©e** : 2.5 heures
> **Pr√©requis** : Sections 8.1 et 8.2 (Proc√©dures et Fonctions), compr√©hension des transactions

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre la diff√©rence fondamentale entre triggers BEFORE et AFTER
- Choisir le type de trigger appropri√© selon le cas d'usage
- Utiliser efficacement les variables OLD et NEW
- Impl√©menter des validations avec BEFORE triggers
- Cr√©er des audits et logs avec AFTER triggers
- Appliquer les bonnes pratiques de cr√©ation de triggers

---

## Introduction

Les **triggers** (d√©clencheurs) sont des objets de base de donn√©es qui s'ex√©cutent **automatiquement** en r√©ponse √† des √©v√©nements sur une table. Le timing d'ex√©cution (BEFORE ou AFTER) d√©termine leur comportement et leurs possibilit√©s.

### Pourquoi BEFORE et AFTER ?

Le choix entre BEFORE et AFTER d√©pend de **quand** vous voulez intervenir dans le cycle de vie d'une op√©ration :

- **BEFORE** : Agir **avant** que les donn√©es soient modifi√©es dans la table
- **AFTER** : Agir **apr√®s** que les donn√©es ont √©t√© modifi√©es dans la table

üí° **Analogie** : Imaginez une porte avec un syst√®me de s√©curit√© :
- **BEFORE** = Le contr√¥le d'acc√®s **avant** d'entrer (validation, refus possible)
- **AFTER** = La cam√©ra qui enregistre **apr√®s** votre passage (audit, tra√ßabilit√©)

---

## Diff√©rences fondamentales BEFORE vs AFTER

### Tableau comparatif

| Caract√©ristique | BEFORE | AFTER |
|----------------|--------|-------|
| **Moment d'ex√©cution** | Avant modification des donn√©es | Apr√®s modification des donn√©es |
| **Modification NEW** | ‚úÖ Possible | ‚ùå Impossible |
| **Lecture OLD** | ‚úÖ Possible | ‚úÖ Possible |
| **Lecture NEW** | ‚úÖ Possible | ‚úÖ Possible |
| **Emp√™cher l'op√©ration** | ‚úÖ SIGNAL possible | ‚ö†Ô∏è Rollback n√©cessaire |
| **Auto-increment ID** | ‚ùå Pas encore g√©n√©r√© | ‚úÖ Disponible |
| **Cas d'usage typique** | Validation, normalisation | Audit, synchronisation |
| **Performance** | L√©g√®rement plus rapide | L√©g√®rement plus lent |

### Cycle de vie d'une op√©ration avec triggers

```
1. D√©but de l'op√©ration (INSERT/UPDATE/DELETE)
2. ‚Üì
3. BEFORE TRIGGER s'ex√©cute
4.    ‚Üí Peut modifier NEW
5.    ‚Üí Peut annuler avec SIGNAL
6. ‚Üì
7. Op√©ration sur la table (donn√©es √©crites)
8. ‚Üì
9. AFTER TRIGGER s'ex√©cute
10.   ‚Üí Lecture seule de NEW/OLD
11.   ‚Üí Peut effectuer d'autres op√©rations
12. ‚Üì
13. Fin de l'op√©ration (COMMIT si succ√®s)
```

---

## BEFORE Triggers : Validation et Transformation

### Principe

Les triggers BEFORE s'ex√©cutent **avant** que les donn√©es soient √©crites dans la table. Ils permettent :
- **Validation** : V√©rifier la coh√©rence des donn√©es
- **Transformation** : Modifier les valeurs avant insertion/mise √† jour
- **Normalisation** : Formater les donn√©es selon des r√®gles
- **Blocage** : Emp√™cher une op√©ration invalide avec SIGNAL

### Syntaxe de base

```sql
CREATE TRIGGER nom_trigger
BEFORE INSERT|UPDATE|DELETE  -- Timing BEFORE
ON nom_table
FOR EACH ROW
BEGIN
    -- Code du trigger
    -- Acc√®s √† OLD (UPDATE/DELETE)
    -- Acc√®s et modification de NEW (INSERT/UPDATE)
END;
```

### Exemple 1 : Validation avec BEFORE INSERT

```sql
DELIMITER //

-- Table de clients
CREATE TABLE IF NOT EXISTS clients (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nom VARCHAR(100) NOT NULL,
    prenom VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    telephone VARCHAR(20),
    date_naissance DATE,
    date_creation DATETIME DEFAULT NOW()
)//

-- Trigger de validation BEFORE INSERT
CREATE TRIGGER before_insert_client
BEFORE INSERT ON clients
FOR EACH ROW
BEGIN
    -- Validation 1 : Email format valide
    IF NEW.email NOT LIKE '%@%.%' THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Format d''email invalide';
    END IF;

    -- Validation 2 : Nom et pr√©nom non vides
    IF TRIM(NEW.nom) = '' OR TRIM(NEW.prenom) = '' THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Nom et pr√©nom obligatoires';
    END IF;

    -- Validation 3 : √Çge minimum 18 ans
    IF NEW.date_naissance IS NOT NULL THEN
        IF TIMESTAMPDIFF(YEAR, NEW.date_naissance, CURDATE()) < 18 THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'Le client doit avoir au moins 18 ans';
        END IF;
    END IF;

    -- Validation 4 : T√©l√©phone format fran√ßais (optionnel)
    IF NEW.telephone IS NOT NULL AND NEW.telephone != '' THEN
        IF LENGTH(REPLACE(REPLACE(REPLACE(NEW.telephone, ' ', ''), '-', ''), '.', '')) < 10 THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'Format de t√©l√©phone invalide';
        END IF;
    END IF;
END//

DELIMITER ;

-- Tests
-- ‚úÖ Insertion valide
INSERT INTO clients (nom, prenom, email, date_naissance)
VALUES ('Dupont', 'Jean', 'jean.dupont@example.com', '1990-05-15');

-- ‚ùå Email invalide
INSERT INTO clients (nom, prenom, email, date_naissance)
VALUES ('Martin', 'Sophie', 'email_invalide', '1985-03-20');
-- ERROR 1644: Format d'email invalide

-- ‚ùå √Çge insuffisant
INSERT INTO clients (nom, prenom, email, date_naissance)
VALUES ('Petit', 'Luc', 'luc.petit@example.com', '2010-01-01');
-- ERROR 1644: Le client doit avoir au moins 18 ans
```

**Points cl√©s** :
- `NEW` repr√©sente les valeurs √† ins√©rer
- `SIGNAL` arr√™te l'op√©ration et retourne une erreur
- Les validations s'ex√©cutent **avant** l'√©criture en base
- Si une validation √©choue, **rien n'est √©crit**

### Exemple 2 : Normalisation avec BEFORE INSERT/UPDATE

```sql
DELIMITER //

-- Trigger de normalisation BEFORE INSERT
CREATE TRIGGER before_insert_client_normalisation
BEFORE INSERT ON clients
FOR EACH ROW
BEGIN
    -- Normalisation 1 : Nom et pr√©nom en majuscules
    SET NEW.nom = UPPER(TRIM(NEW.nom));
    SET NEW.prenom = CONCAT(
        UPPER(LEFT(TRIM(NEW.prenom), 1)),
        LOWER(SUBSTRING(TRIM(NEW.prenom), 2))
    );

    -- Normalisation 2 : Email en minuscules
    SET NEW.email = LOWER(TRIM(NEW.email));

    -- Normalisation 3 : Suppression espaces t√©l√©phone
    IF NEW.telephone IS NOT NULL THEN
        SET NEW.telephone = REPLACE(REPLACE(REPLACE(
            NEW.telephone, ' ', ''), '-', ''), '.', '');
    END IF;

    -- Normalisation 4 : Date de cr√©ation forc√©e
    SET NEW.date_creation = NOW();
END//

-- Trigger de normalisation BEFORE UPDATE
CREATE TRIGGER before_update_client_normalisation
BEFORE UPDATE ON clients
FOR EACH ROW
BEGIN
    -- M√™mes normalisations qu'√† l'insertion
    SET NEW.nom = UPPER(TRIM(NEW.nom));
    SET NEW.prenom = CONCAT(
        UPPER(LEFT(TRIM(NEW.prenom), 1)),
        LOWER(SUBSTRING(TRIM(NEW.prenom), 2))
    );
    SET NEW.email = LOWER(TRIM(NEW.email));

    IF NEW.telephone IS NOT NULL THEN
        SET NEW.telephone = REPLACE(REPLACE(REPLACE(
            NEW.telephone, ' ', ''), '-', ''), '.', '');
    END IF;

    -- Ne pas modifier date_creation (garder l'originale)
    SET NEW.date_creation = OLD.date_creation;
END//

DELIMITER ;

-- Test
INSERT INTO clients (nom, prenom, email, telephone, date_naissance)
VALUES ('  dupont  ', 'JEAN', 'Jean.DUPONT@Example.COM', '01-23-45-67-89', '1990-05-15');

-- R√©sultat stock√© :
-- nom = 'DUPONT'
-- prenom = 'Jean'
-- email = 'jean.dupont@example.com'
-- telephone = '0123456789'
```

üí° **Avantage BEFORE** : Les donn√©es sont **automatiquement nettoy√©es** √† chaque insertion/mise √† jour, garantissant la coh√©rence sans intervention applicative.

### Exemple 3 : Calcul automatique avec BEFORE INSERT/UPDATE

```sql
DELIMITER //

-- Table de produits
CREATE TABLE IF NOT EXISTS produits (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nom VARCHAR(100) NOT NULL,
    prix_ht DECIMAL(10,2) NOT NULL,
    taux_tva DECIMAL(5,2) NOT NULL DEFAULT 20.00,
    prix_ttc DECIMAL(10,2),  -- Calcul√© automatiquement
    remise_pct DECIMAL(5,2) DEFAULT 0,
    prix_final DECIMAL(10,2)  -- Avec remise
)//

-- Trigger BEFORE INSERT : Calcul automatique des prix
CREATE TRIGGER before_insert_produit
BEFORE INSERT ON produits
FOR EACH ROW
BEGIN
    -- Calcul du prix TTC
    SET NEW.prix_ttc = NEW.prix_ht * (1 + NEW.taux_tva / 100);

    -- Calcul du prix final avec remise
    SET NEW.prix_final = NEW.prix_ttc * (1 - NEW.remise_pct / 100);

    -- Arrondi √† 2 d√©cimales
    SET NEW.prix_ttc = ROUND(NEW.prix_ttc, 2);
    SET NEW.prix_final = ROUND(NEW.prix_final, 2);
END//

-- Trigger BEFORE UPDATE : Recalcul si prix/tva/remise changent
CREATE TRIGGER before_update_produit
BEFORE UPDATE ON produits
FOR EACH ROW
BEGIN
    -- Recalcul uniquement si prix_ht, taux_tva ou remise changent
    IF NEW.prix_ht != OLD.prix_ht
       OR NEW.taux_tva != OLD.taux_tva
       OR NEW.remise_pct != OLD.remise_pct THEN

        SET NEW.prix_ttc = NEW.prix_ht * (1 + NEW.taux_tva / 100);
        SET NEW.prix_final = NEW.prix_ttc * (1 - NEW.remise_pct / 100);
        SET NEW.prix_ttc = ROUND(NEW.prix_ttc, 2);
        SET NEW.prix_final = ROUND(NEW.prix_final, 2);
    END IF;
END//

DELIMITER ;

-- Test
INSERT INTO produits (nom, prix_ht, taux_tva, remise_pct)
VALUES ('Ordinateur portable', 800.00, 20.00, 10.00);

-- R√©sultat :
-- prix_ht = 800.00
-- prix_ttc = 960.00 (800 * 1.20)
-- prix_final = 864.00 (960 * 0.90)

-- Mise √† jour
UPDATE produits SET remise_pct = 15.00 WHERE id = 1;
-- prix_final recalcul√© automatiquement : 816.00
```

### Exemple 4 : Validation m√©tier complexe

```sql
DELIMITER //

-- Table de commandes
CREATE TABLE IF NOT EXISTS commandes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    client_id INT NOT NULL,
    montant_total DECIMAL(10,2) NOT NULL,
    statut VARCHAR(20) NOT NULL,
    date_commande DATETIME DEFAULT NOW(),
    FOREIGN KEY (client_id) REFERENCES clients(id)
)//

-- Trigger BEFORE UPDATE : Validation des transitions de statut
CREATE TRIGGER before_update_commande_statut
BEFORE UPDATE ON commandes
FOR EACH ROW
BEGIN
    -- V√©rifier que le statut change
    IF NEW.statut != OLD.statut THEN

        -- R√®gle 1 : Une commande ANNULEE ne peut plus changer
        IF OLD.statut = 'ANNULEE' THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'Impossible de modifier une commande annul√©e';
        END IF;

        -- R√®gle 2 : Une commande LIVREE ne peut plus changer (sauf RETOURNEE)
        IF OLD.statut = 'LIVREE' AND NEW.statut != 'RETOURNEE' THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'Une commande livr√©e ne peut √™tre que retourn√©e';
        END IF;

        -- R√®gle 3 : Transitions valides depuis EN_COURS
        IF OLD.statut = 'EN_COURS' THEN
            IF NEW.statut NOT IN ('VALIDEE', 'ANNULEE') THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'Transition de statut invalide depuis EN_COURS';
            END IF;
        END IF;

        -- R√®gle 4 : Transitions valides depuis VALIDEE
        IF OLD.statut = 'VALIDEE' THEN
            IF NEW.statut NOT IN ('EXPEDIEE', 'ANNULEE') THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'Transition de statut invalide depuis VALIDEE';
            END IF;
        END IF;

        -- R√®gle 5 : Transitions valides depuis EXPEDIEE
        IF OLD.statut = 'EXPEDIEE' THEN
            IF NEW.statut != 'LIVREE' THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'Une commande exp√©di√©e ne peut √™tre que livr√©e';
            END IF;
        END IF;

    END IF;
END//

DELIMITER ;

-- Tests
INSERT INTO commandes (client_id, montant_total, statut)
VALUES (1, 250.00, 'EN_COURS');

-- ‚úÖ Transition valide
UPDATE commandes SET statut = 'VALIDEE' WHERE id = 1;

-- ‚ùå Transition invalide
UPDATE commandes SET statut = 'LIVREE' WHERE id = 1;
-- ERROR 1644: Transition de statut invalide depuis VALIDEE
```

‚ö†Ô∏è **Important** : Les triggers BEFORE sont id√©aux pour les **machines √† √©tats** (workflow) car ils emp√™chent les transitions invalides **avant** l'√©criture.

---

## AFTER Triggers : Audit et Synchronisation

### Principe

Les triggers AFTER s'ex√©cutent **apr√®s** que les donn√©es ont √©t√© √©crites dans la table. Ils permettent :
- **Audit** : Enregistrer l'historique des modifications
- **Synchronisation** : Mettre √† jour d'autres tables
- **Notifications** : Envoyer des alertes ou d√©clencher des actions
- **Calculs d√©riv√©s** : Mettre √† jour des agr√©gations

### Syntaxe de base

```sql
CREATE TRIGGER nom_trigger
AFTER INSERT|UPDATE|DELETE  -- Timing AFTER
ON nom_table
FOR EACH ROW
BEGIN
    -- Code du trigger
    -- Lecture seule de OLD (UPDATE/DELETE)
    -- Lecture seule de NEW (INSERT/UPDATE)
    -- Pas de modification de NEW possible
END;
```

### Exemple 1 : Audit avec AFTER INSERT/UPDATE/DELETE

```sql
DELIMITER //

-- Table d'audit
CREATE TABLE IF NOT EXISTS audit_clients (
    id INT PRIMARY KEY AUTO_INCREMENT,
    operation VARCHAR(10) NOT NULL,
    client_id INT,
    ancien_nom VARCHAR(100),
    nouveau_nom VARCHAR(100),
    ancien_email VARCHAR(255),
    nouveau_email VARCHAR(255),
    utilisateur VARCHAR(100) NOT NULL,
    date_operation DATETIME NOT NULL,
    INDEX idx_client (client_id),
    INDEX idx_date (date_operation)
)//

-- Trigger AFTER INSERT : Enregistrement de la cr√©ation
CREATE TRIGGER after_insert_client_audit
AFTER INSERT ON clients
FOR EACH ROW
BEGIN
    INSERT INTO audit_clients (
        operation,
        client_id,
        nouveau_nom,
        nouveau_email,
        utilisateur,
        date_operation
    ) VALUES (
        'INSERT',
        NEW.id,  -- ‚úÖ L'ID auto-increment est maintenant disponible
        NEW.nom,
        NEW.email,
        USER(),
        NOW()
    );
END//

-- Trigger AFTER UPDATE : Enregistrement des modifications
CREATE TRIGGER after_update_client_audit
AFTER UPDATE ON clients
FOR EACH ROW
BEGIN
    -- Enregistrer uniquement si nom ou email changent
    IF OLD.nom != NEW.nom OR OLD.email != NEW.email THEN
        INSERT INTO audit_clients (
            operation,
            client_id,
            ancien_nom,
            nouveau_nom,
            ancien_email,
            nouveau_email,
            utilisateur,
            date_operation
        ) VALUES (
            'UPDATE',
            NEW.id,
            OLD.nom,    -- Ancienne valeur
            NEW.nom,    -- Nouvelle valeur
            OLD.email,
            NEW.email,
            USER(),
            NOW()
        );
    END IF;
END//

-- Trigger AFTER DELETE : Enregistrement de la suppression
CREATE TRIGGER after_delete_client_audit
AFTER DELETE ON clients
FOR EACH ROW
BEGIN
    INSERT INTO audit_clients (
        operation,
        client_id,
        ancien_nom,
        ancien_email,
        utilisateur,
        date_operation
    ) VALUES (
        'DELETE',
        OLD.id,
        OLD.nom,
        OLD.email,
        USER(),
        NOW()
    );
END//

DELIMITER ;

-- Tests
INSERT INTO clients (nom, prenom, email, date_naissance)
VALUES ('Durand', 'Paul', 'paul.durand@example.com', '1985-08-20');

UPDATE clients SET email = 'paul.d@example.com' WHERE id = 1;

DELETE FROM clients WHERE id = 1;

-- Consultation de l'audit
SELECT * FROM audit_clients ORDER BY date_operation;
```

**Sortie audit** :
```
+----+-----------+------------+-------------+--------------------------+----------------------+-------------------+
| id | operation | client_id  | ancien_nom  | nouveau_nom              | ancien_email         | nouveau_email     |
+----+-----------+------------+-------------+--------------------------+----------------------+-------------------+
|  1 | INSERT    |          1 | NULL        | DURAND                   | NULL                 | paul.durand@...   |
|  2 | UPDATE    |          1 | DURAND      | DURAND                   | paul.durand@...      | paul.d@...        |
|  3 | DELETE    |          1 | DURAND      | NULL                     | paul.d@...           | NULL              |
+----+-----------+------------+-------------+--------------------------+----------------------+-------------------+
```

üí° **Avantage AFTER** : L'ID auto-g√©n√©r√© (NEW.id) est disponible apr√®s l'insertion.

### Exemple 2 : Synchronisation de donn√©es agr√©g√©es

```sql
DELIMITER //

-- Table de statistiques clients (donn√©es agr√©g√©es)
CREATE TABLE IF NOT EXISTS stats_clients (
    client_id INT PRIMARY KEY,
    nb_commandes INT DEFAULT 0,
    montant_total DECIMAL(12,2) DEFAULT 0,
    derniere_commande DATE,
    FOREIGN KEY (client_id) REFERENCES clients(id) ON DELETE CASCADE
)//

-- Trigger AFTER INSERT commande : Mise √† jour des stats
CREATE TRIGGER after_insert_commande_stats
AFTER INSERT ON commandes
FOR EACH ROW
BEGIN
    -- Cr√©er ou mettre √† jour les statistiques du client
    INSERT INTO stats_clients (
        client_id,
        nb_commandes,
        montant_total,
        derniere_commande
    ) VALUES (
        NEW.client_id,
        1,
        NEW.montant_total,
        DATE(NEW.date_commande)
    )
    ON DUPLICATE KEY UPDATE
        nb_commandes = nb_commandes + 1,
        montant_total = montant_total + NEW.montant_total,
        derniere_commande = DATE(NEW.date_commande);
END//

-- Trigger AFTER UPDATE commande : Recalcul si montant change
CREATE TRIGGER after_update_commande_stats
AFTER UPDATE ON commandes
FOR EACH ROW
BEGIN
    IF NEW.montant_total != OLD.montant_total THEN
        UPDATE stats_clients
        SET montant_total = montant_total - OLD.montant_total + NEW.montant_total
        WHERE client_id = NEW.client_id;
    END IF;
END//

-- Trigger AFTER DELETE commande : D√©cr√©menter les stats
CREATE TRIGGER after_delete_commande_stats
AFTER DELETE ON commandes
FOR EACH ROW
BEGIN
    UPDATE stats_clients
    SET
        nb_commandes = nb_commandes - 1,
        montant_total = montant_total - OLD.montant_total
    WHERE client_id = OLD.client_id;

    -- Si plus de commandes, supprimer l'entr√©e
    DELETE FROM stats_clients
    WHERE client_id = OLD.client_id AND nb_commandes = 0;
END//

DELIMITER ;

-- Test
INSERT INTO commandes (client_id, montant_total, statut)
VALUES (1, 150.00, 'VALIDEE');

INSERT INTO commandes (client_id, montant_total, statut)
VALUES (1, 250.00, 'VALIDEE');

-- Consultation des stats
SELECT * FROM stats_clients WHERE client_id = 1;
-- nb_commandes = 2, montant_total = 400.00
```

### Exemple 3 : Gestion d'un stock en temps r√©el

```sql
DELIMITER //

-- Table de stock
CREATE TABLE IF NOT EXISTS stock_produits (
    produit_id INT PRIMARY KEY,
    quantite_disponible INT NOT NULL DEFAULT 0,
    quantite_reservee INT NOT NULL DEFAULT 0,
    derniere_maj DATETIME DEFAULT NOW(),
    FOREIGN KEY (produit_id) REFERENCES produits(id)
)//

-- Table de lignes de commande
CREATE TABLE IF NOT EXISTS lignes_commande (
    id INT PRIMARY KEY AUTO_INCREMENT,
    commande_id INT NOT NULL,
    produit_id INT NOT NULL,
    quantite INT NOT NULL,
    prix_unitaire DECIMAL(10,2) NOT NULL,
    FOREIGN KEY (commande_id) REFERENCES commandes(id),
    FOREIGN KEY (produit_id) REFERENCES produits(id)
)//

-- Trigger AFTER INSERT ligne : R√©servation du stock
CREATE TRIGGER after_insert_ligne_commande_stock
AFTER INSERT ON lignes_commande
FOR EACH ROW
BEGIN
    -- V√©rifier que le stock est suffisant
    DECLARE stock_dispo INT;

    SELECT quantite_disponible INTO stock_dispo
    FROM stock_produits
    WHERE produit_id = NEW.produit_id;

    IF stock_dispo < NEW.quantite THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Stock insuffisant pour ce produit';
    END IF;

    -- R√©server le stock
    UPDATE stock_produits
    SET
        quantite_disponible = quantite_disponible - NEW.quantite,
        quantite_reservee = quantite_reservee + NEW.quantite,
        derniere_maj = NOW()
    WHERE produit_id = NEW.produit_id;
END//

-- Trigger AFTER UPDATE ligne : Ajustement du stock
CREATE TRIGGER after_update_ligne_commande_stock
AFTER UPDATE ON lignes_commande
FOR EACH ROW
BEGIN
    IF NEW.quantite != OLD.quantite THEN
        DECLARE diff INT;
        SET diff = NEW.quantite - OLD.quantite;

        -- V√©rifier stock disponible si augmentation
        IF diff > 0 THEN
            DECLARE stock_dispo INT;
            SELECT quantite_disponible INTO stock_dispo
            FROM stock_produits
            WHERE produit_id = NEW.produit_id;

            IF stock_dispo < diff THEN
                SIGNAL SQLSTATE '45000'
                    SET MESSAGE_TEXT = 'Stock insuffisant pour augmentation';
            END IF;
        END IF;

        -- Ajuster le stock
        UPDATE stock_produits
        SET
            quantite_disponible = quantite_disponible - diff,
            quantite_reservee = quantite_reservee + diff,
            derniere_maj = NOW()
        WHERE produit_id = NEW.produit_id;
    END IF;
END//

-- Trigger AFTER DELETE ligne : Lib√©ration du stock
CREATE TRIGGER after_delete_ligne_commande_stock
AFTER DELETE ON lignes_commande
FOR EACH ROW
BEGIN
    UPDATE stock_produits
    SET
        quantite_disponible = quantite_disponible + OLD.quantite,
        quantite_reservee = quantite_reservee - OLD.quantite,
        derniere_maj = NOW()
    WHERE produit_id = OLD.produit_id;
END//

DELIMITER ;
```

üí° **Pattern AFTER** : Id√©al pour maintenir la coh√©rence entre tables li√©es (d√©normalisation, caches).

### Exemple 4 : Historisation compl√®te avec AFTER

```sql
DELIMITER //

-- Table d'historique (copie compl√®te des lignes)
CREATE TABLE IF NOT EXISTS historique_produits (
    id INT PRIMARY KEY AUTO_INCREMENT,
    operation VARCHAR(10) NOT NULL,
    produit_id INT NOT NULL,
    nom VARCHAR(100),
    prix_ht DECIMAL(10,2),
    prix_ttc DECIMAL(10,2),
    date_operation DATETIME NOT NULL,
    utilisateur VARCHAR(100) NOT NULL,
    INDEX idx_produit_date (produit_id, date_operation)
)//

-- Trigger AFTER UPDATE : Historisation des changements
CREATE TRIGGER after_update_produit_historique
AFTER UPDATE ON produits
FOR EACH ROW
BEGIN
    -- Enregistrer l'ancienne version
    INSERT INTO historique_produits (
        operation,
        produit_id,
        nom,
        prix_ht,
        prix_ttc,
        date_operation,
        utilisateur
    ) VALUES (
        'UPDATE_OLD',
        OLD.id,
        OLD.nom,
        OLD.prix_ht,
        OLD.prix_ttc,
        NOW(),
        USER()
    );

    -- Enregistrer la nouvelle version
    INSERT INTO historique_produits (
        operation,
        produit_id,
        nom,
        prix_ht,
        prix_ttc,
        date_operation,
        utilisateur
    ) VALUES (
        'UPDATE_NEW',
        NEW.id,
        NEW.nom,
        NEW.prix_ht,
        NEW.prix_ttc,
        NOW(),
        USER()
    );
END//

DELIMITER ;

-- Test
UPDATE produits SET prix_ht = 850.00 WHERE id = 1;

-- Consultation de l'historique
SELECT * FROM historique_produits WHERE produit_id = 1 ORDER BY date_operation;
```

---

## Variables OLD et NEW : Utilisation d√©taill√©e

### Disponibilit√© selon l'op√©ration

| Op√©ration | OLD disponible ? | NEW disponible ? |
|-----------|------------------|------------------|
| **INSERT** | ‚ùå Non | ‚úÖ Oui |
| **UPDATE** | ‚úÖ Oui | ‚úÖ Oui |
| **DELETE** | ‚úÖ Oui | ‚ùå Non |

### OLD : Valeurs avant modification

```sql
DELIMITER //

-- Exemple d√©taill√© OLD dans UPDATE
CREATE TRIGGER demo_old_update
BEFORE UPDATE ON produits
FOR EACH ROW
BEGIN
    -- OLD contient les valeurs AVANT la mise √† jour
    IF NEW.prix_ht < OLD.prix_ht * 0.5 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Impossible de baisser le prix de plus de 50%';
    END IF;

    -- Comparaison OLD vs NEW
    IF NEW.nom != OLD.nom THEN
        -- Le nom change
        INSERT INTO logs (message)
        VALUES (CONCAT('Produit renomm√© : ', OLD.nom, ' ‚Üí ', NEW.nom));
    END IF;
END//

-- Exemple d√©taill√© OLD dans DELETE
CREATE TRIGGER demo_old_delete
AFTER DELETE ON produits
FOR EACH ROW
BEGIN
    -- OLD contient les valeurs de la ligne supprim√©e
    INSERT INTO produits_archives (
        produit_id,
        nom,
        prix,
        date_suppression
    ) VALUES (
        OLD.id,
        OLD.nom,
        OLD.prix_ht,
        NOW()
    );
END//

DELIMITER ;
```

### NEW : Valeurs apr√®s modification

```sql
DELIMITER //

-- Exemple d√©taill√© NEW dans INSERT
CREATE TRIGGER demo_new_insert
BEFORE INSERT ON produits
FOR EACH ROW
BEGIN
    -- NEW contient les valeurs √† ins√©rer
    -- On peut les MODIFIER dans BEFORE
    SET NEW.nom = UPPER(TRIM(NEW.nom));

    -- Valeur par d√©faut calcul√©e
    IF NEW.prix_ttc IS NULL THEN
        SET NEW.prix_ttc = NEW.prix_ht * 1.20;
    END IF;
END//

-- Exemple d√©taill√© NEW dans UPDATE
CREATE TRIGGER demo_new_update
BEFORE UPDATE ON produits
FOR EACH ROW
BEGIN
    -- NEW contient les nouvelles valeurs
    -- On peut les MODIFIER dans BEFORE

    -- Forcer recalcul si prix_ht change
    IF NEW.prix_ht != OLD.prix_ht THEN
        SET NEW.prix_ttc = NEW.prix_ht * (1 + NEW.taux_tva / 100);
    END IF;

    -- Emp√™cher modification de certains champs
    SET NEW.date_creation = OLD.date_creation;  -- Immuable
END//

DELIMITER ;
```

‚ö†Ô∏è **Restriction importante** : Dans un trigger AFTER, on ne peut **pas modifier** NEW. Tentative = erreur.

```sql
-- ‚ùå ERREUR
CREATE TRIGGER after_insert_erreur
AFTER INSERT ON produits
FOR EACH ROW
BEGIN
    SET NEW.prix_ttc = NEW.prix_ht * 1.20;  -- ‚ùå Impossible dans AFTER
END;
```

---

## Cas d'usage : BEFORE ou AFTER ?

### Guide de d√©cision

```
Question 1 : Dois-je MODIFIER les donn√©es avant leur √©criture ?
    OUI ‚Üí BEFORE
    NON ‚Üí Question 2

Question 2 : Dois-je EMP√äCHER l'op√©ration selon des r√®gles ?
    OUI ‚Üí BEFORE (avec SIGNAL)
    NON ‚Üí Question 3

Question 3 : Ai-je besoin de l'ID auto-g√©n√©r√© ?
    OUI ‚Üí AFTER (pour INSERT)
    NON ‚Üí Question 4

Question 4 : Dois-je MODIFIER D'AUTRES TABLES ?
    OUI ‚Üí AFTER (synchronisation, audit)
    NON ‚Üí Les deux fonctionnent
```

### Tableau de cas d'usage

| Besoin | Trigger recommand√© | Raison |
|--------|-------------------|--------|
| Validation de donn√©es | BEFORE | Bloquer avant √©criture |
| Normalisation de format | BEFORE | Modifier NEW |
| Calcul de champs d√©riv√©s | BEFORE | √âcrire une seule fois |
| Machine √† √©tats (workflow) | BEFORE | Emp√™cher transitions invalides |
| Audit et historique | AFTER | ID disponible, donn√©es finales |
| Synchronisation entre tables | AFTER | Donn√©es d√©j√† √©crites |
| Mise √† jour d'agr√©gations | AFTER | Coh√©rence garantie |
| Notification / Logging | AFTER | Op√©ration confirm√©e |
| R√©servation de ressources | AFTER | Transaction valid√©e |

### Exemples de d√©cisions

```sql
-- Besoin : Valider un email
-- ‚Üí BEFORE INSERT/UPDATE (bloquer si invalide)

-- Besoin : Enregistrer qui a modifi√© quoi
-- ‚Üí AFTER UPDATE (audit)

-- Besoin : Calculer un prix TTC
-- ‚Üí BEFORE INSERT/UPDATE (√©crire une seule fois)

-- Besoin : Mettre √† jour un compteur dans une autre table
-- ‚Üí AFTER INSERT/DELETE (synchronisation)

-- Besoin : Emp√™cher suppression si solde > 0
-- ‚Üí BEFORE DELETE (validation)

-- Besoin : Archiver une ligne supprim√©e
-- ‚Üí AFTER DELETE (copie compl√®te)
```

---

## Bonnes pratiques BEFORE et AFTER

### 1. Utiliser SIGNAL pour les erreurs m√©tier (BEFORE)

```sql
-- ‚úÖ BON : Message d'erreur clair
CREATE TRIGGER validation_age
BEFORE INSERT ON employes
FOR EACH ROW
BEGIN
    IF TIMESTAMPDIFF(YEAR, NEW.date_naissance, CURDATE()) < 16 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = '√Çge minimum requis : 16 ans';
    END IF;
END;

-- ‚ùå MAUVAIS : Erreur silencieuse
CREATE TRIGGER validation_age_mauvais
BEFORE INSERT ON employes
FOR EACH ROW
BEGIN
    IF TIMESTAMPDIFF(YEAR, NEW.date_naissance, CURDATE()) < 16 THEN
        SET NEW.actif = 0;  -- Silencieux, donn√©es ins√©r√©es quand m√™me
    END IF;
END;
```

### 2. Minimiser la logique dans les triggers

```sql
-- ‚ùå MAUVAIS : Logique complexe dans le trigger
CREATE TRIGGER complexe
BEFORE INSERT ON commandes
FOR EACH ROW
BEGIN
    -- 50 lignes de validation complexe
    -- Calculs multiples
    -- Appels de fonctions
END;

-- ‚úÖ BON : D√©l√©guer √† une proc√©dure
CREATE TRIGGER simple
BEFORE INSERT ON commandes
FOR EACH ROW
BEGIN
    CALL valider_commande(NEW.client_id, NEW.montant_total);
    CALL calculer_frais(NEW.montant_total, @frais);
    SET NEW.frais_livraison = @frais;
END;
```

### 3. Documenter les triggers

```sql
DELIMITER //

/*
 * TRIGGER : before_update_stock_validation
 * TABLE : stock_produits
 * TYPE : BEFORE UPDATE
 *
 * Description :
 *   Valide que les quantit√©s de stock restent coh√©rentes
 *
 * R√®gles :
 *   - quantite_disponible >= 0
 *   - quantite_reservee >= 0
 *   - quantite_disponible + quantite_reservee = stock_total
 *
 * Auteur : √âquipe Logistique
 * Date : 2025-12-12
 * Version : 1.2
 */
CREATE TRIGGER before_update_stock_validation
BEFORE UPDATE ON stock_produits
FOR EACH ROW
BEGIN
    -- Validation quantit√©s positives
    IF NEW.quantite_disponible < 0 OR NEW.quantite_reservee < 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Les quantit√©s de stock ne peuvent pas √™tre n√©gatives';
    END IF;
END//

DELIMITER ;
```

### 4. √âviter les modifications circulaires

```sql
-- ‚ùå DANGER : Boucle infinie
CREATE TRIGGER danger_circular_1
AFTER UPDATE ON table_a
FOR EACH ROW
BEGIN
    UPDATE table_b SET valeur = NEW.valeur WHERE id = NEW.id;
END;

CREATE TRIGGER danger_circular_2
AFTER UPDATE ON table_b
FOR EACH ROW
BEGIN
    UPDATE table_a SET valeur = NEW.valeur WHERE id = NEW.id;  -- ‚ùå Boucle !
END;

-- ‚úÖ BON : √âviter les mises √† jour circulaires
CREATE TRIGGER safe_update
AFTER UPDATE ON table_a
FOR EACH ROW
BEGIN
    -- V√©rifier si vraiment n√©cessaire
    IF OLD.valeur != NEW.valeur THEN
        -- Mise √† jour conditionnelle
        UPDATE table_b SET valeur = NEW.valeur
        WHERE id = NEW.id AND valeur != NEW.valeur;
    END IF;
END;
```

### 5. Privil√©gier OLD et NEW plut√¥t que SELECT

```sql
-- ‚ùå INEFFICACE : SELECT inutile
CREATE TRIGGER inefficace
AFTER UPDATE ON produits
FOR EACH ROW
BEGIN
    DECLARE ancien_prix DECIMAL(10,2);
    SELECT prix_ht INTO ancien_prix FROM produits WHERE id = NEW.id;
    -- ...
END;

-- ‚úÖ EFFICACE : Utiliser OLD directement
CREATE TRIGGER efficace
AFTER UPDATE ON produits
FOR EACH ROW
BEGIN
    DECLARE ancien_prix DECIMAL(10,2);
    SET ancien_prix = OLD.prix_ht;  -- D√©j√† disponible !
    -- ...
END;
```

### 6. Tester les triggers isol√©ment

```sql
-- Script de test d√©di√©
START TRANSACTION;

-- Test 1 : Insertion valide
INSERT INTO clients (nom, prenom, email, date_naissance)
VALUES ('Test', 'User', 'test@example.com', '1990-01-01');
-- V√©rifier : Trigger BEFORE normalisation appliqu√©e ?
SELECT * FROM clients WHERE email = 'test@example.com';

-- Test 2 : Insertion invalide (email)
INSERT INTO clients (nom, prenom, email, date_naissance)
VALUES ('Test2', 'User2', 'invalide', '1990-01-01');
-- Doit √©chouer avec message d'erreur appropri√©

-- Test 3 : Audit enregistr√© ?
SELECT * FROM audit_clients WHERE client_id = LAST_INSERT_ID();

ROLLBACK;  -- Ne pas persister les tests
```

---

## Performance et consid√©rations

### Impact sur les performances

**BEFORE** :
- L√©ger overhead avant chaque √©criture
- Optimal si validation/normalisation n√©cessaire
- √âvite les √©critures inutiles si SIGNAL d√©clench√©

**AFTER** :
- Ex√©cution apr√®s √©criture (l√©g√®rement plus lent)
- Permet des op√©rations en parall√®le
- Attention aux cascades d'updates

### Optimisations

```sql
-- ‚úÖ BON : Condition pour √©viter ex√©cutions inutiles
CREATE TRIGGER optimise
AFTER UPDATE ON produits
FOR EACH ROW
BEGIN
    -- Ne rien faire si le prix n'a pas chang√©
    IF NEW.prix_ht != OLD.prix_ht THEN
        -- Mise √† jour de stats, audit, etc.
    END IF;
END;

-- ‚ùå MAUVAIS : Ex√©cution syst√©matique
CREATE TRIGGER non_optimise
AFTER UPDATE ON produits
FOR EACH ROW
BEGIN
    -- Toujours ex√©cut√© m√™me si rien √† faire
    UPDATE stats SET maj = NOW();
END;
```

---

## ‚úÖ Points cl√©s √† retenir

- **BEFORE** : Ex√©cution avant modification, peut modifier NEW, peut bloquer avec SIGNAL
- **AFTER** : Ex√©cution apr√®s modification, lecture seule, ID auto-increment disponible
- **OLD** : Valeurs avant modification (UPDATE/DELETE)
- **NEW** : Valeurs apr√®s modification (INSERT/UPDATE), modifiable uniquement dans BEFORE
- **Validation** : BEFORE pour emp√™cher les donn√©es invalides
- **Audit** : AFTER pour enregistrer les modifications confirm√©es
- **Normalisation** : BEFORE pour transformer les donn√©es avant √©criture
- **Synchronisation** : AFTER pour maintenir la coh√©rence entre tables
- **Performance** : Conditionner l'ex√©cution, √©viter les logiques lourdes
- **Documentation** : Commenter les triggers, expliquer les r√®gles m√©tier

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation officielle MariaDB - CREATE TRIGGER](https://mariadb.com/kb/en/create-trigger/)
- [üìñ Trigger Syntax](https://mariadb.com/kb/en/trigger-overview/)
- [üìñ OLD and NEW](https://mariadb.com/kb/en/trigger-overview/#old-and-new)
- [üìñ Trigger Limitations](https://mariadb.com/kb/en/trigger-limitations/)
- [üí° Blog : Best Practices for Triggers](https://mariadb.com/resources/blog/)

---

## ‚û°Ô∏è Section suivante

**[8.3.2 INSERT, UPDATE, DELETE triggers](./03.2-insert-update-delete-triggers.md)** : Approfondissez les sp√©cificit√©s de chaque type d'√©v√©nement et d√©couvrez des patterns avanc√©s pour chaque op√©ration.

---


‚è≠Ô∏è [INSERT, UPDATE, DELETE triggers](/08-programmation-cote-serveur/03.2-insert-update-delete-triggers.md)
