üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.1.1 Syntaxe CREATE PROCEDURE

> **Niveau** : Interm√©diaire √† Avanc√©
> **Dur√©e estim√©e** : 2 heures
> **Pr√©requis** : Ma√Ætrise du SQL de base (SELECT, INSERT, UPDATE, DELETE), compr√©hension des transactions

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre la syntaxe compl√®te de CREATE PROCEDURE dans MariaDB
- Cr√©er des proc√©dures stock√©es simples et complexes
- Utiliser les d√©limiteurs pour d√©finir des blocs de code
- G√©rer les caract√©ristiques et attributs des proc√©dures
- Appliquer les bonnes pratiques de nommage et de structure

---

## Introduction

Les **proc√©dures stock√©es** (stored procedures) sont des blocs de code SQL pr√©compil√©s et stock√©s dans la base de donn√©es. Elles constituent un √©l√©ment fondamental de la programmation c√¥t√© serveur MariaDB, permettant d'encapsuler la logique m√©tier directement au niveau de la base de donn√©es.

### Pourquoi utiliser des proc√©dures stock√©es ?

Les proc√©dures stock√©es offrent plusieurs avantages strat√©giques :

- **Performance** : Code pr√©compil√© et optimis√© par le serveur
- **Centralisation** : Logique m√©tier au niveau de la base de donn√©es
- **R√©utilisabilit√©** : Appelables depuis n'importe quelle application cliente
- **S√©curit√©** : Contr√¥le d'acc√®s granulaire, encapsulation des donn√©es sensibles
- **R√©duction du trafic r√©seau** : Ex√©cution de multiples requ√™tes en un seul appel
- **Maintenabilit√©** : Modification centralis√©e sans red√©ploiement applicatif

üí° **Conseil pratique** : Les proc√©dures stock√©es sont particuli√®rement utiles pour les op√©rations complexes impliquant plusieurs tables ou n√©cessitant une logique conditionnelle √©labor√©e.

---

## Syntaxe de base CREATE PROCEDURE

### Structure g√©n√©rale

La syntaxe compl√®te d'une proc√©dure stock√©e MariaDB suit ce mod√®le :

```sql
CREATE [OR REPLACE]
    [DEFINER = utilisateur]
    PROCEDURE nom_procedure ([parametres])
    [caracteristiques]
BEGIN
    -- Corps de la proc√©dure
    -- Instructions SQL
END
```

### √âl√©ments constitutifs

**CREATE OR REPLACE** üÜï
- `CREATE PROCEDURE` : Cr√©e une nouvelle proc√©dure (erreur si elle existe d√©j√†)
- `CREATE OR REPLACE PROCEDURE` : Cr√©e ou remplace une proc√©dure existante (MariaDB 10.1.3+)

**DEFINER**
- Sp√©cifie l'utilisateur sous l'identit√© duquel la proc√©dure s'ex√©cute
- Par d√©faut : utilisateur qui cr√©e la proc√©dure
- Important pour la s√©curit√© et les privil√®ges

**Nom de la proc√©dure**
- Suit les r√®gles de nommage MariaDB (max 64 caract√®res)
- Sensible √† la casse selon la configuration syst√®me
- Convention : utiliser le snake_case (`calculer_remise`, `maj_stock`)

---

## Utilisation des d√©limiteurs

### Probl√©matique

Le client MariaDB utilise le point-virgule (`;`) comme d√©limiteur de fin d'instruction. Or, le corps d'une proc√©dure contient plusieurs instructions termin√©es par des points-virgules. Il faut donc **temporairement changer le d√©limiteur**.

### Solution : DELIMITER

```sql
-- √âtape 1 : Changer le d√©limiteur temporairement
DELIMITER //

-- √âtape 2 : Cr√©er la proc√©dure avec ; √† l'int√©rieur
CREATE PROCEDURE exemple_simple()
BEGIN
    SELECT 'Bonjour' AS message;
    SELECT NOW() AS date_heure;
END//

-- √âtape 3 : R√©tablir le d√©limiteur par d√©faut
DELIMITER ;
```

‚ö†Ô∏è **Attention** : Le changement de d√©limiteur n'est n√©cessaire que dans le client CLI `mariadb` ou `mysql`. Les clients graphiques (HeidiSQL, DBeaver) et les langages de programmation g√®rent cela automatiquement.

üí° **Astuce** : Les d√©limiteurs courants sont `//`, `$$`, ou `||`. Choisissez celui qui ne risque pas d'appara√Ætre dans votre code.

---

## Exemple : Premi√®re proc√©dure stock√©e simple

### Proc√©dure sans param√®tres

```sql
DELIMITER //

-- Proc√©dure affichant les statistiques de la base de donn√©es
CREATE OR REPLACE PROCEDURE afficher_stats_db()
BEGIN
    -- Comptage des tables
    SELECT COUNT(*) AS nombre_tables
    FROM information_schema.TABLES
    WHERE TABLE_SCHEMA = DATABASE();

    -- Taille totale de la base
    SELECT
        ROUND(SUM(DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) AS taille_mb
    FROM information_schema.TABLES
    WHERE TABLE_SCHEMA = DATABASE();
END//

DELIMITER ;

-- Appel de la proc√©dure
CALL afficher_stats_db();
```

**Explications** :
- `DATABASE()` : Retourne le nom de la base de donn√©es courante
- Deux SELECT distincts produisent deux r√©sultats s√©par√©s
- La proc√©dure peut √™tre appel√©e par n'importe quel utilisateur ayant le privil√®ge `EXECUTE`

---

## Caract√©ristiques des proc√©dures

Les caract√©ristiques (characteristics) d√©finissent le comportement et les propri√©t√©s de la proc√©dure.

### SQL SECURITY

D√©finit le contexte de s√©curit√© d'ex√©cution :

```sql
DELIMITER //

CREATE PROCEDURE exemple_security()
    SQL SECURITY DEFINER  -- Ou SQL SECURITY INVOKER
BEGIN
    SELECT USER() AS utilisateur_actuel;
    SELECT CURRENT_USER() AS contexte_execution;
END//

DELIMITER ;
```

- **SQL SECURITY DEFINER** (d√©faut) : La proc√©dure s'ex√©cute avec les privil√®ges du cr√©ateur
- **SQL SECURITY INVOKER** : La proc√©dure s'ex√©cute avec les privil√®ges de l'appelant

üí° **Conseil** : Utilisez `DEFINER` pour les op√©rations sensibles n√©cessitant des privil√®ges √©lev√©s, `INVOKER` pour plus de flexibilit√©.

### COMMENT

Ajoute une description textuelle :

```sql
DELIMITER //

CREATE PROCEDURE calculer_statistiques_ventes()
    COMMENT 'Calcule les statistiques mensuelles des ventes avec agr√©gation'
BEGIN
    -- Code de la proc√©dure
    SELECT 'Statistiques calcul√©es' AS resultat;
END//

DELIMITER ;
```

‚ö†Ô∏è **Important** : Le commentaire est limit√© √† 64 caract√®res dans certaines versions. Utilisez des commentaires SQL (`--` ou `/* */`) pour des descriptions d√©taill√©es.

### LANGUAGE SQL

Sp√©cifie le langage (toujours SQL dans MariaDB) :

```sql
CREATE PROCEDURE ma_procedure()
    LANGUAGE SQL
BEGIN
    -- Instructions SQL
END;
```

üí° **Note** : Cette clause est principalement pr√©sente pour la compatibilit√© avec le standard SQL. MariaDB ne supporte que le langage SQL pour les proc√©dures.

---

## Exemple complet avec caract√©ristiques

```sql
DELIMITER //

-- Proc√©dure compl√®te avec toutes les caract√©ristiques recommand√©es
CREATE OR REPLACE PROCEDURE audit_connexions(
    IN jours_historique INT
)
    SQL SECURITY INVOKER
    COMMENT 'Analyse les connexions des N derniers jours'
BEGIN
    -- D√©claration de variables locales
    DECLARE v_debut DATETIME;
    DECLARE v_fin DATETIME;

    -- Calcul de la p√©riode
    SET v_fin = NOW();
    SET v_debut = DATE_SUB(v_fin, INTERVAL jours_historique DAY);

    -- Rapport des connexions
    SELECT
        DATE(event_time) AS date_connexion,
        user_host,
        COUNT(*) AS nombre_connexions
    FROM mysql.general_log
    WHERE
        event_time BETWEEN v_debut AND v_fin
        AND command_type = 'Connect'
    GROUP BY DATE(event_time), user_host
    ORDER BY date_connexion DESC, nombre_connexions DESC;

    -- Statistique globale
    SELECT
        COUNT(DISTINCT user_host) AS utilisateurs_uniques,
        COUNT(*) AS total_connexions
    FROM mysql.general_log
    WHERE
        event_time BETWEEN v_debut AND v_fin
        AND command_type = 'Connect';
END//

DELIMITER ;

-- Appel avec param√®tre
CALL audit_connexions(7);  -- Derniers 7 jours
```

**Points cl√©s de cet exemple** :
1. **Param√®tre IN** pour passer la dur√©e d'historique
2. **Variables locales** avec `DECLARE` et `SET`
3. **Plusieurs SELECT** pour des r√©sultats multiples
4. **SQL SECURITY INVOKER** : Les privil√®ges de l'appelant sont requis
5. **Logique m√©tier** encapsul√©e (calcul de dates, agr√©gation)

---

## Bonnes pratiques de syntaxe

### 1. Nommage coh√©rent

```sql
-- ‚úÖ BON : Noms explicites et coh√©rents
CREATE PROCEDURE calculer_total_commande(IN commande_id INT)
CREATE PROCEDURE maj_statut_client(IN client_id INT, IN nouveau_statut VARCHAR(50))

-- ‚ùå MAUVAIS : Noms trop courts ou ambigus
CREATE PROCEDURE calc(IN id INT)
CREATE PROCEDURE proc1(IN x INT, IN y VARCHAR(50))
```

**Convention recommand√©e** :
- Verbe d'action + compl√©ment : `calculer_`, `maj_` (mise √† jour), `verifier_`, `generer_`
- snake_case en minuscules
- √âviter les abr√©viations obscures

### 2. Documentation interne

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE traiter_commande(
    IN p_commande_id INT,
    OUT p_montant_total DECIMAL(10,2)
)
    COMMENT 'Traite une commande et retourne le montant total'
BEGIN
    /*
     * Proc√©dure : traiter_commande
     * Description : Valide et calcule le montant total d'une commande
     * Auteur : √âquipe DBA
     * Date : 2025-12-12
     * Version : 1.0
     *
     * Param√®tres :
     *   - p_commande_id : Identifiant de la commande (IN)
     *   - p_montant_total : Montant total calcul√© (OUT)
     *
     * D√©pendances :
     *   - Table commandes
     *   - Table lignes_commande
     *   - Fonction calculer_tva()
     */

    -- Logique de traitement
    SELECT SUM(quantite * prix_unitaire)
    INTO p_montant_total
    FROM lignes_commande
    WHERE commande_id = p_commande_id;
END//

DELIMITER ;
```

üí° **Conseil** : Un en-t√™te document√© facilite grandement la maintenance, surtout dans les grandes √©quipes.

### 3. Pr√©fixage des param√®tres

```sql
DELIMITER //

-- ‚úÖ BON : Pr√©fixe pour √©viter les ambigu√Øt√©s
CREATE PROCEDURE rechercher_clients(
    IN p_nom VARCHAR(100),
    IN p_ville VARCHAR(50)
)
BEGIN
    SELECT *
    FROM clients
    WHERE
        nom LIKE CONCAT('%', p_nom, '%')
        AND ville = p_ville;  -- Pas de confusion avec les colonnes
END//

-- ‚ùå MAUVAIS : Risque de confusion
CREATE PROCEDURE rechercher_clients2(
    IN nom VARCHAR(100),
    IN ville VARCHAR(50)
)
BEGIN
    SELECT *
    FROM clients
    WHERE
        nom LIKE CONCAT('%', nom, '%')  -- Quel 'nom' ? Param√®tre ou colonne ?
        AND ville = ville;  -- Ambigu√Øt√© totale !
END//

DELIMITER ;
```

**Conventions de pr√©fixage** :
- `p_` pour les param√®tres (IN, OUT, INOUT)
- `v_` pour les variables locales
- `c_` pour les constantes (via variables)

### 4. Structure claire et indent√©e

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE exemple_structure()
BEGIN
    -- Section 1 : D√©clarations
    DECLARE v_compteur INT DEFAULT 0;
    DECLARE v_done INT DEFAULT FALSE;

    -- Section 2 : Handlers (gestionnaires d'erreurs)
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = TRUE;

    -- Section 3 : Logique principale
    -- Sous-section A : Validation
    IF v_compteur < 0 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Compteur invalide';
    END IF;

    -- Sous-section B : Traitement
    SELECT COUNT(*) INTO v_compteur FROM ma_table;

    -- Sous-section C : R√©sultat
    SELECT v_compteur AS total;
END//

DELIMITER ;
```

**R√®gles d'indentation** :
- 4 espaces par niveau (ou 2 selon votre standard)
- Blocs `BEGIN...END` align√©s
- Commentaires de section pour la lisibilit√©

### 5. Gestion explicite des erreurs

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE transfert_securise(
    IN p_compte_source INT,
    IN p_compte_dest INT,
    IN p_montant DECIMAL(10,2)
)
BEGIN
    -- Handler pour annuler en cas d'erreur
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        -- Rollback automatique
        ROLLBACK;
        -- Signal de l'erreur
        RESIGNAL;
    END;

    -- Transaction explicite
    START TRANSACTION;

    -- Op√©rations du transfert
    UPDATE comptes SET solde = solde - p_montant
    WHERE compte_id = p_compte_source;

    UPDATE comptes SET solde = solde + p_montant
    WHERE compte_id = p_compte_dest;

    -- Validation
    COMMIT;

    SELECT 'Transfert r√©ussi' AS statut;
END//

DELIMITER ;
```

üí° **Meilleure pratique** : Toujours encadrer les op√©rations critiques avec des handlers et des transactions explicites.

---

## Consultation des proc√©dures existantes

### Lister toutes les proc√©dures

```sql
-- Proc√©dures de la base de donn√©es courante
SHOW PROCEDURE STATUS WHERE Db = DATABASE();

-- Ou via INFORMATION_SCHEMA
SELECT
    ROUTINE_NAME AS nom_procedure,
    ROUTINE_TYPE AS type,
    DEFINER AS createur,
    CREATED AS date_creation,
    LAST_ALTERED AS derniere_modif,
    ROUTINE_COMMENT AS commentaire
FROM information_schema.ROUTINES
WHERE
    ROUTINE_SCHEMA = DATABASE()
    AND ROUTINE_TYPE = 'PROCEDURE'
ORDER BY ROUTINE_NAME;
```

### Afficher le code d'une proc√©dure

```sql
-- Voir la d√©finition compl√®te
SHOW CREATE PROCEDURE nom_procedure;

-- Exemple de sortie : affiche le CREATE PROCEDURE complet
```

### V√©rifier l'existence avant cr√©ation

```sql
-- Approche d√©fensive
DROP PROCEDURE IF EXISTS ma_procedure;

DELIMITER //
CREATE PROCEDURE ma_procedure()
BEGIN
    SELECT 'Nouvelle version' AS version;
END//
DELIMITER ;

-- Ou utiliser CREATE OR REPLACE (recommand√©)
DELIMITER //
CREATE OR REPLACE PROCEDURE ma_procedure()
BEGIN
    SELECT 'Nouvelle version' AS version;
END//
DELIMITER ;
```

---

## Suppression de proc√©dures

```sql
-- Suppression simple (erreur si n'existe pas)
DROP PROCEDURE nom_procedure;

-- Suppression s√©curis√©e (pas d'erreur si absente)
DROP PROCEDURE IF EXISTS nom_procedure;

-- Suppression multiple (MariaDB 10.5+)
DROP PROCEDURE IF EXISTS proc1, proc2, proc3;
```

‚ö†Ô∏è **Attention** : La suppression d'une proc√©dure utilis√©e par des applications peut causer des erreurs en production. Toujours v√©rifier les d√©pendances avant suppression.

---

## Privil√®ges requis

### Cr√©ation de proc√©dures

```sql
-- Privil√®ge CREATE ROUTINE n√©cessaire
GRANT CREATE ROUTINE ON database_name.* TO 'developpeur'@'localhost';

-- Exemple de cr√©ation par l'utilisateur
-- (connect√© en tant que 'developpeur'@'localhost')
CREATE PROCEDURE ma_proc() BEGIN SELECT 1; END;
```

### Ex√©cution de proc√©dures

```sql
-- Privil√®ge EXECUTE pour appeler la proc√©dure
GRANT EXECUTE ON PROCEDURE database_name.ma_proc TO 'app_user'@'%';

-- Ou pour toutes les proc√©dures d'une base
GRANT EXECUTE ON database_name.* TO 'app_user'@'%';
```

### Modification et suppression

```sql
-- Privil√®ge ALTER ROUTINE pour modifier
GRANT ALTER ROUTINE ON database_name.* TO 'dba'@'localhost';

-- Le cr√©ateur peut toujours modifier/supprimer ses propres proc√©dures
```

üí° **S√©curit√©** : S√©parez les r√¥les :
- **D√©veloppeurs** : CREATE ROUTINE, ALTER ROUTINE
- **Applications** : EXECUTE seulement
- **DBA** : Tous les privil√®ges

---

## Cas d'usage et exemples pratiques

### Exemple 1 : Proc√©dure d'audit simple

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE enregistrer_action_audit(
    IN p_utilisateur VARCHAR(100),
    IN p_action VARCHAR(50),
    IN p_details TEXT
)
    COMMENT 'Enregistre une action dans la table d\'audit'
BEGIN
    INSERT INTO audit_log (
        utilisateur,
        action,
        details,
        date_action,
        adresse_ip
    ) VALUES (
        p_utilisateur,
        p_action,
        p_details,
        NOW(),
        SUBSTRING_INDEX(USER(), '@', -1)  -- Extrait l'IP/host
    );
END//

DELIMITER ;

-- Utilisation
CALL enregistrer_action_audit('admin', 'LOGIN', 'Connexion r√©ussie');
```

### Exemple 2 : Proc√©dure de maintenance

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE maintenance_hebdomadaire()
    SQL SECURITY DEFINER  -- Privil√®ges √©lev√©s n√©cessaires
    COMMENT 'Maintenance automatique hebdomadaire'
BEGIN
    -- Optimisation des tables
    OPTIMIZE TABLE commandes;
    OPTIMIZE TABLE clients;
    OPTIMIZE TABLE produits;

    -- Mise √† jour des statistiques
    ANALYZE TABLE commandes;
    ANALYZE TABLE clients;

    -- Purge des anciennes donn√©es (> 2 ans)
    DELETE FROM logs_application
    WHERE date_log < DATE_SUB(NOW(), INTERVAL 2 YEAR);

    -- Log de fin
    INSERT INTO maintenance_log (date_execution, statut)
    VALUES (NOW(), 'Succ√®s');
END//

DELIMITER ;

-- Planification via Event Scheduler (voir section 8.4)
```

### Exemple 3 : Proc√©dure de validation m√©tier

```sql
DELIMITER //

CREATE OR REPLACE PROCEDURE valider_commande(
    IN p_commande_id INT
)
BEGIN
    DECLARE v_montant_total DECIMAL(10,2);
    DECLARE v_stock_suffisant INT;

    -- V√©rification 1 : Commande existe
    IF NOT EXISTS (SELECT 1 FROM commandes WHERE id = p_commande_id) THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Commande inexistante';
    END IF;

    -- V√©rification 2 : Stock disponible
    SELECT COUNT(*) INTO v_stock_suffisant
    FROM lignes_commande lc
    INNER JOIN produits p ON lc.produit_id = p.id
    WHERE
        lc.commande_id = p_commande_id
        AND p.stock_disponible >= lc.quantite;

    IF v_stock_suffisant < (SELECT COUNT(*) FROM lignes_commande WHERE commande_id = p_commande_id) THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Stock insuffisant pour certains produits';
    END IF;

    -- Calcul du montant
    SELECT SUM(lc.quantite * lc.prix_unitaire) INTO v_montant_total
    FROM lignes_commande lc
    WHERE lc.commande_id = p_commande_id;

    -- Mise √† jour de la commande
    UPDATE commandes
    SET
        statut = 'VALIDEE',
        montant_total = v_montant_total,
        date_validation = NOW()
    WHERE id = p_commande_id;

    -- Confirmation
    SELECT 'Commande valid√©e avec succ√®s' AS resultat, v_montant_total AS montant;
END//

DELIMITER ;
```

**Points d'apprentissage** :
1. Validations multiples avec `IF...THEN`
2. Utilisation de `SIGNAL` pour les erreurs m√©tier
3. Transactions implicites (ou explicites si n√©cessaire)
4. Calculs et mises √† jour atomiques

---

## ‚úÖ Points cl√©s √† retenir

- **D√©limiteur** : Utilisez `DELIMITER //` dans le CLI pour d√©finir des proc√©dures multi-instructions
- **CREATE OR REPLACE** : Syntaxe moderne pour √©viter les erreurs de recr√©ation
- **Caract√©ristiques** : `SQL SECURITY`, `COMMENT`, `LANGUAGE SQL` d√©finissent le comportement
- **DEFINER vs INVOKER** : Choisissez selon les besoins de s√©curit√© (privil√®ges du cr√©ateur vs appelant)
- **Nommage** : Utilisez des pr√©fixes (`p_`, `v_`) pour √©viter les ambigu√Øt√©s
- **Documentation** : Commentez abondamment le code complexe
- **Privil√®ges** : `CREATE ROUTINE` pour cr√©er, `EXECUTE` pour appeler
- **Consultation** : `SHOW CREATE PROCEDURE` et `INFORMATION_SCHEMA.ROUTINES` pour l'inspection
- **Erreurs** : Utilisez `SIGNAL` pour les erreurs m√©tier personnalis√©es
- **Structure** : Organisez en sections (d√©clarations, handlers, logique, r√©sultats)

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation officielle MariaDB - CREATE PROCEDURE](https://mariadb.com/kb/en/create-procedure/)
- [üìñ Stored Routine Privileges](https://mariadb.com/kb/en/stored-routine-privileges/)
- [üìñ SHOW CREATE PROCEDURE](https://mariadb.com/kb/en/show-create-procedure/)
- [üìñ SQL Security](https://mariadb.com/kb/en/stored-routine-privileges/#sql-security)
- [üí° Blog : Best Practices for Stored Procedures](https://mariadb.com/resources/blog/)

---

## ‚û°Ô∏è Section suivante

**[8.1.2 Param√®tres IN, OUT, INOUT](./01.2-parametres-in-out-inout.md)** : D√©couvrez comment passer et retourner des valeurs avec les diff√©rents types de param√®tres, √©l√©ment essentiel pour cr√©er des proc√©dures stock√©es flexibles et r√©utilisables.

---


‚è≠Ô∏è [Param√®tres IN, OUT, INOUT](/08-programmation-cote-serveur/01.2-parametres-in-out-inout.md)
