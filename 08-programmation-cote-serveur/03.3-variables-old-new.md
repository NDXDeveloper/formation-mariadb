üîù Retour au [Sommaire](/SOMMAIRE.md)

# 8.3.3 Variables OLD et NEW

> **Niveau** : Interm√©diaire √† Avanc√©
> **Dur√©e estim√©e** : 2.5 heures
> **Pr√©requis** : Sections 8.3.1 et 8.3.2 (BEFORE/AFTER et INSERT/UPDATE/DELETE triggers)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Ma√Ætriser en profondeur les variables OLD et NEW dans tous les contextes
- Comprendre les restrictions de lecture/√©criture selon le type de trigger
- Impl√©menter des patterns de manipulation avanc√©s
- Comparer efficacement OLD et NEW pour d√©tecter les changements
- Utiliser OLD et NEW dans des expressions SQL complexes
- √âviter les pi√®ges courants li√©s √† ces variables pseudo-tables

---

## Introduction

Les variables **OLD** et **NEW** sont des **pseudo-tables** sp√©ciales disponibles dans les triggers. Elles repr√©sentent respectivement l'√©tat **avant** et **apr√®s** l'op√©ration sur une ligne.

### Nature des variables OLD et NEW

Ces variables ne sont **pas** de simples variables SQL. Elles fonctionnent comme des **r√©f√©rences de ligne** (row references) permettant d'acc√©der aux colonnes de la table.

```sql
-- Syntaxe d'acc√®s aux colonnes
OLD.nom_colonne  -- Valeur avant modification
NEW.nom_colonne  -- Valeur apr√®s modification

-- Exemples
OLD.prix         -- Prix avant mise √† jour
NEW.email        -- Email √† ins√©rer
OLD.date_creation -- Date de cr√©ation de la ligne supprim√©e
```

üí° **Analogie** : Pensez √† OLD et NEW comme √† des "photos" de la ligne √† deux moments diff√©rents :
- **OLD** = Photo "avant" l'op√©ration
- **NEW** = Photo "apr√®s" l'op√©ration

---

## Disponibilit√© et droits d'acc√®s

### Tableau de disponibilit√© complet

| Type de trigger | OLD existe | NEW existe | OLD lecture | OLD √©criture | NEW lecture | NEW √©criture |
|-----------------|------------|------------|-------------|--------------|-------------|--------------|
| **BEFORE INSERT** | ‚ùå Non | ‚úÖ Oui | N/A | N/A | ‚úÖ Oui | ‚úÖ Oui |
| **AFTER INSERT** | ‚ùå Non | ‚úÖ Oui | N/A | N/A | ‚úÖ Oui | ‚ùå Non |
| **BEFORE UPDATE** | ‚úÖ Oui | ‚úÖ Oui | ‚úÖ Oui | ‚ùå Non | ‚úÖ Oui | ‚úÖ Oui |
| **AFTER UPDATE** | ‚úÖ Oui | ‚úÖ Oui | ‚úÖ Oui | ‚ùå Non | ‚úÖ Oui | ‚ùå Non |
| **BEFORE DELETE** | ‚úÖ Oui | ‚ùå Non | ‚úÖ Oui | ‚ùå Non | N/A | N/A |
| **AFTER DELETE** | ‚úÖ Oui | ‚ùå Non | ‚úÖ Oui | ‚ùå Non | N/A | N/A |

### R√®gles fondamentales

**R√®gle 1** : OLD est **toujours en lecture seule**
```sql
-- ‚ùå ERREUR : Impossible de modifier OLD
CREATE TRIGGER erreur_old
BEFORE UPDATE ON table1
FOR EACH ROW
BEGIN
    SET OLD.prix = 100;  -- ‚ùå ERREUR : OLD est immuable
END;
```

**R√®gle 2** : NEW est modifiable **uniquement dans BEFORE**
```sql
-- ‚úÖ OK : Modification de NEW dans BEFORE
CREATE TRIGGER ok_before
BEFORE INSERT ON table1
FOR EACH ROW
BEGIN
    SET NEW.prix = NEW.prix * 1.20;  -- ‚úÖ OK
END;

-- ‚ùå ERREUR : NEW en lecture seule dans AFTER
CREATE TRIGGER erreur_after
AFTER INSERT ON table1
FOR EACH ROW
BEGIN
    SET NEW.prix = NEW.prix * 1.20;  -- ‚ùå ERREUR
END;
```

**R√®gle 3** : OLD n'existe pas pour INSERT, NEW n'existe pas pour DELETE
```sql
-- ‚ùå ERREUR : OLD n'existe pas dans INSERT
CREATE TRIGGER erreur_insert
BEFORE INSERT ON table1
FOR EACH ROW
BEGIN
    IF OLD.prix > 100 THEN  -- ‚ùå ERREUR : OLD n'existe pas
        ...
    END IF;
END;

-- ‚ùå ERREUR : NEW n'existe pas dans DELETE
CREATE TRIGGER erreur_delete
BEFORE DELETE ON table1
FOR EACH ROW
BEGIN
    SET NEW.actif = FALSE;  -- ‚ùå ERREUR : NEW n'existe pas
END;
```

---

## Acc√®s aux colonnes via OLD et NEW

### Syntaxe et typage

Les colonnes sont accessibles avec la notation point√©e, et **h√©ritent du type** de la colonne de la table.

```sql
DELIMITER //

CREATE TABLE produits_demo (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nom VARCHAR(100) NOT NULL,
    prix DECIMAL(10,2) NOT NULL,
    quantite INT DEFAULT 0,
    actif BOOLEAN DEFAULT TRUE,
    date_creation DATETIME DEFAULT NOW()
)//

CREATE TRIGGER demo_acces_colonnes
BEFORE UPDATE ON produits_demo
FOR EACH ROW
BEGIN
    -- Acc√®s direct aux colonnes
    DECLARE v_ancien_prix DECIMAL(10,2);
    DECLARE v_nouveau_prix DECIMAL(10,2);

    -- OLD.colonne : valeur avant modification
    SET v_ancien_prix = OLD.prix;      -- Type DECIMAL(10,2)

    -- NEW.colonne : valeur apr√®s modification
    SET v_nouveau_prix = NEW.prix;     -- Type DECIMAL(10,2)

    -- Comparaison directe
    IF NEW.prix > OLD.prix * 1.5 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Augmentation de prix sup√©rieure √† 50% interdite';
    END IF;

    -- Utilisation dans expressions
    SET NEW.prix = ROUND(NEW.prix, 2);

    -- Utilisation dans fonctions
    IF LENGTH(NEW.nom) < 3 THEN
        SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Nom trop court';
    END IF;
END//

DELIMITER ;
```

### Acc√®s √† toutes les colonnes

```sql
DELIMITER //

CREATE TRIGGER demo_toutes_colonnes
AFTER UPDATE ON produits_demo
FOR EACH ROW
BEGIN
    -- Enregistrement de toutes les modifications
    INSERT INTO audit_modifications (
        table_name,
        record_id,
        champ,
        ancienne_valeur,
        nouvelle_valeur,
        date_modif
    )
    SELECT
        'produits_demo',
        NEW.id,
        'nom',
        OLD.nom,
        NEW.nom,
        NOW()
    WHERE OLD.nom != NEW.nom

    UNION ALL

    SELECT
        'produits_demo',
        NEW.id,
        'prix',
        CAST(OLD.prix AS CHAR),
        CAST(NEW.prix AS CHAR),
        NOW()
    WHERE OLD.prix != NEW.prix

    UNION ALL

    SELECT
        'produits_demo',
        NEW.id,
        'quantite',
        CAST(OLD.quantite AS CHAR),
        CAST(NEW.quantite AS CHAR),
        NOW()
    WHERE OLD.quantite != NEW.quantite;
END//

DELIMITER ;
```

---

## Patterns de comparaison OLD vs NEW

### Pattern 1 : D√©tection de changement simple

```sql
DELIMITER //

CREATE TRIGGER audit_changement_prix
AFTER UPDATE ON produits
FOR EACH ROW
BEGIN
    -- V√©rifier si le prix a chang√©
    IF OLD.prix != NEW.prix THEN
        INSERT INTO audit_prix (
            produit_id,
            ancien_prix,
            nouveau_prix,
            variation_pct,
            date_changement
        ) VALUES (
            NEW.id,
            OLD.prix,
            NEW.prix,
            ((NEW.prix - OLD.prix) / OLD.prix) * 100,
            NOW()
        );
    END IF;
END//

DELIMITER ;
```

### Pattern 2 : Comparaison multiple avec priorit√©s

```sql
DELIMITER //

CREATE TRIGGER detection_changements_multiples
AFTER UPDATE ON clients
FOR EACH ROW
BEGIN
    DECLARE v_changements VARCHAR(255) DEFAULT '';

    -- D√©tecter tous les changements
    IF OLD.nom != NEW.nom THEN
        SET v_changements = CONCAT(v_changements, 'nom,');
    END IF;

    IF OLD.email != NEW.email THEN
        SET v_changements = CONCAT(v_changements, 'email,');
    END IF;

    IF OLD.telephone != NEW.telephone THEN
        SET v_changements = CONCAT(v_changements, 'telephone,');
    END IF;

    IF OLD.adresse != NEW.adresse THEN
        SET v_changements = CONCAT(v_changements, 'adresse,');
    END IF;

    -- Enregistrer si au moins un changement
    IF v_changements != '' THEN
        -- Retirer la virgule finale
        SET v_changements = LEFT(v_changements, LENGTH(v_changements) - 1);

        INSERT INTO historique_modifications (
            client_id,
            champs_modifies,
            utilisateur,
            date_modification
        ) VALUES (
            NEW.id,
            v_changements,
            USER(),
            NOW()
        );
    END IF;
END//

DELIMITER ;
```

### Pattern 3 : Comparaison avec gestion NULL

```sql
DELIMITER //

CREATE TRIGGER comparaison_null_safe
BEFORE UPDATE ON contacts
FOR EACH ROW
BEGIN
    /*
     * Comparaison NULL-safe :
     * NULL != NULL est FALSE (comportement SQL standard)
     * On doit traiter NULL explicitement
     */

    -- ‚ùå MAUVAIS : Ne d√©tecte pas NULL ‚Üí valeur ou valeur ‚Üí NULL
    IF OLD.telephone != NEW.telephone THEN
        -- Cette condition est FALSE si l'un est NULL
    END IF;

    -- ‚úÖ BON : Comparaison NULL-safe avec <=>
    IF NOT (OLD.telephone <=> NEW.telephone) THEN
        -- D√©tecte tous les changements, y compris NULL
        INSERT INTO log_changements VALUES (
            NEW.id,
            'telephone',
            COALESCE(OLD.telephone, '[NULL]'),
            COALESCE(NEW.telephone, '[NULL]'),
            NOW()
        );
    END IF;

    -- Alternative avec IS NULL
    IF (OLD.email IS NULL AND NEW.email IS NOT NULL)
       OR (OLD.email IS NOT NULL AND NEW.email IS NULL)
       OR (OLD.email IS NOT NULL AND NEW.email IS NOT NULL AND OLD.email != NEW.email) THEN
        -- Changement d√©tect√©
        INSERT INTO log_changements VALUES (
            NEW.id,
            'email',
            COALESCE(OLD.email, '[NULL]'),
            COALESCE(NEW.email, '[NULL]'),
            NOW()
        );
    END IF;
END//

DELIMITER ;
```

üí° **L'op√©rateur `<=>`** (NULL-safe equal) est essentiel pour comparer des valeurs qui peuvent √™tre NULL.

### Pattern 4 : Calcul de delta

```sql
DELIMITER //

CREATE TRIGGER calcul_delta_stock
AFTER UPDATE ON produits
FOR EACH ROW
BEGIN
    DECLARE v_delta INT;

    -- Calcul du delta de stock
    IF OLD.stock != NEW.stock THEN
        SET v_delta = NEW.stock - OLD.stock;

        INSERT INTO mouvements_stock (
            produit_id,
            type_mouvement,
            quantite,
            stock_avant,
            stock_apres,
            date_mouvement
        ) VALUES (
            NEW.id,
            CASE
                WHEN v_delta > 0 THEN 'ENTREE'
                WHEN v_delta < 0 THEN 'SORTIE'
                ELSE 'AJUSTEMENT'
            END,
            ABS(v_delta),
            OLD.stock,
            NEW.stock,
            NOW()
        );
    END IF;
END//

DELIMITER ;
```

### Pattern 5 : Comparaison de structures JSON

```sql
DELIMITER //

CREATE TRIGGER comparaison_json
AFTER UPDATE ON configurations
FOR EACH ROW
BEGIN
    /*
     * Comparaison de colonnes JSON
     * N√©cessite extraction et comparaison valeur par valeur
     */

    DECLARE v_old_value VARCHAR(255);
    DECLARE v_new_value VARCHAR(255);

    -- Extraction de cl√©s sp√©cifiques
    SET v_old_value = JSON_UNQUOTE(JSON_EXTRACT(OLD.settings, '$.theme'));
    SET v_new_value = JSON_UNQUOTE(JSON_EXTRACT(NEW.settings, '$.theme'));

    IF v_old_value != v_new_value THEN
        INSERT INTO audit_config (
            config_id,
            cle_json,
            ancienne_valeur,
            nouvelle_valeur,
            date_changement
        ) VALUES (
            NEW.id,
            'theme',
            v_old_value,
            v_new_value,
            NOW()
        );
    END IF;

    -- Comparaison de l'ensemble du JSON
    IF OLD.settings != NEW.settings THEN
        INSERT INTO audit_config_complet (
            config_id,
            ancien_json,
            nouveau_json,
            date_changement
        ) VALUES (
            NEW.id,
            OLD.settings,
            NEW.settings,
            NOW()
        );
    END IF;
END//

DELIMITER ;
```

---

## Modification de NEW dans BEFORE triggers

### Normalisation automatique

```sql
DELIMITER //

CREATE TRIGGER normalisation_client
BEFORE INSERT ON clients
FOR EACH ROW
BEGIN
    /*
     * Modification de NEW avant insertion
     * Garantit la qualit√© des donn√©es
     */

    -- Normalisation 1 : Trim et casse
    SET NEW.nom = UPPER(TRIM(NEW.nom));
    SET NEW.prenom = CONCAT(
        UPPER(LEFT(TRIM(NEW.prenom), 1)),
        LOWER(SUBSTRING(TRIM(NEW.prenom), 2))
    );

    -- Normalisation 2 : Email en minuscules
    SET NEW.email = LOWER(TRIM(NEW.email));

    -- Normalisation 3 : T√©l√©phone sans espaces
    IF NEW.telephone IS NOT NULL THEN
        SET NEW.telephone = REPLACE(REPLACE(REPLACE(
            NEW.telephone, ' ', ''), '-', ''), '.', '');

        -- Ajout du pr√©fixe international si absent
        IF NOT NEW.telephone LIKE '+%' THEN
            IF LEFT(NEW.telephone, 1) = '0' THEN
                SET NEW.telephone = CONCAT('+33', SUBSTRING(NEW.telephone, 2));
            END IF;
        END IF;
    END IF;

    -- Normalisation 4 : Code postal fran√ßais
    IF NEW.code_postal IS NOT NULL THEN
        SET NEW.code_postal = LPAD(NEW.code_postal, 5, '0');
    END IF;
END//

DELIMITER ;
```

### Calculs d√©riv√©s automatiques

```sql
DELIMITER //

CREATE TRIGGER calculs_commande
BEFORE INSERT ON lignes_commande
FOR EACH ROW
BEGIN
    /*
     * Calcul automatique de champs d√©riv√©s
     * √âvite les incoh√©rences applicatives
     */

    DECLARE v_prix_unitaire DECIMAL(10,2);
    DECLARE v_taux_remise DECIMAL(5,2);

    -- R√©cup√©ration du prix produit
    SELECT prix INTO v_prix_unitaire
    FROM produits
    WHERE id = NEW.produit_id;

    -- Application du prix si non fourni
    IF NEW.prix_unitaire IS NULL OR NEW.prix_unitaire = 0 THEN
        SET NEW.prix_unitaire = v_prix_unitaire;
    END IF;

    -- Calcul du montant HT
    SET NEW.montant_ht = NEW.quantite * NEW.prix_unitaire;

    -- Application de la remise
    IF NEW.remise_pct IS NOT NULL AND NEW.remise_pct > 0 THEN
        SET NEW.montant_remise = NEW.montant_ht * (NEW.remise_pct / 100);
        SET NEW.montant_ht = NEW.montant_ht - NEW.montant_remise;
    END IF;

    -- Calcul de la TVA
    SET NEW.montant_tva = NEW.montant_ht * (NEW.taux_tva / 100);

    -- Calcul du montant TTC
    SET NEW.montant_ttc = NEW.montant_ht + NEW.montant_tva;

    -- Arrondi √† 2 d√©cimales
    SET NEW.montant_ht = ROUND(NEW.montant_ht, 2);
    SET NEW.montant_tva = ROUND(NEW.montant_tva, 2);
    SET NEW.montant_ttc = ROUND(NEW.montant_ttc, 2);
END//

DELIMITER ;
```

### Enrichissement automatique de m√©tadonn√©es

```sql
DELIMITER //

CREATE TRIGGER enrichissement_document
BEFORE INSERT ON documents
FOR EACH ROW
BEGIN
    /*
     * Enrichissement automatique de m√©tadonn√©es
     * Tra√ßabilit√© et audit int√©gr√©s
     */

    -- Hash du contenu pour d√©tection de modifications
    SET NEW.hash_contenu = SHA2(NEW.contenu, 256);

    -- Extraction de m√©tadonn√©es du contenu
    SET NEW.nb_caracteres = LENGTH(NEW.contenu);
    SET NEW.nb_mots = LENGTH(NEW.contenu) - LENGTH(REPLACE(NEW.contenu, ' ', '')) + 1;
    SET NEW.nb_lignes = LENGTH(NEW.contenu) - LENGTH(REPLACE(NEW.contenu, '\n', '')) + 1;

    -- M√©tadonn√©es de cr√©ation
    SET NEW.cree_par = USER();
    SET NEW.date_creation = NOW();
    SET NEW.adresse_ip_creation = @client_ip;  -- Variable de session

    -- Slug g√©n√©r√© depuis le titre
    SET NEW.slug = LOWER(REPLACE(REPLACE(REPLACE(
        NEW.titre, ' ', '-'), '√©', 'e'), '√®', 'e'));

    -- Extraction des tags depuis le contenu (exemple simple)
    -- Recherche de #hashtags
    IF NEW.contenu LIKE '%#%' THEN
        -- Logique d'extraction des tags
        SET NEW.tags_extraits = 'hashtags_detected';
    END IF;
END//

DELIMITER ;
```

### Correction automatique de valeurs invalides

```sql
DELIMITER //

CREATE TRIGGER correction_valeurs
BEFORE INSERT ON produits
FOR EACH ROW
BEGIN
    /*
     * Correction automatique plut√¥t que rejet
     * Garantit l'int√©grit√© sans bloquer l'insertion
     */

    -- Correction 1 : Prix n√©gatif
    IF NEW.prix < 0 THEN
        SET NEW.prix = 0;
        INSERT INTO corrections_automatiques (
            table_name, field_name, valeur_incorrecte, valeur_corrigee
        ) VALUES (
            'produits', 'prix', NEW.prix, 0
        );
    END IF;

    -- Correction 2 : Stock n√©gatif
    IF NEW.stock < 0 THEN
        SET NEW.stock = 0;
    END IF;

    -- Correction 3 : Pourcentage hors bornes
    IF NEW.remise_pct IS NOT NULL THEN
        IF NEW.remise_pct < 0 THEN
            SET NEW.remise_pct = 0;
        ELSEIF NEW.remise_pct > 100 THEN
            SET NEW.remise_pct = 100;
        END IF;
    END IF;

    -- Correction 4 : Cha√Æne trop longue
    IF LENGTH(NEW.nom) > 100 THEN
        SET NEW.nom = LEFT(NEW.nom, 100);
        SET NEW.nom_tronque = TRUE;
    END IF;

    -- Correction 5 : Date future invalide
    IF NEW.date_disponibilite < CURDATE() THEN
        SET NEW.date_disponibilite = CURDATE();
    END IF;
END//

DELIMITER ;
```

---

## Utilisation avanc√©e de OLD dans AFTER triggers

### Pattern : Archivage complet avec OLD

```sql
DELIMITER //

-- Table d'archive miroir
CREATE TABLE produits_archives (
    archive_id INT PRIMARY KEY AUTO_INCREMENT,
    -- Toutes les colonnes de la table originale
    produit_id INT NOT NULL,
    nom VARCHAR(100),
    prix DECIMAL(10,2),
    stock INT,
    actif BOOLEAN,
    -- M√©tadonn√©es d'archivage
    date_archivage DATETIME NOT NULL,
    raison_archivage VARCHAR(50) NOT NULL,
    archive_par VARCHAR(100) NOT NULL
)//

CREATE TRIGGER archivage_produit_supprime
AFTER DELETE ON produits
FOR EACH ROW
BEGIN
    /*
     * Archivage complet des donn√©es supprim√©es
     * OLD contient toutes les valeurs de la ligne supprim√©e
     */

    INSERT INTO produits_archives (
        produit_id,
        nom,
        prix,
        stock,
        actif,
        date_archivage,
        raison_archivage,
        archive_par
    ) VALUES (
        OLD.id,              -- OLD.id existe (ligne supprim√©e)
        OLD.nom,             -- OLD.nom
        OLD.prix,            -- OLD.prix
        OLD.stock,           -- OLD.stock
        OLD.actif,           -- OLD.actif
        NOW(),
        COALESCE(@raison_suppression, 'Non sp√©cifi√©e'),
        USER()
    );
END//

DELIMITER ;

-- Utilisation
SET @raison_suppression = 'Produit obsol√®te';
DELETE FROM produits WHERE id = 123;
```

### Pattern : Snapshot avant modification

```sql
DELIMITER //

-- Table de snapshots
CREATE TABLE utilisateurs_snapshots (
    snapshot_id INT PRIMARY KEY AUTO_INCREMENT,
    utilisateur_id INT NOT NULL,
    snapshot_type VARCHAR(20) NOT NULL,  -- BEFORE_UPDATE, BEFORE_DELETE
    donnees_snapshot JSON NOT NULL,
    date_snapshot DATETIME NOT NULL,
    INDEX idx_user_date (utilisateur_id, date_snapshot)
)//

CREATE TRIGGER snapshot_utilisateur_update
BEFORE UPDATE ON utilisateurs
FOR EACH ROW
BEGIN
    /*
     * Sauvegarde snapshot JSON avant modification
     * OLD contient l'√©tat complet avant modification
     */

    INSERT INTO utilisateurs_snapshots (
        utilisateur_id,
        snapshot_type,
        donnees_snapshot,
        date_snapshot
    ) VALUES (
        OLD.id,
        'BEFORE_UPDATE',
        JSON_OBJECT(
            'id', OLD.id,
            'username', OLD.username,
            'email', OLD.email,
            'nom', OLD.nom,
            'prenom', OLD.prenom,
            'actif', OLD.actif,
            'date_creation', OLD.date_creation,
            'derniere_connexion', OLD.derniere_connexion
        ),
        NOW()
    );
END//

CREATE TRIGGER snapshot_utilisateur_delete
BEFORE DELETE ON utilisateurs
FOR EACH ROW
BEGIN
    INSERT INTO utilisateurs_snapshots (
        utilisateur_id,
        snapshot_type,
        donnees_snapshot,
        date_snapshot
    ) VALUES (
        OLD.id,
        'BEFORE_DELETE',
        JSON_OBJECT(
            'id', OLD.id,
            'username', OLD.username,
            'email', OLD.email,
            'nom', OLD.nom,
            'prenom', OLD.prenom,
            'actif', OLD.actif,
            'date_creation', OLD.date_creation,
            'derniere_connexion', OLD.derniere_connexion
        ),
        NOW()
    );
END//

DELIMITER ;
```

### Pattern : Propagation de OLD √† d'autres tables

```sql
DELIMITER //

CREATE TRIGGER propagation_suppression_client
AFTER DELETE ON clients
FOR EACH ROW
BEGIN
    /*
     * Utilisation de OLD pour propager des informations
     * OLD.id r√©f√©rence l'ID du client supprim√©
     */

    -- 1. Anonymisation des commandes (pas suppression)
    UPDATE commandes
    SET
        client_id = NULL,
        client_nom = CONCAT('[Client supprim√© - ', OLD.id, ']'),
        client_email = NULL
    WHERE client_id = OLD.id;

    -- 2. Notification de suppression
    INSERT INTO notifications_suppression (
        type_entite,
        entite_id,
        entite_nom,
        date_suppression,
        donnees_supplementaires
    ) VALUES (
        'CLIENT',
        OLD.id,
        CONCAT(OLD.prenom, ' ', OLD.nom),
        NOW(),
        JSON_OBJECT(
            'email', OLD.email,
            'nb_commandes', (
                SELECT COUNT(*)
                FROM commandes
                WHERE client_id = OLD.id
            )
        )
    );

    -- 3. Mise √† jour des statistiques
    UPDATE stats_generales
    SET
        nb_clients_actifs = nb_clients_actifs - 1,
        nb_clients_supprimes = nb_clients_supprimes + 1
    WHERE id = 1;
END//

DELIMITER ;
```

---

## Pi√®ges courants et solutions

### Pi√®ge 1 : Confusion entre OLD et NEW dans UPDATE

```sql
DELIMITER //

-- ‚ùå ERREUR COMMUNE : Utiliser OLD au lieu de NEW
CREATE TRIGGER erreur_old_new
AFTER UPDATE ON produits
FOR EACH ROW
BEGIN
    -- Vouloir enregistrer le nouveau prix
    INSERT INTO historique_prix (produit_id, prix, date)
    VALUES (OLD.id, OLD.prix, NOW());  -- ‚ùå Enregistre l'ancien prix !
END//

-- ‚úÖ CORRECT : Utiliser NEW pour la nouvelle valeur
CREATE TRIGGER correct_old_new
AFTER UPDATE ON produits
FOR EACH ROW
BEGIN
    IF OLD.prix != NEW.prix THEN
        INSERT INTO historique_prix (
            produit_id,
            ancien_prix,
            nouveau_prix,
            date_changement
        ) VALUES (
            NEW.id,      -- ‚úÖ ID actuel (NEW ou OLD, m√™me valeur pour UPDATE)
            OLD.prix,    -- ‚úÖ Ancien prix
            NEW.prix,    -- ‚úÖ Nouveau prix
            NOW()
        );
    END IF;
END//

DELIMITER ;
```

### Pi√®ge 2 : NULL dans les comparaisons

```sql
DELIMITER //

-- ‚ùå PI√àGE : Comparaison directe avec NULL
CREATE TRIGGER piege_null
AFTER UPDATE ON contacts
FOR EACH ROW
BEGIN
    -- Cette condition est toujours FALSE si OLD.telephone est NULL
    IF OLD.telephone != NEW.telephone THEN
        -- Ne s'ex√©cute pas si OLD.telephone est NULL !
    END IF;
END//

-- ‚úÖ SOLUTION 1 : Op√©rateur NULL-safe <=>
CREATE TRIGGER solution_null_safe
AFTER UPDATE ON contacts
FOR EACH ROW
BEGIN
    IF NOT (OLD.telephone <=> NEW.telephone) THEN
        -- D√©tecte tous les changements, y compris NULL
        INSERT INTO log_modifications VALUES (...);
    END IF;
END//

-- ‚úÖ SOLUTION 2 : Gestion explicite de NULL
CREATE TRIGGER solution_null_explicite
AFTER UPDATE ON contacts
FOR EACH ROW
BEGIN
    IF (OLD.telephone IS NULL AND NEW.telephone IS NOT NULL)
       OR (OLD.telephone IS NOT NULL AND NEW.telephone IS NULL)
       OR (OLD.telephone IS NOT NULL AND NEW.telephone IS NOT NULL
           AND OLD.telephone != NEW.telephone) THEN
        -- Tous les cas de changement couverts
        INSERT INTO log_modifications VALUES (...);
    END IF;
END//

DELIMITER ;
```

### Pi√®ge 3 : Tentative de modification dans AFTER

```sql
DELIMITER //

-- ‚ùå ERREUR : Modifier NEW dans AFTER
CREATE TRIGGER erreur_after_modify
AFTER INSERT ON produits
FOR EACH ROW
BEGIN
    SET NEW.prix_ttc = NEW.prix_ht * 1.20;  -- ‚ùå ERREUR
    -- Error: Can't update row in trigger
END//

-- ‚úÖ SOLUTION : Utiliser BEFORE pour modifications
CREATE TRIGGER solution_before_modify
BEFORE INSERT ON produits
FOR EACH ROW
BEGIN
    SET NEW.prix_ttc = NEW.prix_ht * 1.20;  -- ‚úÖ OK
END//

DELIMITER ;
```

### Pi√®ge 4 : OLD.id vs NEW.id dans UPDATE

```sql
DELIMITER //

-- Question : OLD.id et NEW.id sont-ils diff√©rents ?
CREATE TRIGGER question_id
AFTER UPDATE ON produits
FOR EACH ROW
BEGIN
    -- R√©ponse : NON, OLD.id et NEW.id sont TOUJOURS identiques dans UPDATE
    -- La cl√© primaire ne peut pas changer

    -- ‚úÖ Les deux sont √©quivalents
    INSERT INTO audit (produit_id) VALUES (OLD.id);   -- ‚úÖ
    INSERT INTO audit (produit_id) VALUES (NEW.id);   -- ‚úÖ M√™me valeur

    -- Par convention, on utilise NEW.id pour coh√©rence
    -- car NEW repr√©sente l'√©tat "actuel" apr√®s update
END//

DELIMITER ;
```

### Pi√®ge 5 : Acc√®s √† des colonnes inexistantes

```sql
DELIMITER //

-- ‚ùå ERREUR : Acc√©der √† une colonne qui n'existe pas
CREATE TRIGGER erreur_colonne
AFTER UPDATE ON produits
FOR EACH ROW
BEGIN
    INSERT INTO audit VALUES (OLD.colonne_inexistante);  -- ‚ùå ERREUR
    -- Error: Unknown column 'colonne_inexistante'
END//

-- ‚úÖ SOLUTION : V√©rifier la structure de la table
-- DESCRIBE produits; ou SHOW CREATE TABLE produits;

DELIMITER ;
```

---

## Patterns avanc√©s de manipulation

### Pattern : Calcul de diff√©rences complexes

```sql
DELIMITER //

CREATE TRIGGER analyse_changements_complexes
AFTER UPDATE ON commandes
FOR EACH ROW
BEGIN
    DECLARE v_variation_montant DECIMAL(10,2);
    DECLARE v_variation_pct DECIMAL(5,2);
    DECLARE v_changement_statut BOOLEAN;

    -- Calcul de variations
    SET v_variation_montant = NEW.montant_total - OLD.montant_total;

    IF OLD.montant_total > 0 THEN
        SET v_variation_pct = (v_variation_montant / OLD.montant_total) * 100;
    ELSE
        SET v_variation_pct = 0;
    END IF;

    SET v_changement_statut = (OLD.statut != NEW.statut);

    -- Enregistrement selon l'ampleur des changements
    IF ABS(v_variation_pct) > 10 OR v_changement_statut THEN
        INSERT INTO alertes_modifications (
            commande_id,
            type_alerte,
            ancien_montant,
            nouveau_montant,
            variation_pct,
            ancien_statut,
            nouveau_statut,
            severite,
            date_alerte
        ) VALUES (
            NEW.id,
            CASE
                WHEN ABS(v_variation_pct) > 50 THEN 'MODIFICATION_MAJEURE'
                WHEN ABS(v_variation_pct) > 10 THEN 'MODIFICATION_IMPORTANTE'
                ELSE 'CHANGEMENT_STATUT'
            END,
            OLD.montant_total,
            NEW.montant_total,
            v_variation_pct,
            OLD.statut,
            NEW.statut,
            CASE
                WHEN ABS(v_variation_pct) > 50 THEN 'CRITIQUE'
                WHEN ABS(v_variation_pct) > 25 THEN 'ELEVEE'
                ELSE 'NORMALE'
            END,
            NOW()
        );
    END IF;
END//

DELIMITER ;
```

### Pattern : Construction de diff textuel

```sql
DELIMITER //

CREATE TRIGGER construction_diff
AFTER UPDATE ON documents
FOR EACH ROW
BEGIN
    DECLARE v_diff TEXT DEFAULT '';

    -- Construction d'un "diff" lisible
    IF OLD.titre != NEW.titre THEN
        SET v_diff = CONCAT(v_diff,
            'Titre: "', OLD.titre, '" ‚Üí "', NEW.titre, '"\n');
    END IF;

    IF OLD.statut != NEW.statut THEN
        SET v_diff = CONCAT(v_diff,
            'Statut: ', OLD.statut, ' ‚Üí ', NEW.statut, '\n');
    END IF;

    IF OLD.categorie != NEW.categorie THEN
        SET v_diff = CONCAT(v_diff,
            'Cat√©gorie: ', OLD.categorie, ' ‚Üí ', NEW.categorie, '\n');
    END IF;

    -- Enregistrement du diff si changements
    IF v_diff != '' THEN
        INSERT INTO historique_documents (
            document_id,
            resume_modifications,
            utilisateur,
            date_modification
        ) VALUES (
            NEW.id,
            v_diff,
            USER(),
            NOW()
        );
    END IF;
END//

DELIMITER ;
```

### Pattern : Validation cross-field avec OLD et NEW

```sql
DELIMITER //

CREATE TRIGGER validation_cross_field
BEFORE UPDATE ON reservations
FOR EACH ROW
BEGIN
    /*
     * Validation de coh√©rence entre plusieurs champs
     * en comparant OLD et NEW
     */

    -- R√®gle 1 : Si date_debut change, date_fin doit rester apr√®s
    IF NEW.date_debut != OLD.date_debut THEN
        IF NEW.date_fin <= NEW.date_debut THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'La date de fin doit √™tre apr√®s la date de d√©but';
        END IF;
    END IF;

    -- R√®gle 2 : Si statut passe √† CONFIRMEE, dates doivent √™tre dans le futur
    IF NEW.statut = 'CONFIRMEE' AND OLD.statut != 'CONFIRMEE' THEN
        IF NEW.date_debut < NOW() THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'Impossible de confirmer une r√©servation pass√©e';
        END IF;
    END IF;

    -- R√®gle 3 : Si nombre de participants augmente, v√©rifier capacit√© salle
    IF NEW.nb_participants > OLD.nb_participants THEN
        DECLARE v_capacite_salle INT;

        SELECT capacite INTO v_capacite_salle
        FROM salles
        WHERE id = NEW.salle_id;

        IF NEW.nb_participants > v_capacite_salle THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = CONCAT(
                    'Capacit√© salle d√©pass√©e : max ',
                    v_capacite_salle,
                    ' personnes'
                );
        END IF;
    END IF;
END//

DELIMITER ;
```

---

## Performance et optimisation

### Optimisation 1 : √âviter les calculs inutiles

```sql
DELIMITER //

-- ‚ùå NON OPTIMIS√â : Calculs syst√©matiques
CREATE TRIGGER non_optimise
AFTER UPDATE ON produits
FOR EACH ROW
BEGIN
    -- Calcul co√ªteux ex√©cut√© √† chaque UPDATE
    INSERT INTO stats_produit
    SELECT
        NEW.id,
        COUNT(*),
        SUM(quantite)
    FROM lignes_commande
    WHERE produit_id = NEW.id;
END//

-- ‚úÖ OPTIMIS√â : Calculs conditionnels
CREATE TRIGGER optimise
AFTER UPDATE ON produits
FOR EACH ROW
BEGIN
    -- Calcul uniquement si le champ pertinent change
    IF OLD.actif != NEW.actif THEN
        -- Recalcul n√©cessaire seulement si statut actif change
        INSERT INTO stats_produit
        SELECT
            NEW.id,
            COUNT(*),
            SUM(quantite)
        FROM lignes_commande
        WHERE produit_id = NEW.id;
    END IF;
END//

DELIMITER ;
```

### Optimisation 2 : Utilisation directe de OLD/NEW

```sql
DELIMITER //

-- ‚ùå NON OPTIMIS√â : SELECT inutile
CREATE TRIGGER non_optimise_select
AFTER UPDATE ON clients
FOR EACH ROW
BEGIN
    DECLARE v_ancien_nom VARCHAR(100);

    -- SELECT inutile, OLD contient d√©j√† cette info
    SELECT nom INTO v_ancien_nom
    FROM clients
    WHERE id = OLD.id;  -- ‚ùå Requ√™te inutile

    INSERT INTO audit VALUES (v_ancien_nom, NOW());
END//

-- ‚úÖ OPTIMIS√â : Utilisation directe de OLD
CREATE TRIGGER optimise_direct
AFTER UPDATE ON clients
FOR EACH ROW
BEGIN
    -- Acc√®s direct √† OLD, pas de SELECT
    INSERT INTO audit VALUES (OLD.nom, NOW());  -- ‚úÖ Direct
END//

DELIMITER ;
```

---

## ‚úÖ Points cl√©s √† retenir

- **OLD** : √âtat avant modification (INSERT: n/a, UPDATE: ‚úÖ, DELETE: ‚úÖ)
- **NEW** : √âtat apr√®s modification (INSERT: ‚úÖ, UPDATE: ‚úÖ, DELETE: n/a)
- **Lecture** : OLD et NEW toujours en lecture (tous types)
- **√âcriture** : NEW modifiable uniquement dans BEFORE
- **Comparaison NULL** : Utiliser `<=>` pour null-safe comparisons
- **Performance** : Conditionner les actions (IF OLD.x != NEW.x)
- **OLD.id = NEW.id** : Toujours identiques dans UPDATE (cl√© primaire)
- **Typage** : OLD/NEW h√©ritent des types de colonnes de la table
- **Acc√®s colonnes** : OLD.nom_colonne et NEW.nom_colonne
- **Pi√®ges** : AFTER ne peut pas modifier NEW, attention aux NULL

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation officielle MariaDB - Trigger OLD and NEW](https://mariadb.com/kb/en/trigger-overview/#old-and-new)
- [üìñ Trigger Syntax](https://mariadb.com/kb/en/create-trigger/)
- [üìñ NULL-Safe Equal Operator](https://mariadb.com/kb/en/null-safe-equal/)
- [üìñ Comparison Operators](https://mariadb.com/kb/en/comparison-operators/)
- [üí° Blog : Advanced Trigger Patterns](https://mariadb.com/resources/blog/)

---

## ‚û°Ô∏è Section suivante

**[8.4 Events (t√¢ches planifi√©es)](./04-events.md)** : D√©couvrez les events qui permettent d'automatiser l'ex√©cution de t√¢ches selon des planifications temporelles.

---


‚è≠Ô∏è [Events (t√¢ches planifi√©es)](/08-programmation-cote-serveur/04-events.md)
