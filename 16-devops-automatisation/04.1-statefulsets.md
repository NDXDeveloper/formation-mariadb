ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 16.4.1 StatefulSets pour MariaDB

> **Niveau** : AvancÃ© Ã  Expert  
> **DurÃ©e estimÃ©e** : 4-5 heures  
> **PrÃ©requis** : Kubernetes fundamentals, StatefulSets, PersistentVolumes, MariaDB architecture

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre pourquoi StatefulSet est essentiel pour MariaDB sur Kubernetes
- DÃ©ployer MariaDB en production avec StatefulSets et PersistentVolumes
- Configurer la persistance, le rÃ©seau et l'ordonnancement des pods
- GÃ©rer le cycle de vie des instances MariaDB (scaling, updates, rollback)
- ImplÃ©menter des patterns de haute disponibilitÃ© (rÃ©plication, Galera)
- Appliquer les meilleures pratiques de sÃ©curitÃ© et performance
- Orchestrer des opÃ©rations de maintenance sans downtime

---

## Introduction

Dans Kubernetes, les bases de donnÃ©es nÃ©cessitent un traitement particulier car elles sont **stateful** : elles maintiennent un Ã©tat persistant qui doit survivre aux redÃ©marrages de pods. Les **StatefulSets** sont la ressource Kubernetes conÃ§ue spÃ©cifiquement pour gÃ©rer ces workloads stateful.

### Pourquoi StatefulSet pour MariaDB ?

**ProblÃ©matiques des Deployments pour les BDD** :
- âŒ IdentitÃ© des pods non stable (noms alÃ©atoires)
- âŒ Ordre de crÃ©ation/suppression non garanti
- âŒ PersistentVolumes non liÃ©s aux pods individuels
- âŒ RÃ©seau non stable (DNS changeant)
- âŒ Difficile de gÃ©rer la rÃ©plication ou Galera

**Avantages des StatefulSets** :
- âœ… **IdentitÃ© stable** : Pods nommÃ©s prÃ©visiblement (mariadb-0, mariadb-1, etc.)
- âœ… **Ordre garanti** : CrÃ©ation/suppression sÃ©quentielle (important pour rÃ©plication)
- âœ… **Storage stable** : Chaque pod a son propre PersistentVolumeClaim
- âœ… **RÃ©seau stable** : DNS prÃ©visible (mariadb-0.mariadb.namespace.svc.cluster.local)
- âœ… **Rolling updates** : Mise Ã  jour contrÃ´lÃ©e pod par pod
- âœ… **Headless Service** : AccÃ¨s direct Ã  chaque pod pour rÃ©plication

### Cas d'usage

- DÃ©ploiement MariaDB standalone en production
- Architecture Master-Slave (Primary-Replica)
- Cluster Galera multi-master
- Bases de donnÃ©es shardÃ©es
- Environnements de dÃ©veloppement/staging isolÃ©s

---

## Architecture StatefulSet

### Composants principaux

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   StatefulSet                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Pod mariadb-0â”‚  â”‚ Pod mariadb-1â”‚  â”‚ mariadb-2â”‚ â”‚
â”‚  â”‚              â”‚  â”‚              â”‚  â”‚          â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â”‚
â”‚  â”‚  â”‚MariaDB â”‚  â”‚  â”‚  â”‚MariaDB â”‚  â”‚  â”‚â”‚MariaDB â”‚â”‚ â”‚
â”‚  â”‚  â”‚11.8 LTSâ”‚  â”‚  â”‚  â”‚11.8 LTSâ”‚  â”‚  â”‚â”‚11.8 LTSâ”‚â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜  â”‚  â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜  â”‚  â”‚â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜â”‚ â”‚
â”‚  â”‚       â”‚      â”‚  â”‚       â”‚      â”‚  â”‚     â”‚    â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â” â”‚  â”‚  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â” â”‚  â”‚â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”â”‚ â”‚
â”‚  â”‚  â”‚   PVC   â”‚ â”‚  â”‚  â”‚   PVC   â”‚ â”‚  â”‚â”‚  PVC   â”‚â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â”‚  â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â”‚  â”‚â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”˜
           â”‚                 â”‚               â”‚
      â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
      â”‚   PV    â”‚       â”‚   PV    â”‚      â”‚   PV    â”‚
      â”‚ (disk)  â”‚       â”‚ (disk)  â”‚      â”‚ (disk)  â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

           â–²                 â–²                â–²
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  Headless Service
              mariadb.namespace.svc.cluster.local
```

### Composants Kubernetes requis

1. **StorageClass** : DÃ©finit le provisioning dynamique de volumes
2. **PersistentVolume** : Stockage physique (ou provisionnÃ© dynamiquement)
3. **Headless Service** : DNS pour communication inter-pods
4. **StatefulSet** : Orchestration des pods MariaDB
5. **ConfigMap** : Configuration MariaDB (my.cnf)
6. **Secret** : Credentials (root password, replication user)
7. **Service** (optionnel) : AccÃ¨s externe ou load balancing

---

## StorageClass et PersistentVolumes

### StorageClass pour MariaDB

```yaml
# storageclass.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: mariadb-storage
  labels:
    app: mariadb
provisioner: kubernetes.io/aws-ebs  # AWS EBS
# Autres provisioners:
# - kubernetes.io/gce-pd           # Google Persistent Disk
# - kubernetes.io/azure-disk        # Azure Disk
# - kubernetes.io/cinder            # OpenStack Cinder
# - ebs.csi.aws.com                 # AWS EBS CSI
# - pd.csi.storage.gke.io           # GKE CSI
# - disk.csi.azure.com              # Azure Disk CSI

parameters:
  type: gp3                         # ğŸ†• OptimisÃ© pour MariaDB 11.8
  iops: "3000"                      # IOPS garantis
  throughput: "125"                 # MB/s
  encrypted: "true"                 # Encryption at rest
  fsType: ext4                      # Filesystem

# RÃ©cupÃ©ration des PV en cas de suppression du PVC
reclaimPolicy: Retain               # Retain, Delete, or Recycle

# Permet l'expansion du volume
allowVolumeExpansion: true

# Binding immÃ©diat ou diffÃ©rÃ©
volumeBindingMode: WaitForFirstConsumer  # Optimise le placement zone AZ

# Mount options
mountOptions:
  - noatime                         # Performance : pas d'update atime
  - nodiratime
```

### StorageClass avec provisioning local (bare metal)

```yaml
# storageclass-local.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: mariadb-local-storage
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
reclaimPolicy: Retain
```

```yaml
# CrÃ©er des PV locaux manuellement
apiVersion: v1
kind: PersistentVolume
metadata:
  name: mariadb-pv-0
  labels:
    type: local
    app: mariadb
spec:
  capacity:
    storage: 100Gi
  volumeMode: Filesystem
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: mariadb-local-storage
  local:
    path: /mnt/disks/ssd0
  nodeAffinity:
    required:
      nodeSelectorTerms:
        - matchExpressions:
            - key: kubernetes.io/hostname
              operator: In
              values:
                - node-1
```

ğŸ’¡ **Conseil** : Utilisez `WaitForFirstConsumer` pour que le PV soit crÃ©Ã© dans la mÃªme zone de disponibilitÃ© que le pod.

---

## ConfigMap pour configuration MariaDB

### ConfigMap avec optimisations 11.8

```yaml
# configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mariadb-config
  namespace: database
  labels:
    app: mariadb
    version: "11.8"
data:
  my.cnf: |
    [client]
    port = 3306
    socket = /var/run/mysqld/mysqld.sock
    default-character-set = utf8mb4

    [mysqld]
    # Basic Settings
    user = mysql
    pid-file = /var/run/mysqld/mysqld.pid
    socket = /var/run/mysqld/mysqld.sock
    port = 3306
    datadir = /var/lib/mysql
    
    # ğŸ†• MariaDB 11.8 - utf8mb4 par dÃ©faut
    character-set-server = utf8mb4
    collation-server = utf8mb4_unicode_ci
    
    # Networking
    bind-address = 0.0.0.0
    max_connections = 500
    max_connect_errors = 1000000
    
    # InnoDB Settings (optimisÃ© pour Kubernetes)
    default-storage-engine = InnoDB
    innodb_buffer_pool_size = 2G              # 70-80% de la mÃ©moire du pod
    innodb_buffer_pool_instances = 4
    innodb_log_file_size = 512M
    innodb_flush_log_at_trx_commit = 2        # Performance vs durabilitÃ©
    innodb_flush_method = O_DIRECT
    
    # ğŸ†• MariaDB 11.8 - Optimisations SSD (K8s utilise souvent du SSD)
    innodb_io_capacity = 2000
    innodb_io_capacity_max = 4000
    
    # ğŸ†• MariaDB 11.8 - ALTER TABLE efficace
    innodb_alter_copy_bulk = 256M
    
    # InnoDB Buffer Pool management
    innodb_buffer_pool_dump_at_shutdown = 1
    innodb_buffer_pool_load_at_startup = 1
    
    # Thread settings
    innodb_read_io_threads = 4
    innodb_write_io_threads = 4
    innodb_purge_threads = 4
    innodb_thread_concurrency = 0
    
    # Query Cache (dÃ©sactivÃ© en 11.8)
    query_cache_type = 0
    query_cache_size = 0
    
    # Logging
    log_error = /var/log/mysql/error.log
    slow_query_log = 1
    slow_query_log_file = /var/log/mysql/slow-query.log
    long_query_time = 2
    log_queries_not_using_indexes = 0
    
    # ğŸ†• MariaDB 11.8 - ContrÃ´le espace temporaire
    max_tmp_space_usage = 10G
    max_total_tmp_space_usage = 20G
    
    # Binary Logging (pour rÃ©plication/backup)
    log_bin = /var/lib/mysql/mariadb-bin
    binlog_format = ROW
    binlog_expire_logs_seconds = 604800       # 7 jours
    max_binlog_size = 100M
    sync_binlog = 1
    
    # GTID pour rÃ©plication
    gtid_strict_mode = 1
    
    # Table cache
    table_open_cache = 4096
    table_definition_cache = 2048
    
    # Performance
    tmp_table_size = 64M
    max_heap_table_size = 64M
    join_buffer_size = 256K
    sort_buffer_size = 256K
    
    # Kubernetes-specific: Ã©viter les timeouts
    wait_timeout = 600
    interactive_timeout = 600
    
    [mysqldump]
    quick
    quote-names
    max_allowed_packet = 64M
```

---

## Secrets pour credentials

### Secret pour mots de passe

```yaml
# secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: mariadb-secret
  namespace: database
  labels:
    app: mariadb
type: Opaque
stringData:
  # Mot de passe root
  mariadb-root-password: "SuperSecureRootPassword123!"
  
  # Mot de passe utilisateur application
  mariadb-password: "AppUserSecurePassword456!"
  
  # Mot de passe rÃ©plication (si nÃ©cessaire)
  mariadb-replication-password: "ReplUserPassword789!"

# Alternative: crÃ©er depuis la ligne de commande
# kubectl create secret generic mariadb-secret \
#   --from-literal=mariadb-root-password='SuperSecureRootPassword123!' \
#   --from-literal=mariadb-password='AppUserSecurePassword456!' \
#   -n database
```

âš ï¸ **Attention** : Ne commitez JAMAIS les secrets en clair dans Git. Utilisez :
- **Sealed Secrets** (Bitnami)
- **External Secrets Operator**
- **HashiCorp Vault**
- **AWS Secrets Manager** / **Azure Key Vault** / **GCP Secret Manager**

### Exemple avec External Secrets Operator

```yaml
# externalsecret.yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: mariadb-secret
  namespace: database
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: vault-backend
    kind: SecretStore
  target:
    name: mariadb-secret
    creationPolicy: Owner
  data:
    - secretKey: mariadb-root-password
      remoteRef:
        key: database/mariadb
        property: root-password
    - secretKey: mariadb-password
      remoteRef:
        key: database/mariadb
        property: app-password
```

---

## Headless Service

### Service pour communication inter-pods

```yaml
# service-headless.yaml
apiVersion: v1
kind: Service
metadata:
  name: mariadb
  namespace: database
  labels:
    app: mariadb
spec:
  # Headless service: clusterIP: None
  clusterIP: None
  
  # SÃ©lecteur pour les pods du StatefulSet
  selector:
    app: mariadb
  
  ports:
    - name: mysql
      port: 3306
      targetPort: 3306
      protocol: TCP
  
  # Publier les endpoints mÃªme si non ready (important pour rÃ©plication)
  publishNotReadyAddresses: true

---
# Service standard pour accÃ¨s externe/load balancing (optionnel)
apiVersion: v1
kind: Service
metadata:
  name: mariadb-read
  namespace: database
  labels:
    app: mariadb
    service-type: read
spec:
  type: ClusterIP
  selector:
    app: mariadb
  ports:
    - name: mysql
      port: 3306
      targetPort: 3306
      protocol: TCP
  
  # Session affinity pour connexions persistantes
  sessionAffinity: ClientIP
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: 10800  # 3 heures
```

### DNS des pods StatefulSet

Avec un Headless Service, chaque pod obtient un DNS prÃ©visible :

```
<pod-name>.<service-name>.<namespace>.svc.cluster.local

Exemples:
- mariadb-0.mariadb.database.svc.cluster.local
- mariadb-1.mariadb.database.svc.cluster.local
- mariadb-2.mariadb.database.svc.cluster.local
```

ğŸ’¡ **Conseil** : Utilisez ces DNS pour configurer la rÃ©plication entre pods.

---

## StatefulSet MariaDB standalone

### Manifest complet

```yaml
# statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mariadb
  namespace: database
  labels:
    app: mariadb
    version: "11.8"
spec:
  # Service headless associÃ©
  serviceName: mariadb
  
  # Nombre de replicas
  replicas: 1
  
  # SÃ©lecteur pour identifier les pods
  selector:
    matchLabels:
      app: mariadb
  
  # Strategy de mise Ã  jour
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      partition: 0  # Mettre Ã  jour tous les pods
  
  # Policy de gestion des pods
  podManagementPolicy: OrderedReady  # ou Parallel pour plus rapide
  
  # Minimum de pods ready avant scale up/down
  minReadySeconds: 10
  
  # Template du pod
  template:
    metadata:
      labels:
        app: mariadb
        version: "11.8"
      annotations:
        # Pour Prometheus monitoring
        prometheus.io/scrape: "true"
        prometheus.io/port: "9104"
    spec:
      # Security context au niveau pod
      securityContext:
        fsGroup: 999              # GID mysql
        fsGroupChangePolicy: "OnRootMismatch"
      
      # Service Account (si besoin de permissions K8s)
      serviceAccountName: mariadb
      
      # Anti-affinity: Ã©viter plusieurs pods MariaDB sur le mÃªme node
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchExpressions:
                  - key: app
                    operator: In
                    values:
                      - mariadb
              topologyKey: kubernetes.io/hostname
        
        # Node affinity: prÃ©fÃ©rer les nodes avec SSD
        nodeAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              preference:
                matchExpressions:
                  - key: node.kubernetes.io/instance-type
                    operator: In
                    values:
                      - r6i.xlarge
                      - r6i.2xlarge
      
      # Init container pour prÃ©paration
      initContainers:
        - name: init-mariadb
          image: busybox:1.35
          command:
            - sh
            - -c
            - |
              # CrÃ©er les rÃ©pertoires nÃ©cessaires
              mkdir -p /var/log/mysql
              chown -R 999:999 /var/log/mysql
              
              # Copier la configuration
              cp /config/my.cnf /etc/mysql/conf.d/
              
              echo "Initialization complete"
          volumeMounts:
            - name: config
              mountPath: /config
            - name: mariadb-config
              mountPath: /etc/mysql/conf.d
            - name: logs
              mountPath: /var/log/mysql
      
      # Conteneur principal MariaDB
      containers:
        - name: mariadb
          image: mariadb:11.8
          imagePullPolicy: IfNotPresent
          
          # Security context au niveau conteneur
          securityContext:
            runAsUser: 999          # UID mysql
            runAsNonRoot: true
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
              add:
                - CHOWN
                - SETGID
                - SETUID
                - DAC_OVERRIDE
          
          # Ports
          ports:
            - name: mysql
              containerPort: 3306
              protocol: TCP
          
          # Variables d'environnement
          env:
            - name: MARIADB_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mariadb-secret
                  key: mariadb-root-password
            
            - name: MARIADB_DATABASE
              value: "myapp"
            
            - name: MARIADB_USER
              value: "appuser"
            
            - name: MARIADB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mariadb-secret
                  key: mariadb-password
            
            # Optimisations Kubernetes
            - name: MARIADB_INITDB_SKIP_TZINFO
              value: "yes"
          
          # Ressources
          resources:
            requests:
              cpu: "1000m"          # 1 CPU
              memory: "3Gi"
            limits:
              cpu: "2000m"          # 2 CPU
              memory: "4Gi"
          
          # Volumes
          volumeMounts:
            - name: data
              mountPath: /var/lib/mysql
            - name: mariadb-config
              mountPath: /etc/mysql/conf.d
              readOnly: true
            - name: logs
              mountPath: /var/log/mysql
            - name: tmp
              mountPath: /tmp
          
          # Liveness probe: redÃ©marrer si non responsive
          livenessProbe:
            exec:
              command:
                - sh
                - -c
                - |
                  mariadb -h127.0.0.1 -uroot -p"${MARIADB_ROOT_PASSWORD}" -e "SELECT 1"
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            successThreshold: 1
            failureThreshold: 3
          
          # Readiness probe: recevoir du trafic si prÃªt
          readinessProbe:
            exec:
              command:
                - sh
                - -c
                - |
                  mariadb -h127.0.0.1 -uroot -p"${MARIADB_ROOT_PASSWORD}" -e "SELECT 1"
            initialDelaySeconds: 10
            periodSeconds: 5
            timeoutSeconds: 3
            successThreshold: 1
            failureThreshold: 3
          
          # Startup probe: temps pour le premier dÃ©marrage
          startupProbe:
            exec:
              command:
                - sh
                - -c
                - |
                  mariadb -h127.0.0.1 -uroot -p"${MARIADB_ROOT_PASSWORD}" -e "SELECT 1"
            initialDelaySeconds: 0
            periodSeconds: 5
            timeoutSeconds: 3
            successThreshold: 1
            failureThreshold: 60  # 5min max pour dÃ©marrer
          
          # Lifecycle hooks
          lifecycle:
            preStop:
              exec:
                command:
                  - sh
                  - -c
                  - |
                    # Graceful shutdown
                    mariadb -h127.0.0.1 -uroot -p"${MARIADB_ROOT_PASSWORD}" -e "SHUTDOWN"
                    sleep 15
        
        # Sidecar: mysqld_exporter pour Prometheus
        - name: mysqld-exporter
          image: prom/mysqld-exporter:v0.15.1
          imagePullPolicy: IfNotPresent
          
          ports:
            - name: metrics
              containerPort: 9104
              protocol: TCP
          
          env:
            - name: DATA_SOURCE_NAME
              value: "root:$(MARIADB_ROOT_PASSWORD)@(127.0.0.1:3306)/"
            - name: MARIADB_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mariadb-secret
                  key: mariadb-root-password
          
          resources:
            requests:
              cpu: "100m"
              memory: "128Mi"
            limits:
              cpu: "200m"
              memory: "256Mi"
          
          livenessProbe:
            httpGet:
              path: /
              port: 9104
            initialDelaySeconds: 30
            periodSeconds: 10
      
      # Volumes
      volumes:
        - name: config
          configMap:
            name: mariadb-config
        - name: mariadb-config
          emptyDir: {}
        - name: logs
          emptyDir: {}
        - name: tmp
          emptyDir: {}
  
  # VolumeClaimTemplates: crÃ©Ã© automatiquement un PVC par pod
  volumeClaimTemplates:
    - metadata:
        name: data
        labels:
          app: mariadb
      spec:
        accessModes:
          - ReadWriteOnce
        storageClassName: mariadb-storage
        resources:
          requests:
            storage: 100Gi
```

### ServiceAccount avec RBAC

```yaml
# serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: mariadb
  namespace: database
  labels:
    app: mariadb

---
# Role (si besoin d'accÃ¨s Ã  l'API Kubernetes)
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: mariadb
  namespace: database
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "watch"]
  - apiGroups: [""]
    resources: ["configmaps"]
    verbs: ["get", "list", "watch"]

---
# RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: mariadb
  namespace: database
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: mariadb
subjects:
  - kind: ServiceAccount
    name: mariadb
    namespace: database
```

---

## DÃ©ploiement et gestion

### DÃ©ploiement complet

```bash
# CrÃ©er le namespace
kubectl create namespace database

# Appliquer les manifests dans l'ordre
kubectl apply -f storageclass.yaml
kubectl apply -f configmap.yaml
kubectl apply -f secret.yaml
kubectl apply -f serviceaccount.yaml
kubectl apply -f service-headless.yaml
kubectl apply -f statefulset.yaml

# VÃ©rifier le dÃ©ploiement
kubectl get statefulsets -n database
kubectl get pods -n database -w

# VÃ©rifier les PVC crÃ©Ã©s
kubectl get pvc -n database

# VÃ©rifier les logs
kubectl logs -f mariadb-0 -n database -c mariadb
```

### Commandes de gestion

```bash
# Voir l'Ã©tat du StatefulSet
kubectl describe statefulset mariadb -n database

# Voir les events
kubectl get events -n database --sort-by='.lastTimestamp'

# Se connecter Ã  MariaDB
kubectl exec -it mariadb-0 -n database -c mariadb -- mariadb -uroot -p

# Port-forward pour accÃ¨s local
kubectl port-forward mariadb-0 3306:3306 -n database

# Voir les mÃ©triques
kubectl top pod mariadb-0 -n database
```

---

## Scaling du StatefulSet

### Scale up

```bash
# Augmenter le nombre de replicas
kubectl scale statefulset mariadb --replicas=3 -n database

# Ou Ã©diter le manifest
kubectl edit statefulset mariadb -n database
```

âš ï¸ **Attention** : Le scale up d'un StatefulSet MariaDB standalone crÃ©era des instances indÃ©pendantes. Pour la rÃ©plication, voir la section suivante.

### Scale down

```bash
# RÃ©duire le nombre de replicas
kubectl scale statefulset mariadb --replicas=1 -n database

# âš ï¸ Les PVC ne sont PAS supprimÃ©s automatiquement
# Supprimer manuellement si nÃ©cessaire
kubectl delete pvc data-mariadb-2 -n database
kubectl delete pvc data-mariadb-1 -n database
```

ğŸ’¡ **Conseil** : Le scale down est sÃ©quentiel : mariadb-2 puis mariadb-1, jamais mariadb-0.

---

## Updates et Rollbacks

### Rolling Update

```bash
# Mettre Ã  jour l'image
kubectl set image statefulset/mariadb mariadb=mariadb:11.8.2 -n database

# Ou Ã©diter le StatefulSet
kubectl edit statefulset mariadb -n database

# Suivre le rollout
kubectl rollout status statefulset/mariadb -n database

# Historique
kubectl rollout history statefulset/mariadb -n database
```

**Ordre de mise Ã  jour** :
- Avec `OrderedReady` : mariadb-2 â†’ mariadb-1 â†’ mariadb-0 (ordre inverse)
- Un pod Ã  la fois
- Attend que le pod soit Ready avant de passer au suivant

### Rollback

```bash
# Annuler le dernier rollout
kubectl rollout undo statefulset/mariadb -n database

# Revenir Ã  une rÃ©vision spÃ©cifique
kubectl rollout undo statefulset/mariadb --to-revision=2 -n database
```

### Partition pour rolling update contrÃ´lÃ©

```yaml
spec:
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      partition: 1  # Ne met Ã  jour que les pods >= partition
```

```bash
# Mettre Ã  jour uniquement mariadb-2
kubectl patch statefulset mariadb -n database -p '{"spec":{"updateStrategy":{"rollingUpdate":{"partition":2}}}}'
kubectl set image statefulset/mariadb mariadb=mariadb:11.8.2 -n database

# Puis mariadb-1
kubectl patch statefulset mariadb -n database -p '{"spec":{"updateStrategy":{"rollingUpdate":{"partition":1}}}}'

# Enfin mariadb-0
kubectl patch statefulset mariadb -n database -p '{"spec":{"updateStrategy":{"rollingUpdate":{"partition":0}}}}'
```

ğŸ’¡ **Conseil** : Utilisez les partitions pour tester les updates sur un sous-ensemble de pods avant rollout complet.

---

## StatefulSet avec rÃ©plication Master-Slave

### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   mariadb-0      â”‚     â”‚   mariadb-1      â”‚     â”‚   mariadb-2      â”‚
â”‚   (Primary)      â”‚â”€â”€â”€â”€â–¶â”‚   (Replica)      â”‚     â”‚   (Replica)      â”‚
â”‚                  â”‚     â”‚                  â”‚     â”‚                  â”‚
â”‚ Read/Write       â”‚     â”‚ Read-only        â”‚     â”‚ Read-only        â”‚
â”‚                  â”‚     â”‚                  â”‚â—€â”€â”€â”€â”€â”‚                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                        â”‚                        â”‚
         â”‚                        â”‚                        â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
    â”‚  PVC-0  â”‚              â”‚  PVC-1  â”‚              â”‚  PVC-2  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ConfigMap pour Primary

```yaml
# configmap-primary.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mariadb-primary-config
  namespace: database
data:
  primary.cnf: |
    [mysqld]
    # Server ID basÃ© sur l'ordinal du pod
    server-id = 1
    
    # Binary logging
    log-bin = mariadb-bin
    binlog-format = ROW
    expire_logs_days = 7
    
    # GTID
    gtid_strict_mode = 1
    
    # Read-only dÃ©sactivÃ© sur primary
    read_only = 0
```

### ConfigMap pour Replicas

```yaml
# configmap-replica.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mariadb-replica-config
  namespace: database
data:
  replica.cnf: |
    [mysqld]
    # Server ID sera calculÃ© dynamiquement (2, 3, ...)
    
    # Read-only
    read_only = 1
    super_read_only = 1
    
    # Relay logs
    relay-log = relay-bin
    relay-log-index = relay-bin.index
    
    # GTID
    gtid_strict_mode = 1
    
    # Crash safety
    relay_log_recovery = 1
    relay_log_purge = 1
```

### StatefulSet avec init container pour rÃ©plication

```yaml
# statefulset-replication.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mariadb
  namespace: database
spec:
  serviceName: mariadb
  replicas: 3
  selector:
    matchLabels:
      app: mariadb
  template:
    metadata:
      labels:
        app: mariadb
    spec:
      initContainers:
        # Init container pour configurer la rÃ©plication
        - name: init-replication
          image: mariadb:11.8
          command:
            - bash
            - -c
            - |
              set -ex
              
              # RÃ©cupÃ©rer l'ordinal du pod
              [[ $(hostname) =~ -([0-9]+)$ ]] || exit 1
              ordinal=${BASH_REMATCH[1]}
              
              # Configuration selon le rÃ´le
              if [[ $ordinal -eq 0 ]]; then
                echo "Configuring as PRIMARY"
                cp /config-primary/primary.cnf /etc/mysql/conf.d/
                echo "server-id=1" >> /etc/mysql/conf.d/server.cnf
              else
                echo "Configuring as REPLICA"
                cp /config-replica/replica.cnf /etc/mysql/conf.d/
                echo "server-id=$((ordinal + 1))" >> /etc/mysql/conf.d/server.cnf
                
                # Attendre que le primary soit prÃªt
                until mariadb -h mariadb-0.mariadb -uroot -p"${MARIADB_ROOT_PASSWORD}" -e "SELECT 1"; do
                  echo "Waiting for primary to be ready..."
                  sleep 5
                done
                
                # Si c'est la premiÃ¨re initialisation, configurer la rÃ©plication
                if [ ! -f /var/lib/mysql/replica_configured ]; then
                  echo "Setting up replication..."
                  
                  # CrÃ©er le fichier de configuration rÃ©plication
                  cat > /tmp/setup-replica.sql <<EOF
              CHANGE MASTER TO
                MASTER_HOST='mariadb-0.mariadb.database.svc.cluster.local',
                MASTER_PORT=3306,
                MASTER_USER='repl_user',
                MASTER_PASSWORD='${MARIADB_REPLICATION_PASSWORD}',
                MASTER_USE_GTID=current_pos;
              START SLAVE;
              EOF
                  
                  touch /var/lib/mysql/replica_configured
                fi
              fi
          env:
            - name: MARIADB_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mariadb-secret
                  key: mariadb-root-password
            - name: MARIADB_REPLICATION_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mariadb-secret
                  key: mariadb-replication-password
          volumeMounts:
            - name: config-primary
              mountPath: /config-primary
            - name: config-replica
              mountPath: /config-replica
            - name: mariadb-config
              mountPath: /etc/mysql/conf.d
            - name: data
              mountPath: /var/lib/mysql
      
      containers:
        - name: mariadb
          image: mariadb:11.8
          # ... reste de la configuration identique au StatefulSet standalone
          
          # Ajouter un script post-start pour configurer rÃ©plication
          lifecycle:
            postStart:
              exec:
                command:
                  - bash
                  - -c
                  - |
                    # Attendre que MariaDB soit prÃªt
                    until mariadb -h127.0.0.1 -uroot -p"${MARIADB_ROOT_PASSWORD}" -e "SELECT 1" 2>/dev/null; do
                      sleep 2
                    done
                    
                    # Si ordinal != 0 et fichier de setup existe, configurer rÃ©plication
                    [[ $(hostname) =~ -([0-9]+)$ ]] || exit 0
                    ordinal=${BASH_REMATCH[1]}
                    
                    if [[ $ordinal -ne 0 ]] && [[ -f /tmp/setup-replica.sql ]]; then
                      mariadb -h127.0.0.1 -uroot -p"${MARIADB_ROOT_PASSWORD}" < /tmp/setup-replica.sql
                      rm /tmp/setup-replica.sql
                    fi
                    
                    # Si ordinal == 0, crÃ©er l'utilisateur de rÃ©plication
                    if [[ $ordinal -eq 0 ]]; then
                      mariadb -h127.0.0.1 -uroot -p"${MARIADB_ROOT_PASSWORD}" <<EOF
              CREATE USER IF NOT EXISTS 'repl_user'@'%' IDENTIFIED BY '${MARIADB_REPLICATION_PASSWORD}';
              GRANT REPLICATION SLAVE ON *.* TO 'repl_user'@'%';
              FLUSH PRIVILEGES;
              EOF
                    fi
      
      volumes:
        - name: config-primary
          configMap:
            name: mariadb-primary-config
        - name: config-replica
          configMap:
            name: mariadb-replica-config
        - name: mariadb-config
          emptyDir: {}
  
  volumeClaimTemplates:
    - metadata:
        name: data
      spec:
        accessModes: ["ReadWriteOnce"]
        storageClassName: mariadb-storage
        resources:
          requests:
            storage: 100Gi
```

### Services pour Primary et Replicas

```yaml
# service-primary.yaml
apiVersion: v1
kind: Service
metadata:
  name: mariadb-primary
  namespace: database
  labels:
    app: mariadb
    role: primary
spec:
  type: ClusterIP
  selector:
    app: mariadb
    statefulset.kubernetes.io/pod-name: mariadb-0
  ports:
    - name: mysql
      port: 3306
      targetPort: 3306

---
# service-replica.yaml
apiVersion: v1
kind: Service
metadata:
  name: mariadb-replica
  namespace: database
  labels:
    app: mariadb
    role: replica
spec:
  type: ClusterIP
  selector:
    app: mariadb
  ports:
    - name: mysql
      port: 3306
      targetPort: 3306
  # Exclure le primary du load balancing
  publishNotReadyAddresses: false
```

ğŸ’¡ **Conseil** : Utilisez `mariadb-primary` pour les Ã©critures et `mariadb-replica` pour les lectures.

---

## Bonnes pratiques et optimisations

### 1. Resource requests et limits

```yaml
resources:
  requests:
    cpu: "1000m"
    memory: "3Gi"
  limits:
    cpu: "2000m"
    memory: "4Gi"
```

**RÃ¨gles** :
- `requests` : Ressources garanties (pour scheduling)
- `limits` : Maximum autorisÃ© (Ã©vite OOM)
- Ratio CPU limit/request : 2x max
- Memory limit â‰ˆ requests (Ã©vite swap)

### 2. Anti-affinity pour haute disponibilitÃ©

```yaml
affinity:
  podAntiAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchLabels:
            app: mariadb
        topologyKey: kubernetes.io/hostname  # Nodes diffÃ©rents
```

### 3. Topology spread constraints

```yaml
topologySpreadConstraints:
  - maxSkew: 1
    topologyKey: topology.kubernetes.io/zone
    whenUnsatisfiable: DoNotSchedule
    labelSelector:
      matchLabels:
        app: mariadb
```

### 4. PodDisruptionBudget

```yaml
# pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: mariadb-pdb
  namespace: database
spec:
  minAvailable: 1  # Au moins 1 pod disponible
  selector:
    matchLabels:
      app: mariadb
```

### 5. Network Policies

```yaml
# networkpolicy.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: mariadb-netpol
  namespace: database
spec:
  podSelector:
    matchLabels:
      app: mariadb
  policyTypes:
    - Ingress
    - Egress
  ingress:
    # Autoriser uniquement depuis l'application
    - from:
        - namespaceSelector:
            matchLabels:
              name: application
        - podSelector:
            matchLabels:
              app: myapp
      ports:
        - protocol: TCP
          port: 3306
    # Autoriser depuis Prometheus
    - from:
        - namespaceSelector:
            matchLabels:
              name: monitoring
      ports:
        - protocol: TCP
          port: 9104
  egress:
    # DNS
    - to:
        - namespaceSelector:
            matchLabels:
              name: kube-system
      ports:
        - protocol: UDP
          port: 53
```

---

## Monitoring avec ServiceMonitor

### ServiceMonitor pour Prometheus Operator

```yaml
# servicemonitor.yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: mariadb
  namespace: database
  labels:
    app: mariadb
    release: prometheus
spec:
  selector:
    matchLabels:
      app: mariadb
  endpoints:
    - port: metrics
      interval: 30s
      path: /metrics
      scheme: http
  namespaceSelector:
    matchNames:
      - database
```

---

## âœ… Points clÃ©s Ã  retenir

- **StatefulSet** : Essentiel pour MariaDB sur K8s (identitÃ© stable, ordre garanti)
- **PersistentVolumes** : Un PVC par pod, crÃ©Ã© automatiquement via volumeClaimTemplates
- **Headless Service** : DNS prÃ©visible pour communication inter-pods
- **Anti-affinity** : Distribuer les pods sur diffÃ©rents nodes
- **Probes** : Liveness, Readiness et Startup pour orchestration robuste
- **Secrets** : Utiliser External Secrets Operator ou Vault en production
- **Resources** : DÃ©finir requests/limits pour scheduling optimal
- **Updates** : Rolling updates avec partition pour contrÃ´le granulaire
- **RÃ©plication** : Init containers pour configurer Master-Slave automatiquement
- **MariaDB 11.8** : utf8mb4 par dÃ©faut, optimisations SSD, GTID strict mode

---

## ğŸ”— Ressources et rÃ©fÃ©rences

### Documentation officielle
- [ğŸ“– Kubernetes StatefulSets](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/)
- [ğŸ“– Kubernetes Persistent Volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/)
- [ğŸ“– MariaDB on Kubernetes](https://mariadb.com/kb/en/getting-started-with-mariadb-on-kubernetes/)

### Best practices
- [Running MariaDB on Kubernetes](https://www.percona.com/blog/running-mariadb-on-kubernetes/)
- [StatefulSet Best Practices](https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/)

### Outils
- [k9s](https://k9scli.io/) - Terminal UI pour Kubernetes
- [Lens](https://k8slens.dev/) - IDE Kubernetes
- [kubectl-tree](https://github.com/ahmetb/kubectl-tree) - Visualiser les ressources

---

## â¡ï¸ Section suivante

**16.4.2 PersistentVolumes et StorageClasses** : Approfondissez la gestion du stockage persistant pour MariaDB sur Kubernetes avec diffÃ©rents provisioners et stratÃ©gies de backup.

---

**MariaDB** : 11.8 LTS

â­ï¸ [PersistentVolumes et StorageClasses](/16-devops-automatisation/04.2-persistentvolumes.md)
