üîù Retour au [Sommaire](/SOMMAIRE.md)

# 16.5.4 Backups automatis√©s avec mariadb-operator

> **Niveau** : Avanc√© √† Expert  
> **Dur√©e estim√©e** : 3-4 heures  
> **Pr√©requis** : Section 16.5.1 (Installation operator), Section 12 (Sauvegarde/Restauration), Kubernetes storage avanc√©

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Configurer des backups automatis√©s via le mariadb-operator avec des CRDs d√©di√©es
- Impl√©menter des strat√©gies de backup compl√®tes (full, incremental, point-in-time)
- Automatiser les backups vers S3, MinIO, et autres object storage
- Orchestrer les restaurations automatiques et le disaster recovery
- Monitorer l'√©tat des backups via Prometheus et alertes
- Int√©grer avec Velero pour les snapshots de volumes Kubernetes
- Mettre en place des politiques de r√©tention et rotation automatiques
- Valider l'int√©grit√© des backups et tester les proc√©dures de restauration

---

## Introduction

La sauvegarde des bases de donn√©es dans un environnement Kubernetes pr√©sente des d√©fis sp√©cifiques :
- **Persistance √©ph√©m√®re** : Les pods peuvent √™tre recr√©√©s √† tout moment
- **Stockage distribu√©** : PersistentVolumes sur diff√©rents n≈ìuds
- **Automatisation** : N√©cessit√© de backups programm√©s sans intervention manuelle
- **Coh√©rence** : Garantir des backups transactionnellement coh√©rents
- **Disaster Recovery** : Restauration rapide en cas de sinistre

Le **mariadb-operator** fournit une CRD `Backup` qui simplifie consid√©rablement ces op√©rations en automatisant :
- La programmation des backups (CronJobs Kubernetes)
- L'orchestration de mariabackup/mysqldump
- Le transfert vers object storage (S3, GCS, Azure Blob)
- La gestion des secrets et credentials
- Le monitoring et les alertes
- La restauration point-in-time

### Strat√©gies de backup support√©es

| Type | Outil | Coh√©rence | Performance | Cas d'usage |
|------|-------|-----------|-------------|-------------|
| **Logical** | mysqldump | Transactionnelle | Lente (grosse DB) | Portabilit√©, migrations |
| **Physical** | mariabackup | Crash-consistent | Rapide | Production, PITR |
| **Snapshot** | Volume snapshots | Block-level | Tr√®s rapide | DR instantan√© |
| **Incremental** | mariabackup --incremental | Optimale | Rapide | Backup fr√©quents |

üí° **Conseil** : Utilisez **mariabackup** (physical) pour les bases de production > 50GB, et **mysqldump** (logical) uniquement pour les petites bases ou les migrations.

---

## Architecture de backup avec mariadb-operator

### Flux d'ex√©cution d'un backup

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Kubernetes Cluster                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ
‚îÇ  ‚îÇ  Backup CRD  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  mariadb-operator   ‚îÇ            ‚îÇ
‚îÇ  ‚îÇ   (YAML)     ‚îÇ         ‚îÇ  (Controller)       ‚îÇ            ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
‚îÇ                                     ‚îÇ                        ‚îÇ
‚îÇ                                     ‚ñº                        ‚îÇ
‚îÇ                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îÇ
‚îÇ                          ‚îÇ   CronJob Created   ‚îÇ             ‚îÇ
‚îÇ                          ‚îÇ   (Schedule)        ‚îÇ             ‚îÇ
‚îÇ                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îÇ
‚îÇ                                     ‚îÇ                        ‚îÇ
‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ                    ‚ñº                                 ‚ñº       ‚îÇ
‚îÇ         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
‚îÇ         ‚îÇ   Job (Backup Pod)  ‚îÇ          ‚îÇ  Service Account ‚îÇ‚îÇ
‚îÇ         ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ          ‚îÇ   + RBAC         ‚îÇ‚îÇ
‚îÇ         ‚îÇ  ‚îÇ  Init Container‚îÇ ‚îÇ          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
‚îÇ         ‚îÇ  ‚îÇ  (Validation)  ‚îÇ ‚îÇ                              ‚îÇ
‚îÇ         ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ                              ‚îÇ
‚îÇ         ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ                              ‚îÇ
‚îÇ         ‚îÇ  ‚îÇ   mariabackup  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                           ‚îÇ
‚îÇ         ‚îÇ  ‚îÇ   Container    ‚îÇ    ‚îÇ                           ‚îÇ
‚îÇ         ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ                           ‚îÇ
‚îÇ         ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ  Read                     ‚îÇ
‚îÇ         ‚îÇ  ‚îÇ   Sidecar:     ‚îÇ    ‚îÇ  Data                     ‚îÇ
‚îÇ         ‚îÇ  ‚îÇ   Upload to S3 ‚îÇ    ‚îÇ                           ‚îÇ
‚îÇ         ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ                           ‚îÇ
‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ                           ‚îÇ
‚îÇ                    ‚îÇ             ‚îÇ                           ‚îÇ
‚îÇ                    ‚îÇ             ‚ñº                           ‚îÇ
‚îÇ                    ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                 ‚îÇ
‚îÇ                    ‚îÇ    ‚îÇ  MariaDB Pod     ‚îÇ                 ‚îÇ
‚îÇ                    ‚îÇ    ‚îÇ  (StatefulSet)   ‚îÇ                 ‚îÇ
‚îÇ                    ‚îÇ    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ                 ‚îÇ
‚îÇ                    ‚îÇ    ‚îÇ  ‚îÇ PV (Data)   ‚îÇ ‚îÇ                 ‚îÇ
‚îÇ                    ‚îÇ    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ                 ‚îÇ
‚îÇ                    ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îÇ
‚îÇ                    ‚îÇ                                         ‚îÇ
‚îÇ                    ‚ñº                                         ‚îÇ
‚îÇ         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                              ‚îÇ
‚îÇ         ‚îÇ   Object Storage    ‚îÇ                              ‚îÇ
‚îÇ         ‚îÇ   (S3/MinIO/GCS)    ‚îÇ                              ‚îÇ
‚îÇ         ‚îÇ  backup-YYYYMMDD... ‚îÇ                              ‚îÇ
‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                              ‚îÇ
‚îÇ                    ‚îÇ                                         ‚îÇ
‚îÇ                    ‚ñº                                         ‚îÇ
‚îÇ         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                              ‚îÇ
‚îÇ         ‚îÇ   BackupStatus CRD  ‚îÇ                              ‚îÇ
‚îÇ         ‚îÇ   - completionTime  ‚îÇ                              ‚îÇ
‚îÇ         ‚îÇ   - size            ‚îÇ                              ‚îÇ
‚îÇ         ‚îÇ   - location        ‚îÇ                              ‚îÇ
‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                              ‚îÇ
‚îÇ                                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Composants cr√©√©s automatiquement

L'operator cr√©e :
- **CronJob** : Planification des backups r√©currents
- **Job** : Ex√©cution ponctuelle d'un backup
- **Pod** : Container temporaire pour ex√©cuter mariabackup/mysqldump
- **Secret** : Credentials S3/GCS si non fournis
- **PVC temporaire** : Stockage interm√©diaire si n√©cessaire
- **BackupStatus** : M√©tadonn√©es et √©tat du backup

---

## Configuration des backups automatis√©s

### 1. Backup physique complet vers S3 (mariabackup)

```yaml
apiVersion: k8s.mariadb.com/v1alpha1
kind: Backup
metadata:
  name: mariadb-daily-backup
  namespace: production
spec:
  # R√©f√©rence √† l'instance MariaDB
  mariadbRef:
    name: mariadb-primary
  
  # Type de backup : physical (mariabackup) ou logical (mysqldump)
  backupType: physical
  
  # Configuration mariabackup
  mariabackup:
    # Options suppl√©mentaires
    extraArgs:
    - "--parallel=4"          # Threads parall√®les
    - "--compress"            # Compression qpress
    - "--compress-threads=4"
    - "--stream=xbstream"     # Format de streaming
  
  # Planification (Cron)
  schedule:
    # Tous les jours √† 2h du matin
    cron: "0 2 * * *"
    # Fuseau horaire
    timezone: "Europe/Paris"
    # Suspendre si n√©cessaire
    suspend: false
  
  # Politique de r√©tention
  retentionPolicy:
    # Conserver les 7 derniers backups
    keepLast: 7
    # Ou d√©finir une dur√©e
    # ttl: "168h"  # 7 jours
  
  # Destination : S3
  storage:
    s3:
      # Bucket S3
      bucket: mariadb-backups-prod
      # R√©gion AWS
      region: eu-west-1
      # Endpoint (personnalis√© pour MinIO)
      endpoint: s3.amazonaws.com
      # Pr√©fixe dans le bucket
      prefix: daily-backups/
      # Credentials AWS
      accessKeyIdSecretKeyRef:
        name: aws-s3-credentials
        key: access-key-id
      secretAccessKeySecretKeyRef:
        name: aws-s3-credentials
        key: secret-access-key
      # TLS
      tls:
        enabled: true
        caSecretKeyRef:
          name: s3-ca-cert
          key: ca.crt
  
  # Resources pour le pod de backup
  resources:
    requests:
      cpu: "2"
      memory: "4Gi"
    limits:
      cpu: "4"
      memory: "8Gi"
  
  # S√©lection du pod source (pour cluster Galera ou replicas)
  podSelector:
    matchLabels:
      # Backup depuis un replica pour ne pas impacter le primary
      app.kubernetes.io/instance: mariadb-replica
      statefulset.kubernetes.io/pod-name: mariadb-replica-2
  
  # Affinity pour placer le backup pod sur le m√™me n≈ìud (optimisation r√©seau)
  affinity:
    podAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - key: app.kubernetes.io/instance
              operator: In
              values:
              - mariadb-replica
          topologyKey: kubernetes.io/hostname
  
  # Tol√©rances pour n≈ìuds d√©di√©s
  tolerations:
  - key: "database"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"
```

### Secret AWS S3

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: aws-s3-credentials
  namespace: production
type: Opaque
stringData:
  access-key-id: "AKIAIOSFODNN7EXAMPLE"
  secret-access-key: "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
```

‚ö†Ô∏è **Attention** : En production, utilisez **External Secrets Operator**, **Sealed Secrets**, ou **AWS IAM Roles for Service Accounts (IRSA)** pour √©viter de stocker les credentials en clair.

### 2. Backup incr√©mental quotidien + full hebdomadaire

Strat√©gie 3-2-1 : 3 copies, 2 supports diff√©rents, 1 copie hors-site.

```yaml
---
# Backup FULL hebdomadaire (dimanche)
apiVersion: k8s.mariadb.com/v1alpha1
kind: Backup
metadata:
  name: mariadb-weekly-full
  namespace: production
spec:
  mariadbRef:
    name: mariadb-primary
  
  backupType: physical
  
  mariabackup:
    extraArgs:
    - "--parallel=8"
    - "--compress"
    - "--compress-threads=8"
  
  schedule:
    # Dimanche √† 1h du matin
    cron: "0 1 * * 0"
    timezone: "Europe/Paris"
  
  retentionPolicy:
    # Conserver 4 backups hebdomadaires (1 mois)
    keepLast: 4
  
  storage:
    s3:
      bucket: mariadb-backups-prod
      region: eu-west-1
      prefix: weekly-full/
      accessKeyIdSecretKeyRef:
        name: aws-s3-credentials
        key: access-key-id
      secretAccessKeySecretKeyRef:
        name: aws-s3-credentials
        key: secret-access-key
  
  resources:
    requests:
      cpu: "4"
      memory: "8Gi"
    limits:
      cpu: "8"
      memory: "16Gi"

---
# Backup INCREMENTAL quotidien (lundi-samedi)
apiVersion: k8s.mariadb.com/v1alpha1
kind: Backup
metadata:
  name: mariadb-daily-incremental
  namespace: production
spec:
  mariadbRef:
    name: mariadb-primary
  
  backupType: physical
  
  mariabackup:
    # Base du backup incr√©mental (r√©f√©rence au dernier full)
    incrementalBasePath: s3://mariadb-backups-prod/weekly-full/latest
    extraArgs:
    - "--parallel=4"
    - "--incremental"
  
  schedule:
    # Lundi √† samedi √† 2h du matin
    cron: "0 2 * * 1-6"
    timezone: "Europe/Paris"
  
  retentionPolicy:
    # Conserver 7 jours d'incr√©mentiels
    keepLast: 7
  
  storage:
    s3:
      bucket: mariadb-backups-prod
      region: eu-west-1
      prefix: daily-incremental/
      accessKeyIdSecretKeyRef:
        name: aws-s3-credentials
        key: access-key-id
      secretAccessKeySecretKeyRef:
        name: aws-s3-credentials
        key: secret-access-key
  
  resources:
    requests:
      cpu: "2"
      memory: "4Gi"
    limits:
      cpu: "4"
      memory: "8Gi"
```

üí° **Conseil** : Les backups incr√©mentiels n√©cessitent une cha√Æne compl√®te (full + tous les incr√©mentiels). Assurez-vous que votre politique de r√©tention conserve le full de base.

### 3. Backup logique (mysqldump) pour migration/archivage

```yaml
apiVersion: k8s.mariadb.com/v1alpha1
kind: Backup
metadata:
  name: mariadb-logical-monthly
  namespace: production
spec:
  mariadbRef:
    name: mariadb-primary
  
  # Type logique
  backupType: logical
  
  # Configuration mysqldump
  mysqldump:
    # Databases sp√©cifiques (ou --all-databases)
    databases:
    - myapp_production
    - analytics
    
    # Options mysqldump
    extraArgs:
    - "--single-transaction"      # Coh√©rence transactionnelle
    - "--routines"                 # Inclure proc√©dures stock√©es
    - "--triggers"                 # Inclure triggers
    - "--events"                   # Inclure events
    - "--compress"                 # Compression r√©seau
    - "--hex-blob"                 # Format binaire portable
    - "--quick"                    # Streaming (pas de buffer)
    - "--skip-lock-tables"         # √âviter les locks globaux
  
  schedule:
    # Premier jour du mois √† 3h
    cron: "0 3 1 * *"
    timezone: "Europe/Paris"
  
  retentionPolicy:
    # Conserver 12 backups mensuels (1 an)
    keepLast: 12
  
  storage:
    s3:
      bucket: mariadb-backups-archive
      region: eu-west-1
      prefix: monthly-logical/
      # Classe de stockage pour archivage long terme
      storageClass: GLACIER
      accessKeyIdSecretKeyRef:
        name: aws-s3-credentials
        key: access-key-id
      secretAccessKeySecretKeyRef:
        name: aws-s3-credentials
        key: secret-access-key
  
  resources:
    requests:
      cpu: "1"
      memory: "2Gi"
    limits:
      cpu: "2"
      memory: "4Gi"
```

### 4. Backup vers MinIO (S3-compatible on-premise)

```yaml
apiVersion: k8s.mariadb.com/v1alpha1
kind: Backup
metadata:
  name: mariadb-backup-minio
  namespace: production
spec:
  mariadbRef:
    name: mariadb-primary
  
  backupType: physical
  
  schedule:
    cron: "0 */6 * * *"  # Toutes les 6 heures
  
  retentionPolicy:
    keepLast: 28  # 7 jours * 4 backups/jour
  
  storage:
    s3:
      bucket: mariadb-backups
      # Endpoint MinIO
      endpoint: minio.storage.svc.cluster.local:9000
      region: us-east-1  # Requis m√™me pour MinIO
      prefix: k8s-backups/
      # TLS d√©sactiv√© pour MinIO interne
      tls:
        enabled: false
      # Credentials MinIO
      accessKeyIdSecretKeyRef:
        name: minio-credentials
        key: access-key
      secretAccessKeySecretKeyRef:
        name: minio-credentials
        key: secret-key
```

---

## Restauration automatis√©e

### 1. Restore CRD pour restauration compl√®te

```yaml
apiVersion: k8s.mariadb.com/v1alpha1
kind: Restore
metadata:
  name: mariadb-restore-20250115
  namespace: production
spec:
  # R√©f√©rence au backup source
  backupRef:
    name: mariadb-daily-backup
  
  # Ou sp√©cifier directement le chemin S3
  # storage:
  #   s3:
  #     bucket: mariadb-backups-prod
  #     region: eu-west-1
  #     prefix: daily-backups/backup-20250115-020000.xbstream
  
  # Destination de la restauration
  targetMariaDB:
    name: mariadb-primary
  
  # Restauration dans une nouvelle instance (DR)
  # targetMariaDB:
  #   name: mariadb-dr-instance
  #   namespace: disaster-recovery
  
  # Options mariabackup --prepare
  mariabackup:
    extraArgs:
    - "--use-memory=8G"  # Optimisation m√©moire pour prepare
  
  # Resources pour le pod de restore
  resources:
    requests:
      cpu: "4"
      memory: "12Gi"
    limits:
      cpu: "8"
      memory: "16Gi"
```

### Proc√©dure de restauration point-in-time (PITR)

Pour restaurer √† un instant T pr√©cis apr√®s un backup :

```yaml
apiVersion: k8s.mariadb.com/v1alpha1
kind: Restore
metadata:
  name: mariadb-pitr-20250115-143000
  namespace: production
spec:
  backupRef:
    name: mariadb-daily-backup
  
  targetMariaDB:
    name: mariadb-restored-pitr
    namespace: production
  
  # Point-in-time recovery
  pointInTime:
    # Timestamp exact de restauration
    timestamp: "2025-01-15T14:30:00Z"
    
    # Binlogs source (si archiv√©s s√©par√©ment)
    binlogStorage:
      s3:
        bucket: mariadb-binlogs-archive
        region: eu-west-1
        prefix: binlogs/
        accessKeyIdSecretKeyRef:
          name: aws-s3-credentials
          key: access-key-id
        secretAccessKeySecretKeyRef:
          name: aws-s3-credentials
          key: secret-access-key
  
  resources:
    requests:
      cpu: "4"
      memory: "12Gi"
```

üí° **Conseil PITR** : Archivez syst√©matiquement les binlogs vers S3 avec un script cron ou un operator secondaire pour permettre le PITR.

### Script pour archivage binlogs vers S3

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: mariadb-binlog-archiver
  namespace: production
spec:
  schedule: "*/15 * * * *"  # Toutes les 15 minutes
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: binlog-archiver
            image: mariadb:11.8.2
            command:
            - /bin/bash
            - -c
            - |
              #!/bin/bash
              set -euo pipefail
              
              # Variables
              MARIADB_HOST="mariadb-primary-svc"
              S3_BUCKET="mariadb-binlogs-archive"
              S3_PREFIX="binlogs/"
              
              # R√©cup√©rer la liste des binlogs
              BINLOGS=$(mariadb -h $MARIADB_HOST -u root -p"${MARIADB_ROOT_PASSWORD}" \
                -e "SHOW BINARY LOGS" -s -N | awk '{print $1}')
              
              # Binlog actuel (ne pas archiver)
              CURRENT_BINLOG=$(mariadb -h $MARIADB_HOST -u root -p"${MARIADB_ROOT_PASSWORD}" \
                -e "SHOW MASTER STATUS" -s -N | awk '{print $1}')
              
              # Pour chaque binlog (sauf le current)
              for BINLOG in $BINLOGS; do
                if [ "$BINLOG" != "$CURRENT_BINLOG" ]; then
                  # V√©rifier si d√©j√† archiv√©
                  if ! aws s3 ls "s3://${S3_BUCKET}/${S3_PREFIX}${BINLOG}" > /dev/null 2>&1; then
                    echo "Archiving $BINLOG to S3..."
                    
                    # Copier depuis le pod MariaDB
                    kubectl cp production/mariadb-primary-0:/var/lib/mysql/$BINLOG /tmp/$BINLOG
                    
                    # Upload vers S3
                    aws s3 cp /tmp/$BINLOG "s3://${S3_BUCKET}/${S3_PREFIX}${BINLOG}"
                    
                    # V√©rifier l'upload
                    if aws s3 ls "s3://${S3_BUCKET}/${S3_PREFIX}${BINLOG}" > /dev/null 2>&1; then
                      echo "Successfully archived $BINLOG"
                      rm -f /tmp/$BINLOG
                      
                      # Purger le binlog local (optionnel, attention!)
                      # mariadb -h $MARIADB_HOST -u root -p"${MARIADB_ROOT_PASSWORD}" \
                      #   -e "PURGE BINARY LOGS TO '$BINLOG'"
                    else
                      echo "ERROR: Failed to archive $BINLOG"
                      exit 1
                    fi
                  fi
                fi
              done
              
              echo "Binlog archiving completed"
            env:
            - name: MARIADB_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mariadb-root
                  key: password
            - name: AWS_ACCESS_KEY_ID
              valueFrom:
                secretKeyRef:
                  name: aws-s3-credentials
                  key: access-key-id
            - name: AWS_SECRET_ACCESS_KEY
              valueFrom:
                secretKeyRef:
                  name: aws-s3-credentials
                  key: secret-access-key
            - name: AWS_DEFAULT_REGION
              value: "eu-west-1"
          restartPolicy: OnFailure
          serviceAccountName: mariadb-binlog-archiver
```

---

## Int√©gration avec Velero pour snapshots de volumes

**Velero** est un outil de backup/restore pour Kubernetes qui utilise les snapshots de volumes cloud-native.

### Installation de Velero

```bash
# Installation via Helm
helm repo add vmware-tanzu https://vmware-tanzu.github.io/helm-charts
helm repo update

helm install velero vmware-tanzu/velero \
  --namespace velero \
  --create-namespace \
  --set configuration.backupStorageLocation.bucket=velero-backups \
  --set configuration.backupStorageLocation.config.region=eu-west-1 \
  --set configuration.volumeSnapshotLocation.config.region=eu-west-1 \
  --set credentials.secretContents.cloud="$(cat aws-credentials.txt)" \
  --set initContainers[0].name=velero-plugin-for-aws \
  --set initContainers[0].image=velero/velero-plugin-for-aws:v1.8.0 \
  --set initContainers[0].volumeMounts[0].mountPath=/target \
  --set initContainers[0].volumeMounts[0].name=plugins
```

### Backup MariaDB avec Velero

```yaml
apiVersion: velero.io/v1
kind: Backup
metadata:
  name: mariadb-snapshot-backup
  namespace: velero
spec:
  # Inclure uniquement le namespace MariaDB
  includedNamespaces:
  - production
  
  # S√©lectionner les ressources MariaDB
  labelSelector:
    matchLabels:
      app.kubernetes.io/name: mariadb
  
  # Snapshot des PersistentVolumes
  snapshotVolumes: true
  
  # Hooks pour coh√©rence des donn√©es
  hooks:
    resources:
    # Avant le snapshot : flush tables et lock
    - name: mariadb-freeze
      includedNamespaces:
      - production
      labelSelector:
        matchLabels:
          app.kubernetes.io/name: mariadb
      pre:
      - exec:
          container: mariadb
          command:
          - /bin/bash
          - -c
          - |
            mariadb -u root -p"${MARIADB_ROOT_PASSWORD}" \
              -e "FLUSH TABLES WITH READ LOCK; SYSTEM sleep 30"
          timeout: 1m
      
      # Apr√®s le snapshot : unlock
      post:
      - exec:
          container: mariadb
          command:
          - /bin/bash
          - -c
          - |
            mariadb -u root -p"${MARIADB_ROOT_PASSWORD}" \
              -e "UNLOCK TABLES"
          timeout: 30s
  
  # R√©tention
  ttl: 720h  # 30 jours
  
  # BackupStorageLocation
  storageLocation: default
  
  # VolumeSnapshotLocation
  volumeSnapshotLocations:
  - default
```

### Schedule automatique Velero

```yaml
apiVersion: velero.io/v1
kind: Schedule
metadata:
  name: mariadb-daily-snapshot
  namespace: velero
spec:
  # Tous les jours √† 1h
  schedule: "0 1 * * *"
  
  template:
    includedNamespaces:
    - production
    labelSelector:
      matchLabels:
        app.kubernetes.io/name: mariadb
    snapshotVolumes: true
    ttl: 168h  # 7 jours
```

### Restauration Velero

```bash
# Lister les backups
velero backup get

# Restaurer un backup sp√©cifique
velero restore create mariadb-restore-20250115 \
  --from-backup mariadb-snapshot-backup \
  --namespace-mappings production:production-restored

# Monitorer la restauration
velero restore describe mariadb-restore-20250115

# Logs d√©taill√©s
velero restore logs mariadb-restore-20250115
```

üí° **Conseil** : Combinez mariadb-operator (backups logiques/physiques) avec Velero (snapshots de volumes) pour une strat√©gie de backup compl√®te : snapshots rapides pour DR imm√©diat, backups physiques pour r√©tention long terme.

---

## Monitoring et alerting des backups

### ServiceMonitor pour m√©triques de backup

```yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: mariadb-backup-metrics
  namespace: production
spec:
  selector:
    matchLabels:
      app.kubernetes.io/component: backup
      app.kubernetes.io/name: mariadb-operator
  endpoints:
  - port: metrics
    interval: 60s
    path: /metrics
```

### PrometheusRule pour alertes backup

```yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: mariadb-backup-alerts
  namespace: production
spec:
  groups:
  - name: mariadb-backups
    interval: 5m
    rules:
    # Alerte si aucun backup r√©ussi depuis 25h
    - alert: MariaDBBackupFailed
      expr: |
        time() - mariadb_backup_last_success_timestamp_seconds > 90000
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "MariaDB backup has not succeeded in 25+ hours"
        description: "No successful backup for {{ $labels.namespace }}/{{ $labels.mariadb }} in the last 25 hours. Last success: {{ $value }}s ago."
    
    # Alerte si backup en cours depuis trop longtemps
    - alert: MariaDBBackupTooLong
      expr: |
        mariadb_backup_duration_seconds > 7200
      for: 10m
      labels:
        severity: warning
      annotations:
        summary: "MariaDB backup running for too long"
        description: "Backup for {{ $labels.namespace }}/{{ $labels.mariadb }} has been running for {{ $value }}s (> 2 hours)."
    
    # Alerte si taille de backup anormale
    - alert: MariaDBBackupSizeAnomaly
      expr: |
        abs(mariadb_backup_size_bytes - avg_over_time(mariadb_backup_size_bytes[7d])) / 
        avg_over_time(mariadb_backup_size_bytes[7d]) > 0.5
      for: 15m
      labels:
        severity: warning
      annotations:
        summary: "MariaDB backup size anomaly detected"
        description: "Backup size for {{ $labels.namespace }}/{{ $labels.mariadb }} is {{ $value | humanizePercentage }} different from 7-day average."
    
    # Alerte si √©chec de CronJob backup
    - alert: MariaDBBackupCronJobFailed
      expr: |
        kube_cronjob_status_last_schedule_time{cronjob=~".*mariadb.*backup.*"} 
        - kube_cronjob_status_last_successful_time{cronjob=~".*mariadb.*backup.*"} > 86400
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "MariaDB backup CronJob failed"
        description: "CronJob {{ $labels.cronjob }} in {{ $labels.namespace }} has not succeeded in 24+ hours."
```

### Dashboard Grafana pour backups

Requ√™tes PromQL cl√©s :

```promql
# Temps depuis dernier backup r√©ussi (secondes)
time() - mariadb_backup_last_success_timestamp_seconds

# Dur√©e moyenne des backups (7 jours)
avg_over_time(mariadb_backup_duration_seconds[7d])

# Taille totale des backups par instance
sum(mariadb_backup_size_bytes) by (mariadb)

# Taux de r√©ussite des backups (7 jours)
sum(rate(mariadb_backup_success_total[7d])) by (mariadb) /
sum(rate(mariadb_backup_attempts_total[7d])) by (mariadb)

# Nombre de backups conserv√©s (par politique de r√©tention)
mariadb_backup_retention_count
```

---

## Validation et tests de restauration

### CronJob pour tests automatiques de restauration

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: mariadb-restore-test
  namespace: production
spec:
  # Hebdomadaire (dimanche 4h)
  schedule: "0 4 * * 0"
  
  # Conserver historique
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: mariadb-restore-test
        spec:
          serviceAccountName: mariadb-operator
          containers:
          - name: restore-validator
            image: mariadb:11.8.2
            command:
            - /bin/bash
            - -c
            - |
              #!/bin/bash
              set -euo pipefail
              
              echo "=== MariaDB Restore Validation Test ==="
              
              # 1. Cr√©er namespace temporaire
              kubectl create namespace mariadb-restore-test || true
              
              # 2. R√©cup√©rer le dernier backup
              LATEST_BACKUP=$(kubectl get backups -n production \
                -o jsonpath='{.items[?(@.status.phase=="Succeeded")].metadata.name}' | \
                tr ' ' '\n' | sort -r | head -n 1)
              
              echo "Testing restore from backup: $LATEST_BACKUP"
              
              # 3. Cr√©er une instance MariaDB de test
              cat <<EOF | kubectl apply -f -
              apiVersion: k8s.mariadb.com/v1alpha1
              kind: MariaDB
              metadata:
                name: mariadb-restore-test
                namespace: mariadb-restore-test
              spec:
                image: mariadb:11.8.2
                rootPasswordSecretKeyRef:
                  name: mariadb-root-test
                  key: password
                  generate: true
                storage:
                  size: 50Gi
                  storageClassName: fast-ssd
              EOF
              
              # 4. Attendre que l'instance soit pr√™te
              kubectl wait --for=condition=Ready mariadb/mariadb-restore-test \
                -n mariadb-restore-test --timeout=300s
              
              # 5. Restaurer le backup
              cat <<EOF | kubectl apply -f -
              apiVersion: k8s.mariadb.com/v1alpha1
              kind: Restore
              metadata:
                name: restore-test-$(date +%Y%m%d)
                namespace: mariadb-restore-test
              spec:
                backupRef:
                  name: $LATEST_BACKUP
                  namespace: production
                targetMariaDB:
                  name: mariadb-restore-test
                  namespace: mariadb-restore-test
              EOF
              
              # 6. Attendre la fin de la restauration
              echo "Waiting for restore to complete..."
              kubectl wait --for=condition=Complete restore/restore-test-$(date +%Y%m%d) \
                -n mariadb-restore-test --timeout=1800s
              
              # 7. Valider l'int√©grit√© des donn√©es
              echo "Validating data integrity..."
              
              # R√©cup√©rer le mot de passe root
              ROOT_PASSWORD=$(kubectl get secret mariadb-root-test \
                -n mariadb-restore-test -o jsonpath='{.data.password}' | base64 -d)
              
              # Tests de validation
              kubectl exec -it mariadb-restore-test-0 -n mariadb-restore-test -- \
                mariadb -u root -p"${ROOT_PASSWORD}" <<SQL
              -- V√©rifier les bases de donn√©es
              SHOW DATABASES;
              
              -- V√©rifier une table (adapter selon votre sch√©ma)
              USE myapp_production;
              SELECT COUNT(*) AS user_count FROM users;
              
              -- V√©rifier l'int√©grit√©
              CHECK TABLE users EXTENDED;
              
              -- V√©rifier les index
              SHOW INDEX FROM users;
              SQL
              
              # 8. Nettoyer
              echo "Cleanup..."
              kubectl delete namespace mariadb-restore-test
              
              echo "=== Restore validation test PASSED ==="
              exit 0
            env:
            - name: KUBECONFIG
              value: /var/run/secrets/kubernetes.io/serviceaccount
          restartPolicy: OnFailure
      backoffLimit: 2
```

### V√©rification manuelle d'un backup

```bash
#!/bin/bash
# Script de validation manuelle d'un backup

set -euo pipefail

BACKUP_NAME="mariadb-daily-backup"
NAMESPACE="production"

echo "=== Validation du backup $BACKUP_NAME ==="

# 1. V√©rifier le statut du backup
echo "1. Checking backup status..."
kubectl get backup $BACKUP_NAME -n $NAMESPACE -o yaml | grep -A 10 status:

# 2. T√©l√©charger le backup depuis S3 (pour inspection)
echo "2. Downloading backup from S3..."
BACKUP_PATH=$(kubectl get backup $BACKUP_NAME -n $NAMESPACE \
  -o jsonpath='{.status.location}')

aws s3 cp "$BACKUP_PATH" /tmp/backup-validation.xbstream

# 3. V√©rifier l'int√©grit√© du fichier
echo "3. Verifying backup file integrity..."
file /tmp/backup-validation.xbstream

# 4. Extraire et pr√©parer le backup (dans un container temporaire)
echo "4. Extracting and preparing backup..."
kubectl run mariadb-backup-validator --rm -it \
  --image=mariadb:11.8.2 \
  --restart=Never \
  -- bash -c '
    # Installer xbstream
    apt-get update && apt-get install -y mariadb-backup
    
    # Extraire
    mkdir -p /tmp/backup-extract
    xbstream -x -C /tmp/backup-extract < /tmp/backup-validation.xbstream
    
    # D√©compresser si compress√©
    if ls /tmp/backup-extract/*.qp 1> /dev/null 2>&1; then
      apt-get install -y qpress
      for file in /tmp/backup-extract/*.qp; do
        qpress -d "$file" "$(dirname "$file")"
        rm -f "$file"
      done
    fi
    
    # Pr√©parer le backup
    mariabackup --prepare --target-dir=/tmp/backup-extract
    
    # V√©rifier la pr√©sence des fichiers cl√©s
    ls -lh /tmp/backup-extract/
    
    echo "Backup validation PASSED"
  '

echo "=== Validation termin√©e ==="
```

---

## Strat√©gie de backup compl√®te en production

### Architecture 3-2-1 recommand√©e

**R√®gle 3-2-1** :
- **3 copies** des donn√©es (production + 2 backups)
- **2 supports diff√©rents** (local + cloud)
- **1 copie hors-site** (r√©gion diff√©rente)

```yaml
---
# 1. Backup physique quotidien vers S3 (r√©gion primaire)
apiVersion: k8s.mariadb.com/v1alpha1
kind: Backup
metadata:
  name: mariadb-daily-s3-primary
  namespace: production
spec:
  mariadbRef:
    name: mariadb-primary
  backupType: physical
  schedule:
    cron: "0 2 * * *"
  retentionPolicy:
    keepLast: 7
  storage:
    s3:
      bucket: mariadb-backups-eu-west-1
      region: eu-west-1
      prefix: daily/

---
# 2. Backup physique hebdomadaire vers S3 (r√©gion secondaire - DR)
apiVersion: k8s.mariadb.com/v1alpha1
kind: Backup
metadata:
  name: mariadb-weekly-s3-dr
  namespace: production
spec:
  mariadbRef:
    name: mariadb-primary
  backupType: physical
  schedule:
    cron: "0 3 * * 0"
  retentionPolicy:
    keepLast: 4
  storage:
    s3:
      bucket: mariadb-backups-us-east-1
      region: us-east-1  # R√©gion diff√©rente
      prefix: weekly-dr/

---
# 3. Snapshot de volume quotidien (via Velero)
apiVersion: velero.io/v1
kind: Schedule
metadata:
  name: mariadb-snapshot-daily
  namespace: velero
spec:
  schedule: "0 1 * * *"
  template:
    includedNamespaces:
    - production
    labelSelector:
      matchLabels:
        app.kubernetes.io/name: mariadb
    snapshotVolumes: true
    ttl: 168h  # 7 jours

---
# 4. Backup logique mensuel vers Glacier (archivage long terme)
apiVersion: k8s.mariadb.com/v1alpha1
kind: Backup
metadata:
  name: mariadb-monthly-archive
  namespace: production
spec:
  mariadbRef:
    name: mariadb-primary
  backupType: logical
  schedule:
    cron: "0 4 1 * *"
  retentionPolicy:
    keepLast: 36  # 3 ans
  storage:
    s3:
      bucket: mariadb-backups-archive
      region: eu-west-1
      prefix: monthly-archive/
      storageClass: GLACIER_DEEP_ARCHIVE
```

### Politique de r√©tention recommand√©e

| Type | Fr√©quence | R√©tention | Objectif |
|------|-----------|-----------|----------|
| **Snapshot volume** | Quotidien | 7 jours | Recovery rapide < 1h |
| **Physical backup** | Quotidien | 7 jours | Recovery standard |
| **Physical backup** | Hebdomadaire | 4 semaines | Recovery mensuel |
| **Logical backup** | Mensuel | 12 mois | Conformit√©/Audit |
| **DR backup (cross-region)** | Hebdomadaire | 8 semaines | Disaster Recovery |
| **Archive (Glacier)** | Mensuel | 36 mois | Conformit√© l√©gale |

---

## Best practices de production

### 1. **Backup depuis un replica**

Toujours effectuer les backups depuis un replica pour ne pas impacter les performances du Primary :

```yaml
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/instance: mariadb-replica
      statefulset.kubernetes.io/pod-name: mariadb-replica-2
```

### 2. **V√©rification automatique d'int√©grit√©**

Ajouter un hook post-backup pour valider :

```yaml
spec:
  hooks:
    post:
    - exec:
        container: backup
        command:
        - /bin/bash
        - -c
        - |
          # V√©rifier la taille minimale (√©viter backup vide)
          BACKUP_SIZE=$(du -sb /backup | awk '{print $1}')
          MIN_SIZE=1073741824  # 1GB minimum
          
          if [ "$BACKUP_SIZE" -lt "$MIN_SIZE" ]; then
            echo "ERROR: Backup too small ($BACKUP_SIZE bytes)"
            exit 1
          fi
          
          echo "Backup size validation passed: $BACKUP_SIZE bytes"
```

### 3. **Chiffrement des backups**

Activer le chiffrement c√¥t√© serveur S3 :

```yaml
storage:
  s3:
    bucket: mariadb-backups-prod
    # SSE-S3 (chiffrement g√©r√© par AWS)
    serverSideEncryption: AES256
    
    # Ou SSE-KMS (cl√© KMS personnalis√©e)
    # serverSideEncryption: aws:kms
    # sseKmsKeyId: arn:aws:kms:eu-west-1:123456789012:key/xxx
```

### 4. **Notifications de backup**

Int√©grer avec Slack/Teams pour notifications :

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: backup-notifier
spec:
  template:
    spec:
      containers:
      - name: notifier
        image: curlimages/curl
        command:
        - /bin/sh
        - -c
        - |
          # R√©cup√©rer le statut du dernier backup
          STATUS=$(kubectl get backup mariadb-daily-backup -n production \
            -o jsonpath='{.status.phase}')
          
          # Envoyer notification Slack
          if [ "$STATUS" = "Succeeded" ]; then
            COLOR="good"
            MESSAGE="‚úÖ MariaDB backup succeeded"
          else
            COLOR="danger"
            MESSAGE="‚ùå MariaDB backup failed"
          fi
          
          curl -X POST "${SLACK_WEBHOOK_URL}" \
            -H 'Content-Type: application/json' \
            -d "{
              \"attachments\": [{
                \"color\": \"${COLOR}\",
                \"title\": \"${MESSAGE}\",
                \"text\": \"Backup: mariadb-daily-backup\nStatus: ${STATUS}\",
                \"footer\": \"Kubernetes Cluster: Production\"
              }]
            }"
        env:
        - name: SLACK_WEBHOOK_URL
          valueFrom:
            secretKeyRef:
              name: slack-webhook
              key: url
      restartPolicy: Never
```

### 5. **Immutabilit√© des backups**

Utiliser S3 Object Lock pour emp√™cher la suppression/modification :

```bash
# Activer Object Lock sur le bucket (cr√©ation)
aws s3api create-bucket \
  --bucket mariadb-backups-immutable \
  --region eu-west-1 \
  --object-lock-enabled-for-bucket

# Configurer la r√©tention par d√©faut
aws s3api put-object-lock-configuration \
  --bucket mariadb-backups-immutable \
  --object-lock-configuration '{
    "ObjectLockEnabled": "Enabled",
    "Rule": {
      "DefaultRetention": {
        "Mode": "GOVERNANCE",
        "Days": 30
      }
    }
  }'
```

### 6. **Monitoring de l'espace S3**

```promql
# Co√ªt mensuel estim√© des backups (n√©cessite CloudWatch metrics)
sum(aws_s3_bucket_size_bytes{bucket=~"mariadb-backups.*"}) * 0.023 / 1073741824

# Nombre total de backups stock√©s
count(mariadb_backup_info{status="succeeded"})

# Croissance de l'espace backup (par semaine)
rate(aws_s3_bucket_size_bytes[7d])
```

### 7. **Tests de restauration planifi√©s**

Au minimum **mensuel**, id√©alement **hebdomadaire** :

```yaml
# Calendrier de tests recommand√©
- Hebdomadaire : Restauration dans un namespace de test
- Mensuel : Restauration compl√®te avec validation fonctionnelle
- Trimestriel : Drill de Disaster Recovery complet (cross-region)
- Annuel : Restauration depuis archive Glacier
```

---

## Troubleshooting

### Probl√®me 1 : Backup √©choue avec "Out of disk space"

**Sympt√¥mes :**
```
Error: No space left on device
```

**Diagnostic :**
```bash
# V√©rifier l'espace disque du pod backup
kubectl exec -it <backup-pod> -n production -- df -h

# V√©rifier la taille estim√©e du backup
kubectl exec -it mariadb-primary-0 -n production -- \
  du -sh /var/lib/mysql
```

**Solution :**
```yaml
# Utiliser un PVC temporaire plus grand
spec:
  storage:
    # Volume temporaire pour staging
    volumeClaimTemplate:
      spec:
        accessModes:
        - ReadWriteOnce
        resources:
          requests:
            storage: 500Gi  # Adapter selon la taille de la DB
        storageClassName: fast-ssd
```

### Probl√®me 2 : Backup lent (> 6 heures)

**Diagnostic :**
```bash
# V√©rifier la bande passante r√©seau vers S3
kubectl exec -it <backup-pod> -n production -- \
  curl -o /dev/null https://s3.eu-west-1.amazonaws.com/test

# V√©rifier les I/O disque
kubectl exec -it <backup-pod> -n production -- iostat -x 5
```

**Solutions :**

1. **Augmenter le parall√©lisme** :
```yaml
mariabackup:
  extraArgs:
  - "--parallel=8"  # Augmenter (nombre de CPU)
```

2. **Utiliser la compression** :
```yaml
mariabackup:
  extraArgs:
  - "--compress"
  - "--compress-threads=8"
```

3. **Optimiser les ressources** :
```yaml
resources:
  requests:
    cpu: "8"
    memory: "16Gi"
  limits:
    cpu: "16"
    memory: "32Gi"
```

### Probl√®me 3 : Restore √©choue avec "Incompatible version"

**Sympt√¥mes :**
```
Error: Backup was created with MariaDB 11.6, but target is 11.8
```

**Solution :**
```bash
# Restaurer d'abord dans une instance 11.6
kubectl apply -f - <<EOF
apiVersion: k8s.mariadb.com/v1alpha1
kind: MariaDB
metadata:
  name: mariadb-temp-116
spec:
  image: mariadb:11.6.2  # Version correspondant au backup
  # ... config ...
EOF

# Restaurer le backup
kubectl apply -f restore-to-116.yaml

# Upgrader vers 11.8
kubectl patch mariadb mariadb-temp-116 \
  --type merge \
  -p '{"spec":{"image":"mariadb:11.8.2"}}'

# Ex√©cuter mariadb-upgrade
kubectl exec -it mariadb-temp-116-0 -- mariadb-upgrade -u root -p
```

---

## ‚úÖ Points cl√©s √† retenir

- **Backups physiques (mariabackup)** : Standard pour production, rapides, supportent PITR avec binlogs
- **Strat√©gie 3-2-1** : 3 copies, 2 supports, 1 hors-site pour r√©silience maximale
- **Automation via CRDs** : Le mariadb-operator g√®re l'orchestration compl√®te des backups/restores
- **Backup depuis replicas** : Ne jamais impacter les performances du Primary
- **Tests r√©guliers** : Validez vos restaurations mensuellement minimum, l'untested backup = no backup
- **Monitoring proactif** : Alerter sur √©checs, dur√©es anormales, taille de backup
- **R√©tention adapt√©e** : Quotidien 7j, Hebdo 4 semaines, Mensuel 12 mois, Archive 3 ans
- **Chiffrement obligatoire** : SSE-S3 ou SSE-KMS pour donn√©es sensibles
- **Immutabilit√© S3** : Object Lock pour protection contre ransomware/suppression accidentelle
- **PITR avec binlogs** : Archivage continu des binlogs vers S3 pour point-in-time recovery
- **Velero compl√©mentaire** : Snapshots de volumes pour recovery ultra-rapide (< 1h)
- **Notifications** : Int√©gration Slack/Teams pour awareness imm√©diate

---

## üîó Ressources et r√©f√©rences

### Documentation officielle
- **[Mariabackup Documentation](https://mariadb.com/kb/en/mariabackup-overview/)** - Guide complet mariabackup
- **[mariadb-operator Backup Guide](https://github.com/mariadb-operator/mariadb-operator/blob/main/docs/BACKUP.md)** - Documentation backup CRD
- **[Point-in-Time Recovery](https://mariadb.com/kb/en/point-in-time-recovery-using-mariabackup/)** - PITR avec mariabackup
- **[Velero Documentation](https://velero.io/docs/)** - Backup/restore Kubernetes

### Articles techniques
- **[Backup Best Practices](https://mariadb.com/kb/en/backup-and-restore-overview/)** - Strat√©gies de backup MariaDB
- **[S3 Backup Encryption](https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingEncryption.html)** - Chiffrement S3
- **[Kubernetes Backup Strategies](https://kubernetes.io/blog/2021/04/19/kubernetes-release-1.21-backup-restore/)** - Best practices K8s

### Outils
- **[mysqldump vs mariabackup](https://mariadb.com/kb/en/backup-restore-and-import-clients/)** - Comparaison outils backup
- **[MinIO](https://min.io/)** - Object storage S3-compatible on-premise
- **[Velero Plugins](https://velero.io/plugins/)** - Int√©grations cloud providers

---

## ‚û°Ô∏è Section suivante

**16.6 MariaDB Enterprise Operator** : Pr√©sentation de l'Enterprise Operator avec fonctionnalit√©s avanc√©es : backups chiffr√©s, monitoring int√©gr√©, support multi-cloud, et gestion centralis√©e.

‚è≠Ô∏è [MariaDB Enterprise Operator](/16-devops-automatisation/06-mariadb-enterprise-operator.md)
