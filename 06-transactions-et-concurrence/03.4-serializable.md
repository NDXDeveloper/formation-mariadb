ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 6.3.4 SERIALIZABLE : Isolation maximale

> **Niveau** : Expert
> **DurÃ©e estimÃ©e** : 2 heures

> **PrÃ©requis** :
> - MaÃ®trise complÃ¨te des propriÃ©tÃ©s ACID
> - ComprÃ©hension des trois niveaux prÃ©cÃ©dents (6.3.1, 6.3.2, 6.3.3)
> - Connaissance approfondie du MVCC et des verrous

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre le fonctionnement de SERIALIZABLE et ses garanties maximales
- Identifier les situations oÃ¹ SERIALIZABLE est rÃ©ellement nÃ©cessaire
- MaÃ®triser l'Ã©limination du write skew et des anomalies complexes
- Ã‰valuer l'impact drastique sur les performances et la concurrence
- DÃ©cider quand le coÃ»t de SERIALIZABLE est justifiÃ©
- ImplÃ©menter des alternatives plus performantes quand possible

---

## Introduction

**SERIALIZABLE** est le niveau d'isolation le plus strict et le plus restrictif. Il garantit que l'exÃ©cution concurrente de transactions produit exactement le mÃªme rÃ©sultat que si ces transactions s'Ã©taient exÃ©cutÃ©es **sÃ©quentiellement**, une aprÃ¨s l'autre, dans un certain ordre.

### Position dans la hiÃ©rarchie

```
READ UNCOMMITTED  â† Dirty reads possibles
    â†“
READ COMMITTED    â† Pas de dirty reads
    â†“
REPEATABLE READ   â† Pas de non-repeatable reads
    â†“
SERIALIZABLE      â† ğŸ”’ Isolation TOTALE (sÃ©rialisation complÃ¨te)
```

**Garantie absolue** : SERIALIZABLE Ã©limine **toutes** les anomalies de concurrence, y compris le write skew et les anomalies complexes invisibles aux autres niveaux.

âš ï¸ **Attention critique** : SERIALIZABLE offre la cohÃ©rence maximale au prix d'une performance dramatiquement rÃ©duite et d'un risque de blocage trÃ¨s Ã©levÃ©. Son usage doit Ãªtre extrÃªmement limitÃ© et parfaitement justifiÃ©.

---

## Principe de fonctionnement

### SÃ©rialisation des transactions

Au niveau SERIALIZABLE, InnoDB transforme **tous les SELECT** en **SELECT ... FOR SHARE**, posant des verrous partagÃ©s (shared locks) mÃªme sur les lectures simples.

```sql
-- Configuration
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- VÃ©rifier
SELECT @@SESSION.transaction_isolation;
-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
-- â•‘ @@SESSION.transaction_isolation â•‘
-- â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
-- â•‘ SERIALIZABLE                    â•‘
-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### Comportement des verrous

En SERIALIZABLE, **chaque SELECT** devient bloquant :

```sql
-- En REPEATABLE READ
START TRANSACTION;
SELECT * FROM comptes WHERE id = 1;
-- âœ… Pas de verrou, lecture MVCC

-- En SERIALIZABLE
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;
SELECT * FROM comptes WHERE id = 1;
-- ğŸ”’ Verrou partagÃ© posÃ© automatiquement
-- Ã‰quivalent Ã  : SELECT * FROM comptes WHERE id = 1 FOR SHARE;
```

### Matrice des verrous

| OpÃ©ration | READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE |
|-----------|------------------|----------------|-----------------|--------------|
| **SELECT** | Aucun verrou | Aucun verrou | Aucun verrou | ğŸ”’ **Shared lock** |
| **INSERT** | Verrou exclusif | Verrou exclusif | Verrou exclusif | Verrou exclusif |
| **UPDATE** | Verrou exclusif | Verrou exclusif | Verrou exclusif | Verrou exclusif |
| **DELETE** | Verrou exclusif | Verrou exclusif | Verrou exclusif | Verrou exclusif |

### MÃ©canisme de sÃ©rialisation

```
Transaction A (SERIALIZABLE)
    â”‚
    â”‚  START TRANSACTION
    â”‚
    â”‚  SELECT ... â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                      â”‚
    â”‚                      â”œâ”€â–º ğŸ”’ Shared lock posÃ©
    â”‚                      â”‚   EmpÃªche les UPDATE/DELETE
    â”‚  UPDATE ...          â”‚
    â”‚                      â”œâ”€â–º Upgrade vers exclusive lock
    â”‚                      â”‚
    â”‚  COMMIT              â”‚
    â”‚                      â””â”€â–º LibÃ©ration des verrous
    â””â”€

Transaction B (tente de modifier)
    â”‚
    â”‚  UPDATE ... â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â³ BLOQUÃ‰E
    â”‚  (attend que A libÃ¨re)  (shared lock de A l'empÃªche)
    â””â”€
```

---

## Ã‰limination de toutes les anomalies

### Tableau complet des anomalies

| Anomalie | READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE |
|----------|------------------|----------------|-----------------|--------------|
| **Dirty Reads** | âœ… Possible | âŒ Impossible | âŒ Impossible | âŒ **Impossible** |
| **Non-Repeatable Reads** | âœ… Possible | âœ… Possible | âŒ Impossible | âŒ **Impossible** |
| **Phantom Reads** | âœ… Possible | âœ… Possible | âŒ Impossible* | âŒ **Impossible** |
| **Write Skew** | âœ… Possible | âœ… Possible | âœ… Possible | âŒ **Impossible** |
| **Read Skew** | âœ… Possible | âœ… Possible | âŒ Impossible | âŒ **Impossible** |

*InnoDB avec gap locking

### Ã‰limination du Write Skew

Le **write skew** est l'anomalie la plus subtile, impossible Ã  Ã©viter mÃªme en REPEATABLE READ. SERIALIZABLE est le seul niveau qui l'empÃªche.

#### Rappel : Exemple du Write Skew

```sql
-- Table de gardes mÃ©dicales
CREATE TABLE gardes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    medecin_id INT,
    date DATE,
    statut VARCHAR(20),
    INDEX(date, statut)
) ENGINE=InnoDB;

-- Contrainte mÃ©tier : Au moins 2 mÃ©decins de garde par jour
INSERT INTO gardes VALUES
(1, 101, '2025-12-15', 'active'),
(2, 102, '2025-12-15', 'active'),
(3, 103, '2025-12-15', 'active');
```

**En REPEATABLE READ (problÃ¨me) :**

```sql
-- Transaction A : MÃ©decin 101 annule
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;

SELECT COUNT(*) FROM gardes
WHERE date = '2025-12-15' AND statut = 'active';
-- RÃ©sultat : 3 âœ…

UPDATE gardes SET statut = 'annulee'
WHERE medecin_id = 101 AND date = '2025-12-15';

-- Transaction B : MÃ©decin 102 annule (parallÃ¨le)
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;

SELECT COUNT(*) FROM gardes
WHERE date = '2025-12-15' AND statut = 'active';
-- RÃ©sultat : 3 âœ… (mÃªme snapshot)

UPDATE gardes SET statut = 'annulee'
WHERE medecin_id = 102 AND date = '2025-12-15';

-- Les deux COMMIT
COMMIT; -- Transaction A
COMMIT; -- Transaction B

-- âŒ PROBLÃˆME : Il reste 1 seul mÃ©decin !
SELECT COUNT(*) FROM gardes
WHERE date = '2025-12-15' AND statut = 'active';
-- RÃ©sultat : 1 (contrainte violÃ©e)
```

**En SERIALIZABLE (rÃ©solu) :**

```sql
-- Transaction A : MÃ©decin 101 annule
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

-- SELECT pose un shared lock sur toutes les lignes matchÃ©es
SELECT COUNT(*) FROM gardes
WHERE date = '2025-12-15' AND statut = 'active';
-- ğŸ”’ Shared locks posÃ©s sur les 3 lignes
-- RÃ©sultat : 3 âœ…

-- Transaction B : MÃ©decin 102 tente d'annuler (parallÃ¨le)
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

-- SELECT pose aussi des shared locks
SELECT COUNT(*) FROM gardes
WHERE date = '2025-12-15' AND statut = 'active';
-- ğŸ”’ Shared locks posÃ©s (compatible avec A)
-- RÃ©sultat : 3 âœ…

-- Transaction A tente de modifier
UPDATE gardes SET statut = 'annulee'
WHERE medecin_id = 101 AND date = '2025-12-15';
-- âœ… RÃ©ussit (upgrade vers exclusive lock)

COMMIT; -- Transaction A

-- Transaction B tente de modifier maintenant
UPDATE gardes SET statut = 'annulee'
WHERE medecin_id = 102 AND date = '2025-12-15';
-- AprÃ¨s le COMMIT de A, le SELECT doit Ãªtre refait
-- Car les shared locks ont empÃªchÃ© le write skew

-- âš ï¸ En pratique, Transaction B pourrait Ãªtre sÃ©rialisÃ©e
-- ou obtenir une erreur de conflit

COMMIT; -- Transaction B
```

ğŸ’¡ **MÃ©canisme clÃ©** : Les shared locks empÃªchent les transactions de prendre des dÃ©cisions basÃ©es sur des lectures qui pourraient devenir invalides.

### Exemple 2 : Allocation de budget

```sql
-- Table de budgets dÃ©partementaux
CREATE TABLE budgets (
    departement_id INT PRIMARY KEY,
    budget_alloue DECIMAL(12,2),
    budget_utilise DECIMAL(12,2),
    INDEX(departement_id)
) ENGINE=InnoDB;

-- Budget central : 1 million total
-- Dept A : 400k allouÃ©s, 350k utilisÃ©s
-- Dept B : 600k allouÃ©s, 550k utilisÃ©s
INSERT INTO budgets VALUES
(1, 400000, 350000),
(2, 600000, 550000);

-- Contrainte : Total allouÃ© ne peut dÃ©passer 1 million
```

**Write Skew en REPEATABLE READ :**

```sql
-- Transaction A : Dept A demande +100k
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;

-- VÃ©rifier la contrainte globale
SELECT SUM(budget_alloue) FROM budgets;
-- RÃ©sultat : 1,000,000 (limite atteinte)

-- Calculer l'espace disponible
SELECT 1000000 - SUM(budget_alloue) as disponible FROM budgets;
-- RÃ©sultat : 0

-- Mais on peut rÃ©allouer du budget non utilisÃ© d'autres depts
SELECT SUM(budget_alloue - budget_utilise) as non_utilise FROM budgets;
-- RÃ©sultat : 100,000 (50k dept A + 50k dept B)

-- Transaction B : Dept B demande aussi +100k (parallÃ¨le)
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;

-- MÃªme vÃ©rification
SELECT SUM(budget_alloue - budget_utilise) as non_utilise FROM budgets;
-- RÃ©sultat : 100,000 âœ… (mÃªme snapshot)

-- Transaction A approuve +100k pour dept A
UPDATE budgets SET budget_alloue = budget_alloue + 100000
WHERE departement_id = 1;

COMMIT; -- Transaction A

-- Transaction B approuve aussi +100k pour dept B
UPDATE budgets SET budget_alloue = budget_alloue + 100000
WHERE departement_id = 2;

COMMIT; -- Transaction B

-- âŒ PROBLÃˆME : Total = 1,200,000 (dÃ©passe 1M)
SELECT SUM(budget_alloue) FROM budgets;
-- RÃ©sultat : 1,200,000
```

**Solution en SERIALIZABLE :**

```sql
-- Transaction A
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

-- SELECT pose shared locks
SELECT SUM(budget_alloue), SUM(budget_utilise) FROM budgets;
-- ğŸ”’ Shared locks sur toutes les lignes

UPDATE budgets SET budget_alloue = budget_alloue + 100000
WHERE departement_id = 1;

COMMIT;

-- Transaction B
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

-- SELECT doit attendre que A finisse
SELECT SUM(budget_alloue), SUM(budget_utilise) FROM budgets;
-- â³ Attend le COMMIT de A
-- RÃ©sultat : 1,100,000 (voit la modification de A)

-- La contrainte est maintenant visible
-- Transaction B peut prendre la bonne dÃ©cision
-- (refuser ou attendre plus de budget disponible)
```

---

## Impact sur les performances

### Blocage massif des lectures

```sql
-- ScÃ©nario : Application de consultation

-- Transaction A : Lecture longue
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

SELECT * FROM produits WHERE categorie = 'electronique';
-- ğŸ”’ Shared locks sur des milliers de lignes
-- Transaction peut durer 30 secondes

-- Transaction B : Tentative de mise Ã  jour prix
START TRANSACTION;
UPDATE produits SET prix = prix * 1.05
WHERE categorie = 'electronique';
-- â³ BLOQUÃ‰E pendant 30 secondes
-- Attend que Transaction A finisse

-- Transaction C : Autre lecture
START TRANSACTION;
SELECT * FROM produits WHERE categorie = 'electronique';
-- âœ… OK (shared lock compatible avec shared lock de A)

-- Transaction D : Ajout produit
INSERT INTO produits (nom, categorie, prix)
VALUES ('Nouveau', 'electronique', 299.99);
-- â³ Peut Ãªtre bloquÃ©e par gap locks de A
```

### Benchmark de performance

```sql
-- Configuration de test
CREATE TABLE test_concurrence (
    id INT PRIMARY KEY AUTO_INCREMENT,
    valeur INT,
    INDEX(valeur)
) ENGINE=InnoDB;

-- Insertion de 100,000 lignes
-- ...

-- Benchmark 1 : READ COMMITTED (10 transactions concurrentes)
-- Throughput : ~2000 requÃªtes/sec
-- Temps moyen : 5ms

-- Benchmark 2 : REPEATABLE READ (10 transactions concurrentes)
-- Throughput : ~1800 requÃªtes/sec
-- Temps moyen : 5.5ms

-- Benchmark 3 : SERIALIZABLE (10 transactions concurrentes)
-- Throughput : ~200 requÃªtes/sec âŒ
-- Temps moyen : 50ms âŒ
-- Timeouts : 15% âŒ

-- Perte de performance : ~90% !
```

### MÃ©trique d'impact

| MÃ©trique | READ COMMITTED | REPEATABLE READ | SERIALIZABLE |
|----------|----------------|-----------------|--------------|
| **Throughput** | ğŸŸ¢ Excellent (100%) | ğŸŸ¢ TrÃ¨s bon (90%) | ğŸ”´ Faible (10-20%) |
| **Latence moyenne** | ğŸŸ¢ Faible (5ms) | ğŸŸ¢ Faible (5-10ms) | ğŸ”´ Ã‰levÃ©e (50-500ms) |
| **Blocages** | ğŸŸ¢ Rares | ğŸŸ¡ Occasionnels | ğŸ”´ FrÃ©quents |
| **Timeouts** | ğŸŸ¢ <1% | ğŸŸ¡ 1-5% | ğŸ”´ 10-30% |
| **Deadlocks** | ğŸŸ¢ Rares | ğŸŸ¡ Possibles | ğŸ”´ TrÃ¨s frÃ©quents |
| **ScalabilitÃ©** | ğŸŸ¢ Excellente | ğŸŸ¡ Bonne | ğŸ”´ TrÃ¨s limitÃ©e |

---

## Deadlocks en SERIALIZABLE

Les deadlocks sont **extrÃªmement frÃ©quents** en SERIALIZABLE car tous les SELECT posent des verrous.

### Exemple classique

```sql
-- Transaction A
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

-- Lit la table 1
SELECT * FROM table1 WHERE id = 1;
-- ğŸ”’ Shared lock sur table1

-- Transaction B (parallÃ¨le)
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

-- Lit la table 2
SELECT * FROM table2 WHERE id = 1;
-- ğŸ”’ Shared lock sur table2

-- Transaction A tente de modifier table2
UPDATE table2 SET valeur = 100 WHERE id = 1;
-- â³ Veut exclusive lock
-- ATTEND que B libÃ¨re son shared lock sur table2

-- Transaction B tente de modifier table1
UPDATE table1 SET valeur = 200 WHERE id = 1;
-- â³ Veut exclusive lock
-- ATTEND que A libÃ¨re son shared lock sur table1

-- ğŸ’¥ DEADLOCK !
-- InnoDB dÃ©tecte et annule une transaction
```

### Deadlock lecture-Ã©criture

```sql
-- Transaction A : Lecture puis Ã©criture
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

SELECT * FROM produits WHERE id = 100;
-- ğŸ”’ Shared lock posÃ©

-- Transaction B : Ã‰criture immÃ©diate
START TRANSACTION;

UPDATE produits SET stock = stock - 1 WHERE id = 100;
-- â³ BLOQUÃ‰E (attend shared lock de A)

-- Transaction A tente de mettre Ã  jour
UPDATE produits SET prix = 99.99 WHERE id = 100;
-- ğŸ’¥ DEADLOCK !
-- A veut exclusive lock mais B attend dÃ©jÃ  son shared lock
```

### Taux de deadlock

```sql
-- Monitoring des deadlocks
SHOW GLOBAL STATUS LIKE 'Innodb_deadlocks';
-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•—
-- â•‘ Variable_name     â•‘ Value  â•‘
-- â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•£
-- â•‘ Innodb_deadlocks  â•‘ 15,847 â•‘  âŒ TrÃ¨s Ã©levÃ© en SERIALIZABLE
-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•

-- Comparaison avec READ COMMITTED
-- Innodb_deadlocks : 342  âœ… Beaucoup moins

-- Ratio deadlocks/transactions
SELECT
    v1.variable_value / v2.variable_value * 100 as deadlock_percentage
FROM
    (SELECT variable_value FROM information_schema.global_status
     WHERE variable_name = 'Innodb_deadlocks') v1,
    (SELECT variable_value FROM information_schema.global_status
     WHERE variable_name = 'Com_commit') v2;
-- En SERIALIZABLE : 5-15%
-- En READ COMMITTED : <0.1%
```

---

## Cas d'usage lÃ©gitimes (trÃ¨s rares)

SERIALIZABLE doit Ãªtre utilisÃ© **uniquement** dans des situations extrÃªmement spÃ©cifiques oÃ¹ aucune alternative n'est possible.

### 1. Transactions financiÃ¨res critiques avec contraintes complexes

```sql
-- SystÃ¨me de paiement avec multiples contraintes
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

-- VÃ©rifier solde compte source
SELECT @solde_source := solde FROM comptes WHERE id = @compte_source;

-- VÃ©rifier limites de transfert
SELECT @limite_jour := limite_transfert_jour FROM comptes WHERE id = @compte_source;
SELECT @total_jour := IFNULL(SUM(montant), 0)
FROM transferts
WHERE compte_source_id = @compte_source
  AND DATE(created_at) = CURDATE();

-- VÃ©rifier statut compte destination
SELECT @statut_dest := statut FROM comptes WHERE id = @compte_dest;

-- Contraintes mÃ©tier complexes
IF @solde_source >= @montant
   AND (@total_jour + @montant) <= @limite_jour
   AND @statut_dest = 'actif'
   AND NOT EXISTS(SELECT 1 FROM blocages WHERE compte_id = @compte_source)
THEN
    -- Effectuer le transfert
    UPDATE comptes SET solde = solde - @montant WHERE id = @compte_source;
    UPDATE comptes SET solde = solde + @montant WHERE id = @compte_dest;
    INSERT INTO transferts (compte_source_id, compte_dest_id, montant)
    VALUES (@compte_source, @compte_dest, @montant);

    COMMIT;
ELSE
    ROLLBACK;
END IF;
```

ğŸ’¡ **Justification** : Les contraintes multiples et interdÃ©pendantes nÃ©cessitent une vue absolument cohÃ©rente. Le write skew pourrait violer les limites rÃ©glementaires.

### 2. ComptabilitÃ© Ã  double entrÃ©e

```sql
-- SystÃ¨me comptable : Chaque transaction doit respecter dÃ©bit = crÃ©dit
CREATE TABLE ecritures_comptables (
    id INT PRIMARY KEY AUTO_INCREMENT,
    compte VARCHAR(20),
    montant DECIMAL(15,2),
    sens ENUM('debit', 'credit'),
    lot_id INT,
    INDEX(lot_id)
) ENGINE=InnoDB;

-- Transaction comptable
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

-- Lot d'Ã©critures comptables
SET @lot_id = UUID_SHORT();

-- DÃ©biter compte client
INSERT INTO ecritures_comptables (compte, montant, sens, lot_id)
VALUES ('411001', 1000.00, 'debit', @lot_id);

-- CrÃ©diter compte vente
INSERT INTO ecritures_comptables (compte, montant, sens, lot_id)
VALUES ('707001', 1000.00, 'credit', @lot_id);

-- VÃ©rifier l'Ã©quilibre (contrainte stricte)
SELECT
    SUM(CASE WHEN sens = 'debit' THEN montant ELSE 0 END) as total_debit,
    SUM(CASE WHEN sens = 'credit' THEN montant ELSE 0 END) as total_credit
FROM ecritures_comptables
WHERE lot_id = @lot_id;

-- La transaction ne peut COMMIT que si debit = credit
IF @total_debit = @total_credit THEN
    COMMIT;
ELSE
    ROLLBACK;
END IF;
```

ğŸ’¡ **Justification** : La comptabilitÃ© nÃ©cessite une cohÃ©rence absolue. Aucune anomalie n'est acceptable (audit, conformitÃ©).

### 3. Allocation de ressources uniques avec contraintes globales

```sql
-- SystÃ¨me de rÃ©servation de salles avec contraintes complexes
CREATE TABLE reservations_salles (
    id INT PRIMARY KEY AUTO_INCREMENT,
    salle_id INT,
    date DATE,
    heure_debut TIME,
    heure_fin TIME,
    type_event VARCHAR(50),
    participants INT,
    INDEX(salle_id, date)
) ENGINE=InnoDB;

CREATE TABLE salles (
    id INT PRIMARY KEY,
    capacite INT,
    equipements VARCHAR(200)
) ENGINE=InnoDB;

-- Contraintes mÃ©tier :
-- 1. Pas de chevauchement horaire
-- 2. CapacitÃ© suffisante
-- 3. Maximum 3 rÃ©servations/jour par salle
-- 4. Total participants/jour < 500 (capacitÃ© bÃ¢timent)

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

-- VÃ©rifier tous les critÃ¨res avec shared locks
SELECT COUNT(*) INTO @chevauchements
FROM reservations_salles
WHERE salle_id = @salle_id
  AND date = @date
  AND (
    (heure_debut < @heure_fin AND heure_fin > @heure_debut)
  );

SELECT COUNT(*) INTO @reservations_jour
FROM reservations_salles
WHERE salle_id = @salle_id AND date = @date;

SELECT SUM(participants) INTO @total_participants_jour
FROM reservations_salles
WHERE date = @date;

SELECT capacite INTO @capacite_salle
FROM salles WHERE id = @salle_id;

-- Toutes les contraintes doivent Ãªtre satisfaites
IF @chevauchements = 0
   AND @reservations_jour < 3
   AND (@total_participants_jour + @nb_participants) <= 500
   AND @nb_participants <= @capacite_salle
THEN
    INSERT INTO reservations_salles
    (salle_id, date, heure_debut, heure_fin, type_event, participants)
    VALUES
    (@salle_id, @date, @heure_debut, @heure_fin, @type_event, @nb_participants);

    COMMIT;
ELSE
    ROLLBACK;
END IF;
```

ğŸ’¡ **Justification** : Les contraintes multiples et interdÃ©pendantes peuvent crÃ©er du write skew avec des niveaux infÃ©rieurs.

### 4. Inventaire temps rÃ©el avec rÃ©conciliation stricte

```sql
-- SystÃ¨me de gestion d'inventaire pharmaceutique
-- Contraintes rÃ©glementaires strictes (stupÃ©fiants, etc.)

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

-- Lecture de l'Ã©tat complet pour traÃ§abilitÃ©
SELECT * FROM inventaire WHERE medicament_id = @med_id;
SELECT * FROM mouvements WHERE medicament_id = @med_id AND date = CURDATE();

-- VÃ©rifier cohÃ©rence stock physique vs systÃ¨me
SELECT
    i.stock_systeme,
    IFNULL(SUM(CASE WHEN m.type = 'entree' THEN m.quantite ELSE -m.quantite END), 0) as mouvements_jour
FROM inventaire i
LEFT JOIN mouvements m ON i.medicament_id = m.medicament_id
    AND DATE(m.created_at) = CURDATE()
WHERE i.medicament_id = @med_id;

-- Enregistrer mouvement avec traÃ§abilitÃ© totale
INSERT INTO mouvements (medicament_id, type, quantite, operateur_id)
VALUES (@med_id, 'sortie', @quantite, @user_id);

UPDATE inventaire SET stock_systeme = stock_systeme - @quantite
WHERE medicament_id = @med_id;

COMMIT;
```

---

## Alternatives Ã  SERIALIZABLE

Dans 99% des cas, il existe des alternatives plus performantes.

### Alternative 1 : REPEATABLE READ avec SELECT FOR UPDATE

```sql
-- Au lieu de SERIALIZABLE
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;

-- Verrouiller explicitement les lignes nÃ©cessaires
SELECT * FROM comptes WHERE id IN (@source, @dest) FOR UPDATE;

-- Les modifications sont maintenant sÃ»res
UPDATE comptes SET solde = solde - 100 WHERE id = @source;
UPDATE comptes SET solde = solde + 100 WHERE id = @dest;

COMMIT;
```

âœ… **Avantage** : Performance bien meilleure, verrous uniquement oÃ¹ nÃ©cessaire

### Alternative 2 : Verrous applicatifs

```sql
-- Table de verrous applicatifs
CREATE TABLE app_locks (
    resource_name VARCHAR(100) PRIMARY KEY,
    locked_by VARCHAR(100),
    locked_at TIMESTAMP,
    INDEX(locked_at)
) ENGINE=InnoDB;

-- AcquÃ©rir verrou
START TRANSACTION;

-- Tenter d'acquÃ©rir le verrou
INSERT INTO app_locks (resource_name, locked_by, locked_at)
VALUES ('budget_allocation', CONNECTION_ID(), NOW())
ON DUPLICATE KEY UPDATE
    locked_by = IF(locked_at < NOW() - INTERVAL 5 MINUTE,
                   CONNECTION_ID(),
                   locked_by);

IF ROW_COUNT() > 0 THEN
    -- Verrou acquis, faire les opÃ©rations
    -- ...

    -- LibÃ©rer le verrou
    DELETE FROM app_locks WHERE resource_name = 'budget_allocation';
    COMMIT;
ELSE
    ROLLBACK;
    -- Retry ou erreur
END IF;
```

âœ… **Avantage** : ContrÃ´le fin sur la granularitÃ© des verrous

### Alternative 3 : Optimistic Locking avec version

```sql
-- Ajouter colonne de version
ALTER TABLE comptes ADD COLUMN version INT DEFAULT 0;

-- Pattern optimiste
START TRANSACTION;

-- Lire avec version
SELECT solde, version FROM comptes WHERE id = @source;
SET @solde = ..., @version = ...;

-- VÃ©rifier et mettre Ã  jour atomiquement
UPDATE comptes
SET solde = solde - 100, version = version + 1
WHERE id = @source AND version = @version;

IF ROW_COUNT() = 0 THEN
    -- Conflit dÃ©tectÃ©, retry
    ROLLBACK;
ELSE
    COMMIT;
END IF;
```

âœ… **Avantage** : Pas de blocage pendant la lecture

### Alternative 4 : Contraintes mÃ©tier dans la base

```sql
-- Utiliser des contraintes SQL plutÃ´t que des transactions
ALTER TABLE budgets ADD CONSTRAINT check_budget_max
CHECK (budget_alloue <= 1000000);

-- Utiliser des triggers pour contraintes complexes
DELIMITER //
CREATE TRIGGER verify_gardes_minimum
BEFORE UPDATE ON gardes
FOR EACH ROW
BEGIN
    DECLARE nb_gardes_restantes INT;

    IF NEW.statut = 'annulee' AND OLD.statut = 'active' THEN
        SELECT COUNT(*) INTO nb_gardes_restantes
        FROM gardes
        WHERE date = NEW.date
          AND statut = 'active'
          AND medecin_id != NEW.medecin_id;

        IF nb_gardes_restantes < 2 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Minimum 2 mÃ©decins de garde requis';
        END IF;
    END IF;
END//
DELIMITER ;
```

âœ… **Avantage** : Contraintes toujours respectÃ©es, quelle que soit l'isolation

### Alternative 5 : Architecture Ã©vÃ©nementielle

```sql
-- Au lieu de transactions complexes, utiliser un pattern Ã©vÃ©nementiel

-- Table d'Ã©vÃ©nements
CREATE TABLE evenements (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    type VARCHAR(50),
    aggregate_id VARCHAR(100),
    data JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX(aggregate_id, created_at)
) ENGINE=InnoDB;

-- Publier Ã©vÃ©nements atomiquement
START TRANSACTION;
INSERT INTO evenements (type, aggregate_id, data)
VALUES ('DemandeAnnulationGarde', 'medecin-101', '{"date":"2025-12-15"}');
COMMIT;

-- Processeur d'Ã©vÃ©nements (worker sÃ©parÃ©)
-- Traite les Ã©vÃ©nements sÃ©quentiellement
-- Garantit la sÃ©rialisation naturellement
```

âœ… **Avantage** : DÃ©couplage, scalabilitÃ©, audit naturel

---

## Configuration et surveillance

### Configuration

```sql
-- Pour une session
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- Pour une transaction
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;
-- ...
COMMIT;

-- Global (fortement dÃ©conseillÃ©)
SET GLOBAL transaction_isolation = 'SERIALIZABLE';
```

### Timeouts critiques

```sql
-- Augmenter les timeouts (nÃ©cessaire avec SERIALIZABLE)

-- Timeout d'attente de verrou (dÃ©faut: 50s)
SET SESSION innodb_lock_wait_timeout = 120;

-- Pour toutes les sessions
SET GLOBAL innodb_lock_wait_timeout = 120;

-- my.cnf
[mysqld]
innodb_lock_wait_timeout = 120
```

### Monitoring spÃ©cifique

```sql
-- Transactions en attente
SELECT
    r.trx_id,
    r.trx_state,
    r.trx_started,
    TIMESTAMPDIFF(SECOND, r.trx_started, NOW()) as duration_sec,
    r.trx_rows_locked,
    r.trx_rows_modified,
    r.trx_isolation_level,
    r.trx_query
FROM information_schema.innodb_trx r
WHERE r.trx_isolation_level = 'SERIALIZABLE'
ORDER BY r.trx_started;

-- Verrous en attente (probablement nombreux)
SELECT
    w.waiting_trx_id,
    w.waiting_query,
    w.blocking_trx_id,
    w.blocking_query,
    TIMESTAMPDIFF(SECOND, w.wait_started, NOW()) as wait_duration_sec
FROM sys.innodb_lock_waits w;

-- Taux de timeout
SHOW GLOBAL STATUS LIKE 'Innodb_row_lock_time%';
SHOW GLOBAL STATUS LIKE 'Innodb_row_lock_waits';
```

### Alerting

```sql
-- Alerter si trop de transactions SERIALIZABLE actives
SELECT COUNT(*) as serializable_txn_count
FROM information_schema.innodb_trx
WHERE trx_isolation_level = 'SERIALIZABLE';
-- Alerte si > 5

-- Alerter si temps d'attente moyen trop Ã©levÃ©
SELECT
    AVG(TIMESTAMPDIFF(SECOND, wait_started, NOW())) as avg_wait_sec
FROM sys.innodb_lock_waits;
-- Alerte si > 30 secondes
```

---

## DÃ©cision finale : Quand utiliser SERIALIZABLE

### Arbre de dÃ©cision

```
Besoin de cohÃ©rence absolue ?
    â”‚
    â”œâ”€â”€ NON â†’ Utiliser READ COMMITTED (80% des cas)
    â”‚
    â””â”€â”€ OUI â†’ L'anomalie est-elle un write skew ?
              â”‚
              â”œâ”€â”€ NON â†’ REPEATABLE READ suffit (15% des cas)
              â”‚
              â””â”€â”€ OUI â†’ Peut-on utiliser SELECT FOR UPDATE ?
                        â”‚
                        â”œâ”€â”€ OUI â†’ REPEATABLE READ + FOR UPDATE (4% des cas)
                        â”‚
                        â””â”€â”€ NON â†’ Peut-on utiliser verrous applicatifs ?
                                  â”‚
                                  â”œâ”€â”€ OUI â†’ Verrous app (0.9% des cas)
                                  â”‚
                                  â””â”€â”€ NON â†’ SERIALIZABLE (0.1% des cas)
```

### Checklist avant d'utiliser SERIALIZABLE

Cochez TOUTES les cases avant d'envisager SERIALIZABLE :

- [ ] J'ai vÃ©rifiÃ© que READ COMMITTED ne suffit pas
- [ ] J'ai vÃ©rifiÃ© que REPEATABLE READ ne suffit pas
- [ ] J'ai vÃ©rifiÃ© que REPEATABLE READ + FOR UPDATE ne suffit pas
- [ ] J'ai envisagÃ© les verrous applicatifs
- [ ] J'ai envisagÃ© l'optimistic locking
- [ ] J'ai envisagÃ© les contraintes SQL/triggers
- [ ] J'ai envisagÃ© une architecture Ã©vÃ©nementielle
- [ ] Le volume de transactions est faible (<10/sec)
- [ ] La latence Ã©levÃ©e (100-500ms) est acceptable
- [ ] Les timeouts (10-30%) sont acceptables
- [ ] Les deadlocks frÃ©quents sont gÃ©rables (retry)
- [ ] Les contraintes mÃ©tier sont extrÃªmement complexes
- [ ] Le coÃ»t du write skew est inacceptable (financier, lÃ©gal, sÃ©curitÃ©)

Si **toutes** les cases sont cochÃ©es â†’ SERIALIZABLE peut Ãªtre justifiÃ©
Sinon â†’ Utiliser une alternative plus performante

---

## Exemple complet : ImplÃ©mentation avec retry

### Code Python production-ready

```python
import mysql.connector
from mysql.connector import Error
import time
import logging

logger = logging.getLogger(__name__)

class SerializableTransaction:
    """
    Gestionnaire de transactions SERIALIZABLE avec retry intelligent
    """

    def __init__(self, connection, max_retries=5, base_delay=0.1):
        self.connection = connection
        self.max_retries = max_retries
        self.base_delay = base_delay

    def execute(self, callback, *args, **kwargs):
        """
        ExÃ©cute une transaction SERIALIZABLE avec retry exponentiel
        """
        last_error = None

        for attempt in range(self.max_retries):
            cursor = None
            try:
                cursor = self.connection.cursor(dictionary=True)

                # Forcer SERIALIZABLE
                cursor.execute("SET TRANSACTION ISOLATION LEVEL SERIALIZABLE")
                cursor.execute("START TRANSACTION")

                # ExÃ©cuter la logique mÃ©tier
                result = callback(cursor, *args, **kwargs)

                # Commit si tout est OK
                self.connection.commit()

                logger.info(f"Transaction rÃ©ussie (tentative {attempt + 1})")
                return {"success": True, "result": result, "attempts": attempt + 1}

            except Error as e:
                self.connection.rollback()

                # Deadlock (1213) ou Lock wait timeout (1205)
                if e.errno in (1213, 1205):
                    last_error = e

                    if attempt < self.max_retries - 1:
                        # Backoff exponentiel avec jitter
                        delay = self.base_delay * (2 ** attempt)
                        jitter = delay * 0.1 * (hash(time.time()) % 10 / 10)
                        sleep_time = delay + jitter

                        logger.warning(
                            f"Deadlock/Timeout dÃ©tectÃ© (tentative {attempt + 1}), "
                            f"retry dans {sleep_time:.2f}s"
                        )
                        time.sleep(sleep_time)
                        continue
                    else:
                        logger.error(f"Max retries atteint aprÃ¨s {self.max_retries} tentatives")
                        return {
                            "success": False,
                            "error": "Max retries exceeded",
                            "attempts": self.max_retries
                        }
                else:
                    # Erreur non rÃ©cupÃ©rable
                    logger.error(f"Erreur non rÃ©cupÃ©rable: {e}")
                    return {"success": False, "error": str(e), "attempts": attempt + 1}

            finally:
                if cursor:
                    cursor.close()

        return {"success": False, "error": str(last_error), "attempts": self.max_retries}


def transfer_with_complex_constraints(cursor, from_account, to_account, amount):
    """
    Transfert d'argent avec contraintes complexes
    NÃ©cessite SERIALIZABLE pour Ã©viter write skew
    """

    # 1. Lire tous les comptes impliquÃ©s (shared locks posÃ©s)
    cursor.execute("""
        SELECT id, solde, limite_jour, statut, type_compte
        FROM comptes
        WHERE id IN (%s, %s)
        ORDER BY id  -- Toujours le mÃªme ordre pour Ã©viter certains deadlocks
    """, (min(from_account, to_account), max(from_account, to_account)))

    comptes = {row['id']: row for row in cursor.fetchall()}

    # 2. VÃ©rifier total transferts du jour (shared locks sur transferts)
    cursor.execute("""
        SELECT IFNULL(SUM(montant), 0) as total_jour
        FROM transferts
        WHERE compte_source_id = %s
          AND DATE(created_at) = CURDATE()
    """, (from_account,))

    total_jour = cursor.fetchone()['total_jour']

    # 3. VÃ©rifications mÃ©tier complexes
    compte_source = comptes.get(from_account)
    compte_dest = comptes.get(to_account)

    if not compte_source or not compte_dest:
        raise ValueError("Compte inexistant")

    if compte_source['statut'] != 'actif':
        raise ValueError("Compte source inactif")

    if compte_dest['statut'] == 'bloque':
        raise ValueError("Compte destination bloquÃ©")

    if compte_source['solde'] < amount:
        raise ValueError("Solde insuffisant")

    if (total_jour + amount) > compte_source['limite_jour']:
        raise ValueError("Limite journaliÃ¨re dÃ©passÃ©e")

    # Contrainte mÃ©tier : comptes entreprise ne peuvent transfÃ©rer vers particuliers
    if compte_source['type_compte'] == 'entreprise' and compte_dest['type_compte'] == 'particulier':
        raise ValueError("Transfert entrepriseâ†’particulier non autorisÃ©")

    # 4. Effectuer le transfert (upgrade vers exclusive locks)
    cursor.execute("""
        UPDATE comptes
        SET solde = solde - %s
        WHERE id = %s
    """, (amount, from_account))

    cursor.execute("""
        UPDATE comptes
        SET solde = solde + %s
        WHERE id = %s
    """, (amount, to_account))

    # 5. Enregistrer dans l'historique
    cursor.execute("""
        INSERT INTO transferts
        (compte_source_id, compte_dest_id, montant, created_at)
        VALUES (%s, %s, %s, NOW())
    """, (from_account, to_account, amount))

    return {
        "transfert_id": cursor.lastrowid,
        "from": from_account,
        "to": to_account,
        "amount": float(amount)
    }


# Utilisation
if __name__ == "__main__":
    config = {
        'host': 'localhost',
        'user': 'root',
        'password': 'password',
        'database': 'bank_db',
        'autocommit': False
    }

    try:
        connection = mysql.connector.connect(**config)
        tx_manager = SerializableTransaction(connection, max_retries=5)

        # ExÃ©cuter le transfert
        result = tx_manager.execute(
            transfer_with_complex_constraints,
            from_account=1001,
            to_account=2002,
            amount=500.00
        )

        if result['success']:
            print(f"âœ… Transfert rÃ©ussi aprÃ¨s {result['attempts']} tentative(s)")
            print(f"   DÃ©tails: {result['result']}")
        else:
            print(f"âŒ Transfert Ã©chouÃ© aprÃ¨s {result['attempts']} tentative(s)")
            print(f"   Erreur: {result['error']}")

    except Error as e:
        print(f"âŒ Erreur de connexion: {e}")

    finally:
        if connection.is_connected():
            connection.close()
```

---

## âœ… Points clÃ©s Ã  retenir

- **SERIALIZABLE** offre l'isolation maximale en transformant tous les SELECT en SELECT FOR SHARE, posant des verrous partagÃ©s mÃªme sur les lectures

- **Ã‰limination totale des anomalies** : Seul niveau qui empÃªche le write skew et toutes les anomalies de concurrence

- **Impact dramatique sur les performances** : Perte de 80-90% du throughput, latences multipliÃ©es par 10-50x, timeouts frÃ©quents (10-30%)

- **Deadlocks extrÃªmement frÃ©quents** : Les shared locks sur les SELECT augmentent drastiquement les risques d'interblocage, nÃ©cessitant des stratÃ©gies de retry robustes

- **Cas d'usage ultra-limitÃ©s** : RÃ©servÃ© Ã  <0.1% des situations
  - Transactions financiÃ¨res critiques avec contraintes multiples
  - ComptabilitÃ© stricte (double entrÃ©e)
  - Allocations de ressources avec contraintes globales complexes
  - SystÃ¨mes rÃ©glementÃ©s (pharmaceutique, etc.)

- **Alternatives quasi-systÃ©matiques** :
  - REPEATABLE READ + SELECT FOR UPDATE (99% des cas)
  - Verrous applicatifs
  - Optimistic locking avec version
  - Contraintes SQL/triggers
  - Architecture Ã©vÃ©nementielle

- **Checklist stricte** : 13 critÃ¨res Ã  valider avant d'utiliser SERIALIZABLE - dans la plupart des cas, une alternative est plus appropriÃ©e

- **Retry obligatoire** : ImplÃ©menter un mÃ©canisme de retry avec backoff exponentiel est **non nÃ©gociable** en SERIALIZABLE

- **Monitoring critique** : Surveiller Ã©troitement les transactions SERIALIZABLE, les temps d'attente, les timeouts et les deadlocks

- **RÃ¨gle d'or** : **N'utilisez JAMAIS SERIALIZABLE par dÃ©faut**. C'est un outil de dernier recours pour des cas extrÃªmes parfaitement identifiÃ©s et documentÃ©s.

---

## ğŸ”— Ressources et rÃ©fÃ©rences

### Documentation officielle MariaDB

- [ğŸ“– Transaction Isolation Levels](https://mariadb.com/kb/en/set-transaction-isolation-level/)
- [ğŸ“– InnoDB Locking and Transaction Model](https://mariadb.com/kb/en/innodb-lock-modes/)
- [ğŸ“– Deadlocks in InnoDB](https://mariadb.com/kb/en/deadlock-detection/)

### Articles de recherche

- [A Critique of ANSI SQL Isolation Levels (1995)](http://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf) - Article fondamental sur les niveaux d'isolation
- [Serializable Snapshot Isolation](https://dl.acm.org/doi/10.1145/1620585.1620587) - Alternative Ã  SERIALIZABLE traditionnel

### Articles techniques

- [Understanding MySQL Transaction Isolation](https://www.percona.com/blog/understanding-mysql-isolation-levels/)
- [PostgreSQL SSI vs MySQL SERIALIZABLE](https://wiki.postgresql.org/wiki/SSI)

---

## ğŸ“Š Comparaison finale des 4 niveaux

| Aspect | READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE |
|--------|------------------|----------------|-----------------|--------------|
| **Performance** | ğŸŸ¢ 100% | ğŸŸ¢ 90% | ğŸŸ¡ 70% | ğŸ”´ 10-20% |
| **Dirty Reads** | âŒ Possible | âœ… Impossible | âœ… Impossible | âœ… Impossible |
| **Non-Repeatable** | âŒ Possible | âŒ Possible | âœ… Impossible | âœ… Impossible |
| **Phantom Reads** | âŒ Possible | âŒ Possible | âœ… Impossible* | âœ… Impossible |
| **Write Skew** | âŒ Possible | âŒ Possible | âŒ Possible | âœ… **Impossible** |
| **Verrous SELECT** | Aucun | Aucun | Aucun | ğŸ”’ **Shared** |
| **Concurrence** | ğŸŸ¢ Maximale | ğŸŸ¢ Excellente | ğŸŸ¡ Bonne | ğŸ”´ TrÃ¨s faible |
| **Deadlocks** | Rares | Rares | Possibles | ğŸ”´ **FrÃ©quents** |
| **Usage recommandÃ©** | Jamais | 80% des cas | 19% des cas | <1% des cas |

*InnoDB avec gap locking

---

## â¡ï¸ Prochaine section

**[6.4 Verrous (LOCK TABLES, SELECT FOR UPDATE, SELECT FOR SHARE)](./04-verrous.md)** : Approfondissez la gestion explicite des verrous pour contrÃ´ler finement la concurrence sans recourir Ã  SERIALIZABLE.

---

**ğŸ’¡ Conseil final** : SERIALIZABLE est comme un marteau-piqueur - extrÃªmement puissant mais appropriÃ© pour trÃ¨s peu de situations. Dans 99.9% des cas, il existe une alternative plus performante et tout aussi sÃ»re. **Si vous pensez avoir besoin de SERIALIZABLE, rÃ©flÃ©chissez-y Ã  deux fois, puis trois fois, puis cherchez une alternative.** Ce niveau d'isolation doit Ãªtre l'exception absolue, jamais la rÃ¨gle.

â­ï¸ [Verrous (LOCK TABLES, SELECT FOR UPDATE, SELECT FOR SHARE)](/06-transactions-et-concurrence/04-verrous.md)
