üîù Retour au [Sommaire](/SOMMAIRE.md)

# 6.3.1 READ UNCOMMITTED : Dirty reads possibles

> **Niveau** : Avanc√©
> **Dur√©e estim√©e** : 1 heure

> **Pr√©requis** :
> - Compr√©hension des propri√©t√©s ACID
> - Connaissance des transactions (6.1, 6.2)
> - Notions de concurrence d'acc√®s

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre le fonctionnement du niveau d'isolation READ UNCOMMITTED
- Identifier les situations de dirty reads et leurs cons√©quences
- √âvaluer les compromis performance vs coh√©rence
- D√©cider quand (et surtout quand ne pas) utiliser ce niveau d'isolation
- Anticiper les probl√®mes de coh√©rence des donn√©es

---

## Introduction

**READ UNCOMMITTED** est le niveau d'isolation le plus bas et le plus permissif dans MariaDB. Il offre les meilleures performances au prix d'une coh√©rence des donn√©es fortement compromise. Ce niveau permet √† une transaction de lire des donn√©es modifi√©es par d'autres transactions **avant m√™me leur COMMIT**, cr√©ant ce qu'on appelle des **dirty reads** (lectures sales).

### Position dans la hi√©rarchie des niveaux d'isolation

```
READ UNCOMMITTED  ‚Üê Le plus permissif (le moins isol√©)
    ‚Üì
READ COMMITTED
    ‚Üì
REPEATABLE READ   ‚Üê D√©faut InnoDB
    ‚Üì
SERIALIZABLE      ‚Üê Le plus strict (le plus isol√©)
```

‚ö†Ô∏è **Avertissement critique** : READ UNCOMMITTED est rarement appropri√© pour des applications de production n√©cessitant une coh√©rence des donn√©es. Son utilisation doit √™tre exceptionnelle et parfaitement justifi√©e.

---

## Principe de fonctionnement

### D√©finition technique

Au niveau READ UNCOMMITTED, une transaction peut voir les modifications effectu√©es par d'autres transactions **m√™me si ces modifications n'ont pas encore √©t√© valid√©es (COMMIT)** ou pourraient √™tre annul√©es (ROLLBACK).

```sql
-- Configuration du niveau d'isolation
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- Ou pour une transaction sp√©cifique
START TRANSACTION;
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
-- ... requ√™tes ...
COMMIT;
```

### Comportement par rapport aux verrous

READ UNCOMMITTED se comporte comme suit :

| Op√©ration | Verrous pos√©s | Verrous respect√©s |
|-----------|---------------|-------------------|
| **SELECT** | Aucun | Non (lit m√™me les donn√©es verrouill√©es) |
| **INSERT** | Verrous d'√©criture | Oui |
| **UPDATE** | Verrous d'√©criture | Oui |
| **DELETE** | Verrous d'√©criture | Oui |

üí° **Point cl√©** : Les SELECT ne posent aucun verrou et ignorent les verrous pos√©s par d'autres transactions, permettant de lire des donn√©es en cours de modification.

---

## Les Dirty Reads : Explications et Exemples

### Qu'est-ce qu'un Dirty Read ?

Un **dirty read** se produit quand une transaction lit des donn√©es qui ont √©t√© modifi√©es mais **pas encore valid√©es** par une autre transaction. Si la transaction qui a modifi√© ces donn√©es effectue un ROLLBACK, les donn√©es lues deviennent invalides r√©troactivement.

### Exemple 1 : Dirty Read classique

Imaginons un syst√®me bancaire (cas d'usage √† √©viter absolument avec READ UNCOMMITTED) :

```sql
-- Base de donn√©es : comptes bancaires
CREATE TABLE comptes (
    id INT PRIMARY KEY,
    titulaire VARCHAR(100),
    solde DECIMAL(10,2)
) ENGINE=InnoDB;

INSERT INTO comptes VALUES (1, 'Alice', 1000.00);
INSERT INTO comptes VALUES (2, 'Bob', 500.00);
```

**Sc√©nario temporel :**

| Temps | Transaction A (READ UNCOMMITTED) | Transaction B |
|-------|----------------------------------|---------------|
| T1 | | `START TRANSACTION;` |
| T2 | | `UPDATE comptes SET solde = solde - 500 WHERE id = 1;`<br>*-- Solde Alice = 500‚Ç¨* |
| T3 | `SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;`<br>`START TRANSACTION;` | |
| T4 | `SELECT solde FROM comptes WHERE id = 1;`<br>*-- Lit 500‚Ç¨ (donn√©e non valid√©e !)* | |
| T5 | | `ROLLBACK;`<br>*-- Annulation, solde revient √† 1000‚Ç¨* |
| T6 | *-- Transaction A a lu 500‚Ç¨ mais la vraie valeur est 1000‚Ç¨* | |

```sql
-- Transaction B (qui modifie les donn√©es)
START TRANSACTION;
UPDATE comptes SET solde = solde - 500 WHERE id = 1;
-- Alice a maintenant 500‚Ç¨ (non valid√©)

-- Transaction A (READ UNCOMMITTED)
-- Dans une autre session
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;
SELECT solde FROM comptes WHERE id = 1;
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë solde  ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë 500.00 ‚ïë  ‚Üê DIRTY READ !
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

-- Transaction B annule son op√©ration
-- De retour dans la session B
ROLLBACK;

-- Le solde r√©el d'Alice est en fait 1000‚Ç¨
-- mais Transaction A a lu 500‚Ç¨ !
```

**Cons√©quence** : Si Transaction A utilise cette valeur pour prendre une d√©cision (ex: autoriser un pr√™t), elle base sa d√©cision sur des donn√©es invalides.

### Exemple 2 : Dirty Read dans un syst√®me de r√©servation

```sql
-- Syst√®me de r√©servation de places
CREATE TABLE reservations (
    id INT PRIMARY KEY AUTO_INCREMENT,
    evenement_id INT,
    places_disponibles INT,
    INDEX(evenement_id)
) ENGINE=InnoDB;

INSERT INTO reservations VALUES (1, 100, 50);
```

**Sc√©nario probl√©matique :**

```sql
-- Transaction B : Tentative de r√©servation group√©e
START TRANSACTION;
UPDATE reservations
SET places_disponibles = places_disponibles - 30
WHERE evenement_id = 100;
-- places_disponibles = 20 (non valid√©)

-- Transaction A (READ UNCOMMITTED) : V√©rification de disponibilit√©
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;
SELECT places_disponibles FROM reservations WHERE evenement_id = 100;
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë places_disponibles    ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë 20                    ‚ïë  ‚Üê DIRTY READ !
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

-- L'application d√©cide qu'il reste 20 places

-- Transaction B √©choue finalement et annule
-- Retour √† la session B
ROLLBACK; -- Probl√®me technique, annulation

-- La r√©alit√© : il y a en fait 50 places disponibles
-- Mais l'application a affich√© "20 places restantes" √† l'utilisateur
```

### Exemple 3 : Impact sur les agr√©gations

Les dirty reads affectent particuli√®rement les fonctions d'agr√©gation :

```sql
-- Table de commandes e-commerce
CREATE TABLE commandes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    client_id INT,
    montant DECIMAL(10,2),
    statut ENUM('en_cours', 'validee', 'annulee') DEFAULT 'en_cours',
    INDEX(client_id)
) ENGINE=InnoDB;

-- Transaction B : Cr√©ation de plusieurs commandes
START TRANSACTION;
INSERT INTO commandes (client_id, montant, statut)
VALUES (1, 150.00, 'en_cours');
INSERT INTO commandes (client_id, montant, statut)
VALUES (1, 200.00, 'en_cours');
INSERT INTO commandes (client_id, montant, statut)
VALUES (1, 100.00, 'en_cours');
-- Total non valid√© : 450‚Ç¨

-- Transaction A (READ UNCOMMITTED) : Calcul du CA
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT SUM(montant) as ca_total FROM commandes WHERE client_id = 1;
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë ca_total  ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë 450.00    ‚ïë  ‚Üê DIRTY READ !
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

-- Transaction B d√©tecte une fraude et annule
-- Retour √† la session B
ROLLBACK;

-- Le vrai CA du client est 0‚Ç¨, pas 450‚Ç¨
-- Si cette valeur est utilis√©e pour un rapport, il sera faux
```

---

## Ph√©nom√®nes de coh√©rence compromis

Avec READ UNCOMMITTED, plusieurs ph√©nom√®nes d'incoh√©rence sont possibles :

### 1. Dirty Reads (lectures sales)

‚úÖ **Possible** - C'est la caract√©ristique principale de ce niveau

### 2. Non-Repeatable Reads (lectures non r√©p√©tables)

‚úÖ **Possible** - Une m√™me requ√™te peut retourner des r√©sultats diff√©rents

```sql
-- Transaction A (READ UNCOMMITTED)
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;

SELECT solde FROM comptes WHERE id = 1;
-- R√©sultat : 1000‚Ç¨

-- Transaction B modifie et COMMIT
-- (dans une autre session)
UPDATE comptes SET solde = 1500 WHERE id = 1;
COMMIT;

-- Transaction A relit
SELECT solde FROM comptes WHERE id = 1;
-- R√©sultat : 1500‚Ç¨ (diff√©rent du premier SELECT !)

COMMIT;
```

### 3. Phantom Reads (lectures fant√¥mes)

‚úÖ **Possible** - De nouvelles lignes peuvent appara√Ætre

```sql
-- Transaction A
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;

SELECT COUNT(*) FROM commandes WHERE statut = 'en_cours';
-- R√©sultat : 5

-- Transaction B ins√®re et COMMIT
INSERT INTO commandes (client_id, montant, statut)
VALUES (2, 300.00, 'en_cours');
COMMIT;

-- Transaction A recompte
SELECT COUNT(*) FROM commandes WHERE statut = 'en_cours';
-- R√©sultat : 6 (ligne fant√¥me !)

COMMIT;
```

### Tableau r√©capitulatif des anomalies

| Anomalie | READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE |
|----------|------------------|----------------|-----------------|--------------|
| **Dirty Reads** | ‚úÖ Possible | ‚ùå Impossible | ‚ùå Impossible | ‚ùå Impossible |
| **Non-Repeatable Reads** | ‚úÖ Possible | ‚úÖ Possible | ‚ùå Impossible | ‚ùå Impossible |
| **Phantom Reads** | ‚úÖ Possible | ‚úÖ Possible | ‚úÖ Possible* | ‚ùå Impossible |

*InnoDB utilise gap locking pour √©viter les phantom reads m√™me en REPEATABLE READ

---

## Cas d'usage l√©gitimes (rares)

Malgr√© ses risques, READ UNCOMMITTED peut √™tre appropri√© dans de tr√®s rares situations :

### 1. Tableaux de bord approximatifs

```sql
-- Dashboard de monitoring en temps r√©el
-- La pr√©cision absolue n'est pas critique
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

SELECT
    DATE(created_at) as date,
    COUNT(*) as nb_commandes,
    AVG(montant) as montant_moyen,
    SUM(montant) as ca_jour
FROM commandes
WHERE created_at >= CURDATE() - INTERVAL 7 DAY
GROUP BY DATE(created_at)
ORDER BY date DESC;

-- Performance : Lecture sans verrous, tr√®s rapide
-- Acceptabilit√© : Quelques centimes d'√©cart sur le CA acceptable
```

üí° **Justification** : Pour un dashboard rafra√Æchi toutes les 30 secondes, une pr√©cision √† 99.9% est suffisante. La rapidit√© d'ex√©cution prime sur l'exactitude absolue.

### 2. Rapports statistiques non critiques

```sql
-- Analyse des tendances g√©n√©rales (BI)
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

SELECT
    categorie,
    COUNT(DISTINCT client_id) as nb_clients,
    AVG(note) as note_moyenne
FROM avis_produits
WHERE created_at >= CURDATE() - INTERVAL 30 DAY
GROUP BY categorie;

-- Les quelques avis non valid√©s ne changeront pas les tendances
```

### 3. V√©rifications d'existence approximatives

```sql
-- V√©rification rapide si des donn√©es existent
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

SELECT EXISTS(
    SELECT 1 FROM logs_erreurs
    WHERE niveau = 'CRITICAL'
    AND timestamp > NOW() - INTERVAL 5 MINUTE
) as alertes_recentes;

-- Utilis√© pour d√©cider de lancer une analyse plus approfondie
```

‚ö†Ô∏è **Important** : Ces cas restent exceptionnels. Dans 99% des cas, utilisez au minimum READ COMMITTED.

---

## Implications en production

### Avantages

#### 1. Performance maximale

```sql
-- Comparaison de performance (benchmark simplifi√©)

-- READ UNCOMMITTED : ~0.001s
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT COUNT(*) FROM grosse_table; -- 10 millions de lignes

-- REPEATABLE READ (d√©faut) : ~0.015s
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT COUNT(*) FROM grosse_table;

-- Gain : jusqu'√† 15x plus rapide sur les lectures pures
```

Raisons de ce gain :
- ‚úÖ Aucun verrou partag√© pos√©
- ‚úÖ Pas d'attente sur les verrous d'√©criture
- ‚úÖ Moins de contention sur les structures internes InnoDB
- ‚úÖ Overhead m√©moire minimal (pas de snapshot MVCC)

#### 2. Aucun blocage

```sql
-- Lecture possible m√™me pendant un UPDATE massif
-- Transaction B : UPDATE de longue dur√©e
START TRANSACTION;
UPDATE grosse_table SET colonne = valeur WHERE condition;
-- Prend 30 secondes, verrouille des millions de lignes

-- Transaction A (READ UNCOMMITTED) : Lecture imm√©diate
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT COUNT(*) FROM grosse_table WHERE autre_condition;
-- Retourne imm√©diatement, ne bloque pas
```

### Inconv√©nients (majeurs)

#### 1. D√©cisions bas√©es sur des donn√©es invalides

```sql
-- Exemple catastrophique : Gestion de stock
-- Transaction B
START TRANSACTION;
UPDATE stocks SET quantite = quantite - 100 WHERE produit_id = 1;
-- quantite passe de 150 √† 50 (non valid√©)

-- Transaction A (READ UNCOMMITTED)
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT quantite FROM stocks WHERE produit_id = 1;
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë quantite ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë 50       ‚ïë  ‚Üê Application voit "stock faible"
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

-- L'application d√©clenche automatiquement une commande d'urgence
-- √† un fournisseur (processus irr√©versible)

-- Transaction B √©choue et annule
ROLLBACK; -- En fait, il reste 150 unit√©s !

-- R√©sultat : Commande inutile pass√©e, surstock, perte financi√®re
```

#### 2. Rapports incoh√©rents

```sql
-- Rapport financier
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- Lecture des ventes du jour
SELECT SUM(montant) as ventes FROM ventes WHERE date = CURDATE();
-- R√©sultat : 50 000‚Ç¨ (inclut des transactions non valid√©es)

-- Lecture des paiements re√ßus
SELECT SUM(montant) as paiements FROM paiements WHERE date = CURDATE();
-- R√©sultat : 48 000‚Ç¨

-- Le rapport montre : Ventes = 50 000‚Ç¨, Paiements = 48 000‚Ç¨
-- Mais si les transactions non valid√©es sont ROLLBACK,
-- les vraies ventes sont 45 000‚Ç¨
-- Rapport incoh√©rent pr√©sent√© √† la direction !
```

#### 3. Violations de contraintes applicatives

```sql
-- Contrainte m√©tier : Un utilisateur ne peut avoir qu'un seul panier actif
-- Transaction B
START TRANSACTION;
INSERT INTO paniers (user_id, statut) VALUES (123, 'actif');
-- Pas encore valid√©

-- Transaction A (READ UNCOMMITTED)
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT COUNT(*) FROM paniers WHERE user_id = 123 AND statut = 'actif';
-- R√©sultat : 1 (lit le panier non valid√©)

-- L'application pense que l'utilisateur a d√©j√† un panier
-- et refuse de cr√©er un nouveau panier

-- Transaction B √©choue
ROLLBACK;

-- R√©sultat : L'utilisateur n'a aucun panier mais l'application
-- refuse de lui en cr√©er un (UX d√©grad√©e, bug per√ßu)
```

---

## Comparaison avec les autres niveaux d'isolation

### Performance vs Coh√©rence

```
Performance ‚Üê‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚Üí Coh√©rence
  (rapide)                              (s√ªr)

READ UNCOMMITTED ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 90% | 10%
READ COMMITTED   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 70% | 30%
REPEATABLE READ  ‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 40% | 60%
SERIALIZABLE     ‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 10% | 90%
```

### Sc√©narios de choix

```sql
-- ‚ùå NE PAS UTILISER pour :
-- - Transactions financi√®res
-- - Donn√©es critiques m√©tier
-- - Tout ce qui n√©cessite ACID strict
-- - Applications o√π la coh√©rence est primordiale

-- ‚ö†Ô∏è UTILISER AVEC PR√âCAUTION pour :
-- - Dashboards approximatifs
-- - Statistiques non critiques
-- - Rapports de tendances

-- ‚úÖ PR√âF√âRER READ COMMITTED ou sup√©rieur pour :
-- - 99% des cas d'usage production
-- - Toute application transactionnelle standard
```

---

## Configuration et bonnes pratiques

### Configuration au niveau session

```sql
-- Pour une transaction ponctuelle
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;
-- ... requ√™tes ...
COMMIT;

-- Pour toute la session
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```

### Configuration globale (d√©conseill√©)

```ini
# my.cnf - √Ä √âVITER !
[mysqld]
transaction-isolation = READ-UNCOMMITTED
```

‚ö†Ô∏è **Ne jamais configurer READ UNCOMMITTED comme d√©faut global** - C'est une invitation aux bugs subtils et aux incoh√©rences de donn√©es.

### Pattern d'utilisation s√ªr

```sql
-- Sauvegarder le niveau actuel
SET @previous_isolation = @@SESSION.transaction_isolation;

-- Utiliser READ UNCOMMITTED temporairement
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT /* requ√™te rapide non critique */ * FROM table_stats;

-- Restaurer le niveau pr√©c√©dent
SET SESSION TRANSACTION ISOLATION LEVEL @previous_isolation;
```

### Code application (Python exemple)

```python
import mysql.connector

def get_approximate_stats(connection):
    """
    R√©cup√®re des statistiques approximatives avec READ UNCOMMITTED
    Accepte des dirty reads pour la performance
    """
    cursor = connection.cursor()

    try:
        # Sauvegarder l'isolation actuelle
        cursor.execute("SELECT @@SESSION.transaction_isolation")
        previous_isolation = cursor.fetchone()[0]

        # Passer en READ UNCOMMITTED
        cursor.execute("SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED")

        # Requ√™te rapide
        cursor.execute("""
            SELECT
                COUNT(*) as total_users,
                AVG(score) as avg_score
            FROM users
        """)
        result = cursor.fetchone()

        return {
            'total': result[0],
            'average': float(result[1]),
            'warning': 'Donn√©es approximatives (dirty reads possibles)'
        }

    finally:
        # Toujours restaurer l'isolation pr√©c√©dente
        cursor.execute(f"SET SESSION TRANSACTION ISOLATION LEVEL {previous_isolation}")
        cursor.close()
```

---

## D√©tection et debugging des dirty reads

### Identifier les dirty reads dans les logs

```sql
-- Activer le general log temporairement
SET GLOBAL general_log = ON;
SET GLOBAL general_log_file = '/var/log/mysql/general.log';

-- Surveiller les changements de niveau d'isolation
-- Dans les logs, rechercher :
-- "SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED"
```

### Requ√™te de monitoring

```sql
-- V√©rifier les niveaux d'isolation actifs
SELECT
    p.id as process_id,
    p.user,
    p.host,
    p.db,
    p.command,
    p.time,
    p.state,
    -- Niveau d'isolation (n√©cessite PERFORMANCE_SCHEMA)
    t.isolation_level
FROM information_schema.processlist p
LEFT JOIN performance_schema.threads t ON p.id = t.processlist_id
WHERE p.command != 'Sleep';
```

### Test de pr√©sence de dirty reads

```sql
-- Sc√©nario de test
-- Session A
START TRANSACTION;
UPDATE test_table SET value = 999 WHERE id = 1;
-- Ne pas COMMIT

-- Session B (READ UNCOMMITTED)
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT value FROM test_table WHERE id = 1;
-- Si = 999 ‚Üí dirty read confirm√©
-- Si = ancienne valeur ‚Üí pas de dirty read

-- Session A
ROLLBACK;
```

---

## Alternatives recommand√©es

### Au lieu de READ UNCOMMITTED...

#### 1. Utiliser READ COMMITTED

```sql
-- Performance excellente, coh√©rence meilleure
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- √âvite les dirty reads
-- Accepte les non-repeatable reads (souvent acceptable)
-- Performance proche de READ UNCOMMITTED
```

#### 2. Utiliser des tables de cache/mat√©rialis√©es

```sql
-- Cr√©er une table de statistiques pr√©-calcul√©es
CREATE TABLE stats_cache (
    metric_name VARCHAR(100),
    metric_value DECIMAL(20,2),
    last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (metric_name)
) ENGINE=InnoDB;

-- Mise √† jour p√©riodique (toutes les 5 minutes)
CREATE EVENT update_stats_cache
ON SCHEDULE EVERY 5 MINUTE
DO
    REPLACE INTO stats_cache (metric_name, metric_value)
    SELECT 'total_sales', SUM(amount) FROM sales WHERE date = CURDATE();

-- Lecture ultra-rapide sans dirty reads
SELECT metric_value FROM stats_cache WHERE metric_name = 'total_sales';
```

#### 3. Utiliser des vues mat√©rialis√©es (workaround)

```sql
-- MariaDB n'a pas de vraies vues mat√©rialis√©es
-- Workaround avec table + trigger

CREATE TABLE mv_daily_sales (
    date DATE PRIMARY KEY,
    total_amount DECIMAL(15,2),
    order_count INT,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB;

-- Rafra√Æchir avec un event ou trigger
-- Lecture rapide et coh√©rente
SELECT * FROM mv_daily_sales WHERE date = CURDATE();
```

#### 4. Utiliser le partitionnement temporel

```sql
-- Pour l'historique : partitionner par date
CREATE TABLE commandes (
    id INT PRIMARY KEY,
    date DATE,
    montant DECIMAL(10,2),
    -- ...
) ENGINE=InnoDB
PARTITION BY RANGE (YEAR(date)*100 + MONTH(date)) (
    PARTITION p202501 VALUES LESS THAN (202502),
    PARTITION p202502 VALUES LESS THAN (202503),
    -- ...
);

-- Les lectures historiques sont isol√©es naturellement
-- Pas besoin de READ UNCOMMITTED
```

---

## ‚úÖ Points cl√©s √† retenir

- **READ UNCOMMITTED** est le niveau d'isolation le plus bas, autorisant les **dirty reads** (lecture de donn√©es non valid√©es)

- Les **dirty reads** permettent de lire des modifications qui pourraient √™tre annul√©es (ROLLBACK), cr√©ant des incoh√©rences de donn√©es graves

- **Performance maximale** au d√©triment de la coh√©rence : aucun verrou de lecture, aucune attente

- **Cas d'usage l√©gitimes** : extr√™mement rares, limit√©s aux dashboards approximatifs et statistiques non critiques o√π 99% de pr√©cision suffit

- **Risques majeurs** :
  - D√©cisions m√©tier bas√©es sur des donn√©es invalides
  - Rapports incoh√©rents
  - Violations de contraintes applicatives
  - Bugs subtils difficiles √† d√©boguer

- **Alternatives recommand√©es** : READ COMMITTED (compromis performance/coh√©rence optimal), tables de cache, vues mat√©rialis√©es

- **R√®gle d'or** : Ne jamais utiliser READ UNCOMMITTED comme d√©faut. Toujours justifier son usage et documenter les risques accept√©s

- Dans 99% des cas, **READ COMMITTED ou REPEATABLE READ** sont plus appropri√©s, offrant un bon √©quilibre performance/coh√©rence

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB

- [üìñ Transaction Isolation Levels](https://mariadb.com/kb/en/set-transaction-isolation-level/)
- [üìñ InnoDB Lock Modes](https://mariadb.com/kb/en/innodb-lock-modes/)
- [üìñ ACID Compliance](https://mariadb.com/kb/en/acid-compliance/)

### Articles approfondis

- [Understanding Transaction Isolation in MySQL](https://www.percona.com/blog/understanding-mysql-isolation-levels/)
- [InnoDB Multi-Versioning](https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html)

### Standards SQL

- ISO/IEC 9075 (SQL Standard) - D√©finition des niveaux d'isolation
- ANSI SQL-92 - Sp√©cification des anomalies transactionnelles

---

## ‚û°Ô∏è Section suivante

**[6.3.2 READ COMMITTED : Lectures coh√©rentes](./03.2-read-committed.md)** : D√©couvrez le niveau d'isolation qui √©limine les dirty reads tout en offrant d'excellentes performances, souvent le meilleur choix pour les applications transactionnelles.

---

**üí° Conseil final** : Si vous vous demandez "Puis-je utiliser READ UNCOMMITTED pour cette fonctionnalit√© ?", la r√©ponse est probablement non. Privil√©giez READ COMMITTED qui offre 90% de la performance avec une coh√©rence bien meilleure.

‚è≠Ô∏è [READ COMMITTED : Lectures coh√©rentes](/06-transactions-et-concurrence/03.2-read-committed.md)
