üîù Retour au [Sommaire](/SOMMAIRE.md)

# 6.3.2 READ COMMITTED : Lectures coh√©rentes

> **Niveau** : Avanc√©
> **Dur√©e estim√©e** : 1.5 heures

> **Pr√©requis** :
> - Compr√©hension des propri√©t√©s ACID
> - Connaissance de READ UNCOMMITTED (6.3.1)
> - Notions de MVCC et verrous

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre le fonctionnement de READ COMMITTED et comment il √©limine les dirty reads
- Identifier et g√©rer les non-repeatable reads (lectures non r√©p√©tables)
- √âvaluer le compromis optimal entre performance et coh√©rence
- Configurer READ COMMITTED pour des applications transactionnelles
- Comparer READ COMMITTED avec les autres niveaux d'isolation
- Choisir READ COMMITTED comme niveau par d√©faut pour la plupart des applications

---

## Introduction

**READ COMMITTED** est le niveau d'isolation qui offre le meilleur compromis entre performance et coh√©rence pour la majorit√© des applications transactionnelles. C'est le niveau par d√©faut dans de nombreux SGBD (Oracle, PostgreSQL, SQL Server) et une alternative tr√®s populaire √† REPEATABLE READ dans MariaDB/MySQL.

### Position dans la hi√©rarchie

```
READ UNCOMMITTED  ‚Üê Dirty reads possibles
    ‚Üì
READ COMMITTED    ‚Üê üéØ √âquilibre optimal
    ‚Üì
REPEATABLE READ   ‚Üê D√©faut InnoDB
    ‚Üì
SERIALIZABLE      ‚Üê Maximum isolation
```

**Garantie principale** : Une transaction en READ COMMITTED ne lit **jamais** des donn√©es non valid√©es (pas de dirty reads). Elle ne voit que les modifications **COMMIT**t√©es par d'autres transactions.

üí° **Choix strat√©gique** : READ COMMITTED est souvent le meilleur choix pour les applications OLTP (Online Transaction Processing) modernes, offrant 95% de la coh√©rence avec 90% de la performance.

---

## Principe de fonctionnement

### D√©finition technique

Au niveau READ COMMITTED, chaque instruction SELECT dans une transaction voit un **snapshot des donn√©es au moment de son ex√©cution**, contenant uniquement les modifications valid√©es (COMMIT) avant ce moment.

```sql
-- Configuration du niveau d'isolation
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- Ou pour une transaction sp√©cifique
START TRANSACTION;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
-- ... requ√™tes ...
COMMIT;
```

### R√®gles de visibilit√©

| Moment | Visibilit√© des donn√©es |
|--------|------------------------|
| **Avant COMMIT** | ‚ùå Non visibles (√©vite dirty reads) |
| **Apr√®s COMMIT** | ‚úÖ Imm√©diatement visibles |
| **Apr√®s ROLLBACK** | ‚ùå Jamais visibles |

### M√©canisme MVCC sous-jacent

READ COMMITTED s'appuie sur le **Multi-Version Concurrency Control (MVCC)** d'InnoDB :

```
Transaction A (READ COMMITTED)
    ‚îÇ
    ‚îÇ  SELECT ... ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ                   ‚îÇ
    ‚îÇ                   ‚îú‚îÄ‚ñ∫ Lit version valid√©e (snapshot)
    ‚îÇ                   ‚îÇ   au moment du SELECT
    ‚îÇ  SELECT ... ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ                   ‚îÇ
    ‚îÇ                   ‚îú‚îÄ‚ñ∫ Nouveau snapshot, peut voir
    ‚îÇ                   ‚îÇ   de nouvelles versions COMMIT
    ‚îÇ  SELECT ...       ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Transaction B
    ‚îÇ
    ‚îÇ  UPDATE ...
    ‚îÇ  ‚ùå Non visible par A
    ‚îÇ
    ‚îÇ  COMMIT
    ‚îÇ  ‚úÖ Visible par les prochains SELECT de A
    ‚îî‚îÄ
```

---

## √âlimination des Dirty Reads

### Exemple 1 : Transactions bancaires s√©curis√©es

Reprenons l'exemple bancaire de la section pr√©c√©dente, mais avec READ COMMITTED :

```sql
-- Base de donn√©es : comptes bancaires
CREATE TABLE comptes (
    id INT PRIMARY KEY,
    titulaire VARCHAR(100),
    solde DECIMAL(10,2)
) ENGINE=InnoDB;

INSERT INTO comptes VALUES (1, 'Alice', 1000.00);
INSERT INTO comptes VALUES (2, 'Bob', 500.00);
```

**Sc√©nario temporel :**

| Temps | Transaction A (READ COMMITTED) | Transaction B |
|-------|--------------------------------|---------------|
| T1 | | `START TRANSACTION;` |
| T2 | | `UPDATE comptes SET solde = solde - 500 WHERE id = 1;`<br>*-- Solde Alice = 500‚Ç¨ (non valid√©)* |
| T3 | `SET TRANSACTION ISOLATION LEVEL READ COMMITTED;`<br>`START TRANSACTION;` | |
| T4 | `SELECT solde FROM comptes WHERE id = 1;`<br>*-- Lit 1000‚Ç¨ (valeur valid√©e !)* | |
| T5 | | `ROLLBACK;`<br>*-- Annulation* |
| T6 | `SELECT solde FROM comptes WHERE id = 1;`<br>*-- Lit toujours 1000‚Ç¨ (coh√©rent)* | |

```sql
-- Transaction B (modifie les donn√©es)
START TRANSACTION;
UPDATE comptes SET solde = solde - 500 WHERE id = 1;
-- Alice a maintenant 500‚Ç¨ (NON VALID√â)

-- Transaction A (READ COMMITTED)
-- Dans une autre session
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;

SELECT solde FROM comptes WHERE id = 1;
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë solde  ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë 1000.00‚ïë  ‚Üê Lit la valeur COMMIT (pas de dirty read !)
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

-- Transaction B annule son op√©ration
ROLLBACK;

-- Transaction A relit
SELECT solde FROM comptes WHERE id = 1;
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë solde  ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë 1000.00‚ïë  ‚Üê Toujours coh√©rent
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

COMMIT;
```

‚úÖ **R√©sultat** : Aucun dirty read possible. Transaction A ne voit jamais les modifications non valid√©es de Transaction B.

### Exemple 2 : Syst√®me de r√©servation fiable

```sql
-- Syst√®me de r√©servation d'h√¥tel
CREATE TABLE chambres (
    id INT PRIMARY KEY,
    numero VARCHAR(10),
    statut ENUM('disponible', 'reservee', 'occupee') DEFAULT 'disponible',
    prix_nuit DECIMAL(8,2)
) ENGINE=InnoDB;

INSERT INTO chambres VALUES (1, '101', 'disponible', 150.00);
```

```sql
-- Transaction B : Tentative de r√©servation
START TRANSACTION;
UPDATE chambres SET statut = 'reservee' WHERE id = 1;
-- Chambre marqu√©e r√©serv√©e (pas encore valid√©)

-- Transaction A (READ COMMITTED) : Recherche de chambres disponibles
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;

SELECT id, numero, statut FROM chambres WHERE statut = 'disponible';
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë id ‚ïë numero ‚ïë statut      ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë 1  ‚ïë 101    ‚ïë disponible  ‚ïë  ‚Üê Voit l'ancien statut (COMMIT)
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

-- La chambre appara√Æt toujours disponible car la r√©servation
-- de Transaction B n'est pas encore valid√©e

-- Transaction B valide
COMMIT;

-- Transaction A recherche √† nouveau
SELECT id, numero, statut FROM chambres WHERE statut = 'disponible';
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë id ‚ïë numero ‚ïë statut      ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë    ‚ïë        ‚ïë             ‚ïë  ‚Üê R√©sultat vide
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
-- La chambre a disparu (maintenant r√©serv√©e)

COMMIT;
```

üí° **Avantage** : L'application ne montre jamais aux utilisateurs des chambres "fant√¥mes" qui pourraient √™tre annul√©es.

---

## Non-Repeatable Reads : Le compromis accept√©

### Qu'est-ce qu'un Non-Repeatable Read ?

Un **non-repeatable read** se produit quand une transaction lit les m√™mes donn√©es deux fois et obtient des r√©sultats diff√©rents parce qu'une autre transaction a modifi√© et COMMIT ces donn√©es entre-temps.

‚ö†Ô∏è **Important** : Contrairement aux dirty reads, les non-repeatable reads impliquent uniquement des donn√©es **valid√©es**. C'est un compromis acceptable pour la plupart des applications.

### Exemple 1 : V√©rification de solde bancaire

```sql
-- Transaction A (READ COMMITTED)
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;

-- Premi√®re lecture : V√©rifier le solde avant une op√©ration
SELECT solde FROM comptes WHERE id = 1;
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë solde  ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë 1000.00‚ïë
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

-- L'application d√©cide : "OK, solde suffisant pour d√©biter 200‚Ç¨"

-- === Entre-temps ===
-- Transaction B effectue un retrait et COMMIT
-- (dans une autre session)
START TRANSACTION;
UPDATE comptes SET solde = solde - 800 WHERE id = 1;
COMMIT;
-- Le solde est maintenant 200‚Ç¨

-- Transaction A relit le solde
SELECT solde FROM comptes WHERE id = 1;
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë solde  ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë 200.00 ‚ïë  ‚Üê Valeur diff√©rente (non-repeatable read !)
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

-- Transaction A tente de d√©biter 200‚Ç¨
UPDATE comptes SET solde = solde - 200 WHERE id = 1;
-- Solde devient 0‚Ç¨

COMMIT;
```

**Analyse** :
- ‚úÖ Pas de dirty read : toutes les lectures sont sur des donn√©es COMMIT
- ‚ö†Ô∏è Non-repeatable read : la m√™me requ√™te retourne des valeurs diff√©rentes
- üéØ R√©sultat final correct : Le solde est bien 0‚Ç¨ (coh√©rent)

### Exemple 2 : Consultation d'un panier e-commerce

```sql
-- Table panier d'achat
CREATE TABLE paniers (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    produit_id INT,
    quantite INT,
    prix_unitaire DECIMAL(10,2),
    INDEX(user_id)
) ENGINE=InnoDB;

-- Transaction A (READ COMMITTED) : Calcul du total du panier
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;

-- Premi√®re lecture : Afficher le panier
SELECT
    produit_id,
    quantite,
    prix_unitaire,
    (quantite * prix_unitaire) as sous_total
FROM paniers
WHERE user_id = 123;
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë produit_id ‚ïë quantite ‚ïë prix_unitaire ‚ïë sous_total ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë 1001       ‚ïë 2        ‚ïë 29.99         ‚ïë 59.98      ‚ïë
-- ‚ïë 1002       ‚ïë 1        ‚ïë 49.99         ‚ïë 49.99      ‚ïë
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
-- Total affich√© : 109.97‚Ç¨

-- === L'utilisateur ajoute un produit dans une autre session ===
-- Transaction B
START TRANSACTION;
INSERT INTO paniers (user_id, produit_id, quantite, prix_unitaire)
VALUES (123, 1003, 1, 19.99);
COMMIT;

-- Transaction A recalcule le total
SELECT SUM(quantite * prix_unitaire) as total
FROM paniers
WHERE user_id = 123;
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë total   ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë 129.96  ‚ïë  ‚Üê Total diff√©rent (ligne ajout√©e)
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

COMMIT;
```

**Analyse** :
- ‚úÖ Comportement attendu : L'utilisateur a r√©ellement ajout√© un produit
- ‚ö†Ô∏è Non-repeatable read : Le total change pendant la transaction
- üéØ Pour l'UX : Acceptable, voire souhaitable (panier √† jour)

### Exemple 3 : Rapport de ventes quotidiennes

```sql
-- Table des ventes
CREATE TABLE ventes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    date DATE,
    montant DECIMAL(10,2),
    statut ENUM('en_cours', 'validee') DEFAULT 'en_cours',
    INDEX(date, statut)
) ENGINE=InnoDB;

-- Transaction A (READ COMMITTED) : G√©n√©ration d'un rapport
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;

-- Premi√®re lecture : Ventes du jour
SELECT
    COUNT(*) as nb_ventes,
    SUM(montant) as ca_total
FROM ventes
WHERE date = CURDATE() AND statut = 'validee';
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë nb_ventes ‚ïë ca_total ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë 150       ‚ïë 45000.00 ‚ïë
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

-- === Pendant ce temps, 5 nouvelles ventes sont valid√©es ===
-- Transaction B
START TRANSACTION;
UPDATE ventes SET statut = 'validee'
WHERE date = CURDATE() AND statut = 'en_cours'
LIMIT 5;
COMMIT;

-- Transaction A relance la m√™me requ√™te
SELECT
    COUNT(*) as nb_ventes,
    SUM(montant) as ca_total
FROM ventes
WHERE date = CURDATE() AND statut = 'validee';
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¶‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë nb_ventes ‚ïë ca_total ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï¨‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë 155       ‚ïë 47500.00 ‚ïë  ‚Üê Valeurs diff√©rentes
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï©‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

COMMIT;
```

**Analyse** :
- ‚ö†Ô∏è Non-repeatable read : Les m√©triques changent en cours de rapport
- ü§î Impact : D√©pend du contexte m√©tier
  - ‚úÖ Dashboard temps r√©el : Acceptable, voire souhaitable
  - ‚ö†Ô∏è Rapport officiel fig√© : Probl√©matique (utiliser REPEATABLE READ)

---

## Phantom Reads : Aussi possibles

Un **phantom read** se produit quand une transaction ex√©cute la m√™me requ√™te deux fois et voit appara√Ætre (ou dispara√Ætre) des lignes qui satisfont les crit√®res de recherche.

### Exemple : Analyse de segments clients

```sql
-- Table clients avec segments
CREATE TABLE clients (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nom VARCHAR(100),
    ca_annuel DECIMAL(12,2),
    segment VARCHAR(20),
    INDEX(segment)
) ENGINE=InnoDB;

-- Transaction A (READ COMMITTED)
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;

-- Compter les clients VIP
SELECT COUNT(*) FROM clients WHERE segment = 'VIP';
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë COUNT(*) ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë 50       ‚ïë
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

-- === Transaction B ins√®re un nouveau client VIP ===
START TRANSACTION;
INSERT INTO clients (nom, ca_annuel, segment)
VALUES ('Nouveau Client', 100000.00, 'VIP');
COMMIT;

-- Transaction A recompte
SELECT COUNT(*) FROM clients WHERE segment = 'VIP';
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë COUNT(*) ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë 51       ‚ïë  ‚Üê Phantom read (nouvelle ligne apparue)
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

COMMIT;
```

üí° **Note** : InnoDB utilise le **gap locking** en REPEATABLE READ pour √©viter les phantom reads, mais pas en READ COMMITTED.

---

## Comparaison d√©taill√©e des anomalies

### Tableau r√©capitulatif

| Anomalie | Description | READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE |
|----------|-------------|------------------|----------------|-----------------|--------------|
| **Dirty Reads** | Lire des donn√©es non COMMIT | ‚úÖ Possible | ‚ùå **Impossible** | ‚ùå Impossible | ‚ùå Impossible |
| **Non-Repeatable Reads** | M√™me SELECT ‚Üí r√©sultats diff√©rents | ‚úÖ Possible | ‚úÖ **Possible** | ‚ùå Impossible | ‚ùå Impossible |
| **Phantom Reads** | Nouvelles lignes apparaissent | ‚úÖ Possible | ‚úÖ **Possible** | ‚úÖ Possible* | ‚ùå Impossible |

*InnoDB √©vite g√©n√©ralement les phantom reads m√™me en REPEATABLE READ gr√¢ce au gap locking

### Matrice de d√©cision

```
Besoin de coh√©rence
      ‚îÇ
√âlev√© ‚îÇ                                    ‚óÜ SERIALIZABLE
      ‚îÇ                              ‚óÜ REPEATABLE READ
      ‚îÇ                    ‚óÜ READ COMMITTED
      ‚îÇ          ‚óÜ READ UNCOMMITTED
Faible‚îÇ_______________________________________________
       Faible                               √âlev√©
                  Performance requise
```

---

## Gestion des verrous

### Comportement des verrous en READ COMMITTED

```sql
-- READ COMMITTED pose des verrous uniquement sur les lignes effectivement modifi√©es
START TRANSACTION;

-- UPDATE verrouille UNIQUEMENT les lignes match√©es
UPDATE comptes SET solde = solde + 100 WHERE id = 1;
-- ‚úÖ Ligne id=1 verrouill√©e
-- ‚úÖ Autres lignes accessibles

-- SELECT ne pose PAS de verrous
SELECT solde FROM comptes WHERE id = 2;
-- ‚úÖ Aucun verrou, lecture libre

COMMIT;
```

### Comparaison avec REPEATABLE READ

```sql
-- REPEATABLE READ (d√©faut InnoDB)
START TRANSACTION;

-- Range scan verrouille un "gap" (espace entre les cl√©s)
UPDATE comptes SET solde = solde + 10 WHERE solde > 1000;
-- ‚úÖ Lignes match√©es verrouill√©es
-- ‚ö†Ô∏è "Gap locks" pour √©viter phantom reads
-- ‚ùå Peut bloquer INSERT dans la range

-- READ COMMITTED
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;

-- Range scan verrouille UNIQUEMENT les lignes match√©es
UPDATE comptes SET solde = solde + 10 WHERE solde > 1000;
-- ‚úÖ Lignes match√©es verrouill√©es
-- ‚úÖ Pas de gap locks
-- ‚úÖ INSERT possible dans la range (concurrence meilleure)

COMMIT;
```

### Avantages en termes de concurrence

```sql
-- Sc√©nario : 2 transactions modifient des lignes diff√©rentes

-- Table avec beaucoup de lignes
CREATE TABLE commandes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    statut VARCHAR(20),
    montant DECIMAL(10,2),
    INDEX(statut)
) ENGINE=InnoDB;

-- Transaction A (READ COMMITTED)
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
UPDATE commandes SET statut = 'expediee' WHERE id = 100;
-- ‚úÖ Seule la ligne 100 est verrouill√©e

-- Transaction B (READ COMMITTED) - peut s'ex√©cuter en parall√®le
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
UPDATE commandes SET statut = 'expediee' WHERE id = 200;
-- ‚úÖ Pas de blocage, ligne diff√©rente

-- Les deux transactions peuvent COMMIT sans attente
COMMIT; -- Transaction A
COMMIT; -- Transaction B
```

En REPEATABLE READ avec gap locks, Transaction B pourrait √™tre bloqu√©e dans certains sc√©narios.

---

## Cas d'usage en production

### 1. Applications web transactionnelles (recommand√©)

```sql
-- Configuration pour une application e-commerce
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- Sc√©nario : Passer une commande
START TRANSACTION;

-- 1. V√©rifier le stock (lecture coh√©rente)
SELECT stock FROM produits WHERE id = 1001 FOR UPDATE;
-- FOR UPDATE verrouille la ligne pour √©viter overselling

-- 2. Cr√©er la commande
INSERT INTO commandes (user_id, total) VALUES (123, 99.99);
SET @order_id = LAST_INSERT_ID();

-- 3. D√©cr√©menter le stock
UPDATE produits SET stock = stock - 1 WHERE id = 1001;

-- 4. Ajouter les lignes de commande
INSERT INTO commandes_lignes (commande_id, produit_id, quantite)
VALUES (@order_id, 1001, 1);

COMMIT;
```

‚úÖ **Avantages** :
- Pas de dirty reads sur le stock
- Concurrence √©lev√©e (peu de verrous)
- Performance excellente

### 2. Syst√®mes de paiement

```sql
-- Transaction de paiement s√©curis√©e
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;

-- V√©rifier le solde avec verrou
SELECT solde FROM portefeuilles WHERE user_id = 123 FOR UPDATE;
-- FOR UPDATE assure qu'aucune autre transaction ne modifie le solde

-- V√©rifier suffisance
IF solde >= 50.00 THEN
    -- D√©biter
    UPDATE portefeuilles SET solde = solde - 50.00 WHERE user_id = 123;

    -- Enregistrer la transaction
    INSERT INTO transactions (user_id, montant, type)
    VALUES (123, 50.00, 'debit');

    COMMIT;
ELSE
    ROLLBACK;
END IF;
```

- ‚úÖ **Coh√©rence** : Le solde lu est toujours valid√© (pas de dirty read)
- ‚úÖ **S√©curit√©** : FOR UPDATE garantit l'atomicit√©

### 3. Syst√®mes de r√©servation (h√¥tels, vols, √©v√©nements)

```sql
-- R√©servation de places avec READ COMMITTED
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;

-- V√©rifier et r√©server atomiquement
SELECT places_disponibles FROM evenements
WHERE id = 500 AND places_disponibles >= 2
FOR UPDATE;

-- Si suffisant, r√©server
UPDATE evenements
SET places_disponibles = places_disponibles - 2
WHERE id = 500;

-- Cr√©er la r√©servation
INSERT INTO reservations (user_id, evenement_id, nb_places)
VALUES (123, 500, 2);

COMMIT;
```

### 4. API REST avec requ√™tes ind√©pendantes

```sql
-- Configuration id√©ale pour microservices
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- Chaque requ√™te API est une transaction courte
-- GET /users/123
START TRANSACTION;
SELECT * FROM users WHERE id = 123;
COMMIT;

-- POST /orders
START TRANSACTION;
INSERT INTO orders (user_id, total) VALUES (123, 199.99);
COMMIT;

-- Pas besoin de REPEATABLE READ car chaque requ√™te est ind√©pendante
```

üí° **Architecture moderne** : READ COMMITTED est parfait pour les architectures REST/microservices o√π chaque requ√™te est une transaction isol√©e.

---

## Configuration et bonnes pratiques

### Configuration au niveau session

```sql
-- Pour toute la session
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- V√©rifier le niveau actuel
SELECT @@SESSION.transaction_isolation;
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë @@SESSION.transaction_isolation ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë READ-COMMITTED                  ‚ïë
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

-- Pour une transaction sp√©cifique
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
-- ... requ√™tes ...
COMMIT;
```

### Configuration globale (recommand√© pour applications web)

```ini
# my.cnf - Configuration recommand√©e
[mysqld]
transaction-isolation = READ-COMMITTED
```

Ou via variable dynamique :

```sql
-- Configuration globale (requiert SUPER privilege)
SET GLOBAL transaction_isolation = 'READ-COMMITTED';

-- Les nouvelles connexions utiliseront READ COMMITTED
-- Les connexions existantes gardent leur niveau actuel
```

### Pattern d'utilisation avec FOR UPDATE

```sql
-- Pattern "Select For Update" pour op√©rations critiques
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;

-- Lire et verrouiller en une seule op√©ration
SELECT solde FROM comptes WHERE id = 1 FOR UPDATE;
-- ‚úÖ Lit la valeur COMMIT
-- ‚úÖ Verrouille la ligne pour modifications exclusives

-- Modifier en toute s√©curit√©
UPDATE comptes SET solde = solde - 100 WHERE id = 1;

COMMIT;
```

üí° **Astuce** : FOR UPDATE transforme READ COMMITTED en "READ COMMITTED + verrou", id√©al pour les read-modify-write.

### Pattern avec conditions m√©tier

```sql
-- Pattern pour validations m√©tier complexes
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;

-- 1. Lire les donn√©es n√©cessaires
SELECT @stock := stock FROM produits WHERE id = 1001;
SELECT @limite_credit := limite_credit FROM clients WHERE id = 123;
SELECT @encours := SUM(total) FROM commandes
WHERE client_id = 123 AND statut = 'en_cours';

-- 2. V√©rifications m√©tier
IF @stock > 0 AND (@encours + 100) <= @limite_credit THEN
    -- 3. Modifications
    UPDATE produits SET stock = stock - 1 WHERE id = 1001;
    INSERT INTO commandes (client_id, total) VALUES (123, 100);
    COMMIT;
ELSE
    ROLLBACK;
END IF;
```

### Code application (Python avec SQLAlchemy)

```python
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker

# Configuration avec READ COMMITTED
engine = create_engine(
    'mysql+pymysql://user:pass@localhost/mydb',
    isolation_level='READ COMMITTED'  # D√©faut pour toutes les sessions
)

Session = sessionmaker(bind=engine)

def transfer_money(from_account_id, to_account_id, amount):
    """
    Transfert d'argent avec READ COMMITTED
    """
    session = Session()

    try:
        # Transaction d√©marre automatiquement

        # SELECT FOR UPDATE pour verrouiller les comptes
        from_account = session.execute(
            text("SELECT solde FROM comptes WHERE id = :id FOR UPDATE"),
            {"id": from_account_id}
        ).fetchone()

        to_account = session.execute(
            text("SELECT solde FROM comptes WHERE id = :id FOR UPDATE"),
            {"id": to_account_id}
        ).fetchone()

        # V√©rification
        if from_account.solde < amount:
            session.rollback()
            return False, "Solde insuffisant"

        # Modifications
        session.execute(
            text("UPDATE comptes SET solde = solde - :amount WHERE id = :id"),
            {"amount": amount, "id": from_account_id}
        )
        session.execute(
            text("UPDATE comptes SET solde = solde + :amount WHERE id = :id"),
            {"amount": amount, "id": to_account_id}
        )

        session.commit()
        return True, "Transfert r√©ussi"

    except Exception as e:
        session.rollback()
        return False, str(e)

    finally:
        session.close()
```

### Configuration Node.js (avec mysql2)

```javascript
const mysql = require('mysql2/promise');

// Pool de connexions avec READ COMMITTED
const pool = mysql.createPool({
  host: 'localhost',
  user: 'root',
  password: 'password',
  database: 'mydb',
  waitForConnections: true,
  connectionLimit: 10
});

async function processOrder(userId, items) {
  const connection = await pool.getConnection();

  try {
    // D√©finir READ COMMITTED pour cette transaction
    await connection.query('SET TRANSACTION ISOLATION LEVEL READ COMMITTED');
    await connection.beginTransaction();

    // V√©rifier le stock et verrouiller
    for (const item of items) {
      const [rows] = await connection.query(
        'SELECT stock FROM produits WHERE id = ? FOR UPDATE',
        [item.productId]
      );

      if (rows[0].stock < item.quantity) {
        throw new Error(`Stock insuffisant pour produit ${item.productId}`);
      }

      // D√©cr√©menter le stock
      await connection.query(
        'UPDATE produits SET stock = stock - ? WHERE id = ?',
        [item.quantity, item.productId]
      );
    }

    // Cr√©er la commande
    const [result] = await connection.query(
      'INSERT INTO commandes (user_id, total) VALUES (?, ?)',
      [userId, calculateTotal(items)]
    );

    await connection.commit();
    return { success: true, orderId: result.insertId };

  } catch (error) {
    await connection.rollback();
    return { success: false, error: error.message };

  } finally {
    connection.release();
  }
}
```

---

## Gestion des non-repeatable reads

### Strat√©gie 1 : Accepter les non-repeatable reads

```sql
-- Pour les dashboards, rapports temps r√©el
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;

-- Les donn√©es peuvent changer, c'est acceptable
SELECT
    COUNT(*) as total_commandes,
    SUM(montant) as ca_total,
    AVG(montant) as panier_moyen
FROM commandes
WHERE DATE(created_at) = CURDATE();

-- Afficher avec disclaimer : "Donn√©es en temps r√©el"
COMMIT;
```

### Strat√©gie 2 : Utiliser FOR UPDATE quand n√©cessaire

```sql
-- Pour les op√©rations critiques n√©cessitant coh√©rence
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;

-- Lire et verrouiller pour garantir coh√©rence
SELECT * FROM comptes WHERE id = 1 FOR UPDATE;

-- Les modifications ult√©rieures sont coh√©rentes avec cette lecture
UPDATE comptes SET solde = solde - 100 WHERE id = 1;

COMMIT;
```

### Strat√©gie 3 : Passer √† REPEATABLE READ ponctuellement

```sql
-- Pour un rapport fig√© n√©cessitant coh√©rence absolue
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;

-- Snapshot coh√©rent au d√©but de la transaction
SELECT COUNT(*) FROM ventes WHERE date = CURDATE();
-- ... autres requ√™tes ...
-- Toutes verront le m√™me √©tat des donn√©es

COMMIT;

-- Revenir √† READ COMMITTED pour les op√©rations normales
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

### Strat√©gie 4 : Architecture √©v√©nementielle

```sql
-- Utiliser des tables de snapshot pour rapports
CREATE TABLE snapshots_ventes_jour (
    date DATE PRIMARY KEY,
    nb_ventes INT,
    ca_total DECIMAL(15,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;

-- Event qui cr√©e un snapshot quotidien
CREATE EVENT snapshot_ventes_quotidien
ON SCHEDULE EVERY 1 DAY
STARTS '2025-01-01 23:59:00'
DO
    INSERT INTO snapshots_ventes_jour (date, nb_ventes, ca_total)
    SELECT
        CURDATE() as date,
        COUNT(*) as nb_ventes,
        SUM(montant) as ca_total
    FROM ventes
    WHERE DATE(created_at) = CURDATE();

-- Lecture du snapshot (pas de non-repeatable reads possibles)
SELECT * FROM snapshots_ventes_jour WHERE date = CURDATE();
```

---

## Performance et optimisations

### Benchmark : READ COMMITTED vs REPEATABLE READ

```sql
-- Configuration de test
CREATE TABLE test_perf (
    id INT PRIMARY KEY AUTO_INCREMENT,
    valeur VARCHAR(100),
    INDEX(valeur)
) ENGINE=InnoDB;

-- Ins√©rer 100 000 lignes
-- ...

-- Test 1 : READ COMMITTED
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
SELECT COUNT(*) FROM test_perf WHERE valeur LIKE 'ABC%';
-- Temps : ~50ms
COMMIT;

-- Test 2 : REPEATABLE READ (avec gap locks)
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT COUNT(*) FROM test_perf WHERE valeur LIKE 'ABC%';
-- Temps : ~50ms (lecture similaire)

-- Diff√©rence : Dans les UPDATE concurrents
-- READ COMMITTED : Moins de blocages, meilleure concurrence
-- REPEATABLE READ : Plus de gap locks, concurrence r√©duite
```

### M√©triques de performance

| M√©trique | READ COMMITTED | REPEATABLE READ |
|----------|----------------|-----------------|
| **Temps de lecture** | ‚âà √©quivalent | ‚âà √©quivalent |
| **Verrous pos√©s** | Moins (pas de gap) | Plus (gap locks) |
| **Concurrence UPDATE** | Meilleure | R√©duite |
| **Deadlocks** | Moins fr√©quents | Plus fr√©quents |
| **Throughput OLTP** | üî• Sup√©rieur | Standard |

### Monitoring des verrous

```sql
-- Voir les verrous actifs
SELECT
    r.trx_id,
    r.trx_mysql_thread_id,
    r.trx_query,
    l.lock_mode,
    l.lock_type,
    l.lock_table,
    l.lock_index
FROM information_schema.innodb_trx r
LEFT JOIN information_schema.innodb_locks l
    ON r.trx_id = l.lock_trx_id
WHERE r.trx_state = 'RUNNING';
```

```sql
-- Identifier les transactions bloquantes
SELECT
    waiting_trx_id,
    waiting_pid,
    waiting_query,
    blocking_trx_id,
    blocking_pid,
    blocking_query
FROM sys.innodb_lock_waits;
```

---

## Migration de REPEATABLE READ vers READ COMMITTED

### √âtapes recommand√©es

```sql
-- Phase 1 : Tests en environnement de d√©veloppement
-- Changer le niveau d'isolation
SET GLOBAL transaction_isolation = 'READ-COMMITTED';

-- Tester l'application compl√®tement
-- Surveiller les logs d'erreur

-- Phase 2 : Identifier les transactions sensibles
-- Certaines transactions peuvent n√©cessiter REPEATABLE READ
SELECT
    SUBSTRING(query, 1, 100) as query_start,
    COUNT(*) as occurrences
FROM mysql.slow_log
WHERE query LIKE '%transaction%'
GROUP BY SUBSTRING(query, 1, 100)
ORDER BY occurrences DESC;

-- Phase 3 : Adapter le code si n√©cessaire
-- Ajouter FOR UPDATE o√π requis
-- Ou forcer REPEATABLE READ pour transactions sp√©cifiques
```

### Cas n√©cessitant attention

```sql
-- Transaction n√©cessitant REPEATABLE READ
-- (coh√©rence absolue requise)
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;

-- Rapport financier r√©glementaire
SELECT
    SUM(debit) as total_debit,
    SUM(credit) as total_credit
FROM transactions
WHERE date_comptable = '2025-12-31';

-- Tous les SELECT doivent voir le m√™me √©tat
-- REPEATABLE READ garantit cela
COMMIT;
```

### V√©rification post-migration

```sql
-- V√©rifier que le niveau est bien appliqu√©
SELECT @@GLOBAL.transaction_isolation;
-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
-- ‚ïë @@GLOBAL.transaction_isolation  ‚ïë
-- ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
-- ‚ïë READ-COMMITTED                  ‚ïë
-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

-- Surveiller les deadlocks (doivent diminuer)
SHOW ENGINE INNODB STATUS\G
-- Chercher "LATEST DETECTED DEADLOCK"

-- M√©triques de performance (doivent s'am√©liorer)
SELECT * FROM sys.statement_analysis
ORDER BY total_latency DESC
LIMIT 10;
```

---

## Comparaison avec d'autres SGBD

### Oracle Database

```sql
-- Oracle utilise READ COMMITTED par d√©faut
-- Comportement similaire √† MariaDB READ COMMITTED
-- Mais avec "read consistency" via UNDO segments

-- MariaDB √©quivalent
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

### PostgreSQL

```sql
-- PostgreSQL appelle cela "Read Committed" aussi
-- Comportement identique : pas de dirty reads

-- Configuration PostgreSQL
SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- √âquivalent MariaDB
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

### SQL Server

```sql
-- SQL Server : READ COMMITTED (avec locking par d√©faut)
-- Ou READ COMMITTED SNAPSHOT (avec MVCC)

-- MariaDB est plus proche de READ COMMITTED SNAPSHOT
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
-- MariaDB utilise toujours MVCC (pas de locking sur SELECT)
```

---

## ‚úÖ Points cl√©s √† retenir

- **READ COMMITTED** √©limine totalement les **dirty reads** : une transaction ne voit que les donn√©es valid√©es (COMMIT)

- **Compromis optimal** : Excellent √©quilibre entre performance (90%) et coh√©rence (95%) pour la majorit√© des applications OLTP

- **Non-repeatable reads accept√©s** : Une m√™me requ√™te peut retourner des r√©sultats diff√©rents si d'autres transactions COMMIT entre-temps (souvent acceptable)

- **Phantom reads possibles** : De nouvelles lignes peuvent appara√Ætre dans les r√©sultats (moins critique que les dirty reads)

- **Meilleure concurrence** : Moins de verrous (pas de gap locks) = meilleur throughput et moins de deadlocks que REPEATABLE READ

- **FOR UPDATE** : Permet de verrouiller explicitement des lignes pour garantir la coh√©rence dans les op√©rations read-modify-write

- **Cas d'usage id√©aux** :
  - Applications web transactionnelles
  - APIs REST/microservices
  - Syst√®mes de r√©servation
  - E-commerce
  - Syst√®mes de paiement (avec FOR UPDATE)

- **Configuration recommand√©e** : Pour 80% des applications modernes, READ COMMITTED devrait √™tre le niveau par d√©faut plut√¥t que REPEATABLE READ

- **Compatible avec MVCC** : READ COMMITTED b√©n√©ficie pleinement du Multi-Version Concurrency Control d'InnoDB pour des lectures sans blocage

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB

- [üìñ SET TRANSACTION Isolation Level](https://mariadb.com/kb/en/set-transaction-isolation-level/)
- [üìñ InnoDB Transaction Model](https://mariadb.com/kb/en/innodb-transaction-model/)
- [üìñ MVCC in InnoDB](https://mariadb.com/kb/en/innodb-multi-versioning/)

### Comparaisons et benchmarks

- [Percona: Transaction Isolation Levels](https://www.percona.com/blog/understanding-mysql-isolation-levels/)
- [MySQL Performance Blog: READ COMMITTED vs REPEATABLE READ](https://www.percona.com/blog/read-committed-vs-repeatable-read/)

### Standards SQL

- ISO/IEC 9075-2:2016 - SQL Foundation (d√©finition des niveaux d'isolation)
- ANSI SQL-92 Standard

---

## ‚û°Ô∏è Section suivante

**[6.3.3 REPEATABLE READ : Default InnoDB](./03.3-repeatable-read.md)** : Explorez le niveau d'isolation par d√©faut de MariaDB/InnoDB, qui garantit des lectures r√©p√©tables au sein d'une m√™me transaction gr√¢ce au MVCC et au gap locking.

---

**üí° Recommandation finale** : Pour la majorit√© des applications web modernes, **READ COMMITTED est le meilleur choix**. Il offre un excellent compromis performance/coh√©rence et correspond mieux aux patterns d'architecture REST/microservices. Consid√©rez REPEATABLE READ uniquement pour des cas sp√©cifiques n√©cessitant une coh√©rence stricte au sein d'une transaction longue.

‚è≠Ô∏è [REPEATABLE READ : Default InnoDB](/06-transactions-et-concurrence/03.3-repeatable-read.md)
