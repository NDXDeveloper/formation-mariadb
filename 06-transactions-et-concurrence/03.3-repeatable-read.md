ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 6.3.3 REPEATABLE READ : Default InnoDB

> **Niveau** : AvancÃ©
> **DurÃ©e estimÃ©e** : 2 heures

> **PrÃ©requis** :
> - ComprÃ©hension des propriÃ©tÃ©s ACID
> - Connaissance de READ UNCOMMITTED (6.3.1) et READ COMMITTED (6.3.2)
> - Notions de MVCC et verrous

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre pourquoi REPEATABLE READ est le niveau par dÃ©faut d'InnoDB
- MaÃ®triser le concept de snapshot cohÃ©rent au dÃ©but d'une transaction
- Expliquer le fonctionnement du gap locking et son impact
- Identifier et gÃ©rer les problÃ¨mes de concurrence spÃ©cifiques (deadlocks)
- Ã‰valuer quand utiliser REPEATABLE READ vs READ COMMITTED
- Optimiser les transactions pour minimiser les blocages

---

## Introduction

**REPEATABLE READ** est le niveau d'isolation par dÃ©faut dans MariaDB/MySQL avec le moteur InnoDB depuis sa crÃ©ation. Il offre des garanties de cohÃ©rence plus fortes que READ COMMITTED tout en restant performant grÃ¢ce au MVCC (Multi-Version Concurrency Control).

### Position dans la hiÃ©rarchie

```
READ UNCOMMITTED  â† Dirty reads possibles
    â†“
READ COMMITTED    â† Pas de dirty reads
    â†“
REPEATABLE READ   â† ğŸ¯ DÃ©faut InnoDB (pas de non-repeatable reads)
    â†“
SERIALIZABLE      â† Maximum isolation
```

**Garantie principale** : Dans une transaction REPEATABLE READ, une requÃªte SELECT qui lit les mÃªmes donnÃ©es plusieurs fois retournera **toujours les mÃªmes rÃ©sultats**, Ã©tablissant un **snapshot cohÃ©rent** au premier SELECT de la transaction.

ğŸ”‘ **Concept clÃ©** : REPEATABLE READ utilise MVCC pour crÃ©er un "instantanÃ© figÃ©" des donnÃ©es au dÃ©but de la transaction, permettant des lectures cohÃ©rentes sans bloquer les Ã©critures concurrentes.

---

## Principe de fonctionnement

### Snapshot cohÃ©rent avec MVCC

Au niveau REPEATABLE READ, InnoDB crÃ©e un **snapshot read view** lors de la premiÃ¨re lecture de la transaction. Toutes les lectures ultÃ©rieures utilisent ce mÃªme snapshot.

```sql
-- Configuration (dÃ©jÃ  par dÃ©faut)
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- VÃ©rifier le niveau actuel
SELECT @@SESSION.transaction_isolation;
-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
-- â•‘ @@SESSION.transaction_isolation â•‘
-- â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
-- â•‘ REPEATABLE-READ                 â•‘
-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### MÃ©canisme du snapshot

```
Transaction A (REPEATABLE READ)
    â”‚
    â”‚  START TRANSACTION
    â”‚
    â”‚  SELECT ... â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  (premier SELECT)      â”‚
    â”‚                        â”œâ”€â–º CrÃ©e SNAPSHOT au temps T0
    â”‚                        â”‚   (enregistre transaction ID)
    â”‚  SELECT ... â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  (mÃªme requÃªte)        â”‚
    â”‚                        â”œâ”€â–º Lit MÃŠME SNAPSHOT T0
    â”‚  SELECT ...            â”‚   (mÃªme si d'autres ont COMMIT)
    â”‚                        â”‚
    â”‚  COMMIT                â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Transaction B
    â”‚
    â”‚  UPDATE ...
    â”‚  COMMIT (aprÃ¨s T0)
    â”‚
    â”‚  âœ… Change les donnÃ©es rÃ©elles
    â”‚  âŒ Invisible pour Transaction A
    â”‚     (utilise toujours snapshot T0)
    â””â”€
```

### VisibilitÃ© des versions

InnoDB maintient plusieurs versions d'une mÃªme ligne grÃ¢ce au systÃ¨me de **undo logs** :

```
Ligne ID=1 dans la table :

Version actuelle (Transaction ID: 1005)
â”œâ”€ solde = 1500â‚¬
â”‚
â””â”€ Undo log (Transaction ID: 1003)
   â”œâ”€ solde = 1200â‚¬
   â”‚
   â””â”€ Undo log (Transaction ID: 1001)
      â””â”€ solde = 1000â‚¬

Transaction A (ID: 1002, snapshot Ã  T0)
â””â”€â–º Lit version 1001 (solde = 1000â‚¬)
    Car les versions 1003 et 1005 sont postÃ©rieures Ã  son snapshot
```

---

## Ã‰limination des Non-Repeatable Reads

### Exemple 1 : Compte bancaire avec lectures rÃ©pÃ©tables

```sql
-- Base de donnÃ©es : comptes bancaires
CREATE TABLE comptes (
    id INT PRIMARY KEY,
    titulaire VARCHAR(100),
    solde DECIMAL(10,2)
) ENGINE=InnoDB;

INSERT INTO comptes VALUES (1, 'Alice', 1000.00);
```

**ScÃ©nario temporel :**

| Temps | Transaction A (REPEATABLE READ) | Transaction B |
|-------|--------------------------------|---------------|
| T1 | `START TRANSACTION;` | |
| T2 | `SELECT solde FROM comptes WHERE id = 1;`<br>*-- RÃ©sultat: 1000â‚¬*<br>*-- ğŸ“¸ Snapshot crÃ©Ã©* | |
| T3 | | `START TRANSACTION;` |
| T4 | | `UPDATE comptes SET solde = 1500 WHERE id = 1;` |
| T5 | | `COMMIT;` |
| T6 | `SELECT solde FROM comptes WHERE id = 1;`<br>*-- RÃ©sultat: 1000â‚¬ (identique !)* | |
| T7 | `COMMIT;` | |

```sql
-- Transaction A (REPEATABLE READ) - Par dÃ©faut
START TRANSACTION;

-- PremiÃ¨re lecture : CrÃ©e le snapshot
SELECT solde FROM comptes WHERE id = 1;
-- â•”â•â•â•â•â•â•â•â•â•—
-- â•‘ solde  â•‘
-- â• â•â•â•â•â•â•â•â•â•£
-- â•‘ 1000.00â•‘  ğŸ“¸ Snapshot crÃ©Ã©
-- â•šâ•â•â•â•â•â•â•â•â•

-- === Transaction B modifie et COMMIT ===
-- (dans une autre session)
START TRANSACTION;
UPDATE comptes SET solde = 1500 WHERE id = 1;
COMMIT;

-- Transaction A relit (toujours dans la premiÃ¨re session)
SELECT solde FROM comptes WHERE id = 1;
-- â•”â•â•â•â•â•â•â•â•â•—
-- â•‘ solde  â•‘
-- â• â•â•â•â•â•â•â•â•â•£
-- â•‘ 1000.00â•‘  âœ… MÃªme valeur (lecture rÃ©pÃ©table !)
-- â•šâ•â•â•â•â•â•â•â•â•

-- La cohÃ©rence est maintenue dans la transaction
COMMIT;

-- AprÃ¨s COMMIT de Transaction A, nouvelle transaction voit 1500â‚¬
START TRANSACTION;
SELECT solde FROM comptes WHERE id = 1;
-- â•”â•â•â•â•â•â•â•â•â•—
-- â•‘ solde  â•‘
-- â• â•â•â•â•â•â•â•â•â•£
-- â•‘ 1500.00â•‘  âœ… Nouvelle transaction, nouveau snapshot
-- â•šâ•â•â•â•â•â•â•â•â•
COMMIT;
```

âœ… **Avantage** : La transaction A voit un Ã©tat cohÃ©rent des donnÃ©es du dÃ©but Ã  la fin, mÃªme si d'autres transactions modifient les donnÃ©es.

### Exemple 2 : Rapport financier cohÃ©rent

```sql
-- Table de transactions financiÃ¨res
CREATE TABLE transactions (
    id INT PRIMARY KEY AUTO_INCREMENT,
    compte_id INT,
    montant DECIMAL(10,2),
    type ENUM('debit', 'credit'),
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX(compte_id)
) ENGINE=InnoDB;

-- Transaction A : GÃ©nÃ©ration d'un rapport
START TRANSACTION;

-- 1. Calculer le total des dÃ©bits
SELECT @total_debit := SUM(montant)
FROM transactions
WHERE compte_id = 1 AND type = 'debit';
-- RÃ©sultat : 5000â‚¬ (snapshot crÃ©Ã©)

-- === Pendant ce temps, nouvelles transactions sont ajoutÃ©es ===
-- Transaction B (dans une autre session)
START TRANSACTION;
INSERT INTO transactions (compte_id, montant, type)
VALUES (1, 500.00, 'debit');
COMMIT;

-- Transaction A continue son rapport
-- 2. Calculer le total des crÃ©dits
SELECT @total_credit := SUM(montant)
FROM transactions
WHERE compte_id = 1 AND type = 'credit';
-- RÃ©sultat : 7000â‚¬

-- 3. Recalculer les dÃ©bits pour vÃ©rification
SELECT SUM(montant)
FROM transactions
WHERE compte_id = 1 AND type = 'debit';
-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
-- â•‘ SUM(montant)â•‘
-- â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
-- â•‘ 5000.00     â•‘  âœ… Toujours 5000â‚¬, pas 5500â‚¬
-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Le rapport est cohÃ©rent
SELECT
    @total_debit as debits,
    @total_credit as credits,
    @total_credit - @total_debit as solde;
-- â•”â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•—
-- â•‘ debits  â•‘ credits â•‘ solde   â•‘
-- â• â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•£
-- â•‘ 5000.00 â•‘ 7000.00 â•‘ 2000.00 â•‘
-- â•šâ•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•

COMMIT;
```

ğŸ’¡ **Cas d'usage idÃ©al** : Rapports financiers, analyses de donnÃ©es, toute opÃ©ration nÃ©cessitant une vue cohÃ©rente des donnÃ©es sur une pÃ©riode de temps.

### Exemple 3 : Calcul de statistiques complexes

```sql
-- Analyse de panier moyen e-commerce
CREATE TABLE commandes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    montant DECIMAL(10,2),
    statut VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX(created_at, statut)
) ENGINE=InnoDB;

-- Transaction A : Calcul de statistiques pour le mois
START TRANSACTION;

-- Snapshot crÃ©Ã© Ã  ce moment
SELECT
    COUNT(*) as nb_commandes,
    AVG(montant) as panier_moyen,
    MIN(montant) as montant_min,
    MAX(montant) as montant_max
FROM commandes
WHERE MONTH(created_at) = 12
  AND YEAR(created_at) = 2025
  AND statut = 'validee';
-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
-- â•‘ nb_commandes â•‘ panier_moyen  â•‘ montant_min â•‘ montant_max â•‘
-- â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
-- â•‘ 1500         â•‘ 85.50         â•‘ 15.00       â•‘ 450.00      â•‘
-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- === 100 nouvelles commandes validÃ©es pendant l'analyse ===
-- (par d'autres sessions)

-- Analyse des segments de prix (mÃªme snapshot)
SELECT
    CASE
        WHEN montant < 50 THEN 'petit'
        WHEN montant < 100 THEN 'moyen'
        ELSE 'grand'
    END as segment,
    COUNT(*) as nb,
    SUM(montant) as ca
FROM commandes
WHERE MONTH(created_at) = 12
  AND YEAR(created_at) = 2025
  AND statut = 'validee'
GROUP BY segment;
-- â•”â•â•â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•—
-- â•‘ segment â•‘ nb   â•‘ ca        â•‘
-- â• â•â•â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•£
-- â•‘ petit   â•‘ 500  â•‘ 15000.00  â•‘
-- â•‘ moyen   â•‘ 800  â•‘ 60000.00  â•‘
-- â•‘ grand   â•‘ 200  â•‘ 53250.00  â•‘
-- â•šâ•â•â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•
-- Total : 1500 commandes (cohÃ©rent avec le premier SELECT)

COMMIT;
```

âœ… **CohÃ©rence garantie** : Tous les calculs sont basÃ©s sur le mÃªme ensemble de donnÃ©es, mÃªme si de nouvelles commandes arrivent pendant l'analyse.

---

## Gap Locking : PrÃ©vention des Phantom Reads

### Qu'est-ce que le Gap Locking ?

Le **gap locking** est un mÃ©canisme unique Ã  InnoDB en REPEATABLE READ qui verrouille non seulement les lignes existantes, mais aussi les "espaces" (gaps) entre les clÃ©s d'index pour empÃªcher l'insertion de nouvelles lignes qui satisferaient les critÃ¨res de recherche.

```
Index sur colonne 'age':

    10 â”€â”€â”€â”€â”€â”€â”€â”€ 20 â”€â”€â”€â”€â”€â”€â”€â”€ 30 â”€â”€â”€â”€â”€â”€â”€â”€ 40
     â”‚    gap    â”‚    gap    â”‚    gap    â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SELECT ... WHERE age > 20 AND age < 40;

Verrous posÃ©s en REPEATABLE READ:
âœ“ Ligne age=30 (record lock)
âœ“ Gap entre 20 et 30 (gap lock)
âœ“ Gap entre 30 et 40 (gap lock)

â†’ EmpÃªche INSERT de lignes avec age=25, 35, etc.
```

### Exemple 1 : Ã‰viter les Phantom Reads

```sql
-- Table de rÃ©servations
CREATE TABLE reservations (
    id INT PRIMARY KEY AUTO_INCREMENT,
    salle_id INT,
    date_reservation DATE,
    heure_debut TIME,
    statut VARCHAR(20),
    INDEX(salle_id, date_reservation)
) ENGINE=InnoDB;

INSERT INTO reservations VALUES
(1, 100, '2025-12-15', '09:00', 'confirmee'),
(2, 100, '2025-12-15', '14:00', 'confirmee');
```

**ScÃ©nario avec REPEATABLE READ (gap locking actif) :**

```sql
-- Transaction A : VÃ©rifier disponibilitÃ©s
START TRANSACTION;

-- Compter les rÃ©servations pour la salle 100 le 15/12
SELECT COUNT(*) FROM reservations
WHERE salle_id = 100 AND date_reservation = '2025-12-15';
-- â•”â•â•â•â•â•â•â•â•â•â•—
-- â•‘ COUNT(*)â•‘
-- â• â•â•â•â•â•â•â•â•â•â•£
-- â•‘ 2       â•‘  ğŸ“¸ Snapshot + Gap locks posÃ©s
-- â•šâ•â•â•â•â•â•â•â•â•â•

-- === Transaction B tente d'insÃ©rer une nouvelle rÃ©servation ===
-- (dans une autre session)
START TRANSACTION;
INSERT INTO reservations (salle_id, date_reservation, heure_debut, statut)
VALUES (100, '2025-12-15', '11:00', 'confirmee');
-- â³ BLOQUÃ‰ ! Gap lock empÃªche l'insertion

-- Transaction A recompte (pendant que B est bloquÃ©e)
SELECT COUNT(*) FROM reservations
WHERE salle_id = 100 AND date_reservation = '2025-12-15';
-- â•”â•â•â•â•â•â•â•â•â•â•—
-- â•‘ COUNT(*)â•‘
-- â• â•â•â•â•â•â•â•â•â•â•£
-- â•‘ 2       â•‘  âœ… Toujours 2 (pas de phantom read)
-- â•šâ•â•â•â•â•â•â•â•â•â•

COMMIT; -- Transaction A

-- Maintenant Transaction B peut s'exÃ©cuter
-- (dans la session B)
-- INSERT rÃ©ussit enfin
COMMIT;
```

**Comparaison avec READ COMMITTED (pas de gap locking) :**

```sql
-- Transaction A en READ COMMITTED
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;

SELECT COUNT(*) FROM reservations
WHERE salle_id = 100 AND date_reservation = '2025-12-15';
-- RÃ©sultat : 2 (pas de gap locks posÃ©s)

-- === Transaction B peut insÃ©rer immÃ©diatement ===
START TRANSACTION;
INSERT INTO reservations (salle_id, date_reservation, heure_debut, statut)
VALUES (100, '2025-12-15', '11:00', 'confirmee');
COMMIT; -- âœ… Pas de blocage

-- Transaction A recompte
SELECT COUNT(*) FROM reservations
WHERE salle_id = 100 AND date_reservation = '2025-12-15';
-- â•”â•â•â•â•â•â•â•â•â•â•—
-- â•‘ COUNT(*)â•‘
-- â• â•â•â•â•â•â•â•â•â•â•£
-- â•‘ 3       â•‘  âš ï¸ Phantom read (ligne fantÃ´me apparue)
-- â•šâ•â•â•â•â•â•â•â•â•â•

COMMIT;
```

### Exemple 2 : Gap Lock sur range queries

```sql
-- Table de produits avec prix
CREATE TABLE produits (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nom VARCHAR(100),
    prix DECIMAL(10,2),
    INDEX(prix)
) ENGINE=InnoDB;

-- Transaction A : Mettre Ã  jour les prix dans une fourchette
START TRANSACTION;

-- UPDATE avec WHERE sur range
UPDATE produits
SET prix = prix * 1.10
WHERE prix >= 50 AND prix <= 100;

-- Gap locks posÃ©s :
-- âœ“ Toutes les lignes avec prix entre 50 et 100
-- âœ“ Gap avant 50
-- âœ“ Gaps entre chaque ligne dans la range
-- âœ“ Gap aprÃ¨s 100

-- === Transaction B tente d'insÃ©rer dans la range ===
START TRANSACTION;
INSERT INTO produits (nom, prix) VALUES ('Nouveau Produit', 75.00);
-- â³ BLOQUÃ‰ par gap lock

-- Transaction A peut faire d'autres opÃ©rations
SELECT COUNT(*) FROM produits WHERE prix >= 50 AND prix <= 100;
-- RÃ©sultat cohÃ©rent

COMMIT; -- Transaction A

-- Transaction B peut maintenant s'exÃ©cuter
COMMIT;
```

### Types de verrous en REPEATABLE READ

| Type de verrou | Description | Objectif |
|----------------|-------------|----------|
| **Record Lock** | Verrou sur une ligne existante | EmpÃªcher modifications concurrentes |
| **Gap Lock** | Verrou sur l'espace entre deux clÃ©s | EmpÃªcher insertions dans le gap |
| **Next-Key Lock** | Record Lock + Gap Lock suivant | Combinaison des deux (par dÃ©faut) |

```sql
-- Visualiser les verrous actifs
SELECT
    lock_type,
    lock_mode,
    lock_status,
    lock_data
FROM performance_schema.data_locks
WHERE object_schema = 'mydb'
  AND object_name = 'produits';
```

---

## Comparaison des anomalies

### Tableau rÃ©capitulatif complet

| Anomalie | READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE |
|----------|------------------|----------------|-----------------|--------------|
| **Dirty Reads** | âœ… Possible | âŒ Impossible | âŒ **Impossible** | âŒ Impossible |
| **Non-Repeatable Reads** | âœ… Possible | âœ… Possible | âŒ **Impossible** | âŒ Impossible |
| **Phantom Reads** | âœ… Possible | âœ… Possible | âŒ **Impossible*** | âŒ Impossible |
| **Write Skew** | âœ… Possible | âœ… Possible | âœ… **Possible** | âŒ Impossible |

*InnoDB Ã©vite les phantom reads grÃ¢ce au gap locking, contrairement Ã  certains SGBD oÃ¹ REPEATABLE READ permet encore les phantom reads

### Exemple de Write Skew en REPEATABLE READ

Le **write skew** est une anomalie subtile oÃ¹ deux transactions lisent les mÃªmes donnÃ©es, prennent des dÃ©cisions basÃ©es sur ces lectures, puis Ã©crivent des rÃ©sultats qui violent une contrainte mÃ©tier.

```sql
-- Table de gardes mÃ©dicales
CREATE TABLE gardes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    medecin_id INT,
    date DATE,
    statut VARCHAR(20),
    INDEX(date)
) ENGINE=InnoDB;

-- Contrainte mÃ©tier : Au moins 2 mÃ©decins de garde chaque jour
INSERT INTO gardes VALUES
(1, 101, '2025-12-15', 'active'),
(2, 102, '2025-12-15', 'active'),
(3, 103, '2025-12-15', 'active');

-- Transaction A : MÃ©decin 101 veut annuler sa garde
START TRANSACTION;

-- VÃ©rifier qu'il reste au moins 2 mÃ©decins
SELECT COUNT(*) FROM gardes
WHERE date = '2025-12-15' AND statut = 'active';
-- RÃ©sultat : 3 âœ… OK, on peut annuler

-- Transaction B : MÃ©decin 102 veut aussi annuler (session parallÃ¨le)
START TRANSACTION;

-- MÃªme vÃ©rification
SELECT COUNT(*) FROM gardes
WHERE date = '2025-12-15' AND statut = 'active';
-- RÃ©sultat : 3 âœ… OK pour lui aussi

-- Transaction A annule
UPDATE gardes SET statut = 'annulee'
WHERE medecin_id = 101 AND date = '2025-12-15';
COMMIT;

-- Transaction B annule aussi
UPDATE gardes SET statut = 'annulee'
WHERE medecin_id = 102 AND date = '2025-12-15';
COMMIT;

-- âŒ PROBLÃˆME : Il ne reste plus qu'1 mÃ©decin de garde !
SELECT COUNT(*) FROM gardes
WHERE date = '2025-12-15' AND statut = 'active';
-- RÃ©sultat : 1 (viole la contrainte mÃ©tier)
```

âš ï¸ **Write Skew** : REPEATABLE READ ne peut pas empÃªcher ce problÃ¨me. Solution : utiliser SERIALIZABLE ou des verrous explicites (SELECT FOR UPDATE).

```sql
-- Solution avec SELECT FOR UPDATE
START TRANSACTION;

-- Verrouiller toutes les gardes du jour
SELECT COUNT(*) FROM gardes
WHERE date = '2025-12-15' AND statut = 'active'
FOR UPDATE;

-- Maintenant les deux transactions s'exÃ©cuteront sÃ©quentiellement
-- Transaction B devra attendre que A ait COMMIT
-- Et verra le nouveau compte (2) aprÃ¨s annulation de A
```

---

## Deadlocks en REPEATABLE READ

Les deadlocks (interblocages) sont plus frÃ©quents en REPEATABLE READ Ã  cause des gap locks.

### Exemple 1 : Deadlock classique avec gap locks

```sql
-- Table de stocks
CREATE TABLE stocks (
    produit_id INT PRIMARY KEY,
    quantite INT,
    INDEX(quantite)
) ENGINE=InnoDB;

INSERT INTO stocks VALUES (1, 100), (2, 150), (3, 200);
```

**ScÃ©nario de deadlock :**

| Temps | Transaction A | Transaction B |
|-------|---------------|---------------|
| T1 | `START TRANSACTION;` | `START TRANSACTION;` |
| T2 | `UPDATE stocks SET quantite = quantite - 10 WHERE produit_id = 1;`<br>*-- Verrou sur ligne 1* | |
| T3 | | `UPDATE stocks SET quantite = quantite - 10 WHERE produit_id = 2;`<br>*-- Verrou sur ligne 2* |
| T4 | `UPDATE stocks SET quantite = quantite - 5 WHERE produit_id = 2;`<br>*-- â³ ATTEND verrou de B* | |
| T5 | | `UPDATE stocks SET quantite = quantite - 5 WHERE produit_id = 1;`<br>*-- â³ ATTEND verrou de A* |
| T6 | **ğŸ’¥ DEADLOCK DÃ‰TECTÃ‰** | |

```sql
-- Transaction A
START TRANSACTION;
UPDATE stocks SET quantite = quantite - 10 WHERE produit_id = 1;
-- Attend un peu...
UPDATE stocks SET quantite = quantite - 5 WHERE produit_id = 2;
-- â³ BloquÃ©e, attend Transaction B

-- Transaction B (session parallÃ¨le)
START TRANSACTION;
UPDATE stocks SET quantite = quantite - 10 WHERE produit_id = 2;
-- Attend un peu...
UPDATE stocks SET quantite = quantite - 5 WHERE produit_id = 1;
-- â³ BloquÃ©e, attend Transaction A

-- ğŸ’¥ DEADLOCK !
-- InnoDB dÃ©tecte le cycle et annule une transaction
```

**Message d'erreur :**

```
ERROR 1213 (40001): Deadlock found when trying to get lock;
try restarting transaction
```

### Visualiser les deadlocks

```sql
-- Voir le dernier deadlock dÃ©tectÃ©
SHOW ENGINE INNODB STATUS\G

-- Extrait du rÃ©sultat
-- ------------------------
-- LATEST DETECTED DEADLOCK
-- ------------------------
-- 2025-12-12 10:30:45 0x7f8c4c001700
-- *** (1) TRANSACTION:
-- TRANSACTION 12345, ACTIVE 5 sec starting index read
-- mysql tables in use 1, locked 1
-- LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s)
-- MySQL thread id 10, OS thread handle 140238568, query id 150 localhost root updating
-- UPDATE stocks SET quantite = quantite - 5 WHERE produit_id = 2
--
-- *** (1) WAITING FOR THIS LOCK TO BE GRANTED:
-- RECORD LOCKS space id 58 page no 3 n bits 72 index PRIMARY of table `mydb`.`stocks`
-- trx id 12345 lock_mode X locks rec but not gap waiting
--
-- *** (2) TRANSACTION:
-- TRANSACTION 12346, ACTIVE 4 sec starting index read
-- ...
```

### StratÃ©gies pour minimiser les deadlocks

#### 1. Ordonner les accÃ¨s aux ressources

```sql
-- âŒ Mauvais : Ordre alÃ©atoire
START TRANSACTION;
UPDATE stocks SET quantite = quantite - 1 WHERE produit_id = 5;
UPDATE stocks SET quantite = quantite - 1 WHERE produit_id = 2;
UPDATE stocks SET quantite = quantite - 1 WHERE produit_id = 8;
COMMIT;

-- âœ… Bon : Toujours le mÃªme ordre (par produit_id croissant)
START TRANSACTION;
UPDATE stocks SET quantite = quantite - 1 WHERE produit_id = 2;
UPDATE stocks SET quantite = quantite - 1 WHERE produit_id = 5;
UPDATE stocks SET quantite = quantite - 1 WHERE produit_id = 8;
COMMIT;
```

#### 2. Minimiser la durÃ©e des transactions

```sql
-- âŒ Mauvais : Transaction longue
START TRANSACTION;
UPDATE stocks SET quantite = quantite - 1 WHERE produit_id = 1;
-- ... logique mÃ©tier complexe (5 secondes) ...
-- ... appels API externes ...
UPDATE stocks SET quantite = quantite - 1 WHERE produit_id = 2;
COMMIT;

-- âœ… Bon : Transaction courte
-- Faire la logique AVANT la transaction
-- PrÃ©parer les donnÃ©es
-- Puis transaction rapide
START TRANSACTION;
UPDATE stocks SET quantite = quantite - 1 WHERE produit_id = 1;
UPDATE stocks SET quantite = quantite - 1 WHERE produit_id = 2;
COMMIT;
-- Logique post-transaction
```

#### 3. Utiliser des verrous optimistes si possible

```sql
-- Pattern optimiste avec version
CREATE TABLE stocks (
    produit_id INT PRIMARY KEY,
    quantite INT,
    version INT DEFAULT 0
) ENGINE=InnoDB;

-- Transaction optimiste
START TRANSACTION;

-- Lire avec la version
SELECT quantite, version FROM stocks WHERE produit_id = 1;
-- @quantite = 100, @version = 5

-- Tenter la mise Ã  jour avec vÃ©rification de version
UPDATE stocks
SET quantite = quantite - 10, version = version + 1
WHERE produit_id = 1 AND version = 5;

-- Si affected_rows = 0, quelqu'un d'autre a modifiÃ©
-- Retry nÃ©cessaire
IF ROW_COUNT() = 0 THEN
    ROLLBACK;
    -- Retry la transaction
ELSE
    COMMIT;
END IF;
```

#### 4. Retry automatique des deadlocks

```python
# Code Python avec retry automatique
import mysql.connector
from mysql.connector import Error
import time

def transfer_with_retry(conn, from_id, to_id, amount, max_retries=3):
    """
    Transfert avec retry automatique en cas de deadlock
    """
    for attempt in range(max_retries):
        try:
            cursor = conn.cursor()

            # Transaction
            cursor.execute("START TRANSACTION")

            # Toujours ordonner les IDs pour Ã©viter deadlocks
            ids = sorted([from_id, to_id])

            # Verrouiller dans l'ordre
            for account_id in ids:
                cursor.execute(
                    "SELECT solde FROM comptes WHERE id = %s FOR UPDATE",
                    (account_id,)
                )

            # Effectuer le transfert
            cursor.execute(
                "UPDATE comptes SET solde = solde - %s WHERE id = %s",
                (amount, from_id)
            )
            cursor.execute(
                "UPDATE comptes SET solde = solde + %s WHERE id = %s",
                (amount, to_id)
            )

            conn.commit()
            return True, "Transfert rÃ©ussi"

        except mysql.connector.Error as e:
            conn.rollback()

            # Erreur 1213 = Deadlock
            if e.errno == 1213 and attempt < max_retries - 1:
                # Attendre un peu avec backoff exponentiel
                time.sleep(0.1 * (2 ** attempt))
                continue
            else:
                return False, f"Erreur: {e}"

        finally:
            cursor.close()

    return False, "Max retries atteint"
```

---

## Cas d'usage appropriÃ©s

### 1. Rapports et analyses nÃ©cessitant cohÃ©rence

```sql
-- Rapport financier de fin de mois
-- REPEATABLE READ garantit la cohÃ©rence
START TRANSACTION;

-- Toutes ces requÃªtes voient le mÃªme Ã©tat des donnÃ©es
SELECT @ventes := SUM(montant) FROM ventes
WHERE MONTH(date) = 12 AND statut = 'validee';

SELECT @remboursements := SUM(montant) FROM remboursements
WHERE MONTH(date) = 12;

SELECT @commissions := SUM(montant) FROM commissions
WHERE MONTH(date) = 12;

-- Calcul final cohÃ©rent
SELECT
    @ventes as ventes,
    @remboursements as remboursements,
    @commissions as commissions,
    @ventes - @remboursements - @commissions as resultat_net;

COMMIT;
```

### 2. Batch processing avec lectures multiples

```sql
-- Traitement par lot de commandes
START TRANSACTION;

-- SÃ©lectionner les commandes Ã  traiter
CREATE TEMPORARY TABLE commandes_batch AS
SELECT id, montant FROM commandes
WHERE statut = 'en_attente'
LIMIT 1000;

-- Traiter chaque commande (plusieurs Ã©tapes)
-- Les SELECT subsÃ©quents verront les mÃªmes donnÃ©es
UPDATE commandes c
JOIN commandes_batch b ON c.id = b.id
SET c.statut = 'en_cours';

-- CrÃ©er les factures
INSERT INTO factures (commande_id, montant)
SELECT id, montant FROM commandes_batch;

-- Mise Ã  jour finale
UPDATE commandes c
JOIN commandes_batch b ON c.id = b.id
SET c.statut = 'traitee';

COMMIT;

DROP TEMPORARY TABLE commandes_batch;
```

### 3. Lecture de donnÃ©es pour prise de dÃ©cision

```sql
-- SystÃ¨me de pricing dynamique
START TRANSACTION;

-- Analyser la demande (snapshot cohÃ©rent)
SELECT
    @reservations_jour := COUNT(*)
FROM reservations
WHERE date = CURDATE();

SELECT
    @capacite_totale := SUM(capacite)
FROM salles
WHERE disponible = 1;

SELECT
    @taux_occupation := (@reservations_jour / @capacite_totale) * 100;

-- DÃ©cision de pricing basÃ©e sur analyse cohÃ©rente
IF @taux_occupation > 80 THEN
    UPDATE prix SET multiplicateur = 1.5 WHERE date >= CURDATE();
ELSEIF @taux_occupation > 50 THEN
    UPDATE prix SET multiplicateur = 1.2 WHERE date >= CURDATE();
END IF;

COMMIT;
```

### 4. Applications avec transactions longues

```sql
-- Workflow d'approbation multi-Ã©tapes
START TRANSACTION;

-- Ã‰tape 1 : VÃ©rifier les prÃ©requis
SELECT * FROM demandes WHERE id = 1001;
-- Snapshot crÃ©Ã©

-- Ã‰tape 2 : Validation mÃ©tier (peut prendre du temps)
SELECT COUNT(*) FROM validations WHERE demande_id = 1001;

-- Ã‰tape 3 : Approbation finale
-- Les donnÃ©es restent cohÃ©rentes mÃªme si la transaction est longue
UPDATE demandes SET statut = 'approuvee' WHERE id = 1001;
INSERT INTO historique (demande_id, action) VALUES (1001, 'approuvee');

COMMIT;
```

---

## Quand choisir REPEATABLE READ vs READ COMMITTED

### Matrice de dÃ©cision

| CritÃ¨re | REPEATABLE READ | READ COMMITTED |
|---------|----------------|----------------|
| **CohÃ©rence intra-transaction** | ğŸŸ¢ Forte (snapshot fixe) | ğŸŸ¡ Moyenne (snapshot par SELECT) |
| **Performance Ã©criture** | ğŸŸ¡ Moyenne (gap locks) | ğŸŸ¢ Excellente (moins de locks) |
| **Risque deadlock** | ğŸ”´ Ã‰levÃ© | ğŸŸ¢ Faible |
| **ComplexitÃ©** | ğŸŸ¡ Moyenne | ğŸŸ¢ Simple |
| **Rapports cohÃ©rents** | ğŸŸ¢ IdÃ©al | ğŸ”´ Non recommandÃ© |
| **OLTP haute concurrence** | ğŸŸ¡ Acceptable | ğŸŸ¢ IdÃ©al |
| **Phantom reads** | ğŸŸ¢ Ã‰vitÃ©s | ğŸ”´ Possibles |

### Choisir REPEATABLE READ quand :

- âœ… **Rapports multi-requÃªtes** nÃ©cessitant cohÃ©rence totale
- âœ… **Analyses de donnÃ©es** sur un snapshot figÃ©
- âœ… **Transactions longues** avec lectures rÃ©pÃ©tÃ©es
- âœ… **Batch processing** avec validations multiples
- âœ… **Ã‰viter phantom reads** est critique
- âœ… **DÃ©faut acceptable** (dÃ©jÃ  configurÃ©, pas de problÃ¨me de performance)

### Choisir READ COMMITTED quand :

- âœ… **OLTP haute concurrence** (e-commerce, rÃ©servations)
- âœ… **Transactions courtes** indÃ©pendantes
- âœ… **APIs REST/microservices** (une requÃªte = une transaction)
- âœ… **Deadlocks frÃ©quents** avec REPEATABLE READ
- âœ… **Performance critique** et gap locks problÃ©matiques
- âœ… **Non-repeatable reads acceptables** pour votre cas d'usage

### Exemple de dÃ©cision

```sql
-- Application e-commerce

-- âŒ REPEATABLE READ pour checkout (overkill)
-- Deadlocks frÃ©quents, performance rÃ©duite
START TRANSACTION;
-- Verrouiller produit
SELECT stock FROM produits WHERE id = 1001 FOR UPDATE;
-- CrÃ©er commande
INSERT INTO commandes (user_id, total) VALUES (123, 99.99);
-- DÃ©crÃ©menter stock
UPDATE produits SET stock = stock - 1 WHERE id = 1001;
COMMIT;

-- âœ… READ COMMITTED pour checkout (optimal)
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
-- MÃªme logique, moins de verrous, meilleure concurrence
-- ...
COMMIT;

-- âœ… REPEATABLE READ pour rapports (appropriÃ©)
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
-- Analyser les ventes du mois (plusieurs requÃªtes)
SELECT COUNT(*), SUM(total) FROM commandes WHERE MONTH(date) = 12;
SELECT AVG(total) FROM commandes WHERE MONTH(date) = 12;
-- CohÃ©rence garantie entre les requÃªtes
COMMIT;
```

---

## Configuration et bonnes pratiques

### VÃ©rifier le niveau actuel

```sql
-- Niveau de la session
SELECT @@SESSION.transaction_isolation;

-- Niveau global
SELECT @@GLOBAL.transaction_isolation;

-- Niveau pour la prochaine transaction uniquement
SELECT @@transaction_isolation;
```

### Configurer pour une session

```sql
-- Changer pour la session entiÃ¨re
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- Changer pour une seule transaction
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
-- ...
COMMIT;
```

### Configuration globale

```ini
# my.cnf
[mysqld]
# REPEATABLE READ est dÃ©jÃ  le dÃ©faut
transaction-isolation = REPEATABLE-READ

# Ou pour passer Ã  READ COMMITTED globalement
# transaction-isolation = READ-COMMITTED
```

### Bonnes pratiques

#### 1. Garder les transactions courtes

```sql
-- âŒ Mauvais : Transaction longue avec I/O
START TRANSACTION;
SELECT * FROM commandes WHERE id = 1001;
-- Appel API externe (5 secondes)
-- Traitement mÃ©tier complexe
UPDATE commandes SET statut = 'traitee' WHERE id = 1001;
COMMIT;

-- âœ… Bon : Transaction courte, I/O avant/aprÃ¨s
-- PrÃ©parer les donnÃ©es
SELECT * FROM commandes WHERE id = 1001;
-- Appel API externe
-- Traitement mÃ©tier
-- Transaction rapide
START TRANSACTION;
UPDATE commandes SET statut = 'traitee' WHERE id = 1001;
COMMIT;
```

#### 2. Utiliser SELECT FOR UPDATE judicieusement

```sql
-- Pour read-modify-write atomique
START TRANSACTION;

-- Verrouiller explicitement
SELECT solde FROM comptes WHERE id = 1 FOR UPDATE;

-- Modification garantie cohÃ©rente
UPDATE comptes SET solde = solde - 100 WHERE id = 1;

COMMIT;
```

#### 3. Ordonner les accÃ¨s pour Ã©viter deadlocks

```sql
-- âœ… Toujours accÃ©der aux ressources dans le mÃªme ordre
START TRANSACTION;

-- Ordonner les IDs
SET @id1 = LEAST(from_account, to_account);
SET @id2 = GREATEST(from_account, to_account);

-- Verrouiller dans l'ordre
SELECT solde FROM comptes WHERE id = @id1 FOR UPDATE;
SELECT solde FROM comptes WHERE id = @id2 FOR UPDATE;

-- Modifications
-- ...

COMMIT;
```

#### 4. Monitoring des deadlocks

```sql
-- Activer le logging des deadlocks
SET GLOBAL innodb_print_all_deadlocks = ON;

-- Les deadlocks seront loggÃ©s dans le error log
-- /var/log/mysql/error.log

-- Analyser les patterns de deadlocks
SELECT
    SUBSTRING_INDEX(SUBSTRING_INDEX(
        SUBSTRING(argument, LOCATE('TRANSACTION', argument)),
        '***', 1
    ), 'TRANSACTION', -1) as transaction_info
FROM mysql.general_log
WHERE argument LIKE '%DEADLOCK%';
```

### Code application (Node.js)

```javascript
const mysql = require('mysql2/promise');

class TransactionManager {
  constructor(pool) {
    this.pool = pool;
  }

  /**
   * ExÃ©cuter une transaction en REPEATABLE READ avec retry sur deadlock
   */
  async executeWithRetry(callback, maxRetries = 3) {
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const connection = await this.pool.getConnection();

      try {
        // REPEATABLE READ est dÃ©jÃ  le dÃ©faut
        await connection.beginTransaction();

        // ExÃ©cuter la logique mÃ©tier
        const result = await callback(connection);

        await connection.commit();
        return { success: true, result };

      } catch (error) {
        await connection.rollback();

        // Retry sur deadlock (code 1213)
        if (error.errno === 1213 && attempt < maxRetries - 1) {
          // Backoff exponentiel
          const delay = Math.pow(2, attempt) * 100;
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }

        return { success: false, error: error.message };

      } finally {
        connection.release();
      }
    }
  }

  /**
   * Exemple : GÃ©nÃ©rer un rapport cohÃ©rent
   */
  async generateMonthlyReport(month, year) {
    return this.executeWithRetry(async (conn) => {
      // Toutes les requÃªtes verront le mÃªme snapshot

      const [sales] = await conn.query(`
        SELECT COUNT(*) as count, SUM(amount) as total
        FROM orders
        WHERE MONTH(created_at) = ? AND YEAR(created_at) = ?
        AND status = 'completed'
      `, [month, year]);

      const [refunds] = await conn.query(`
        SELECT SUM(amount) as total
        FROM refunds
        WHERE MONTH(created_at) = ? AND YEAR(created_at) = ?
      `, [month, year]);

      const [expenses] = await conn.query(`
        SELECT SUM(amount) as total
        FROM expenses
        WHERE MONTH(date) = ? AND YEAR(date) = ?
      `, [month, year]);

      // Calcul cohÃ©rent
      return {
        sales: sales[0],
        refunds: refunds[0].total || 0,
        expenses: expenses[0].total || 0,
        profit: sales[0].total - (refunds[0].total || 0) - (expenses[0].total || 0)
      };
    });
  }
}

// Utilisation
const pool = mysql.createPool({ /* config */ });
const txManager = new TransactionManager(pool);

const report = await txManager.generateMonthlyReport(12, 2025);
console.log(report);
```

---

## Impact sur les performances

### Overhead du MVCC

```sql
-- MVCC maintient plusieurs versions des lignes
-- Overhead mÃ©moire pour les undo logs

-- Surveiller la taille des undo logs
SELECT
    COUNT(*) as active_transactions,
    MAX(trx_rows_modified) as max_rows_modified,
    SUM(trx_rows_modified) as total_rows_modified
FROM information_schema.innodb_trx;

-- Purge des anciennes versions
-- InnoDB purge automatiquement les anciennes versions
-- Quand plus aucune transaction ne les lit

SHOW ENGINE INNODB STATUS\G
-- Chercher "History list length"
-- Une valeur Ã©levÃ©e (>10000) indique un problÃ¨me de purge
```

### Gap Locks et concurrence

```sql
-- Impact des gap locks sur la concurrence

-- Table de test
CREATE TABLE concurrent_test (
    id INT PRIMARY KEY AUTO_INCREMENT,
    category INT,
    value INT,
    INDEX(category)
) ENGINE=InnoDB;

-- Benchmark : UPDATE en REPEATABLE READ
-- Transaction A
START TRANSACTION;
UPDATE concurrent_test SET value = value + 1
WHERE category = 1;
-- Gap locks posÃ©s sur la range

-- Transaction B (bloquÃ©e par gap lock)
START TRANSACTION;
INSERT INTO concurrent_test (category, value) VALUES (1, 100);
-- â³ ATTEND que A finisse

-- Benchmark : UPDATE en READ COMMITTED
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
UPDATE concurrent_test SET value = value + 1
WHERE category = 1;
-- Pas de gap locks

-- Transaction B (pas bloquÃ©e)
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
INSERT INTO concurrent_test (category, value) VALUES (1, 100);
-- âœ… S'exÃ©cute immÃ©diatement
```

### MÃ©triques de monitoring

```sql
-- Transactions actives et durÃ©e
SELECT
    trx_id,
    trx_state,
    trx_started,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) as duration_sec,
    trx_rows_locked,
    trx_isolation_level
FROM information_schema.innodb_trx
ORDER BY trx_started;

-- Verrous en attente
SELECT
    waiting_trx_id,
    waiting_pid,
    waiting_query,
    blocking_trx_id,
    blocking_pid,
    blocking_query,
    wait_started,
    TIMESTAMPDIFF(SECOND, wait_started, NOW()) as wait_duration_sec
FROM sys.innodb_lock_waits;

-- Deadlocks (compteur global)
SHOW GLOBAL STATUS LIKE 'Innodb_deadlocks';
```

---

## Migration vers READ COMMITTED

Si REPEATABLE READ cause des problÃ¨mes (deadlocks, performance), migrer vers READ COMMITTED :

### Ã‰tape 1 : Analyse d'impact

```sql
-- Identifier les transactions sensibles
-- RequÃªtes avec plusieurs SELECT sur les mÃªmes donnÃ©es
SELECT
    DIGEST_TEXT,
    COUNT_STAR,
    SUM_TIMER_WAIT / 1000000000000 as total_time_sec,
    AVG_TIMER_WAIT / 1000000000000 as avg_time_sec
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE '%SELECT%'
  AND DIGEST_TEXT LIKE '%START TRANSACTION%'
ORDER BY total_time_sec DESC
LIMIT 20;
```

### Ã‰tape 2 : Tests en dÃ©veloppement

```sql
-- Test avec READ COMMITTED
SET GLOBAL transaction_isolation = 'READ-COMMITTED';

-- ExÃ©cuter les tests de rÃ©gression
-- VÃ©rifier particuliÃ¨rement :
-- - Rapports multi-requÃªtes
-- - Batch processing
-- - Workflows multi-Ã©tapes
```

### Ã‰tape 3 : Adapter le code si nÃ©cessaire

```sql
-- Transactions nÃ©cessitant cohÃ©rence â†’ forcer REPEATABLE READ
DELIMITER //
CREATE PROCEDURE generate_monthly_report(IN p_month INT, IN p_year INT)
BEGIN
    -- Forcer REPEATABLE READ pour ce rapport
    SET @prev_isolation = @@SESSION.transaction_isolation;
    SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

    START TRANSACTION;

    -- RequÃªtes du rapport
    -- ...

    COMMIT;

    -- Restaurer l'isolation prÃ©cÃ©dente
    SET SESSION TRANSACTION ISOLATION LEVEL @prev_isolation;
END//
DELIMITER ;
```

### Ã‰tape 4 : DÃ©ploiement progressif

```sql
-- Ã‰tape 4a : Applications non critiques d'abord
-- my.cnf pour serveur de dev/staging
[mysqld]
transaction-isolation = READ-COMMITTED

-- Ã‰tape 4b : Monitoring pendant 1-2 semaines
-- Surveiller les mÃ©triques :
-- - Temps de rÃ©ponse
-- - Taux d'erreur
-- - Deadlocks (doivent diminuer)

-- Ã‰tape 4c : Production
-- DÃ©ployer en production aprÃ¨s validation
```

---

## âœ… Points clÃ©s Ã  retenir

- **REPEATABLE READ** est le niveau d'isolation par dÃ©faut d'InnoDB, offrant un excellent compromis entre cohÃ©rence et performance

- **Snapshot cohÃ©rent** : Une transaction voit un Ã©tat figÃ© des donnÃ©es depuis son premier SELECT, Ã©liminant les non-repeatable reads

- **MVCC** (Multi-Version Concurrency Control) permet des lectures sans blocage en maintenant plusieurs versions des lignes

- **Gap locking** : InnoDB verrouille les "espaces" entre les clÃ©s pour empÃªcher les phantom reads, unique parmi les SGBD en REPEATABLE READ

- **Deadlocks plus frÃ©quents** : Les gap locks augmentent le risque d'interblocage, nÃ©cessitant des stratÃ©gies de retry

- **Cas d'usage idÃ©aux** :
  - Rapports nÃ©cessitant cohÃ©rence absolue
  - Analyses de donnÃ©es sur snapshot figÃ©
  - Batch processing avec validations multiples
  - Transactions longues avec lectures rÃ©pÃ©tÃ©es

- **ConsidÃ©rer READ COMMITTED** pour :
  - Applications OLTP haute concurrence
  - APIs REST/microservices
  - Quand deadlocks sont frÃ©quents
  - Quand non-repeatable reads sont acceptables

- **Bonnes pratiques** :
  - Garder les transactions courtes
  - Ordonner les accÃ¨s aux ressources
  - Utiliser SELECT FOR UPDATE pour read-modify-write
  - ImplÃ©menter retry automatique sur deadlock
  - Monitoring des verrous et deadlocks

- **Write skew** : Anomalie encore possible mÃªme en REPEATABLE READ, nÃ©cessite SERIALIZABLE ou verrous explicites pour Ãªtre Ã©vitÃ©e

---

## ğŸ”— Ressources et rÃ©fÃ©rences

### Documentation officielle MariaDB

- [ğŸ“– InnoDB Transaction Isolation Levels](https://mariadb.com/kb/en/innodb-lock-modes/)
- [ğŸ“– Multi-Version Concurrency Control](https://mariadb.com/kb/en/innodb-multi-versioning/)
- [ğŸ“– InnoDB Locking](https://mariadb.com/kb/en/innodb-lock-modes/)
- [ğŸ“– Deadlock Detection](https://mariadb.com/kb/en/deadlock-detection/)

### Articles techniques

- [Understanding InnoDB MVCC](https://www.percona.com/blog/understanding-innodb-mvcc/)
- [Gap Locks Explained](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-gap-locks)
- [Dealing with MySQL Deadlocks](https://www.percona.com/blog/dealing-with-mysql-deadlocks/)

### Standards SQL

- ISO/IEC 9075-2:2016 - SQL Foundation
- ANSI SQL-92 - Transaction isolation levels

---

## â¡ï¸ Section suivante

**[6.3.4 SERIALIZABLE : Isolation maximale](./03.4-serializable.md)** : DÃ©couvrez le niveau d'isolation le plus strict, qui garantit une sÃ©rialisation complÃ¨te des transactions au prix d'une performance rÃ©duite et d'un risque de blocage Ã©levÃ©.

---

**ğŸ’¡ Conseil final** : **REPEATABLE READ est un excellent dÃ©faut** pour la plupart des bases de donnÃ©es. Ne le changez que si vous rencontrez des problÃ¨mes spÃ©cifiques (deadlocks frÃ©quents, concurrence limitÃ©e) ou si votre architecture (microservices REST) bÃ©nÃ©ficie clairement de READ COMMITTED. Pour les rapports et analyses, REPEATABLE READ est souvent le meilleur choix.

â­ï¸ [SERIALIZABLE : Isolation maximale](/06-transactions-et-concurrence/03.4-serializable.md)
