üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.9.2 Recommendation Engines

> **Niveau** : Interm√©diaire √† Avanc√©  
> **Dur√©e estim√©e** : 4-5 heures  
> **Pr√©requis** : Section 20.9.1 (Semantic Search), Chapitre 18.10 (MariaDB Vector), notions de filtrage collaboratif et content-based filtering

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre les diff√©rentes approches de recommandation (collaborative, content-based, hybride)
- Concevoir un syst√®me de recommandation vectoriel avec MariaDB 11.8
- Impl√©menter des recommandations produits, contenus et utilisateurs similaires
- Combiner donn√©es relationnelles et embeddings pour des recommandations contextuelles
- Optimiser les performances pour des syst√®mes de recommandation √† grande √©chelle

---

## Introduction

Les **moteurs de recommandation** sont omnipr√©sents dans les applications modernes : suggestions de produits e-commerce, recommandations de contenus (vid√©os, articles, musique), "personnes que vous pourriez conna√Ætre" sur les r√©seaux sociaux, ou encore suggestions de candidats dans les applications de recrutement.

Traditionnellement, ces syst√®mes reposaient sur des bases de donn√©es sp√©cialis√©es (Redis, Elasticsearch) ou des services externes (AWS Personalize, Google Recommendations AI). Avec MariaDB 11.8 LTS et son support natif des vecteurs, il devient possible de construire des syst√®mes de recommandation performants directement dans votre base de donn√©es relationnelle.

üÜï **Nouveaut√© MariaDB 11.8** : Le type `VECTOR` et les index `HNSW` permettent de calculer efficacement la similarit√© entre utilisateurs, produits ou contenus, tout en conservant l'int√©grit√© relationnelle et les capacit√©s transactionnelles de MariaDB.

---

## Approches de recommandation

### Vue d'ensemble des strat√©gies

| Approche | Principe | Donn√©es requises | Forces | Faiblesses |
|----------|----------|------------------|--------|------------|
| **Collaborative Filtering** | Utilisateurs similaires aiment des choses similaires | Interactions (clics, achats, notes) | D√©couvre des items inattendus | Cold start, sparsit√© |
| **Content-Based** | Recommander des items similaires √† ceux appr√©ci√©s | Attributs des items (embeddings) | Fonctionne avec peu d'utilisateurs | Manque de s√©rendipit√© |
| **Hybride** | Combine les deux approches | Interactions + Attributs | Meilleur des deux mondes | Plus complexe |
| **Knowledge-Based** | R√®gles m√©tier explicites | Contraintes, pr√©f√©rences | Explicable, contr√¥lable | N√©cessite expertise domaine |

### Repr√©sentation vectorielle pour les recommandations

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  RECOMMANDATION VECTORIELLE                             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                         ‚îÇ
‚îÇ   CONTENT-BASED                        COLLABORATIVE                    ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îÇ
‚îÇ   ‚îÇ   Produit   ‚îÇ                      ‚îÇ Utilisateur ‚îÇ                  ‚îÇ
‚îÇ   ‚îÇ  Attributs  ‚îÇ                      ‚îÇ   Profil    ‚îÇ                  ‚îÇ
‚îÇ   ‚îÇ  (texte,    ‚îÇ                      ‚îÇ (historique ‚îÇ                  ‚îÇ
‚îÇ   ‚îÇ   images)   ‚îÇ                      ‚îÇ   actions)  ‚îÇ                  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îÇ
‚îÇ          ‚îÇ                                    ‚îÇ                         ‚îÇ
‚îÇ          ‚ñº                                    ‚ñº                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îÇ
‚îÇ   ‚îÇ  Embedding  ‚îÇ                      ‚îÇ  Embedding  ‚îÇ                  ‚îÇ
‚îÇ   ‚îÇ   Mod√®le    ‚îÇ                      ‚îÇ   Mod√®le    ‚îÇ                  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îÇ
‚îÇ          ‚îÇ                                    ‚îÇ                         ‚îÇ
‚îÇ          ‚ñº                                    ‚ñº                         ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îÇ
‚îÇ   ‚îÇ  VECTOR(N)  ‚îÇ                      ‚îÇ  VECTOR(M)  ‚îÇ                  ‚îÇ
‚îÇ   ‚îÇ  MariaDB    ‚îÇ                      ‚îÇ  MariaDB    ‚îÇ                  ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îÇ
‚îÇ          ‚îÇ                                    ‚îÇ                         ‚îÇ
‚îÇ          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                         ‚îÇ
‚îÇ                           ‚îÇ                                             ‚îÇ
‚îÇ                           ‚ñº                                             ‚îÇ
‚îÇ                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                   ‚îÇ
‚îÇ                 ‚îÇ  VEC_DISTANCE_*   ‚îÇ                                   ‚îÇ
‚îÇ                 ‚îÇ  Similarit√© KNN   ‚îÇ                                   ‚îÇ
‚îÇ                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                   ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Architecture de base : Sch√©ma relationnel + vectoriel

### Mod√®le de donn√©es pour e-commerce

```sql
-- Base de donn√©es pour syst√®me de recommandation e-commerce
CREATE DATABASE IF NOT EXISTS recommendation_engine
    CHARACTER SET utf8mb4
    COLLATE utf8mb4_uca1400_ai_ci;

USE recommendation_engine;

-- ============================================
-- TABLES RELATIONNELLES CLASSIQUES
-- ============================================

-- Utilisateurs
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    nom VARCHAR(100),
    date_inscription DATETIME DEFAULT CURRENT_TIMESTAMP,
    segment ENUM('nouveau', 'occasionnel', 'regulier', 'premium') DEFAULT 'nouveau',
    preferences JSON,  -- {"categories_favorites": [...], "marques_exclues": [...]}
    
    INDEX idx_segment (segment)
) ENGINE=InnoDB;

-- Produits
CREATE TABLE products (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    sku VARCHAR(50) UNIQUE NOT NULL,
    nom VARCHAR(300) NOT NULL,
    description TEXT,
    categorie_id INT UNSIGNED,
    sous_categorie_id INT UNSIGNED,
    marque VARCHAR(100),
    prix DECIMAL(10,2),
    prix_initial DECIMAL(10,2),
    en_stock BOOLEAN DEFAULT TRUE,
    note_moyenne DECIMAL(3,2) DEFAULT 0,
    nombre_avis INT UNSIGNED DEFAULT 0,
    date_ajout DATETIME DEFAULT CURRENT_TIMESTAMP,
    attributs JSON,  -- {"couleur": "noir", "taille": "M", "materiau": "coton"}
    
    INDEX idx_categorie (categorie_id),
    INDEX idx_marque (marque),
    INDEX idx_prix (prix),
    INDEX idx_stock_note (en_stock, note_moyenne DESC)
) ENGINE=InnoDB;

-- Interactions utilisateur-produit
CREATE TABLE user_interactions (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT UNSIGNED NOT NULL,
    product_id BIGINT UNSIGNED NOT NULL,
    interaction_type ENUM('view', 'click', 'add_cart', 'purchase', 'wishlist', 'review') NOT NULL,
    rating TINYINT UNSIGNED,  -- 1-5 pour les reviews
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    session_id VARCHAR(64),
    contexte JSON,  -- {"device": "mobile", "source": "search", "query": "..."}
    
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE,
    
    INDEX idx_user_time (user_id, timestamp DESC),
    INDEX idx_product_type (product_id, interaction_type),
    INDEX idx_timestamp (timestamp)
) ENGINE=InnoDB;

-- ============================================
-- TABLES VECTORIELLES (MariaDB 11.8)
-- ============================================

-- üÜï Embeddings des produits (content-based)
CREATE TABLE product_embeddings (
    product_id BIGINT UNSIGNED PRIMARY KEY,
    
    -- Embedding textuel (nom + description) - 1536 dim pour OpenAI
    text_embedding VECTOR(1536) NOT NULL,
    
    -- Embedding visuel (image produit) - 512 dim pour CLIP
    image_embedding VECTOR(512),
    
    -- Embedding combin√© (texte + image + attributs) - 768 dim
    combined_embedding VECTOR(768) NOT NULL,
    
    date_generation DATETIME DEFAULT CURRENT_TIMESTAMP,
    model_version VARCHAR(50),
    
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE,
    
    -- üÜï Index HNSW pour recherche de produits similaires
    VECTOR INDEX idx_text_embedding (text_embedding) 
        WITH (DISTANCE = COSINE, M = 24, EF_CONSTRUCTION = 200),
    VECTOR INDEX idx_combined_embedding (combined_embedding)
        WITH (DISTANCE = COSINE, M = 32, EF_CONSTRUCTION = 300)
) ENGINE=InnoDB;

-- üÜï Profils utilisateurs vectoriels (collaborative filtering)
CREATE TABLE user_embeddings (
    user_id BIGINT UNSIGNED PRIMARY KEY,
    
    -- Embedding du profil utilisateur bas√© sur son historique
    preference_embedding VECTOR(768) NOT NULL,
    
    -- Embedding court terme (derni√®res 24h)
    recent_embedding VECTOR(768),
    
    -- Nombre d'interactions utilis√©es pour calculer l'embedding
    interaction_count INT UNSIGNED DEFAULT 0,
    
    date_mise_a_jour DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    
    VECTOR INDEX idx_preference_embedding (preference_embedding)
        WITH (DISTANCE = COSINE, M = 16, EF_CONSTRUCTION = 150)
) ENGINE=InnoDB;
```

üí° **Conseil** : S√©parez les embeddings dans des tables d√©di√©es plut√¥t que de les ajouter aux tables principales. Cela facilite la mise √† jour ind√©pendante des vecteurs et √©vite d'alourdir les requ√™tes classiques.

---

## Recommandations Content-Based

### Principe : "Produits similaires √† celui-ci"

L'approche content-based recommande des items dont les **attributs** sont similaires √† ceux que l'utilisateur a appr√©ci√©s.

```sql
-- Trouver les 10 produits les plus similaires √† un produit donn√©
-- Bas√© sur l'embedding textuel (nom + description)

SET @product_id = 12345;

SELECT 
    p.id,
    p.nom,
    p.marque,
    p.prix,
    p.note_moyenne,
    VEC_DISTANCE_COSINE(pe.text_embedding, ref.text_embedding) AS distance,
    (1 - VEC_DISTANCE_COSINE(pe.text_embedding, ref.text_embedding)) AS similarite
FROM product_embeddings pe
JOIN products p ON pe.product_id = p.id
CROSS JOIN (
    SELECT text_embedding 
    FROM product_embeddings 
    WHERE product_id = @product_id
) ref
WHERE 
    pe.product_id != @product_id
    AND p.en_stock = TRUE
ORDER BY distance ASC
LIMIT 10;
```

### Recommandations avec filtres m√©tier

```sql
-- Produits similaires dans la m√™me gamme de prix (¬±30%)
-- et de la m√™me cat√©gorie

SET @product_id = 12345;

WITH product_ref AS (
    SELECT 
        p.id,
        p.categorie_id,
        p.prix,
        pe.combined_embedding
    FROM products p
    JOIN product_embeddings pe ON p.id = pe.product_id
    WHERE p.id = @product_id
)
SELECT 
    p.id,
    p.nom,
    p.marque,
    p.prix,
    p.note_moyenne,
    VEC_DISTANCE_COSINE(pe.combined_embedding, ref.combined_embedding) AS distance
FROM products p
JOIN product_embeddings pe ON p.id = pe.product_id
CROSS JOIN product_ref ref
WHERE 
    p.id != @product_id
    AND p.en_stock = TRUE
    AND p.categorie_id = ref.categorie_id
    AND p.prix BETWEEN ref.prix * 0.7 AND ref.prix * 1.3
ORDER BY distance ASC
LIMIT 8;
```

### Recommandations "Fr√©quemment achet√©s ensemble"

```sql
-- Produits fr√©quemment achet√©s avec un produit donn√©
-- Combinaison de co-occurrence et similarit√© vectorielle

SET @product_id = 12345;

WITH 
-- Trouver les produits achet√©s ensemble (co-occurrence)
co_purchased AS (
    SELECT 
        ui2.product_id,
        COUNT(*) AS co_purchase_count
    FROM user_interactions ui1
    JOIN user_interactions ui2 
        ON ui1.user_id = ui2.user_id 
        AND ui1.session_id = ui2.session_id
        AND ui1.interaction_type = 'purchase'
        AND ui2.interaction_type = 'purchase'
    WHERE 
        ui1.product_id = @product_id
        AND ui2.product_id != @product_id
    GROUP BY ui2.product_id
    HAVING co_purchase_count >= 3
),
-- Calculer la similarit√© vectorielle
similarity_scores AS (
    SELECT 
        p.id AS product_id,
        VEC_DISTANCE_COSINE(pe.combined_embedding, ref.combined_embedding) AS distance
    FROM products p
    JOIN product_embeddings pe ON p.id = pe.product_id
    CROSS JOIN (
        SELECT combined_embedding 
        FROM product_embeddings 
        WHERE product_id = @product_id
    ) ref
    WHERE p.id != @product_id AND p.en_stock = TRUE
)
-- Fusionner avec score hybride
SELECT 
    p.id,
    p.nom,
    p.prix,
    COALESCE(cp.co_purchase_count, 0) AS achats_ensemble,
    ss.distance AS distance_vectorielle,
    -- Score hybride : 60% co-achat + 40% similarit√©
    (COALESCE(cp.co_purchase_count, 0) * 0.6 / 10 + (1 - ss.distance) * 0.4) AS score_hybride
FROM products p
JOIN similarity_scores ss ON p.id = ss.product_id
LEFT JOIN co_purchased cp ON p.id = cp.product_id
WHERE p.en_stock = TRUE
ORDER BY score_hybride DESC
LIMIT 6;
```

---

## Recommandations Collaborative Filtering

### Principe : "Les utilisateurs comme vous ont aim√©..."

Le filtrage collaboratif identifie des utilisateurs aux comportements similaires et recommande ce qu'ils ont appr√©ci√©.

### Construction du profil utilisateur vectoriel

```sql
-- Proc√©dure pour calculer l'embedding d'un utilisateur
-- bas√© sur la moyenne pond√©r√©e des embeddings des produits qu'il a consult√©s/achet√©s

DELIMITER //

CREATE PROCEDURE update_user_embedding(IN p_user_id BIGINT UNSIGNED)
BEGIN
    DECLARE v_interaction_count INT;
    
    -- Calculer l'embedding moyen pond√©r√© par type d'interaction
    -- Poids : purchase=5, add_cart=3, wishlist=2, click=1, view=0.5
    INSERT INTO user_embeddings (user_id, preference_embedding, interaction_count, date_mise_a_jour)
    SELECT 
        p_user_id,
        -- Moyenne pond√©r√©e des embeddings produits
        VEC_FromText(
            CONCAT('[', 
                GROUP_CONCAT(
                    -- Cette partie serait faite c√¥t√© application en pratique
                    -- car MariaDB ne supporte pas nativement les op√©rations vectorielles complexes
                ),
            ']')
        ),
        COUNT(*),
        NOW()
    FROM user_interactions ui
    JOIN product_embeddings pe ON ui.product_id = pe.product_id
    WHERE ui.user_id = p_user_id
    ON DUPLICATE KEY UPDATE
        preference_embedding = VALUES(preference_embedding),
        interaction_count = VALUES(interaction_count),
        date_mise_a_jour = NOW();
    
END //

DELIMITER ;
```

‚ö†Ô∏è **Attention** : Le calcul de la moyenne vectorielle pond√©r√©e est g√©n√©ralement effectu√© c√¥t√© application (Python, Java) car SQL n'est pas optimis√© pour les op√©rations vectorielles √©l√©ment par √©l√©ment. Le r√©sultat est ensuite stock√© dans MariaDB.

### Impl√©mentation Python du profil utilisateur

```python
# user_embedding_service.py
import numpy as np
import mariadb
from typing import List, Tuple

class UserEmbeddingService:
    
    # Poids des interactions
    INTERACTION_WEIGHTS = {
        'purchase': 5.0,
        'add_cart': 3.0,
        'wishlist': 2.0,
        'review': 4.0,  # Bonus si note >= 4
        'click': 1.0,
        'view': 0.5
    }
    
    def __init__(self, db_connection):
        self.conn = db_connection
    
    def compute_user_embedding(self, user_id: int, embedding_dim: int = 768) -> np.ndarray:
        """
        Calcule l'embedding d'un utilisateur comme moyenne pond√©r√©e
        des embeddings des produits avec lesquels il a interagi.
        """
        cursor = self.conn.cursor()
        
        # R√©cup√©rer les interactions et embeddings associ√©s
        cursor.execute("""
            SELECT 
                ui.interaction_type,
                ui.rating,
                VEC_ToText(pe.combined_embedding) AS embedding_text
            FROM user_interactions ui
            JOIN product_embeddings pe ON ui.product_id = pe.product_id
            WHERE ui.user_id = %s
            AND ui.timestamp >= DATE_SUB(NOW(), INTERVAL 90 DAY)
            ORDER BY ui.timestamp DESC
            LIMIT 500
        """, (user_id,))
        
        weighted_embeddings = []
        total_weight = 0.0
        
        for row in cursor.fetchall():
            interaction_type = row[0]
            rating = row[1]
            embedding = np.array(eval(row[2]))  # Parse le vecteur
            
            # Calculer le poids
            weight = self.INTERACTION_WEIGHTS.get(interaction_type, 0.5)
            
            # Bonus/malus pour les reviews selon la note
            if interaction_type == 'review' and rating:
                if rating >= 4:
                    weight *= 1.5
                elif rating <= 2:
                    weight *= -0.5  # Embedding n√©gatif pour produits mal not√©s
            
            weighted_embeddings.append(embedding * weight)
            total_weight += abs(weight)
        
        if not weighted_embeddings:
            return np.zeros(embedding_dim)
        
        # Moyenne pond√©r√©e
        user_embedding = np.sum(weighted_embeddings, axis=0) / total_weight
        
        # Normaliser L2
        norm = np.linalg.norm(user_embedding)
        if norm > 0:
            user_embedding = user_embedding / norm
        
        return user_embedding
    
    def update_user_embedding(self, user_id: int):
        """Met √† jour l'embedding utilisateur dans la base."""
        embedding = self.compute_user_embedding(user_id)
        
        cursor = self.conn.cursor()
        cursor.execute("""
            INSERT INTO user_embeddings (user_id, preference_embedding, interaction_count, date_mise_a_jour)
            VALUES (%s, VEC_FromText(%s), 
                    (SELECT COUNT(*) FROM user_interactions WHERE user_id = %s),
                    NOW())
            ON DUPLICATE KEY UPDATE
                preference_embedding = VEC_FromText(%s),
                interaction_count = (SELECT COUNT(*) FROM user_interactions WHERE user_id = %s),
                date_mise_a_jour = NOW()
        """, (user_id, str(embedding.tolist()), user_id, str(embedding.tolist()), user_id))
        
        self.conn.commit()
```

### Recommandations bas√©es sur le profil utilisateur

```sql
-- Recommander des produits proches du profil utilisateur
-- en excluant ceux d√©j√† vus/achet√©s

SET @user_id = 42;

SELECT 
    p.id,
    p.nom,
    p.marque,
    p.categorie_id,
    p.prix,
    p.note_moyenne,
    VEC_DISTANCE_COSINE(pe.combined_embedding, ue.preference_embedding) AS distance
FROM products p
JOIN product_embeddings pe ON p.id = pe.product_id
CROSS JOIN user_embeddings ue
WHERE 
    ue.user_id = @user_id
    AND p.en_stock = TRUE
    -- Exclure les produits d√©j√† vus/achet√©s
    AND p.id NOT IN (
        SELECT DISTINCT product_id 
        FROM user_interactions 
        WHERE user_id = @user_id
        AND interaction_type IN ('purchase', 'view', 'click')
        AND timestamp >= DATE_SUB(NOW(), INTERVAL 30 DAY)
    )
ORDER BY distance ASC
LIMIT 20;
```

### Utilisateurs similaires (User-to-User)

```sql
-- Trouver les utilisateurs avec des go√ªts similaires
SET @user_id = 42;

SELECT 
    u.id,
    u.segment,
    ue.interaction_count,
    VEC_DISTANCE_COSINE(ue.preference_embedding, ref.preference_embedding) AS distance
FROM user_embeddings ue
JOIN users u ON ue.user_id = u.id
CROSS JOIN (
    SELECT preference_embedding 
    FROM user_embeddings 
    WHERE user_id = @user_id
) ref
WHERE 
    ue.user_id != @user_id
    AND ue.interaction_count >= 10  -- Utilisateurs actifs seulement
ORDER BY distance ASC
LIMIT 50;

-- Puis recommander ce que ces utilisateurs similaires ont aim√©
WITH similar_users AS (
    SELECT ue.user_id
    FROM user_embeddings ue
    CROSS JOIN (
        SELECT preference_embedding 
        FROM user_embeddings 
        WHERE user_id = @user_id
    ) ref
    WHERE ue.user_id != @user_id
    ORDER BY VEC_DISTANCE_COSINE(ue.preference_embedding, ref.preference_embedding) ASC
    LIMIT 20
)
SELECT 
    p.id,
    p.nom,
    p.prix,
    COUNT(*) AS recommande_par_n_utilisateurs,
    AVG(ui.rating) AS note_moyenne_similaires
FROM user_interactions ui
JOIN similar_users su ON ui.user_id = su.user_id
JOIN products p ON ui.product_id = p.id
WHERE 
    ui.interaction_type IN ('purchase', 'wishlist')
    AND ui.product_id NOT IN (
        SELECT product_id FROM user_interactions WHERE user_id = @user_id
    )
    AND p.en_stock = TRUE
GROUP BY p.id
ORDER BY recommande_par_n_utilisateurs DESC, note_moyenne_similaires DESC
LIMIT 15;
```

---

## Syst√®me de recommandation hybride

### Architecture hybride compl√®te

```sql
-- Recommandation hybride combinant :
-- 1. Similarit√© avec le profil utilisateur (collaborative)
-- 2. Produits tendance (popularit√©)
-- 3. R√®gles m√©tier (boost cat√©gories favorites, promotion)

SET @user_id = 42;

WITH 
-- Score de similarit√© vectorielle
similarity_score AS (
    SELECT 
        pe.product_id,
        1 - VEC_DISTANCE_COSINE(pe.combined_embedding, ue.preference_embedding) AS score_similarity
    FROM product_embeddings pe
    CROSS JOIN user_embeddings ue
    WHERE ue.user_id = @user_id
),
-- Score de popularit√© (ventes + avis r√©cents)
popularity_score AS (
    SELECT 
        product_id,
        LOG10(1 + COUNT(*)) / 3 AS score_popularity  -- Normalis√© ~0-1
    FROM user_interactions
    WHERE 
        interaction_type IN ('purchase', 'review')
        AND timestamp >= DATE_SUB(NOW(), INTERVAL 7 DAY)
    GROUP BY product_id
),
-- Pr√©f√©rences utilisateur (cat√©gories favorites)
user_preferences AS (
    SELECT 
        JSON_UNQUOTE(JSON_EXTRACT(preferences, '$.categories_favorites')) AS categories
    FROM users
    WHERE id = @user_id
),
-- Score de boost cat√©gorie
category_boost AS (
    SELECT 
        p.id AS product_id,
        CASE 
            WHEN JSON_CONTAINS(
                (SELECT categories FROM user_preferences),
                CAST(p.categorie_id AS JSON)
            ) THEN 0.2
            ELSE 0
        END AS score_category_boost
    FROM products p
),
-- Produits d√©j√† vus (√† exclure ou d√©prioriser)
seen_products AS (
    SELECT DISTINCT product_id
    FROM user_interactions
    WHERE user_id = @user_id
    AND timestamp >= DATE_SUB(NOW(), INTERVAL 14 DAY)
)
-- Score final hybride
SELECT 
    p.id,
    p.nom,
    p.marque,
    p.prix,
    p.note_moyenne,
    CASE WHEN p.prix < p.prix_initial THEN TRUE ELSE FALSE END AS en_promo,
    
    -- Scores individuels
    COALESCE(ss.score_similarity, 0) AS score_similarite,
    COALESCE(ps.score_popularity, 0) AS score_popularite,
    COALESCE(cb.score_category_boost, 0) AS score_categorie,
    
    -- Score hybride pond√©r√©
    (
        COALESCE(ss.score_similarity, 0) * 0.50 +      -- 50% similarit√© profil
        COALESCE(ps.score_popularity, 0) * 0.25 +      -- 25% popularit√©
        COALESCE(cb.score_category_boost, 0) * 0.15 +  -- 15% cat√©gorie favorite
        CASE WHEN p.prix < p.prix_initial THEN 0.10 ELSE 0 END  -- 10% bonus promo
    ) AS score_final
    
FROM products p
LEFT JOIN similarity_score ss ON p.id = ss.product_id
LEFT JOIN popularity_score ps ON p.id = ps.product_id
LEFT JOIN category_boost cb ON p.id = cb.product_id
WHERE 
    p.en_stock = TRUE
    AND p.id NOT IN (SELECT product_id FROM seen_products)
ORDER BY score_final DESC
LIMIT 24;
```

üí° **Conseil** : Ajustez les poids (50/25/15/10) en fonction de vos m√©triques A/B testing. Commencez avec des poids √©gaux puis optimisez selon le taux de clic et de conversion.

---

## Recommandations contextuelles

### Recommandations en temps r√©el bas√©es sur la session

```sql
-- Recommander en fonction des produits consult√©s dans la session courante
-- (pas encore en base, pass√©s en param√®tre)

SET @session_product_ids = '12345,12346,12350';

WITH 
-- Centro√Øde des produits de la session
session_centroid AS (
    SELECT 
        -- En pratique, calcul√© c√¥t√© application
        -- Ici on prend le premier produit comme r√©f√©rence simplifi√©e
        combined_embedding
    FROM product_embeddings
    WHERE product_id = CAST(SUBSTRING_INDEX(@session_product_ids, ',', 1) AS UNSIGNED)
)
SELECT 
    p.id,
    p.nom,
    p.prix,
    VEC_DISTANCE_COSINE(pe.combined_embedding, sc.combined_embedding) AS distance
FROM products p
JOIN product_embeddings pe ON p.id = pe.product_id
CROSS JOIN session_centroid sc
WHERE 
    p.en_stock = TRUE
    AND FIND_IN_SET(p.id, @session_product_ids) = 0  -- Exclure produits d√©j√† vus
ORDER BY distance ASC
LIMIT 8;
```

### Recommandations g√©o-localis√©es

```sql
-- Produits populaires dans la r√©gion de l'utilisateur
-- avec boost de similarit√© vectorielle

SET @user_id = 42;
SET @user_region = 'FR-IDF';  -- √éle-de-France

WITH 
regional_popularity AS (
    SELECT 
        ui.product_id,
        COUNT(*) AS regional_purchases
    FROM user_interactions ui
    JOIN users u ON ui.user_id = u.id
    WHERE 
        ui.interaction_type = 'purchase'
        AND JSON_UNQUOTE(JSON_EXTRACT(u.preferences, '$.region')) = @user_region
        AND ui.timestamp >= DATE_SUB(NOW(), INTERVAL 30 DAY)
    GROUP BY ui.product_id
)
SELECT 
    p.id,
    p.nom,
    p.prix,
    rp.regional_purchases,
    VEC_DISTANCE_COSINE(pe.combined_embedding, ue.preference_embedding) AS distance,
    -- Score combin√© r√©gional + similarit√©
    (LOG10(1 + COALESCE(rp.regional_purchases, 0)) * 0.3 + 
     (1 - VEC_DISTANCE_COSINE(pe.combined_embedding, ue.preference_embedding)) * 0.7
    ) AS score_regional
FROM products p
JOIN product_embeddings pe ON p.id = pe.product_id
CROSS JOIN user_embeddings ue
LEFT JOIN regional_popularity rp ON p.id = rp.product_id
WHERE 
    ue.user_id = @user_id
    AND p.en_stock = TRUE
ORDER BY score_regional DESC
LIMIT 12;
```

---

## Cas d'usage par industrie

### 1. E-commerce : Recommandations produits

**Architecture d√©cisionnelle** :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    E-COMMERCE RECOMMENDATION                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îÇ
‚îÇ  ‚îÇ   Page Produit  ‚îÇ     ‚îÇ   Page Panier   ‚îÇ                      ‚îÇ
‚îÇ  ‚îÇ   "Similaires"  ‚îÇ     ‚îÇ  "Compl√®te ton" ‚îÇ                      ‚îÇ
‚îÇ  ‚îÇ  Content-Based  ‚îÇ     ‚îÇ   achat"        ‚îÇ                      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ  Co-occurrence  ‚îÇ                      ‚îÇ
‚îÇ           ‚îÇ              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îÇ
‚îÇ           ‚îÇ                       ‚îÇ                               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îÇ
‚îÇ  ‚îÇ                                         ‚îÇ                      ‚îÇ
‚îÇ  ‚îÇ         MariaDB 11.8 LTS                ‚îÇ                      ‚îÇ
‚îÇ  ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ                      ‚îÇ
‚îÇ  ‚îÇ    ‚îÇ  products + embeddings      ‚îÇ      ‚îÇ                      ‚îÇ
‚îÇ  ‚îÇ    ‚îÇ  VECTOR INDEX (HNSW)        ‚îÇ      ‚îÇ                      ‚îÇ
‚îÇ  ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ                      ‚îÇ
‚îÇ  ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ                      ‚îÇ
‚îÇ  ‚îÇ    ‚îÇ  user_interactions          ‚îÇ      ‚îÇ                      ‚îÇ
‚îÇ  ‚îÇ    ‚îÇ  (click, cart, purchase)    ‚îÇ      ‚îÇ                      ‚îÇ
‚îÇ  ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ                      ‚îÇ
‚îÇ  ‚îÇ                                         ‚îÇ                      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îÇ
‚îÇ           ‚îÇ                       ‚îÇ                               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îÇ
‚îÇ  ‚îÇ   Homepage      ‚îÇ      ‚îÇ   Email/Push   ‚îÇ                      ‚îÇ
‚îÇ  ‚îÇ   "Pour toi"    ‚îÇ      ‚îÇ  "Tu pourrais  ‚îÇ                      ‚îÇ
‚îÇ  ‚îÇ   Collaborative ‚îÇ      ‚îÇ   aimer"       ‚îÇ                      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ   Hybride      ‚îÇ                      ‚îÇ
‚îÇ                           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îÇ
‚îÇ                                                                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**M√©triques cl√©s** :
- CTR (Click-Through Rate) des recommandations
- Taux de conversion des recommandations
- Diversit√© des recommandations (√©viter les bulles de filtre)
- Couverture du catalogue (% produits recommand√©s au moins une fois)

### 2. Streaming vid√©o : Recommandations de contenus

```sql
-- Sch√©ma pour plateforme de streaming
CREATE TABLE videos (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    titre VARCHAR(300) NOT NULL,
    description TEXT,
    genre JSON,  -- ["action", "sci-fi"]
    duree_minutes INT,
    annee_sortie YEAR,
    note_moyenne DECIMAL(3,2),
    nombre_vues BIGINT UNSIGNED DEFAULT 0,
    
    -- Embedding combin√© (synopsis + m√©tadonn√©es + poster)
    content_embedding VECTOR(768) NOT NULL,
    
    VECTOR INDEX idx_content (content_embedding) WITH (DISTANCE = COSINE, M = 32)
) ENGINE=InnoDB;

CREATE TABLE watch_history (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT UNSIGNED NOT NULL,
    video_id BIGINT UNSIGNED NOT NULL,
    watch_duration_seconds INT UNSIGNED,
    video_duration_seconds INT UNSIGNED,
    completion_rate DECIMAL(5,4) AS (watch_duration_seconds / video_duration_seconds) STORED,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_user_completion (user_id, completion_rate DESC)
) ENGINE=InnoDB;

-- Recommander des vid√©os bas√©es sur celles regard√©es jusqu'au bout
WITH completed_videos AS (
    SELECT video_id
    FROM watch_history
    WHERE user_id = @user_id
    AND completion_rate >= 0.80  -- Regard√© au moins 80%
    ORDER BY timestamp DESC
    LIMIT 10
),
reference_embedding AS (
    -- Moyenne des embeddings des vid√©os compl√©t√©es (simplifi√©)
    SELECT content_embedding
    FROM videos
    WHERE id IN (SELECT video_id FROM completed_videos)
    LIMIT 1
)
SELECT 
    v.id,
    v.titre,
    v.genre,
    v.note_moyenne,
    VEC_DISTANCE_COSINE(v.content_embedding, re.content_embedding) AS distance
FROM videos v
CROSS JOIN reference_embedding re
WHERE 
    v.id NOT IN (SELECT video_id FROM watch_history WHERE user_id = @user_id)
ORDER BY distance ASC
LIMIT 20;
```

### 3. R√©seau social : "Personnes que vous pourriez conna√Ætre"

```sql
-- Sch√©ma pour recommandation de connexions
CREATE TABLE social_profiles (
    user_id BIGINT UNSIGNED PRIMARY KEY,
    bio TEXT,
    interets JSON,  -- ["tech", "music", "travel"]
    localisation VARCHAR(100),
    
    -- Embedding du profil (bio + int√©r√™ts + activit√©)
    profile_embedding VECTOR(512) NOT NULL,
    
    VECTOR INDEX idx_profile (profile_embedding) WITH (DISTANCE = COSINE, M = 24)
) ENGINE=InnoDB;

CREATE TABLE connections (
    user_id BIGINT UNSIGNED,
    connected_user_id BIGINT UNSIGNED,
    date_connexion DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    PRIMARY KEY (user_id, connected_user_id)
) ENGINE=InnoDB;

-- Recommander des personnes similaires non encore connect√©es
SET @user_id = 42;

WITH 
-- Connexions existantes (√† exclure)
existing_connections AS (
    SELECT connected_user_id AS user_id FROM connections WHERE user_id = @user_id
    UNION
    SELECT user_id FROM connections WHERE connected_user_id = @user_id
),
-- Amis d'amis (bonus de confiance)
friends_of_friends AS (
    SELECT 
        c2.connected_user_id AS potential_id,
        COUNT(*) AS mutual_friends
    FROM connections c1
    JOIN connections c2 ON c1.connected_user_id = c2.user_id
    WHERE c1.user_id = @user_id
    AND c2.connected_user_id != @user_id
    AND c2.connected_user_id NOT IN (SELECT user_id FROM existing_connections)
    GROUP BY c2.connected_user_id
)
SELECT 
    sp.user_id,
    u.nom,
    sp.localisation,
    COALESCE(fof.mutual_friends, 0) AS amis_communs,
    VEC_DISTANCE_COSINE(sp.profile_embedding, ref.profile_embedding) AS distance,
    -- Score combin√©
    (
        (1 - VEC_DISTANCE_COSINE(sp.profile_embedding, ref.profile_embedding)) * 0.6 +
        LEAST(COALESCE(fof.mutual_friends, 0) / 10, 1) * 0.4
    ) AS score_recommandation
FROM social_profiles sp
JOIN users u ON sp.user_id = u.id
CROSS JOIN (
    SELECT profile_embedding FROM social_profiles WHERE user_id = @user_id
) ref
LEFT JOIN friends_of_friends fof ON sp.user_id = fof.potential_id
WHERE 
    sp.user_id != @user_id
    AND sp.user_id NOT IN (SELECT user_id FROM existing_connections)
ORDER BY score_recommandation DESC
LIMIT 15;
```

---

## Optimisation des performances

### Strat√©gies de cache

```sql
-- Table de cache pour recommandations pr√©-calcul√©es
CREATE TABLE recommendation_cache (
    user_id BIGINT UNSIGNED NOT NULL,
    recommendation_type ENUM('homepage', 'similar', 'trending', 'personalized') NOT NULL,
    product_ids JSON NOT NULL,  -- [123, 456, 789, ...]
    scores JSON,  -- [0.95, 0.92, 0.88, ...]
    generated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    expires_at DATETIME NOT NULL,
    
    PRIMARY KEY (user_id, recommendation_type),
    INDEX idx_expiration (expires_at)
) ENGINE=InnoDB;

-- R√©cup√©rer depuis le cache ou g√©n√©rer
DELIMITER //

CREATE PROCEDURE get_recommendations(
    IN p_user_id BIGINT UNSIGNED,
    IN p_type VARCHAR(20),
    IN p_limit INT
)
BEGIN
    DECLARE v_cached_ids JSON;
    
    -- V√©rifier le cache
    SELECT product_ids INTO v_cached_ids
    FROM recommendation_cache
    WHERE user_id = p_user_id 
    AND recommendation_type = p_type
    AND expires_at > NOW();
    
    IF v_cached_ids IS NOT NULL THEN
        -- Retourner depuis le cache
        SELECT 
            p.id, p.nom, p.prix, p.note_moyenne
        FROM products p
        WHERE JSON_CONTAINS(v_cached_ids, CAST(p.id AS JSON))
        AND p.en_stock = TRUE
        LIMIT p_limit;
    ELSE
        -- G√©n√©rer et mettre en cache (logique simplifi√©e)
        -- En production, appeler la proc√©dure de g√©n√©ration appropri√©e
        SELECT 'CACHE_MISS' AS status;
    END IF;
END //

DELIMITER ;
```

### Batch processing pour mise √† jour des embeddings

```python
# batch_embedding_update.py
import mariadb
from concurrent.futures import ThreadPoolExecutor
import schedule
import time

class EmbeddingBatchProcessor:
    def __init__(self, db_config, embedding_service):
        self.db_config = db_config
        self.embedding_service = embedding_service
        self.batch_size = 100
    
    def get_users_needing_update(self) -> list:
        """Identifie les utilisateurs dont l'embedding doit √™tre recalcul√©."""
        conn = mariadb.connect(**self.db_config)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT DISTINCT u.id
            FROM users u
            LEFT JOIN user_embeddings ue ON u.id = ue.user_id
            LEFT JOIN (
                SELECT user_id, MAX(timestamp) as last_interaction
                FROM user_interactions
                GROUP BY user_id
            ) li ON u.id = li.user_id
            WHERE 
                ue.user_id IS NULL  -- Pas encore d'embedding
                OR ue.date_mise_a_jour < li.last_interaction  -- Nouvelles interactions
                OR ue.date_mise_a_jour < DATE_SUB(NOW(), INTERVAL 24 HOUR)  -- Refresh quotidien
            LIMIT 10000
        """)
        
        user_ids = [row[0] for row in cursor.fetchall()]
        conn.close()
        return user_ids
    
    def process_batch(self, user_ids: list):
        """Traite un batch d'utilisateurs."""
        conn = mariadb.connect(**self.db_config)
        
        for user_id in user_ids:
            try:
                self.embedding_service.update_user_embedding(user_id)
            except Exception as e:
                print(f"Erreur pour user {user_id}: {e}")
        
        conn.close()
    
    def run_batch_job(self):
        """Job de mise √† jour batch."""
        user_ids = self.get_users_needing_update()
        print(f"Mise √† jour de {len(user_ids)} utilisateurs")
        
        # Traiter en parall√®le
        with ThreadPoolExecutor(max_workers=4) as executor:
            batches = [
                user_ids[i:i+self.batch_size] 
                for i in range(0, len(user_ids), self.batch_size)
            ]
            executor.map(self.process_batch, batches)

# Planification
processor = EmbeddingBatchProcessor(db_config, embedding_service)
schedule.every(6).hours.do(processor.run_batch_job)

while True:
    schedule.run_pending()
    time.sleep(60)
```

### Monitoring des recommandations

```sql
-- Table de tracking des recommandations servies
CREATE TABLE recommendation_logs (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT UNSIGNED,
    recommendation_type VARCHAR(50),
    products_shown JSON,
    product_clicked BIGINT UNSIGNED,
    product_purchased BIGINT UNSIGNED,
    latency_ms INT UNSIGNED,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_user_time (user_id, timestamp),
    INDEX idx_type_time (recommendation_type, timestamp)
) ENGINE=InnoDB;

-- M√©triques de performance des recommandations
SELECT 
    recommendation_type,
    DATE(timestamp) AS date,
    COUNT(*) AS impressions,
    SUM(CASE WHEN product_clicked IS NOT NULL THEN 1 ELSE 0 END) AS clicks,
    SUM(CASE WHEN product_purchased IS NOT NULL THEN 1 ELSE 0 END) AS purchases,
    ROUND(SUM(CASE WHEN product_clicked IS NOT NULL THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) AS ctr_percent,
    ROUND(SUM(CASE WHEN product_purchased IS NOT NULL THEN 1 ELSE 0 END) * 100.0 / NULLIF(SUM(CASE WHEN product_clicked IS NOT NULL THEN 1 ELSE 0 END), 0), 2) AS conversion_rate,
    ROUND(AVG(latency_ms), 0) AS avg_latency_ms
FROM recommendation_logs
WHERE timestamp >= DATE_SUB(NOW(), INTERVAL 7 DAY)
GROUP BY recommendation_type, DATE(timestamp)
ORDER BY date DESC, recommendation_type;
```

---

## Cold Start : G√©rer les nouveaux utilisateurs/produits

### Strat√©gies pour nouveaux utilisateurs

```sql
-- Recommandations pour utilisateur sans historique
-- Bas√© sur popularit√© + segment d√©mographique

SET @new_user_segment = 'nouveau';
SET @user_region = 'FR';

SELECT 
    p.id,
    p.nom,
    p.prix,
    p.note_moyenne,
    pop.purchase_count
FROM products p
JOIN (
    -- Produits populaires r√©cemment
    SELECT 
        product_id,
        COUNT(*) AS purchase_count
    FROM user_interactions
    WHERE interaction_type = 'purchase'
    AND timestamp >= DATE_SUB(NOW(), INTERVAL 7 DAY)
    GROUP BY product_id
) pop ON p.id = pop.product_id
WHERE 
    p.en_stock = TRUE
    AND p.note_moyenne >= 4.0
ORDER BY pop.purchase_count DESC, p.note_moyenne DESC
LIMIT 20;
```

### Strat√©gies pour nouveaux produits

```sql
-- Propager un nouveau produit aux utilisateurs susceptibles d'aimer

SET @new_product_id = 99999;

-- Trouver les utilisateurs dont le profil est proche du nouveau produit
SELECT 
    ue.user_id,
    u.email,
    VEC_DISTANCE_COSINE(pe.combined_embedding, ue.preference_embedding) AS distance
FROM product_embeddings pe
CROSS JOIN user_embeddings ue
JOIN users u ON ue.user_id = u.id
WHERE 
    pe.product_id = @new_product_id
    AND ue.interaction_count >= 5  -- Utilisateurs avec profil √©tabli
ORDER BY distance ASC
LIMIT 1000;

-- Ces utilisateurs peuvent recevoir une notification ou voir le produit en priorit√©
```

---

## ‚úÖ Points cl√©s √† retenir

- Les **recommandations vectorielles** avec MariaDB 11.8 permettent de combiner donn√©es relationnelles et similarit√© s√©mantique dans une seule base
- Le **collaborative filtering** utilise les embeddings utilisateurs pour trouver des profils similaires et recommander leurs pr√©f√©rences
- Le **content-based filtering** utilise les embeddings produits pour trouver des items similaires √† ceux appr√©ci√©s
- L'approche **hybride** combine les deux et ajoute des r√®gles m√©tier (popularit√©, promotions, contraintes stock)
- Le **profil utilisateur vectoriel** est calcul√© comme moyenne pond√©r√©e des embeddings des items consult√©s/achet√©s
- Les **recommandations contextuelles** prennent en compte la session, la localisation et le moment
- Le **cold start** se g√®re via popularit√© (nouveaux users) ou propagation aux profils proches (nouveaux items)
- Le **cache** et le **batch processing** sont essentiels pour les performances en production

---

## üîó Ressources et r√©f√©rences

- [üìñ MariaDB Vector Documentation](https://mariadb.com/kb/en/vector/) ‚Äî Documentation officielle MariaDB Vector
- [üìñ Recommender Systems Handbook](https://www.springer.com/gp/book/9781489976369) ‚Äî R√©f√©rence acad√©mique
- [üìñ Two-Tower Model Architecture](https://ai.google/research/pubs/pub45530) ‚Äî Architecture Google pour recommandations
- [üìñ Item2Vec Paper](https://arxiv.org/abs/1603.04259) ‚Äî Embeddings de produits inspir√©s de Word2Vec
- [üìñ HNSW Algorithm](https://arxiv.org/abs/1603.09320) ‚Äî Algorithme d'indexation vectorielle utilis√© par MariaDB

---

## ‚û°Ô∏è Section suivante

**20.9.3 Anomaly Detection** : D√©couvrez comment utiliser la distance vectorielle pour d√©tecter des comportements anormaux, des transactions frauduleuses ou des d√©gradations de performance ‚Äî une application critique de la recherche vectorielle dans la s√©curit√© et l'observabilit√©.

‚è≠Ô∏è [Anomaly Detection](/20-cas-usage-architectures/09.3-anomaly-detection.md)
