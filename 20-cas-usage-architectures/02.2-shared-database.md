üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.2.2 Shared Database Pattern

> **Niveau** : Interm√©diaire √† Avanc√©  
> **Dur√©e estim√©e** : 2 heures  
> **Pr√©requis** : Chapitre 10 (S√©curit√© et Gestion des Utilisateurs), Section 20.2.1 (Database per Service), Chapitre 6 (Transactions et Concurrence)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :

- Comprendre le pattern Shared Database et ses variantes d'impl√©mentation
- Identifier les cas d'usage l√©gitimes justifiant une base de donn√©es partag√©e
- Concevoir une architecture de sch√©mas isol√©s avec MariaDB
- Impl√©menter des m√©canismes de gouvernance et d'isolation logique
- Planifier une migration progressive vers une architecture plus d√©coupl√©e

---

## Introduction

Le pattern **Shared Database** (base de donn√©es partag√©e) repr√©sente l'approche traditionnelle o√π **plusieurs services ou applications acc√®dent √† une m√™me instance de base de donn√©es**. Souvent consid√©r√© comme un anti-pattern dans le monde des microservices, il reste n√©anmoins une solution pragmatique et parfois optimale dans de nombreux contextes.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SHARED DATABASE PATTERN                          ‚îÇ
‚îÇ                                                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ   Service   ‚îÇ  ‚îÇ   Service   ‚îÇ  ‚îÇ   Service   ‚îÇ  ‚îÇ   Service   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  Commandes  ‚îÇ  ‚îÇ   Clients   ‚îÇ  ‚îÇ  Inventaire ‚îÇ  ‚îÇ  Reporting  ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ         ‚îÇ                ‚îÇ                ‚îÇ                ‚îÇ        ‚îÇ
‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ                                   ‚îÇ                                 ‚îÇ
‚îÇ                                   ‚ñº                                 ‚îÇ
‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                     ‚îÇ
‚îÇ                    ‚îÇ      MariaDB 11.8        ‚îÇ                     ‚îÇ
‚îÇ                    ‚îÇ    Base de donn√©es       ‚îÇ                     ‚îÇ
‚îÇ                    ‚îÇ        partag√©e          ‚îÇ                     ‚îÇ
‚îÇ                    ‚îÇ                          ‚îÇ                     ‚îÇ
‚îÇ                    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ                     ‚îÇ
‚îÇ                    ‚îÇ  ‚îÇorders  ‚îÇ ‚îÇcustomers‚îÇ  ‚îÇ                     ‚îÇ
‚îÇ                    ‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îÇ                     ‚îÇ
‚îÇ                    ‚îÇ  ‚îÇproducts‚îÇ ‚îÇinventory‚îÇ  ‚îÇ                     ‚îÇ
‚îÇ                    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ                     ‚îÇ
‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Contrairement √† ce que sugg√®re la doxa microservices, le Shared Database pattern n'est pas intrins√®quement mauvais. Il s'agit d'un **compromis architectural** qui privil√©gie la simplicit√©, la coh√©rence transactionnelle et l'efficacit√© op√©rationnelle au d√©triment de l'autonomie des services.

---

## Variantes du pattern

Le Shared Database pattern se d√©cline en plusieurs variantes offrant des niveaux d'isolation croissants :

### Variante 1 : Sch√©ma unique partag√©

Tous les services acc√®dent aux m√™mes tables dans le m√™me sch√©ma. C'est la forme la plus coupl√©e.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SCH√âMA UNIQUE PARTAG√â                            ‚îÇ
‚îÇ                                                                     ‚îÇ
‚îÇ  Service A ‚îÄ‚îÄ‚îê                                                      ‚îÇ
‚îÇ  Service B ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚ñ∂  database.table_1                                ‚îÇ
‚îÇ  Service C ‚îÄ‚îÄ‚îò     database.table_2                                ‚îÇ
‚îÇ                    database.table_3                                ‚îÇ
‚îÇ                                                                     ‚îÇ
‚îÇ  Couplage : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà Maximum                                   ‚îÇ
‚îÇ  Isolation : ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë Minimale                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Variante 2 : Sch√©mas s√©par√©s par service (recommand√©)

Chaque service dispose de son propre sch√©ma logique, mais partage la m√™me instance physique.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SCH√âMAS S√âPAR√âS PAR SERVICE                      ‚îÇ
‚îÇ                                                                     ‚îÇ
‚îÇ  Service Orders ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂  orders_schema.orders                         ‚îÇ
‚îÇ                        orders_schema.order_items                    ‚îÇ
‚îÇ                                                                     ‚îÇ
‚îÇ  Service Customers ‚îÄ‚îÄ‚ñ∂ customers_schema.customers                   ‚îÇ
‚îÇ                        customers_schema.addresses                   ‚îÇ
‚îÇ                                                                     ‚îÇ
‚îÇ  Service Inventory ‚îÄ‚îÄ‚ñ∂ inventory_schema.products                    ‚îÇ
‚îÇ                        inventory_schema.stock                       ‚îÇ
‚îÇ                                                                     ‚îÇ
‚îÇ  Couplage : ‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë Mod√©r√©                                     ‚îÇ
‚îÇ  Isolation : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë Bonne                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Variante 3 : Tables partag√©es avec vues sp√©cialis√©es

Des vues encapsulent l'acc√®s aux donn√©es, permettant une √©volution ind√©pendante du sch√©ma physique.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 TABLES PARTAG√âES + VUES SP√âCIALIS√âES                ‚îÇ
‚îÇ                                                                     ‚îÇ
‚îÇ  Service Orders ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂  v_orders_for_orders_svc (vue)                ‚îÇ
‚îÇ                             ‚îÇ                                       ‚îÇ
‚îÇ  Service Shipping ‚îÄ‚îÄ‚ñ∂  v_orders_for_shipping_svc (vue)              ‚îÇ
‚îÇ                             ‚îÇ                                       ‚îÇ
‚îÇ                             ‚ñº                                       ‚îÇ
‚îÇ                    [orders] (table physique)                        ‚îÇ
‚îÇ                                                                     ‚îÇ
‚îÇ  Couplage : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë Mod√©r√© √† √©lev√©                             ‚îÇ
‚îÇ  Isolation : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë Moyenne                                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Impl√©mentation avec MariaDB 11.8

### Architecture √† sch√©mas s√©par√©s

Cette approche offre le meilleur √©quilibre entre isolation logique et efficacit√© op√©rationnelle.

```sql
-- ============================================================
-- CR√âATION DES SCH√âMAS PAR DOMAINE M√âTIER
-- ============================================================

-- Sch√©ma du service Commandes
CREATE DATABASE orders_svc 
    CHARACTER SET utf8mb4 
    COLLATE utf8mb4_uca1400_ai_ci;  -- üÜï Collation UCA 14.0.0

-- Sch√©ma du service Clients
CREATE DATABASE customers_svc 
    CHARACTER SET utf8mb4 
    COLLATE utf8mb4_uca1400_ai_ci;

-- Sch√©ma du service Inventaire
CREATE DATABASE inventory_svc 
    CHARACTER SET utf8mb4 
    COLLATE utf8mb4_uca1400_ai_ci;

-- Sch√©ma partag√© pour les donn√©es de r√©f√©rence
CREATE DATABASE shared_reference 
    CHARACTER SET utf8mb4 
    COLLATE utf8mb4_uca1400_ai_ci;
```

### Gestion des utilisateurs et privil√®ges

L'isolation logique repose sur une **gestion rigoureuse des privil√®ges** :

```sql
-- ============================================================
-- UTILISATEURS APPLICATIFS PAR SERVICE
-- ============================================================

-- Utilisateur du service Commandes
CREATE USER 'orders_app'@'10.0.%' 
    IDENTIFIED BY 'secure_password_orders_2025';

-- Privil√®ges : acc√®s complet √† son sch√©ma uniquement
GRANT ALL PRIVILEGES ON orders_svc.* TO 'orders_app'@'10.0.%';

-- Lecture seule sur les donn√©es de r√©f√©rence partag√©es
GRANT SELECT ON shared_reference.* TO 'orders_app'@'10.0.%';

-- üÜï MariaDB 11.8 : Privil√®ges granulaires sur colonnes sp√©cifiques
-- Acc√®s limit√© √† certaines colonnes du sch√©ma customers
GRANT SELECT (customer_id, name, email) 
    ON customers_svc.customers 
    TO 'orders_app'@'10.0.%';

-- ============================================================
-- Utilisateur du service Clients
CREATE USER 'customers_app'@'10.0.%' 
    IDENTIFIED BY 'secure_password_customers_2025';

GRANT ALL PRIVILEGES ON customers_svc.* TO 'customers_app'@'10.0.%';
GRANT SELECT ON shared_reference.* TO 'customers_app'@'10.0.%';

-- Pas d'acc√®s aux autres sch√©mas par d√©faut

-- ============================================================
-- Utilisateur du service Inventaire
CREATE USER 'inventory_app'@'10.0.%' 
    IDENTIFIED BY 'secure_password_inventory_2025';

GRANT ALL PRIVILEGES ON inventory_svc.* TO 'inventory_app'@'10.0.%';
GRANT SELECT ON shared_reference.* TO 'inventory_app'@'10.0.%';

-- Lecture des produits command√©s (pour v√©rification stock)
GRANT SELECT (order_id, product_id, quantity) 
    ON orders_svc.order_items 
    TO 'inventory_app'@'10.0.%';

-- ============================================================
-- Application des privil√®ges
FLUSH PRIVILEGES;
```

üí° **Conseil** : Utilisez des **r√¥les** pour simplifier la gestion des privil√®ges dans les environnements complexes :

```sql
-- Cr√©ation de r√¥les r√©utilisables
CREATE ROLE read_reference_data;
GRANT SELECT ON shared_reference.* TO read_reference_data;

CREATE ROLE cross_service_reader;
GRANT SELECT ON orders_svc.orders TO cross_service_reader;
GRANT SELECT ON customers_svc.customers TO cross_service_reader;
GRANT SELECT ON inventory_svc.products TO cross_service_reader;

-- Attribution des r√¥les aux utilisateurs
GRANT read_reference_data TO 'orders_app'@'10.0.%';
GRANT read_reference_data TO 'customers_app'@'10.0.%';

-- Utilisateur reporting avec acc√®s transversal
CREATE USER 'reporting_app'@'10.0.%' 
    IDENTIFIED BY 'secure_password_reporting';
GRANT cross_service_reader TO 'reporting_app'@'10.0.%';
GRANT read_reference_data TO 'reporting_app'@'10.0.%';

-- Activation par d√©faut des r√¥les
SET DEFAULT ROLE read_reference_data FOR 'orders_app'@'10.0.%';
SET DEFAULT ROLE ALL FOR 'reporting_app'@'10.0.%';
```

### Cr√©ation des tables par domaine

```sql
-- ============================================================
-- SCH√âMA CUSTOMERS_SVC
-- ============================================================
USE customers_svc;

CREATE TABLE customers (
    customer_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    external_id VARCHAR(64) UNIQUE NOT NULL,  -- ID expos√© publiquement
    email VARCHAR(255) NOT NULL UNIQUE,
    name VARCHAR(255) NOT NULL,
    phone VARCHAR(20),
    status ENUM('active', 'inactive', 'suspended') DEFAULT 'active',
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
               ON UPDATE CURRENT_TIMESTAMP(6),
    
    INDEX idx_email (email),
    INDEX idx_status (status),
    INDEX idx_external (external_id)
) ENGINE=InnoDB;

CREATE TABLE addresses (
    address_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    customer_id BIGINT UNSIGNED NOT NULL,
    address_type ENUM('billing', 'shipping') NOT NULL,
    street_line1 VARCHAR(255) NOT NULL,
    street_line2 VARCHAR(255),
    city VARCHAR(100) NOT NULL,
    postal_code VARCHAR(20) NOT NULL,
    country_code CHAR(2) NOT NULL,
    is_default BOOLEAN DEFAULT FALSE,
    
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id) 
        ON DELETE CASCADE,
    INDEX idx_customer_type (customer_id, address_type)
) ENGINE=InnoDB;

-- ============================================================
-- SCH√âMA ORDERS_SVC
-- ============================================================
USE orders_svc;

CREATE TABLE orders (
    order_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_number VARCHAR(32) UNIQUE NOT NULL,  -- Num√©ro lisible
    customer_id BIGINT UNSIGNED NOT NULL,      -- R√©f√©rence cross-schema
    
    status ENUM('draft', 'pending', 'confirmed', 'processing', 
                'shipped', 'delivered', 'cancelled', 'refunded') 
           DEFAULT 'draft',
    
    -- Snapshot des donn√©es client au moment de la commande
    shipping_address JSON NOT NULL,
    billing_address JSON,
    
    subtotal DECIMAL(15,2) NOT NULL DEFAULT 0,
    tax_amount DECIMAL(15,2) NOT NULL DEFAULT 0,
    shipping_cost DECIMAL(15,2) NOT NULL DEFAULT 0,
    total_amount DECIMAL(15,2) GENERATED ALWAYS AS 
                 (subtotal + tax_amount + shipping_cost) STORED,
    
    ordered_at DATETIME(6),
    shipped_at DATETIME(6),
    delivered_at DATETIME(6),
    
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
               ON UPDATE CURRENT_TIMESTAMP(6),
    
    INDEX idx_customer (customer_id),
    INDEX idx_status (status),
    INDEX idx_ordered (ordered_at DESC),
    INDEX idx_number (order_number)
) ENGINE=InnoDB;

CREATE TABLE order_items (
    item_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT UNSIGNED NOT NULL,
    product_id BIGINT UNSIGNED NOT NULL,      -- R√©f√©rence cross-schema
    
    -- Snapshot du produit au moment de la commande
    product_snapshot JSON NOT NULL,
    
    quantity INT UNSIGNED NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    line_total DECIMAL(12,2) GENERATED ALWAYS AS 
               (quantity * unit_price) STORED,
    
    FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE CASCADE,
    INDEX idx_order (order_id),
    INDEX idx_product (product_id)
) ENGINE=InnoDB;

-- ============================================================
-- SCH√âMA INVENTORY_SVC
-- ============================================================
USE inventory_svc;

CREATE TABLE products (
    product_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    sku VARCHAR(64) UNIQUE NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    category_id BIGINT UNSIGNED,
    
    base_price DECIMAL(10,2) NOT NULL,
    cost_price DECIMAL(10,2),
    
    weight_kg DECIMAL(8,3),
    dimensions JSON,  -- {length, width, height}
    
    is_active BOOLEAN DEFAULT TRUE,
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
               ON UPDATE CURRENT_TIMESTAMP(6),
    
    INDEX idx_sku (sku),
    INDEX idx_category (category_id),
    INDEX idx_active (is_active)
) ENGINE=InnoDB;

CREATE TABLE stock (
    stock_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    product_id BIGINT UNSIGNED NOT NULL,
    warehouse_id BIGINT UNSIGNED NOT NULL,
    
    quantity_available INT NOT NULL DEFAULT 0,
    quantity_reserved INT NOT NULL DEFAULT 0,
    quantity_on_order INT NOT NULL DEFAULT 0,
    
    reorder_point INT NOT NULL DEFAULT 10,
    reorder_quantity INT NOT NULL DEFAULT 50,
    
    last_counted_at DATETIME(6),
    
    UNIQUE KEY uk_product_warehouse (product_id, warehouse_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id),
    
    CONSTRAINT chk_qty_available CHECK (quantity_available >= 0),
    CONSTRAINT chk_qty_reserved CHECK (quantity_reserved >= 0)
) ENGINE=InnoDB;

-- ============================================================
-- SCH√âMA SHARED_REFERENCE (Donn√©es de r√©f√©rence communes)
-- ============================================================
USE shared_reference;

CREATE TABLE countries (
    country_code CHAR(2) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    currency_code CHAR(3),
    is_shipping_enabled BOOLEAN DEFAULT TRUE
) ENGINE=InnoDB;

CREATE TABLE currencies (
    currency_code CHAR(3) PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    symbol VARCHAR(5) NOT NULL,
    decimal_places TINYINT UNSIGNED DEFAULT 2
) ENGINE=InnoDB;

CREATE TABLE tax_rates (
    tax_rate_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    country_code CHAR(2) NOT NULL,
    region_code VARCHAR(10),
    tax_type VARCHAR(50) NOT NULL,
    rate DECIMAL(5,4) NOT NULL,  -- Ex: 0.2000 pour 20%
    effective_from DATE NOT NULL,
    effective_until DATE,
    
    INDEX idx_country_date (country_code, effective_from)
) ENGINE=InnoDB;

-- Donn√©es de r√©f√©rence initiales
INSERT INTO countries (country_code, name, currency_code) VALUES
    ('FR', 'France', 'EUR'),
    ('BE', 'Belgique', 'EUR'),
    ('CH', 'Suisse', 'CHF'),
    ('CA', 'Canada', 'CAD'),
    ('US', '√âtats-Unis', 'USD');

INSERT INTO currencies (currency_code, name, symbol) VALUES
    ('EUR', 'Euro', '‚Ç¨'),
    ('USD', 'Dollar am√©ricain', '$'),
    ('CHF', 'Franc suisse', 'CHF'),
    ('CAD', 'Dollar canadien', 'CA$');
```

---

## Transactions cross-schema

L'un des **avantages majeurs** du Shared Database pattern est la possibilit√© d'utiliser des **transactions ACID natives** impliquant plusieurs domaines.

### Cr√©ation de commande transactionnelle

```sql
-- Proc√©dure de cr√©ation de commande avec coh√©rence transactionnelle
DELIMITER //

CREATE PROCEDURE orders_svc.create_order_with_reservation(
    IN p_customer_id BIGINT UNSIGNED,
    IN p_items JSON,  -- [{product_id, quantity}, ...]
    IN p_shipping_address JSON,
    OUT p_order_id BIGINT UNSIGNED,
    OUT p_status VARCHAR(50),
    OUT p_message VARCHAR(255)
)
this_proc: BEGIN
    DECLARE v_order_id BIGINT UNSIGNED;
    DECLARE v_customer_exists BOOLEAN DEFAULT FALSE;
    DECLARE v_item_count INT;
    DECLARE v_idx INT DEFAULT 0;
    DECLARE v_product_id BIGINT UNSIGNED;
    DECLARE v_quantity INT;
    DECLARE v_available INT;
    DECLARE v_unit_price DECIMAL(10,2);
    DECLARE v_product_name VARCHAR(255);
    DECLARE v_subtotal DECIMAL(15,2) DEFAULT 0;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        GET DIAGNOSTICS CONDITION 1
            p_message = MESSAGE_TEXT;
        SET p_status = 'ERROR';
        SET p_order_id = NULL;
    END;
    
    -- D√©but de la transaction
    START TRANSACTION;
    
    -- ============================================================
    -- √âTAPE 1 : Validation du client (cross-schema)
    -- ============================================================
    SELECT EXISTS(
        SELECT 1 FROM customers_svc.customers 
        WHERE customer_id = p_customer_id AND status = 'active'
    ) INTO v_customer_exists;
    
    IF NOT v_customer_exists THEN
        SET p_status = 'INVALID_CUSTOMER';
        SET p_message = 'Customer not found or inactive';
        ROLLBACK;
        LEAVE this_proc;
    END IF;
    
    -- ============================================================
    -- √âTAPE 2 : Cr√©ation de la commande
    -- ============================================================
    INSERT INTO orders_svc.orders (
        order_number, 
        customer_id, 
        shipping_address,
        status
    ) VALUES (
        CONCAT('ORD-', DATE_FORMAT(NOW(), '%Y%m%d'), '-', 
               LPAD(FLOOR(RAND() * 100000), 5, '0')),
        p_customer_id,
        p_shipping_address,
        'pending'
    );
    
    SET v_order_id = LAST_INSERT_ID();
    
    -- ============================================================
    -- √âTAPE 3 : Traitement des articles avec v√©rification stock
    -- ============================================================
    SET v_item_count = JSON_LENGTH(p_items);
    
    WHILE v_idx < v_item_count DO
        SET v_product_id = JSON_EXTRACT(p_items, CONCAT('$[', v_idx, '].product_id'));
        SET v_quantity = JSON_EXTRACT(p_items, CONCAT('$[', v_idx, '].quantity'));
        
        -- V√©rification et verrouillage du stock (cross-schema)
        SELECT 
            p.name,
            p.base_price,
            COALESCE(SUM(s.quantity_available - s.quantity_reserved), 0)
        INTO v_product_name, v_unit_price, v_available
        FROM inventory_svc.products p
        LEFT JOIN inventory_svc.stock s ON p.product_id = s.product_id
        WHERE p.product_id = v_product_id AND p.is_active = TRUE
        GROUP BY p.product_id
        FOR UPDATE;  -- Verrouillage pour √©viter survente
        
        IF v_product_name IS NULL THEN
            SET p_status = 'INVALID_PRODUCT';
            SET p_message = CONCAT('Product not found: ', v_product_id);
            ROLLBACK;
            LEAVE this_proc;
        END IF;
        
        IF v_available < v_quantity THEN
            SET p_status = 'INSUFFICIENT_STOCK';
            SET p_message = CONCAT('Insufficient stock for product ', 
                                   v_product_id, ': ', v_available, ' available');
            ROLLBACK;
            LEAVE this_proc;
        END IF;
        
        -- Insertion de l'article avec snapshot produit
        INSERT INTO orders_svc.order_items (
            order_id, 
            product_id, 
            product_snapshot,
            quantity, 
            unit_price
        ) VALUES (
            v_order_id,
            v_product_id,
            JSON_OBJECT(
                'name', v_product_name,
                'price_at_order', v_unit_price,
                'captured_at', NOW(6)
            ),
            v_quantity,
            v_unit_price
        );
        
        -- R√©servation du stock (cross-schema)
        UPDATE inventory_svc.stock
        SET quantity_reserved = quantity_reserved + v_quantity
        WHERE product_id = v_product_id
        ORDER BY quantity_available - quantity_reserved DESC
        LIMIT 1;
        
        SET v_subtotal = v_subtotal + (v_quantity * v_unit_price);
        SET v_idx = v_idx + 1;
    END WHILE;
    
    -- ============================================================
    -- √âTAPE 4 : Mise √† jour du total
    -- ============================================================
    UPDATE orders_svc.orders
    SET subtotal = v_subtotal,
        ordered_at = NOW(6)
    WHERE order_id = v_order_id;
    
    -- ============================================================
    -- COMMIT : Tout ou rien
    -- ============================================================
    COMMIT;
    
    SET p_order_id = v_order_id;
    SET p_status = 'SUCCESS';
    SET p_message = 'Order created successfully';
    
END //

DELIMITER ;
```

**Utilisation :**

```sql
-- Cr√©ation d'une commande
CALL orders_svc.create_order_with_reservation(
    1,  -- customer_id
    '[{"product_id": 101, "quantity": 2}, {"product_id": 102, "quantity": 1}]',
    '{"street": "123 Rue de Paris", "city": "Paris", "postal_code": "75001"}',
    @order_id,
    @status,
    @message
);

SELECT @order_id AS order_id, @status AS status, @message AS message;
-- +----------+---------+----------------------------+
-- | order_id | status  | message                    |
-- +----------+---------+----------------------------+
-- |       42 | SUCCESS | Order created successfully |
-- +----------+---------+----------------------------+
```

üí° **Conseil** : Cette transaction implique trois sch√©mas (`orders_svc`, `customers_svc`, `inventory_svc`) en une seule op√©ration ACID. C'est impossible avec le pattern Database per Service sans m√©canisme de Saga.

---

## Encapsulation par les vues

Les **vues** permettent de cr√©er une couche d'abstraction entre le sch√©ma physique et les services consommateurs, facilitant les √©volutions futures.

### Vues d'exposition contr√¥l√©e

```sql
-- ============================================================
-- VUES POUR LE SERVICE COMMANDES
-- ============================================================
USE orders_svc;

-- Vue sur les clients : expose uniquement ce qui est n√©cessaire
CREATE OR REPLACE VIEW v_customers_for_orders AS
SELECT 
    c.customer_id,
    c.external_id,
    c.name,
    c.email,
    a.street_line1,
    a.street_line2,
    a.city,
    a.postal_code,
    a.country_code
FROM customers_svc.customers c
LEFT JOIN customers_svc.addresses a ON c.customer_id = a.customer_id 
    AND a.address_type = 'shipping' 
    AND a.is_default = TRUE
WHERE c.status = 'active';

-- Vue sur les produits : informations pour affichage commande
CREATE OR REPLACE VIEW v_products_for_orders AS
SELECT 
    p.product_id,
    p.sku,
    p.name,
    p.base_price AS current_price,
    COALESCE(SUM(s.quantity_available - s.quantity_reserved), 0) AS available_stock
FROM inventory_svc.products p
LEFT JOIN inventory_svc.stock s ON p.product_id = s.product_id
WHERE p.is_active = TRUE
GROUP BY p.product_id;

-- ============================================================
-- VUES POUR LE SERVICE REPORTING
-- ============================================================
USE shared_reference;

-- Vue consolid√©e des ventes (lecture seule, cross-schema)
CREATE OR REPLACE VIEW v_sales_report AS
SELECT 
    o.order_id,
    o.order_number,
    o.ordered_at,
    o.status,
    o.total_amount,
    c.name AS customer_name,
    c.email AS customer_email,
    cnt.name AS customer_country,
    COUNT(oi.item_id) AS item_count
FROM orders_svc.orders o
JOIN customers_svc.customers c ON o.customer_id = c.customer_id
LEFT JOIN customers_svc.addresses a ON c.customer_id = a.customer_id 
    AND a.is_default = TRUE AND a.address_type = 'billing'
LEFT JOIN shared_reference.countries cnt ON a.country_code = cnt.country_code
LEFT JOIN orders_svc.order_items oi ON o.order_id = oi.order_id
WHERE o.status NOT IN ('draft', 'cancelled')
GROUP BY o.order_id;

-- Vue des m√©triques inventaire
CREATE OR REPLACE VIEW v_inventory_metrics AS
SELECT 
    p.product_id,
    p.sku,
    p.name,
    p.base_price,
    SUM(s.quantity_available) AS total_available,
    SUM(s.quantity_reserved) AS total_reserved,
    SUM(s.quantity_on_order) AS total_on_order,
    COUNT(DISTINCT s.warehouse_id) AS warehouse_count,
    MIN(s.reorder_point) AS min_reorder_point,
    CASE 
        WHEN SUM(s.quantity_available - s.quantity_reserved) <= MIN(s.reorder_point) 
        THEN 'REORDER_NEEDED'
        WHEN SUM(s.quantity_available - s.quantity_reserved) = 0 
        THEN 'OUT_OF_STOCK'
        ELSE 'IN_STOCK'
    END AS stock_status
FROM inventory_svc.products p
LEFT JOIN inventory_svc.stock s ON p.product_id = s.product_id
WHERE p.is_active = TRUE
GROUP BY p.product_id;
```

### Vues mat√©rialis√©es simul√©es

MariaDB ne dispose pas de vues mat√©rialis√©es natives, mais on peut les simuler :

```sql
-- Table de cache pour la vue mat√©rialis√©e
CREATE TABLE shared_reference.mv_daily_sales_summary (
    report_date DATE PRIMARY KEY,
    total_orders INT NOT NULL,
    total_revenue DECIMAL(18,2) NOT NULL,
    avg_order_value DECIMAL(12,2) NOT NULL,
    unique_customers INT NOT NULL,
    top_product_id BIGINT UNSIGNED,
    last_refreshed DATETIME(6) NOT NULL,
    
    INDEX idx_refreshed (last_refreshed)
) ENGINE=InnoDB;

-- Proc√©dure de rafra√Æchissement
DELIMITER //

CREATE PROCEDURE shared_reference.refresh_daily_sales_summary()
BEGIN
    DECLARE v_today DATE DEFAULT CURDATE();
    
    -- Calcul des m√©triques du jour
    INSERT INTO shared_reference.mv_daily_sales_summary (
        report_date,
        total_orders,
        total_revenue,
        avg_order_value,
        unique_customers,
        top_product_id,
        last_refreshed
    )
    SELECT 
        v_today,
        COUNT(DISTINCT o.order_id),
        COALESCE(SUM(o.total_amount), 0),
        COALESCE(AVG(o.total_amount), 0),
        COUNT(DISTINCT o.customer_id),
        (
            SELECT oi2.product_id 
            FROM orders_svc.order_items oi2
            JOIN orders_svc.orders o2 ON oi2.order_id = o2.order_id
            WHERE DATE(o2.ordered_at) = v_today
            GROUP BY oi2.product_id
            ORDER BY SUM(oi2.quantity) DESC
            LIMIT 1
        ),
        NOW(6)
    FROM orders_svc.orders o
    WHERE DATE(o.ordered_at) = v_today
      AND o.status NOT IN ('draft', 'cancelled')
    ON DUPLICATE KEY UPDATE
        total_orders = VALUES(total_orders),
        total_revenue = VALUES(total_revenue),
        avg_order_value = VALUES(avg_order_value),
        unique_customers = VALUES(unique_customers),
        top_product_id = VALUES(top_product_id),
        last_refreshed = VALUES(last_refreshed);
END //

DELIMITER ;

-- Event scheduler pour rafra√Æchissement p√©riodique
CREATE EVENT shared_reference.evt_refresh_sales_summary
ON SCHEDULE EVERY 15 MINUTE
STARTS CURRENT_TIMESTAMP
DO
    CALL shared_reference.refresh_daily_sales_summary();
```

---

## Gouvernance et conventions

Le succ√®s du Shared Database pattern repose sur une **gouvernance stricte** pour √©viter le chaos architectural.

### R√®gles de propri√©t√© des donn√©es

```sql
-- ============================================================
-- TABLE DE M√âTADONN√âES : Propri√©t√© des sch√©mas/tables
-- ============================================================
USE shared_reference;

CREATE TABLE data_ownership (
    schema_name VARCHAR(64) NOT NULL,
    table_name VARCHAR(64) NOT NULL,
    owner_service VARCHAR(100) NOT NULL,
    owner_team VARCHAR(100) NOT NULL,
    data_classification ENUM('public', 'internal', 'confidential', 'restricted') 
                        DEFAULT 'internal',
    allowed_readers JSON,  -- Liste des services autoris√©s en lecture
    change_policy ENUM('notify', 'approve', 'coordinate') DEFAULT 'notify',
    documentation_url VARCHAR(500),
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
               ON UPDATE CURRENT_TIMESTAMP(6),
    
    PRIMARY KEY (schema_name, table_name),
    INDEX idx_owner (owner_service)
) ENGINE=InnoDB;

-- Enregistrement de la propri√©t√©
INSERT INTO data_ownership VALUES
('customers_svc', 'customers', 'customer-service', 'team-customers', 
 'confidential', '["orders-service", "reporting-service"]', 'approve',
 'https://wiki/data/customers', NOW(6), NOW(6)),
 
('customers_svc', 'addresses', 'customer-service', 'team-customers',
 'confidential', '["orders-service", "shipping-service"]', 'notify',
 'https://wiki/data/addresses', NOW(6), NOW(6)),
 
('orders_svc', 'orders', 'order-service', 'team-orders',
 'internal', '["reporting-service", "shipping-service"]', 'notify',
 'https://wiki/data/orders', NOW(6), NOW(6)),
 
('inventory_svc', 'products', 'inventory-service', 'team-catalog',
 'public', '["*"]', 'notify',
 'https://wiki/data/products', NOW(6), NOW(6)),
 
('inventory_svc', 'stock', 'inventory-service', 'team-warehouse',
 'internal', '["orders-service"]', 'coordinate',
 'https://wiki/data/stock', NOW(6), NOW(6));
```

### Conventions de nommage

Adoptez des conventions strictes pour identifier rapidement les propri√©taires :

```sql
-- Convention recommand√©e :
-- Sch√©mas : {service}_svc (ex: orders_svc, customers_svc)
-- Tables : {entity} ou {service_prefix}_{entity} si ambigu
-- Vues cross-schema : v_{source}_{purpose} (ex: v_customers_for_orders)
-- Proc√©dures : sp_{action}_{entity} (ex: sp_create_order)
-- Triggers : trg_{table}_{event}_{action} (ex: trg_orders_after_insert_audit)

-- V√©rification des conventions via requ√™te
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    TABLE_TYPE,
    CASE 
        WHEN TABLE_SCHEMA LIKE '%_svc' THEN '‚úÖ Convention OK'
        WHEN TABLE_SCHEMA = 'shared_reference' THEN '‚úÖ Sch√©ma partag√©'
        ELSE '‚ö†Ô∏è Naming non-conforme'
    END AS schema_compliance,
    CASE
        WHEN TABLE_TYPE = 'VIEW' AND TABLE_NAME LIKE 'v_%' THEN '‚úÖ Vue OK'
        WHEN TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME NOT LIKE 'v_%' THEN '‚úÖ Table OK'
        ELSE '‚ö†Ô∏è Naming non-conforme'
    END AS name_compliance
FROM information_schema.TABLES
WHERE TABLE_SCHEMA NOT IN ('mysql', 'information_schema', 
                           'performance_schema', 'sys')
ORDER BY TABLE_SCHEMA, TABLE_NAME;
```

### Audit des acc√®s cross-schema

```sql
-- ============================================================
-- AUDIT DES ACC√àS INTER-SCH√âMAS
-- ============================================================

-- Activation du Server Audit Plugin
INSTALL SONAME 'server_audit';

SET GLOBAL server_audit_logging = ON;
SET GLOBAL server_audit_events = 'QUERY_DDL,QUERY_DML';
SET GLOBAL server_audit_incl_users = 'orders_app,customers_app,inventory_app';

-- Table d'analyse des requ√™tes cross-schema (aliment√©e par analyse des logs)
CREATE TABLE shared_reference.cross_schema_access_log (
    log_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    timestamp DATETIME(6) NOT NULL,
    user_name VARCHAR(100) NOT NULL,
    source_schema VARCHAR(64),
    accessed_schemas JSON NOT NULL,  -- Liste des sch√©mas acc√©d√©s
    query_type ENUM('SELECT', 'INSERT', 'UPDATE', 'DELETE', 'DDL') NOT NULL,
    query_fingerprint VARCHAR(64) NOT NULL,  -- Hash de la requ√™te normalis√©e
    execution_time_ms INT UNSIGNED,
    
    INDEX idx_timestamp (timestamp),
    INDEX idx_user (user_name),
    INDEX idx_fingerprint (query_fingerprint)
) ENGINE=InnoDB;

-- Vue d'analyse des patterns d'acc√®s
CREATE OR REPLACE VIEW shared_reference.v_cross_schema_patterns AS
SELECT 
    user_name,
    JSON_EXTRACT(accessed_schemas, '$[0]') AS primary_schema,
    accessed_schemas,
    query_type,
    COUNT(*) AS occurrence_count,
    AVG(execution_time_ms) AS avg_execution_ms,
    MAX(timestamp) AS last_access
FROM shared_reference.cross_schema_access_log
WHERE JSON_LENGTH(accessed_schemas) > 1  -- Requ√™tes multi-sch√©mas uniquement
GROUP BY user_name, accessed_schemas, query_type
ORDER BY occurrence_count DESC;
```

---

## Gestion de la concurrence

Le partage d'une base unique n√©cessite une attention particuli√®re √† la **contention des ressources**.

### Monitoring des verrous

```sql
-- ============================================================
-- SURVEILLANCE DES VERROUS INTER-SERVICES
-- ============================================================

-- Vue des verrous actifs par sch√©ma
CREATE OR REPLACE VIEW shared_reference.v_active_locks_by_schema AS
SELECT 
    r.trx_id AS waiting_trx,
    r.trx_mysql_thread_id AS waiting_thread,
    SUBSTRING_INDEX(r.trx_query, ' ', 3) AS waiting_query_preview,
    b.trx_id AS blocking_trx,
    b.trx_mysql_thread_id AS blocking_thread,
    SUBSTRING_INDEX(b.trx_query, ' ', 3) AS blocking_query_preview,
    TIMESTAMPDIFF(SECOND, r.trx_wait_started, NOW()) AS wait_seconds,
    l.lock_table AS locked_table,
    l.lock_mode,
    l.lock_type
FROM information_schema.INNODB_LOCK_WAITS w
JOIN information_schema.INNODB_TRX r ON w.requesting_trx_id = r.trx_id
JOIN information_schema.INNODB_TRX b ON w.blocking_trx_id = b.trx_id
JOIN information_schema.INNODB_LOCKS l ON w.requested_lock_id = l.lock_id;

-- Proc√©dure d'alerte sur verrous prolong√©s
DELIMITER //

CREATE PROCEDURE shared_reference.check_long_running_locks(
    IN p_threshold_seconds INT
)
BEGIN
    SELECT 
        trx_id,
        trx_state,
        trx_mysql_thread_id AS thread_id,
        trx_query,
        TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS duration_seconds,
        trx_tables_locked,
        trx_rows_locked
    FROM information_schema.INNODB_TRX
    WHERE trx_state = 'LOCK WAIT'
      AND TIMESTAMPDIFF(SECOND, trx_wait_started, NOW()) > p_threshold_seconds
    ORDER BY trx_wait_started;
END //

DELIMITER ;

-- Ex√©cution p√©riodique
-- CALL shared_reference.check_long_running_locks(30);
```

### Strat√©gies d'isolation par service

```sql
-- ============================================================
-- CONFIGURATION DE L'ISOLATION PAR TYPE DE SERVICE
-- ============================================================

-- Service OLTP (commandes, clients) : isolation standard
-- Configuration au niveau session via l'application

-- Service Reporting : lectures non-bloquantes
-- Utiliser READ UNCOMMITTED pour les rapports (dirty reads acceptables)

-- Exemple de proc√©dure reporting avec isolation adapt√©e
DELIMITER //

CREATE PROCEDURE shared_reference.generate_sales_report(
    IN p_start_date DATE,
    IN p_end_date DATE
)
BEGIN
    -- Isolation r√©duite pour √©viter de bloquer les transactions OLTP
    SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
    
    SELECT 
        DATE(o.ordered_at) AS order_date,
        COUNT(DISTINCT o.order_id) AS order_count,
        SUM(o.total_amount) AS revenue,
        COUNT(DISTINCT o.customer_id) AS unique_customers,
        SUM(oi.quantity) AS items_sold
    FROM orders_svc.orders o
    LEFT JOIN orders_svc.order_items oi ON o.order_id = oi.order_id
    WHERE o.ordered_at BETWEEN p_start_date AND p_end_date
      AND o.status NOT IN ('draft', 'cancelled')
    GROUP BY DATE(o.ordered_at)
    ORDER BY order_date;
    
    -- Restauration de l'isolation par d√©faut
    SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
END //

DELIMITER ;
```

### Resource Groups pour priorisation üÜï

MariaDB 11.8 permet d'allouer des ressources diff√©renci√©es par type de workload :

```sql
-- ============================================================
-- RESOURCE GROUPS PAR TYPE DE SERVICE (MariaDB 11.8)
-- ============================================================

-- Groupe haute priorit√© pour les transactions OLTP critiques
CREATE RESOURCE GROUP rg_oltp_critical
    TYPE = USER
    VCPU = 0-7
    THREAD_PRIORITY = -10;  -- Haute priorit√©

-- Groupe standard pour les op√©rations courantes
CREATE RESOURCE GROUP rg_oltp_standard
    TYPE = USER
    VCPU = 0-15
    THREAD_PRIORITY = 0;

-- Groupe basse priorit√© pour le reporting
CREATE RESOURCE GROUP rg_reporting
    TYPE = USER
    VCPU = 8-15
    THREAD_PRIORITY = 10;  -- Basse priorit√©

-- Attribution aux threads des services
-- (√† ex√©cuter depuis l'application selon le contexte)

-- Transaction critique (paiement)
SET RESOURCE GROUP rg_oltp_critical;
-- ... requ√™tes de paiement ...

-- Rapport de fin de journ√©e
SET RESOURCE GROUP rg_reporting;
-- ... requ√™tes analytiques ...
```

‚ö†Ô∏è **Attention** : Les Resource Groups n√©cessitent les privil√®ges `RESOURCE_GROUP_ADMIN` et une configuration syst√®me appropri√©e (capabilities Linux).

---

## Strat√©gies de migration progressive

Le Shared Database pattern peut servir d'**√©tape interm√©diaire** vers une architecture plus d√©coupl√©e.

### √âtape 1 : Identification des fronti√®res

```sql
-- ============================================================
-- ANALYSE DES D√âPENDANCES POUR D√âCOUPAGE
-- ============================================================

-- Identifier les tables fortement coupl√©es (FK cross-schema)
SELECT 
    kcu.TABLE_SCHEMA AS dependent_schema,
    kcu.TABLE_NAME AS dependent_table,
    kcu.REFERENCED_TABLE_SCHEMA AS referenced_schema,
    kcu.REFERENCED_TABLE_NAME AS referenced_table,
    kcu.CONSTRAINT_NAME
FROM information_schema.KEY_COLUMN_USAGE kcu
WHERE kcu.REFERENCED_TABLE_NAME IS NOT NULL
  AND kcu.TABLE_SCHEMA != kcu.REFERENCED_TABLE_SCHEMA
ORDER BY dependent_schema, referenced_schema;

-- Identifier les requ√™tes cross-schema les plus fr√©quentes
-- (Analyse du slow query log ou performance_schema)
SELECT 
    DIGEST_TEXT,
    COUNT_STAR AS execution_count,
    SUM_TIMER_WAIT / 1000000000000 AS total_time_sec,
    AVG_TIMER_WAIT / 1000000000 AS avg_time_ms
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE '%JOIN%'
  AND (DIGEST_TEXT LIKE '%orders_svc%' OR DIGEST_TEXT LIKE '%customers_svc%')
ORDER BY execution_count DESC
LIMIT 20;
```

### √âtape 2 : Introduction du pattern Outbox

Pr√©parer la communication √©v√©nementielle tout en conservant la base partag√©e :

```sql
-- ============================================================
-- TABLES OUTBOX POUR TRANSITION VERS EVENT-DRIVEN
-- ============================================================

-- Outbox dans chaque sch√©ma de service
CREATE TABLE customers_svc.outbox_events (
    event_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    aggregate_type VARCHAR(50) NOT NULL,
    aggregate_id BIGINT UNSIGNED NOT NULL,
    event_type VARCHAR(100) NOT NULL,
    payload JSON NOT NULL,
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    published_at DATETIME(6) NULL,
    
    INDEX idx_unpublished (published_at, created_at),
    INDEX idx_aggregate (aggregate_type, aggregate_id)
) ENGINE=InnoDB;

-- Trigger pour capturer les modifications
DELIMITER //

CREATE TRIGGER customers_svc.trg_customer_changes_to_outbox
AFTER UPDATE ON customers_svc.customers
FOR EACH ROW
BEGIN
    INSERT INTO customers_svc.outbox_events 
        (aggregate_type, aggregate_id, event_type, payload)
    VALUES (
        'Customer',
        NEW.customer_id,
        CASE 
            WHEN OLD.status != NEW.status THEN 'CustomerStatusChanged'
            ELSE 'CustomerUpdated'
        END,
        JSON_OBJECT(
            'customer_id', NEW.customer_id,
            'changes', JSON_OBJECT(
                'old', JSON_OBJECT('name', OLD.name, 'email', OLD.email, 'status', OLD.status),
                'new', JSON_OBJECT('name', NEW.name, 'email', NEW.email, 'status', NEW.status)
            ),
            'timestamp', NOW(6)
        )
    );
END //

DELIMITER ;
```

### √âtape 3 : Duplication asynchrone des donn√©es

Commencer √† maintenir des copies locales aliment√©es par √©v√©nements :

```sql
-- ============================================================
-- PROJECTION LOCALE DES DONN√âES CLIENTS DANS ORDERS_SVC
-- ============================================================

CREATE TABLE orders_svc.customer_projections (
    customer_id BIGINT UNSIGNED PRIMARY KEY,
    external_id VARCHAR(64) NOT NULL,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL,
    default_shipping_address JSON,
    source_version BIGINT UNSIGNED NOT NULL,  -- Pour idempotence
    projected_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    
    INDEX idx_external (external_id)
) ENGINE=InnoDB;

-- Proc√©dure de synchronisation (appel√©e par le consommateur d'√©v√©nements)
DELIMITER //

CREATE PROCEDURE orders_svc.project_customer_event(
    IN p_event_id BIGINT UNSIGNED,
    IN p_customer_id BIGINT UNSIGNED,
    IN p_payload JSON
)
BEGIN
    DECLARE v_current_version BIGINT UNSIGNED;
    
    SELECT source_version INTO v_current_version
    FROM orders_svc.customer_projections
    WHERE customer_id = p_customer_id;
    
    -- Mise √† jour uniquement si √©v√©nement plus r√©cent (idempotence)
    IF v_current_version IS NULL OR p_event_id > v_current_version THEN
        INSERT INTO orders_svc.customer_projections (
            customer_id, external_id, name, email, 
            default_shipping_address, source_version
        )
        SELECT 
            p_customer_id,
            JSON_UNQUOTE(JSON_EXTRACT(p_payload, '$.changes.new.external_id')),
            JSON_UNQUOTE(JSON_EXTRACT(p_payload, '$.changes.new.name')),
            JSON_UNQUOTE(JSON_EXTRACT(p_payload, '$.changes.new.email')),
            (SELECT JSON_OBJECT(
                'street', a.street_line1,
                'city', a.city,
                'postal_code', a.postal_code
             )
             FROM customers_svc.addresses a
             WHERE a.customer_id = p_customer_id 
               AND a.is_default = TRUE 
               AND a.address_type = 'shipping'),
            p_event_id
        ON DUPLICATE KEY UPDATE
            external_id = VALUES(external_id),
            name = VALUES(name),
            email = VALUES(email),
            default_shipping_address = VALUES(default_shipping_address),
            source_version = VALUES(source_version),
            projected_at = NOW(6);
    END IF;
END //

DELIMITER ;
```

### √âtape 4 : Bascule progressive des requ√™tes

```sql
-- ============================================================
-- MIGRATION PROGRESSIVE DES LECTURES
-- ============================================================

-- Vue de transition : lit depuis la projection locale si disponible,
-- sinon fallback sur la source (cross-schema)
CREATE OR REPLACE VIEW orders_svc.v_customer_data AS
SELECT 
    COALESCE(cp.customer_id, c.customer_id) AS customer_id,
    COALESCE(cp.external_id, c.external_id) AS external_id,
    COALESCE(cp.name, c.name) AS name,
    COALESCE(cp.email, c.email) AS email,
    COALESCE(cp.default_shipping_address, 
             JSON_OBJECT(
                 'street', a.street_line1,
                 'city', a.city,
                 'postal_code', a.postal_code
             )) AS default_shipping_address,
    CASE WHEN cp.customer_id IS NOT NULL THEN 'projection' ELSE 'source' END AS data_source
FROM customers_svc.customers c
LEFT JOIN customers_svc.addresses a ON c.customer_id = a.customer_id 
    AND a.is_default = TRUE AND a.address_type = 'shipping'
LEFT JOIN orders_svc.customer_projections cp ON c.customer_id = cp.customer_id
WHERE c.status = 'active';

-- Monitoring de la couverture de la projection
SELECT 
    data_source,
    COUNT(*) AS customer_count,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) AS percentage
FROM orders_svc.v_customer_data
GROUP BY data_source;
-- +------------+----------------+------------+
-- | data_source| customer_count | percentage |
-- +------------+----------------+------------+
-- | projection |          8500  |      85.00 |
-- | source     |          1500  |      15.00 |
-- +------------+----------------+------------+
```

---

## Comparaison avec Database per Service

| Crit√®re | Shared Database | Database per Service |
|---------|-----------------|----------------------|
| **Coh√©rence transactionnelle** | ‚úÖ ACID native | ‚ö†Ô∏è √âventuelle (Sagas) |
| **Jointures cross-domaines** | ‚úÖ SQL standard | ‚ùå API Composition |
| **Autonomie des √©quipes** | ‚ö†Ô∏è Coordination requise | ‚úÖ Ind√©pendance totale |
| **Scalabilit√© granulaire** | ‚ùå Instance unique | ‚úÖ Par service |
| **Isolation des pannes** | ‚ùå SPOF potentiel | ‚úÖ Isolation compl√®te |
| **Complexit√© op√©rationnelle** | ‚úÖ Une seule base | ‚ö†Ô∏è N bases √† g√©rer |
| **Co√ªt infrastructure** | ‚úÖ Optimis√© | ‚ö†Ô∏è Plus √©lev√© |
| **√âvolution de sch√©ma** | ‚ö†Ô∏è Coordination | ‚úÖ Ind√©pendante |
| **Performance requ√™tes** | ‚úÖ Jointures locales | ‚ö†Ô∏è Latence r√©seau |
| **D√©ploiement ind√©pendant** | ‚ö†Ô∏è Limit√© | ‚úÖ Total |

---

## Quand utiliser ce pattern ?

### ‚úÖ Recommand√© pour :

- **√âquipes r√©duites** g√©rant l'ensemble de l'application
- Applications avec **nombreuses jointures cross-domaines** essentielles
- Projets n√©cessitant une **coh√©rence transactionnelle forte**
- **Budgets limit√©s** ne permettant pas une infrastructure distribu√©e
- **Phase de transition** d'un monolithe vers des microservices
- **Startups** en phase de validation produit (time-to-market)
- Domaines avec **faible taux de changement** du mod√®le de donn√©es

### ‚ùå D√©conseill√© pour :

- **Grandes organisations** avec √©quipes autonomes par domaine
- Applications n√©cessitant une **scalabilit√© ind√©pendante** des composants
- Syst√®mes o√π l'**isolation des pannes** est critique
- Projets avec **cycles de release tr√®s diff√©rents** par fonctionnalit√©
- Domaines avec des **SLA tr√®s diff√©rents** (ex: e-commerce vs analytics)
- √âquipes g√©ographiquement distribu√©es avec **fuseaux horaires d√©cal√©s**

---

## Anti-patterns √† √©viter

### ‚ùå Acc√®s direct sans gouvernance

```sql
-- ‚ùå ANTI-PATTERN : Acc√®s direct d'un service aux tables d'un autre
-- Sans vues, sans privil√®ges granulaires, sans documentation

SELECT * FROM customers_svc.customers;  -- Acc√®s trop large
UPDATE customers_svc.customers SET status = 'active';  -- Modification non autoris√©e
```

### ‚ùå Foreign keys cross-schema rigides

```sql
-- ‚ùå ANTI-PATTERN : FK cross-schema cr√©ant un couplage fort
-- Rend impossible la s√©paration future des bases

ALTER TABLE orders_svc.orders
ADD CONSTRAINT fk_customer 
FOREIGN KEY (customer_id) REFERENCES customers_svc.customers(customer_id);
-- Cela bloque la migration vers Database per Service
```

### ‚ùå Transactions englobant tous les services

```sql
-- ‚ùå ANTI-PATTERN : Transaction g√©ante multi-services
START TRANSACTION;
    UPDATE customers_svc.customers SET ...;
    INSERT INTO orders_svc.orders ...;
    UPDATE inventory_svc.stock ...;
    INSERT INTO payments_svc.transactions ...;
    UPDATE shipping_svc.shipments ...;
COMMIT;
-- Verrous trop larges, contention maximale
```

### ‚úÖ Bonnes pratiques

```sql
-- ‚úÖ Acc√®s via vues contr√¥l√©es
SELECT * FROM orders_svc.v_customers_for_orders WHERE customer_id = ?;

-- ‚úÖ R√©f√©rences par ID uniquement, pas de FK cross-schema
CREATE TABLE orders_svc.orders (
    customer_id BIGINT UNSIGNED NOT NULL,  -- ID seulement, pas de FK
    -- Snapshot des donn√©es pour autonomie
    customer_snapshot JSON NOT NULL
);

-- ‚úÖ Transactions limit√©es √† un domaine
START TRANSACTION;
    INSERT INTO orders_svc.orders ...;
    INSERT INTO orders_svc.order_items ...;
COMMIT;
-- La r√©servation stock est g√©r√©e s√©par√©ment via √©v√©nement ou appel API
```

---

## ‚úÖ Points cl√©s √† retenir

- Le **Shared Database pattern** n'est pas intrins√®quement mauvais : c'est un compromis architectural adapt√© √† certains contextes
- L'isolation par **sch√©mas s√©par√©s** avec privil√®ges granulaires offre un bon √©quilibre entre simplicit√© et d√©couplage
- Les **vues** cr√©ent une couche d'abstraction facilitant l'√©volution ind√©pendante du sch√©ma physique
- La **gouvernance** (propri√©t√© des donn√©es, conventions, audit) est essentielle au succ√®s du pattern
- Les **transactions ACID cross-schema** sont un avantage majeur par rapport au pattern Database per Service
- La **gestion de la concurrence** (verrous, Resource Groups) n√©cessite une attention particuli√®re
- Le pattern peut servir d'**√©tape interm√©diaire** vers une architecture plus d√©coupl√©e via le pattern Outbox
- √âvitez les **anti-patterns** : FK cross-schema, acc√®s directs non contr√¥l√©s, transactions g√©antes

---

## üîó Ressources et r√©f√©rences

- üìñ [MariaDB Documentation - CREATE DATABASE](https://mariadb.com/kb/en/create-database/)
- üìñ [MariaDB Documentation - GRANT](https://mariadb.com/kb/en/grant/)
- üìñ [MariaDB Documentation - Roles](https://mariadb.com/kb/en/roles/)
- üìñ [MariaDB Documentation - Views](https://mariadb.com/kb/en/views/)
- üìñ [Pattern: Shared Database - microservices.io](https://microservices.io/patterns/data/shared-database.html)
- üìñ [Monolith First - Martin Fowler](https://martinfowler.com/bliki/MonolithFirst.html)
- üìñ [Database Refactoring - Scott Ambler](https://www.agiledata.org/essays/databaseRefactoring.html)

---

## ‚û°Ô∏è Section suivante

**20.3 Data Warehousing avec ColumnStore** : D√©couvrez comment utiliser le moteur ColumnStore de MariaDB pour construire un entrep√¥t de donn√©es analytique performant, capable de traiter des milliards de lignes avec des requ√™tes OLAP complexes.

‚è≠Ô∏è [Data warehousing avec ColumnStore](/20-cas-usage-architectures/03-data-warehousing-columnstore.md)
