üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.4.3 Shared Schema avec Discriminateur

> **Niveau** : Interm√©diaire √† Avanc√©  
> **Dur√©e estim√©e** : 2h30  
> **Pr√©requis** : Chapitre 5 (Index et Performance), Chapitre 10 (S√©curit√©), Section 20.4.1 (Database per Tenant), Section 20.4.2 (Schema per Tenant)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :

- Concevoir une architecture multi-tenant avec sch√©ma partag√© et colonne discriminante
- Impl√©menter des strat√©gies d'indexation optimis√©es pour les requ√™tes multi-tenant
- Mettre en place une isolation logique robuste au niveau applicatif
- Utiliser le partitionnement pour am√©liorer les performances par tenant
- Appliquer les bonnes pratiques de s√©curit√© pour pr√©venir les fuites de donn√©es
- √âvaluer les avantages et limites de ce pattern par rapport aux alternatives

---

## Introduction

Le pattern **Shared Schema avec Discriminateur** (ou **Shared Tables**) repr√©sente l'approche la plus **efficiente en ressources** pour les architectures multi-tenant. Tous les tenants partagent les **m√™mes tables** dans un **m√™me sch√©ma**, diff√©renci√©s uniquement par une **colonne discriminante** (g√©n√©ralement `tenant_id`).

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              SHARED SCHEMA AVEC DISCRIMINATEUR                         ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ                    APPLICATION SaaS                             ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ              (Filtrage tenant_id obligatoire)                   ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                              ‚îÇ                                         ‚îÇ
‚îÇ                              ‚ñº                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ                   INSTANCE MariaDB 11.8                           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ                                                                   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ                    DATABASE saas_app                        ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ                                                             ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  TABLE users                                                ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇtenant_id ‚îÇ user_id ‚îÇ email       ‚îÇ name         ‚îÇ        ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§        ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ acme     ‚îÇ 1       ‚îÇ john@...    ‚îÇ John Doe     ‚îÇ        ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ acme     ‚îÇ 2       ‚îÇ jane@...    ‚îÇ Jane Smith   ‚îÇ        ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ globex   ‚îÇ 3       ‚îÇ bob@...     ‚îÇ Bob Wilson   ‚îÇ        ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ initech  ‚îÇ 4       ‚îÇ alice@...   ‚îÇ Alice Brown  ‚îÇ        ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ globex   ‚îÇ 5       ‚îÇ carol@...   ‚îÇ Carol White  ‚îÇ        ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ                                                             ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  TABLE orders                                               ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇtenant_id ‚îÇ order_id ‚îÇ user_id ‚îÇ total        ‚îÇ           ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§           ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ acme     ‚îÇ 1001     ‚îÇ 1       ‚îÇ 299.99       ‚îÇ           ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ globex   ‚îÇ 1002     ‚îÇ 3       ‚îÇ 149.50       ‚îÇ           ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ ...      ‚îÇ ...      ‚îÇ ...     ‚îÇ ...          ‚îÇ           ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  Isolation : ‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë Minimale (logique applicative)               ‚îÇ
‚îÇ  Co√ªt/tenant : ‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë Minimal                                    ‚îÇ
‚îÇ  Complexit√© ops : ‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë Faible                                  ‚îÇ
‚îÇ  Scalabilit√© : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà Maximale                                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Ce pattern est id√©al pour les **applications B2C**, les **SaaS avec un tr√®s grand nombre de petits tenants**, ou les syst√®mes o√π l'**efficacit√© des ressources** prime sur l'isolation stricte.

---

## Principes fondamentaux

### Le discriminateur : cl√© de l'isolation

Le **discriminateur** (ou **tenant discriminator**) est une colonne pr√©sente dans **chaque table** contenant des donn√©es sp√©cifiques aux tenants. Cette colonne permet de filtrer les donn√©es par tenant.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ANATOMIE D'UNE TABLE MULTI-TENANT                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                          TABLE: orders                                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                                     ‚îÇ
‚îÇ  ‚îÇ  tenant_id     ‚îÇ ‚óÑ‚îÄ‚îÄ DISCRIMINATEUR (colonne de partition logique)   ‚îÇ
‚îÇ  ‚îÇ  VARCHAR(36)   ‚îÇ     - Pr√©sent dans TOUTES les tables tenant         ‚îÇ
‚îÇ  ‚îÇ  NOT NULL      ‚îÇ     - TOUJOURS en premi√®re position de l'index      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     - Filtr√© dans CHAQUE requ√™te                    ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                                     ‚îÇ
‚îÇ  ‚îÇ  order_id      ‚îÇ ‚óÑ‚îÄ‚îÄ Cl√© primaire (souvent composite avec tenant_id) ‚îÇ
‚îÇ  ‚îÇ  BIGINT        ‚îÇ                                                     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                                     ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                                     ‚îÇ
‚îÇ  ‚îÇ  user_id       ‚îÇ ‚óÑ‚îÄ‚îÄ R√©f√©rences (implicitement dans le m√™me tenant)  ‚îÇ
‚îÇ  ‚îÇ  BIGINT        ‚îÇ                                                     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                                     ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                                     ‚îÇ
‚îÇ  ‚îÇ  ...autres     ‚îÇ                                                     ‚îÇ
‚îÇ  ‚îÇ  colonnes      ‚îÇ                                                     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                                     ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îÇ  INDEX: PRIMARY KEY (tenant_id, order_id)                               ‚îÇ
‚îÇ  INDEX: idx_tenant_user (tenant_id, user_id)                            ‚îÇ
‚îÇ  INDEX: idx_tenant_date (tenant_id, created_at)                         ‚îÇ
‚îÇ                                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Types de discriminateurs

| Type | Exemple | Avantages | Inconv√©nients |
|------|---------|-----------|---------------|
| **UUID/VARCHAR(36)** | `550e8400-e29b-41d4...` | Unique global, pas de collision | Taille (36 bytes), jointures plus lentes |
| **INT/BIGINT** | `12345` | Compact, performant | N√©cessite table de mapping |
| **VARCHAR court** | `acme`, `globex` | Lisible, debugging facile | Risque collision, taille variable |
| **BINARY(16)** | UUID binaire | Compact (16 bytes), performant | Moins lisible |

üí° **Conseil** : Pour la plupart des cas, un **INT UNSIGNED** ou **BIGINT UNSIGNED** offre le meilleur compromis entre performance et simplicit√©. Utilisez une table `tenants` pour le mapping vers les slugs lisibles.

---

## Impl√©mentation avec MariaDB 11.8

### Sch√©ma de base complet

```sql
-- ============================================================
-- BASE DE DONN√âES MULTI-TENANT PARTAG√âE
-- ============================================================

CREATE DATABASE saas_shared
    CHARACTER SET utf8mb4
    COLLATE utf8mb4_uca1400_ai_ci;  -- üÜï Collation UCA 14.0.0

USE saas_shared;

-- ============================================================
-- TABLE DES TENANTS (m√©tadonn√©es)
-- ============================================================

CREATE TABLE tenants (
    tenant_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    tenant_uuid VARCHAR(36) UNIQUE NOT NULL DEFAULT (UUID()),
    tenant_slug VARCHAR(64) UNIQUE NOT NULL,
    company_name VARCHAR(255) NOT NULL,
    
    -- Contact et facturation
    billing_email VARCHAR(255) NOT NULL,
    billing_name VARCHAR(255),
    
    -- Abonnement
    subscription_plan ENUM('free', 'starter', 'professional', 'enterprise') 
                      DEFAULT 'free',
    subscription_status ENUM('trial', 'active', 'past_due', 'cancelled', 'suspended') 
                        DEFAULT 'trial',
    trial_ends_at DATETIME(6),
    
    -- Limites (NULL = illimit√©)
    max_users INT UNSIGNED,
    max_storage_bytes BIGINT UNSIGNED,
    max_api_requests_per_day INT UNSIGNED,
    
    -- Configuration
    settings JSON DEFAULT '{}',
    features JSON DEFAULT '{}',
    
    -- M√©tadonn√©es
    timezone VARCHAR(50) DEFAULT 'UTC',
    locale VARCHAR(10) DEFAULT 'en',
    currency_code CHAR(3) DEFAULT 'EUR',
    
    -- Timestamps
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
               ON UPDATE CURRENT_TIMESTAMP(6),
    activated_at DATETIME(6),
    deleted_at DATETIME(6),
    
    -- Soft delete
    is_deleted BOOLEAN DEFAULT FALSE,
    
    INDEX idx_slug (tenant_slug),
    INDEX idx_uuid (tenant_uuid),
    INDEX idx_status (subscription_status),
    INDEX idx_deleted (is_deleted, subscription_status)
) ENGINE=InnoDB;

-- ============================================================
-- TABLE DES UTILISATEURS (multi-tenant)
-- ============================================================

CREATE TABLE users (
    -- Discriminateur en premier (CRUCIAL pour les performances)
    tenant_id INT UNSIGNED NOT NULL,
    
    -- Cl√© primaire locale au tenant
    user_id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    
    -- Identifiant externe (pour APIs)
    user_uuid VARCHAR(36) NOT NULL DEFAULT (UUID()),
    
    -- Donn√©es utilisateur
    email VARCHAR(255) NOT NULL,
    password_hash VARCHAR(255),
    
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    display_name VARCHAR(200) GENERATED ALWAYS AS (
        COALESCE(NULLIF(CONCAT(first_name, ' ', last_name), ' '), email)
    ) VIRTUAL,
    
    role ENUM('owner', 'admin', 'member', 'viewer', 'guest') DEFAULT 'member',
    status ENUM('pending', 'active', 'suspended', 'deleted') DEFAULT 'pending',
    
    -- Profil
    avatar_url VARCHAR(500),
    phone VARCHAR(30),
    timezone VARCHAR(50),
    locale VARCHAR(10),
    
    -- S√©curit√©
    email_verified_at DATETIME(6),
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    last_login_at DATETIME(6),
    last_login_ip VARCHAR(45),
    failed_login_attempts INT UNSIGNED DEFAULT 0,
    locked_until DATETIME(6),
    
    -- M√©tadonn√©es
    metadata JSON DEFAULT '{}',
    
    -- Timestamps
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
               ON UPDATE CURRENT_TIMESTAMP(6),
    
    -- Cl√© primaire composite
    PRIMARY KEY (tenant_id, user_id),
    
    -- Contraintes d'unicit√© par tenant
    UNIQUE KEY uk_tenant_email (tenant_id, email),
    UNIQUE KEY uk_tenant_uuid (tenant_id, user_uuid),
    
    -- Index optimis√©s (tenant_id toujours en premier)
    INDEX idx_tenant_status (tenant_id, status),
    INDEX idx_tenant_role (tenant_id, role),
    INDEX idx_tenant_created (tenant_id, created_at DESC),
    INDEX idx_tenant_login (tenant_id, last_login_at DESC),
    
    -- Cl√© √©trang√®re vers tenants
    CONSTRAINT fk_users_tenant 
        FOREIGN KEY (tenant_id) REFERENCES tenants(tenant_id)
        ON DELETE CASCADE
) ENGINE=InnoDB;

-- ============================================================
-- TABLE DES PRODUITS (multi-tenant)
-- ============================================================

CREATE TABLE products (
    tenant_id INT UNSIGNED NOT NULL,
    product_id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    product_uuid VARCHAR(36) NOT NULL DEFAULT (UUID()),
    
    -- Identification
    sku VARCHAR(100),
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(255),
    description TEXT,
    
    -- Cat√©gorisation
    category_path VARCHAR(500),  -- Ex: "Electronics/Computers/Laptops"
    tags JSON DEFAULT '[]',
    
    -- Prix et taxes
    price DECIMAL(12,2) NOT NULL DEFAULT 0,
    compare_at_price DECIMAL(12,2),
    cost_price DECIMAL(12,2),
    currency_code CHAR(3) DEFAULT 'EUR',
    tax_rate DECIMAL(6,4) DEFAULT 0,
    tax_included BOOLEAN DEFAULT FALSE,
    
    -- Inventaire
    track_inventory BOOLEAN DEFAULT TRUE,
    quantity_in_stock INT DEFAULT 0,
    quantity_reserved INT DEFAULT 0,
    quantity_available INT GENERATED ALWAYS AS (
        quantity_in_stock - quantity_reserved
    ) VIRTUAL,
    low_stock_threshold INT DEFAULT 10,
    
    -- Physique
    weight_grams INT UNSIGNED,
    dimensions JSON,  -- {length, width, height, unit}
    
    -- √âtat
    status ENUM('draft', 'active', 'archived') DEFAULT 'draft',
    is_visible BOOLEAN DEFAULT TRUE,
    
    -- SEO
    meta_title VARCHAR(255),
    meta_description VARCHAR(500),
    
    -- M√©tadonn√©es
    metadata JSON DEFAULT '{}',
    
    -- Timestamps
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
               ON UPDATE CURRENT_TIMESTAMP(6),
    published_at DATETIME(6),
    
    PRIMARY KEY (tenant_id, product_id),
    UNIQUE KEY uk_tenant_uuid (tenant_id, product_uuid),
    UNIQUE KEY uk_tenant_sku (tenant_id, sku),
    UNIQUE KEY uk_tenant_slug (tenant_id, slug),
    
    INDEX idx_tenant_status (tenant_id, status),
    INDEX idx_tenant_category (tenant_id, category_path(100)),
    INDEX idx_tenant_price (tenant_id, price),
    INDEX idx_tenant_created (tenant_id, created_at DESC),
    
    -- Full-text search (tenant-aware via application)
    FULLTEXT INDEX ft_search (name, description),
    
    CONSTRAINT fk_products_tenant 
        FOREIGN KEY (tenant_id) REFERENCES tenants(tenant_id)
        ON DELETE CASCADE
) ENGINE=InnoDB;

-- ============================================================
-- TABLE DES CLIENTS (multi-tenant)
-- ============================================================

CREATE TABLE customers (
    tenant_id INT UNSIGNED NOT NULL,
    customer_id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    customer_uuid VARCHAR(36) NOT NULL DEFAULT (UUID()),
    
    -- Contact
    email VARCHAR(255),
    phone VARCHAR(30),
    
    -- Identification
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    company_name VARCHAR(255),
    
    -- Adresses (stock√©es en JSON pour flexibilit√©)
    default_billing_address JSON,
    default_shipping_address JSON,
    
    -- Fiscalit√©
    tax_exempt BOOLEAN DEFAULT FALSE,
    tax_id VARCHAR(50),
    
    -- Relation
    customer_group VARCHAR(50),
    accepts_marketing BOOLEAN DEFAULT FALSE,
    
    -- Notes
    notes TEXT,
    tags JSON DEFAULT '[]',
    
    -- M√©tadonn√©es
    metadata JSON DEFAULT '{}',
    
    -- Timestamps
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
               ON UPDATE CURRENT_TIMESTAMP(6),
    
    PRIMARY KEY (tenant_id, customer_id),
    UNIQUE KEY uk_tenant_uuid (tenant_id, customer_uuid),
    
    INDEX idx_tenant_email (tenant_id, email),
    INDEX idx_tenant_company (tenant_id, company_name(100)),
    INDEX idx_tenant_created (tenant_id, created_at DESC),
    
    FULLTEXT INDEX ft_customer_search (first_name, last_name, company_name, email),
    
    CONSTRAINT fk_customers_tenant 
        FOREIGN KEY (tenant_id) REFERENCES tenants(tenant_id)
        ON DELETE CASCADE
) ENGINE=InnoDB;

-- ============================================================
-- TABLE DES COMMANDES (multi-tenant)
-- ============================================================

CREATE TABLE orders (
    tenant_id INT UNSIGNED NOT NULL,
    order_id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    order_uuid VARCHAR(36) NOT NULL DEFAULT (UUID()),
    
    -- Num√©ro de commande (unique par tenant)
    order_number VARCHAR(32) NOT NULL,
    
    -- Relations
    customer_id BIGINT UNSIGNED,
    user_id BIGINT UNSIGNED,  -- Utilisateur qui a cr√©√© la commande
    
    -- √âtat
    status ENUM('draft', 'pending', 'confirmed', 'processing', 
                'shipped', 'delivered', 'cancelled', 'refunded') DEFAULT 'draft',
    payment_status ENUM('pending', 'authorized', 'paid', 'partially_refunded', 
                        'refunded', 'failed') DEFAULT 'pending',
    fulfillment_status ENUM('unfulfilled', 'partial', 'fulfilled', 'returned') 
                       DEFAULT 'unfulfilled',
    
    -- Montants
    subtotal DECIMAL(14,2) NOT NULL DEFAULT 0,
    discount_amount DECIMAL(14,2) NOT NULL DEFAULT 0,
    shipping_amount DECIMAL(14,2) NOT NULL DEFAULT 0,
    tax_amount DECIMAL(14,2) NOT NULL DEFAULT 0,
    total_amount DECIMAL(14,2) GENERATED ALWAYS AS (
        subtotal - discount_amount + shipping_amount + tax_amount
    ) STORED,
    
    currency_code CHAR(3) DEFAULT 'EUR',
    exchange_rate DECIMAL(12,6) DEFAULT 1.000000,
    
    -- Adresses (snapshot au moment de la commande)
    billing_address JSON,
    shipping_address JSON,
    
    -- Codes promo
    discount_codes JSON DEFAULT '[]',
    
    -- Notes
    customer_notes TEXT,
    internal_notes TEXT,
    
    -- Dates importantes
    ordered_at DATETIME(6),
    confirmed_at DATETIME(6),
    paid_at DATETIME(6),
    shipped_at DATETIME(6),
    delivered_at DATETIME(6),
    cancelled_at DATETIME(6),
    
    -- Source
    source_name VARCHAR(50),  -- 'web', 'mobile', 'api', 'pos'
    source_identifier VARCHAR(100),
    
    -- M√©tadonn√©es
    metadata JSON DEFAULT '{}',
    
    -- Timestamps
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
               ON UPDATE CURRENT_TIMESTAMP(6),
    
    PRIMARY KEY (tenant_id, order_id),
    UNIQUE KEY uk_tenant_uuid (tenant_id, order_uuid),
    UNIQUE KEY uk_tenant_number (tenant_id, order_number),
    
    INDEX idx_tenant_customer (tenant_id, customer_id),
    INDEX idx_tenant_status (tenant_id, status),
    INDEX idx_tenant_payment (tenant_id, payment_status),
    INDEX idx_tenant_ordered (tenant_id, ordered_at DESC),
    INDEX idx_tenant_created (tenant_id, created_at DESC),
    
    -- Index composite pour les recherches courantes
    INDEX idx_tenant_status_date (tenant_id, status, ordered_at DESC),
    
    CONSTRAINT fk_orders_tenant 
        FOREIGN KEY (tenant_id) REFERENCES tenants(tenant_id)
        ON DELETE CASCADE,
    CONSTRAINT fk_orders_customer 
        FOREIGN KEY (tenant_id, customer_id) 
        REFERENCES customers(tenant_id, customer_id)
        ON DELETE SET NULL
) ENGINE=InnoDB;

-- ============================================================
-- TABLE DES LIGNES DE COMMANDE (multi-tenant)
-- ============================================================

CREATE TABLE order_items (
    tenant_id INT UNSIGNED NOT NULL,
    item_id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    order_id BIGINT UNSIGNED NOT NULL,
    product_id BIGINT UNSIGNED,
    
    -- Snapshot du produit au moment de la commande
    product_snapshot JSON NOT NULL,  -- {name, sku, price, ...}
    
    -- Quantit√© et prix
    quantity INT UNSIGNED NOT NULL DEFAULT 1,
    unit_price DECIMAL(12,2) NOT NULL,
    discount_amount DECIMAL(12,2) DEFAULT 0,
    tax_amount DECIMAL(12,2) DEFAULT 0,
    
    line_total DECIMAL(14,2) GENERATED ALWAYS AS (
        (quantity * unit_price) - discount_amount + tax_amount
    ) STORED,
    
    -- Fulfillment
    quantity_fulfilled INT UNSIGNED DEFAULT 0,
    quantity_refunded INT UNSIGNED DEFAULT 0,
    
    -- M√©tadonn√©es
    metadata JSON DEFAULT '{}',
    
    -- Timestamps
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    
    PRIMARY KEY (tenant_id, item_id),
    
    INDEX idx_tenant_order (tenant_id, order_id),
    INDEX idx_tenant_product (tenant_id, product_id),
    
    CONSTRAINT fk_items_order 
        FOREIGN KEY (tenant_id, order_id) 
        REFERENCES orders(tenant_id, order_id)
        ON DELETE CASCADE,
    CONSTRAINT fk_items_product 
        FOREIGN KEY (tenant_id, product_id) 
        REFERENCES products(tenant_id, product_id)
        ON DELETE SET NULL
) ENGINE=InnoDB;

-- ============================================================
-- TABLE DES PARAM√àTRES PAR TENANT
-- ============================================================

CREATE TABLE tenant_settings (
    tenant_id INT UNSIGNED NOT NULL,
    setting_key VARCHAR(100) NOT NULL,
    setting_value JSON NOT NULL,
    description VARCHAR(500),
    is_sensitive BOOLEAN DEFAULT FALSE,
    updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
               ON UPDATE CURRENT_TIMESTAMP(6),
    updated_by BIGINT UNSIGNED,
    
    PRIMARY KEY (tenant_id, setting_key),
    
    CONSTRAINT fk_settings_tenant 
        FOREIGN KEY (tenant_id) REFERENCES tenants(tenant_id)
        ON DELETE CASCADE
) ENGINE=InnoDB;

-- ============================================================
-- VUE POUR LES STATISTIQUES PAR TENANT
-- ============================================================

CREATE OR REPLACE VIEW v_tenant_stats AS
SELECT 
    t.tenant_id,
    t.tenant_slug,
    t.company_name,
    t.subscription_plan,
    t.subscription_status,
    
    -- Comptages
    (SELECT COUNT(*) FROM users u WHERE u.tenant_id = t.tenant_id AND u.status = 'active') AS active_users,
    (SELECT COUNT(*) FROM products p WHERE p.tenant_id = t.tenant_id AND p.status = 'active') AS active_products,
    (SELECT COUNT(*) FROM customers c WHERE c.tenant_id = t.tenant_id) AS total_customers,
    (SELECT COUNT(*) FROM orders o WHERE o.tenant_id = t.tenant_id) AS total_orders,
    
    -- M√©triques commandes
    (SELECT COALESCE(SUM(o.total_amount), 0) 
     FROM orders o WHERE o.tenant_id = t.tenant_id AND o.status NOT IN ('cancelled', 'refunded')) AS total_revenue,
    
    -- Derni√®re activit√©
    (SELECT MAX(u.last_login_at) FROM users u WHERE u.tenant_id = t.tenant_id) AS last_user_activity,
    (SELECT MAX(o.created_at) FROM orders o WHERE o.tenant_id = t.tenant_id) AS last_order_at
    
FROM tenants t
WHERE t.is_deleted = FALSE;
```

### Insertion de donn√©es de test

```sql
-- ============================================================
-- DONN√âES DE TEST
-- ============================================================

-- Cr√©ation de tenants
INSERT INTO tenants (tenant_slug, company_name, billing_email, subscription_plan, subscription_status, max_users, max_storage_bytes)
VALUES 
    ('acme-corp', 'ACME Corporation', 'billing@acme.com', 'professional', 'active', 100, 10737418240),
    ('globex-inc', 'Globex International', 'finance@globex.com', 'enterprise', 'active', NULL, NULL),
    ('initech', 'Initech LLC', 'accounts@initech.com', 'starter', 'active', 25, 5368709120),
    ('umbrella', 'Umbrella Corp', 'billing@umbrella.com', 'free', 'trial', 5, 1073741824);

-- Les INSERT suivants utilisent les tenant_id g√©n√©r√©s (1, 2, 3, 4)

-- Utilisateurs pour ACME (tenant_id = 1)
INSERT INTO users (tenant_id, email, first_name, last_name, role, status)
VALUES 
    (1, 'john.doe@acme.com', 'John', 'Doe', 'owner', 'active'),
    (1, 'jane.smith@acme.com', 'Jane', 'Smith', 'admin', 'active'),
    (1, 'bob.wilson@acme.com', 'Bob', 'Wilson', 'member', 'active');

-- Utilisateurs pour Globex (tenant_id = 2)
INSERT INTO users (tenant_id, email, first_name, last_name, role, status)
VALUES 
    (2, 'alice@globex.com', 'Alice', 'Brown', 'owner', 'active'),
    (2, 'charlie@globex.com', 'Charlie', 'Davis', 'member', 'active');

-- Produits pour ACME
INSERT INTO products (tenant_id, sku, name, price, status)
VALUES 
    (1, 'ACME-001', 'Widget Pro', 99.99, 'active'),
    (1, 'ACME-002', 'Gadget Plus', 149.99, 'active'),
    (1, 'ACME-003', 'Super Device', 299.99, 'active');

-- Produits pour Globex
INSERT INTO products (tenant_id, sku, name, price, status)
VALUES 
    (2, 'GLX-100', 'Enterprise Solution', 999.99, 'active'),
    (2, 'GLX-200', 'Business Suite', 499.99, 'active');
```

---

## Strat√©gies d'indexation

### Principe fondamental : tenant_id en premier

La r√®gle d'or pour les performances dans un sch√©ma partag√© est de **toujours placer `tenant_id` en premi√®re position** des index composites.

```sql
-- ============================================================
-- INDEXATION OPTIMIS√âE POUR MULTI-TENANT
-- ============================================================

-- ‚úÖ CORRECT : tenant_id en premi√®re position
CREATE INDEX idx_orders_tenant_status ON orders (tenant_id, status);
CREATE INDEX idx_orders_tenant_date ON orders (tenant_id, ordered_at DESC);
CREATE INDEX idx_orders_tenant_customer ON orders (tenant_id, customer_id);

-- ‚ùå INCORRECT : tenant_id absent ou mal positionn√©
-- CREATE INDEX idx_orders_status ON orders (status);  -- Scanne tous les tenants !
-- CREATE INDEX idx_orders_date_tenant ON orders (ordered_at, tenant_id);  -- Inefficace

-- ============================================================
-- ANALYSE DES PLANS D'EX√âCUTION
-- ============================================================

-- Requ√™te optimis√©e (utilise l'index efficacement)
EXPLAIN ANALYZE
SELECT order_id, order_number, total_amount, status
FROM orders
WHERE tenant_id = 1 AND status = 'pending'
ORDER BY created_at DESC
LIMIT 20;

/*
-> Limit: 20 row(s)
    -> Index lookup on orders using idx_tenant_status 
       (tenant_id=1, status='pending'), 
       with index condition: (orders.status = 'pending')
       (cost=2.50 rows=15)
*/

-- Requ√™te probl√©matique (sans tenant_id)
EXPLAIN ANALYZE
SELECT order_id, order_number, total_amount
FROM orders
WHERE status = 'pending'
ORDER BY created_at DESC
LIMIT 20;

/*
‚ö†Ô∏è ATTENTION : Full table scan ou index scan inefficace
-> Limit: 20 row(s)
    -> Sort: orders.created_at DESC
        -> Table scan on orders with filter: (status = 'pending')
           (cost=125000.00 rows=500000)
*/
```

### Index couvrants pour les requ√™tes fr√©quentes

```sql
-- ============================================================
-- INDEX COUVRANTS (COVERING INDEXES)
-- ============================================================

-- Index couvrant pour la liste des commandes d'un tenant
CREATE INDEX idx_orders_covering_list ON orders (
    tenant_id,
    status,
    ordered_at DESC,
    order_id,
    order_number,
    customer_id,
    total_amount
);

-- Cette requ√™te utilise uniquement l'index (pas d'acc√®s table)
EXPLAIN ANALYZE
SELECT order_id, order_number, customer_id, total_amount, status, ordered_at
FROM orders
WHERE tenant_id = 1 AND status IN ('pending', 'confirmed')
ORDER BY ordered_at DESC
LIMIT 50;

/*
-> Limit: 50 row(s)
    -> Index range scan on orders using idx_orders_covering_list
       over (tenant_id = 1 AND status = 'pending') OR 
            (tenant_id = 1 AND status = 'confirmed')
       (cost=45.50 rows=50) (Using index)  <-- "Using index" = couvrant
*/

-- Index couvrant pour la recherche de produits
CREATE INDEX idx_products_covering_search ON products (
    tenant_id,
    status,
    is_visible,
    category_path(50),
    product_id,
    name,
    price
);
```

### Statistiques d'index par tenant

```sql
-- ============================================================
-- ANALYSE DES STATISTIQUES PAR TENANT
-- ============================================================

-- Distribution des donn√©es par tenant
SELECT 
    tenant_id,
    COUNT(*) AS row_count,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) AS pct_of_total
FROM orders
GROUP BY tenant_id
ORDER BY row_count DESC;

-- Identifier les "gros" tenants qui pourraient b√©n√©ficier de partitionnement
SELECT 
    t.tenant_slug,
    u.users,
    p.products,
    o.orders,
    ROUND((u.users + p.products + o.orders) * 100.0 / 
          (SELECT COUNT(*) FROM users) + 
          (SELECT COUNT(*) FROM products) + 
          (SELECT COUNT(*) FROM orders), 2) AS total_pct
FROM tenants t
LEFT JOIN (SELECT tenant_id, COUNT(*) AS users FROM users GROUP BY tenant_id) u 
    ON t.tenant_id = u.tenant_id
LEFT JOIN (SELECT tenant_id, COUNT(*) AS products FROM products GROUP BY tenant_id) p 
    ON t.tenant_id = p.tenant_id
LEFT JOIN (SELECT tenant_id, COUNT(*) AS orders FROM orders GROUP BY tenant_id) o 
    ON t.tenant_id = o.tenant_id
ORDER BY (COALESCE(u.users, 0) + COALESCE(p.products, 0) + COALESCE(o.orders, 0)) DESC
LIMIT 20;
```

---

## Isolation et s√©curit√©

### Couche d'abstraction applicative

L'isolation dans un sch√©ma partag√© repose **enti√®rement sur l'application**. Un oubli de filtre `tenant_id` expose les donn√©es de tous les tenants.

```python
# tenant_repository.py - Repository pattern avec isolation forc√©e

from typing import Optional, List, TypeVar, Generic
from dataclasses import dataclass
from contextlib import contextmanager
import mariadb

T = TypeVar('T')

@dataclass(frozen=True)
class TenantContext:
    """Contexte immuable du tenant pour la requ√™te."""
    tenant_id: int
    tenant_slug: str
    subscription_plan: str

class TenantAwareRepository(Generic[T]):
    """
    Repository de base avec isolation tenant forc√©e.
    
    Toutes les requ√™tes incluent automatiquement le tenant_id.
    """
    
    def __init__(self, connection: mariadb.Connection, tenant: TenantContext):
        self._conn = connection
        self._tenant = tenant
        self._table_name: str = ""  # √Ä d√©finir dans les sous-classes
    
    @property
    def tenant_id(self) -> int:
        return self._tenant.tenant_id
    
    def _execute(self, query: str, params: tuple = ()) -> mariadb.Cursor:
        """Ex√©cute une requ√™te en v√©rifiant la pr√©sence du filtre tenant."""
        
        # S√©curit√© : v√©rifier que tenant_id est dans la requ√™te
        if 'tenant_id' not in query.lower() and self._table_name in query.lower():
            raise SecurityError(
                f"Query on {self._table_name} must include tenant_id filter"
            )
        
        cursor = self._conn.cursor(dictionary=True)
        cursor.execute(query, params)
        return cursor
    
    def find_by_id(self, entity_id: int) -> Optional[dict]:
        """Trouve une entit√© par ID dans le tenant courant."""
        cursor = self._execute(
            f"SELECT * FROM {self._table_name} "
            f"WHERE tenant_id = %s AND {self._pk_column} = %s",
            (self.tenant_id, entity_id)
        )
        return cursor.fetchone()
    
    def find_all(self, limit: int = 100, offset: int = 0) -> List[dict]:
        """Liste toutes les entit√©s du tenant courant."""
        cursor = self._execute(
            f"SELECT * FROM {self._table_name} "
            f"WHERE tenant_id = %s "
            f"ORDER BY created_at DESC LIMIT %s OFFSET %s",
            (self.tenant_id, limit, offset)
        )
        return cursor.fetchall()
    
    def count(self) -> int:
        """Compte les entit√©s du tenant courant."""
        cursor = self._execute(
            f"SELECT COUNT(*) as cnt FROM {self._table_name} WHERE tenant_id = %s",
            (self.tenant_id,)
        )
        return cursor.fetchone()['cnt']
    
    def insert(self, data: dict) -> int:
        """Ins√®re une entit√© avec le tenant_id forc√©."""
        # Force le tenant_id
        data['tenant_id'] = self.tenant_id
        
        columns = ', '.join(data.keys())
        placeholders = ', '.join(['%s'] * len(data))
        
        cursor = self._execute(
            f"INSERT INTO {self._table_name} ({columns}) VALUES ({placeholders})",
            tuple(data.values())
        )
        self._conn.commit()
        return cursor.lastrowid
    
    def update(self, entity_id: int, data: dict) -> bool:
        """Met √† jour une entit√© du tenant courant."""
        # Supprime tenant_id s'il est dans data (ne doit pas √™tre modifiable)
        data.pop('tenant_id', None)
        
        set_clause = ', '.join([f"{k} = %s" for k in data.keys()])
        
        cursor = self._execute(
            f"UPDATE {self._table_name} SET {set_clause} "
            f"WHERE tenant_id = %s AND {self._pk_column} = %s",
            (*data.values(), self.tenant_id, entity_id)
        )
        self._conn.commit()
        return cursor.rowcount > 0
    
    def delete(self, entity_id: int) -> bool:
        """Supprime une entit√© du tenant courant."""
        cursor = self._execute(
            f"DELETE FROM {self._table_name} "
            f"WHERE tenant_id = %s AND {self._pk_column} = %s",
            (self.tenant_id, entity_id)
        )
        self._conn.commit()
        return cursor.rowcount > 0


class OrderRepository(TenantAwareRepository):
    """Repository pour les commandes."""
    
    def __init__(self, connection: mariadb.Connection, tenant: TenantContext):
        super().__init__(connection, tenant)
        self._table_name = "orders"
        self._pk_column = "order_id"
    
    def find_by_status(self, status: str, limit: int = 50) -> List[dict]:
        """Trouve les commandes par statut."""
        cursor = self._execute(
            """
            SELECT o.*, c.first_name, c.last_name, c.email as customer_email
            FROM orders o
            LEFT JOIN customers c ON o.tenant_id = c.tenant_id 
                                  AND o.customer_id = c.customer_id
            WHERE o.tenant_id = %s AND o.status = %s
            ORDER BY o.ordered_at DESC
            LIMIT %s
            """,
            (self.tenant_id, status, limit)
        )
        return cursor.fetchall()
    
    def get_revenue_stats(self, days: int = 30) -> dict:
        """Statistiques de revenus du tenant."""
        cursor = self._execute(
            """
            SELECT 
                COUNT(*) as order_count,
                SUM(total_amount) as total_revenue,
                AVG(total_amount) as avg_order_value
            FROM orders
            WHERE tenant_id = %s 
              AND ordered_at >= DATE_SUB(NOW(), INTERVAL %s DAY)
              AND status NOT IN ('cancelled', 'refunded')
            """,
            (self.tenant_id, days)
        )
        return cursor.fetchone()


class SecurityError(Exception):
    """Exception lev√©e lors d'une violation de s√©curit√© tenant."""
    pass


# Exemple d'utilisation avec FastAPI
from fastapi import FastAPI, Depends, HTTPException, Request

app = FastAPI()

def get_tenant_context(request: Request) -> TenantContext:
    """Extrait le contexte tenant de la requ√™te."""
    tenant = getattr(request.state, 'tenant', None)
    if not tenant:
        raise HTTPException(status_code=401, detail="Tenant context required")
    return tenant


@app.get("/api/orders")
async def list_orders(
    status: Optional[str] = None,
    limit: int = 50,
    tenant: TenantContext = Depends(get_tenant_context)
):
    """Liste les commandes du tenant."""
    
    with get_db_connection() as conn:
        repo = OrderRepository(conn, tenant)
        
        if status:
            orders = repo.find_by_status(status, limit)
        else:
            orders = repo.find_all(limit)
    
    return {"orders": orders, "tenant": tenant.tenant_slug}
```

### Vues de s√©curit√© avec filtre automatique

```sql
-- ============================================================
-- VUES AVEC FILTRE TENANT AUTOMATIQUE (OPTIONNEL)
-- ============================================================

-- Ces vues peuvent √™tre utilis√©es si l'application
-- d√©finit une variable de session @current_tenant_id

DELIMITER //

-- Fonction pour r√©cup√©rer le tenant courant
CREATE FUNCTION get_current_tenant_id()
RETURNS INT UNSIGNED
DETERMINISTIC
NO SQL
BEGIN
    DECLARE v_tenant_id INT UNSIGNED;
    SET v_tenant_id = @current_tenant_id;
    
    IF v_tenant_id IS NULL THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Tenant context not set. Set @current_tenant_id first.';
    END IF;
    
    RETURN v_tenant_id;
END //

DELIMITER ;

-- Vue des commandes filtr√©e automatiquement
CREATE OR REPLACE VIEW v_my_orders AS
SELECT *
FROM orders
WHERE tenant_id = get_current_tenant_id();

-- Vue des utilisateurs filtr√©e automatiquement
CREATE OR REPLACE VIEW v_my_users AS
SELECT user_id, user_uuid, email, first_name, last_name, 
       display_name, role, status, last_login_at, created_at
FROM users
WHERE tenant_id = get_current_tenant_id();

-- Vue des produits filtr√©e automatiquement  
CREATE OR REPLACE VIEW v_my_products AS
SELECT *
FROM products
WHERE tenant_id = get_current_tenant_id();

-- Usage depuis l'application :
-- SET @current_tenant_id = 1;
-- SELECT * FROM v_my_orders WHERE status = 'pending';
```

### Audit et d√©tection des anomalies

```sql
-- ============================================================
-- AUDIT DES ACC√àS MULTI-TENANT
-- ============================================================

CREATE TABLE tenant_access_audit (
    audit_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    timestamp DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    
    -- Contexte de la requ√™te
    session_tenant_id INT UNSIGNED,
    accessed_tenant_id INT UNSIGNED,
    
    -- D√©tails
    table_name VARCHAR(64),
    operation ENUM('SELECT', 'INSERT', 'UPDATE', 'DELETE'),
    row_count INT UNSIGNED,
    
    -- Utilisateur
    db_user VARCHAR(100),
    app_user_id BIGINT UNSIGNED,
    
    -- Requ√™te (tronqu√©e)
    query_fingerprint VARCHAR(64),
    query_preview VARCHAR(500),
    
    -- Alerte
    is_cross_tenant_access BOOLEAN GENERATED ALWAYS AS (
        session_tenant_id != accessed_tenant_id
    ) STORED,
    
    INDEX idx_timestamp (timestamp),
    INDEX idx_cross_tenant (is_cross_tenant_access, timestamp),
    INDEX idx_session_tenant (session_tenant_id)
) ENGINE=InnoDB;

-- Vue des acc√®s cross-tenant suspects
CREATE OR REPLACE VIEW v_suspicious_access AS
SELECT 
    DATE(timestamp) AS access_date,
    session_tenant_id,
    accessed_tenant_id,
    table_name,
    operation,
    COUNT(*) AS occurrence_count,
    GROUP_CONCAT(DISTINCT db_user) AS db_users
FROM tenant_access_audit
WHERE is_cross_tenant_access = TRUE
GROUP BY DATE(timestamp), session_tenant_id, accessed_tenant_id, table_name, operation
ORDER BY access_date DESC, occurrence_count DESC;
```

---

## Partitionnement par tenant

Pour les tr√®s gros volumes ou pour am√©liorer les performances de maintenance, le **partitionnement par tenant** peut √™tre b√©n√©fique.

### Partitionnement par HASH

```sql
-- ============================================================
-- PARTITIONNEMENT PAR HASH SUR TENANT_ID
-- ============================================================

-- Table orders partitionn√©e
CREATE TABLE orders_partitioned (
    tenant_id INT UNSIGNED NOT NULL,
    order_id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    order_uuid VARCHAR(36) NOT NULL DEFAULT (UUID()),
    order_number VARCHAR(32) NOT NULL,
    customer_id BIGINT UNSIGNED,
    status VARCHAR(20) DEFAULT 'draft',
    total_amount DECIMAL(14,2) NOT NULL DEFAULT 0,
    ordered_at DATETIME(6),
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    
    PRIMARY KEY (tenant_id, order_id),
    UNIQUE KEY uk_tenant_number (tenant_id, order_number),
    INDEX idx_tenant_status (tenant_id, status),
    INDEX idx_tenant_ordered (tenant_id, ordered_at DESC)
) ENGINE=InnoDB
PARTITION BY HASH(tenant_id)
PARTITIONS 16;  -- Ajuster selon le nombre de tenants attendu

-- V√©rification des partitions
SELECT 
    PARTITION_NAME,
    TABLE_ROWS,
    DATA_LENGTH / 1024 / 1024 AS data_mb,
    INDEX_LENGTH / 1024 / 1024 AS index_mb
FROM information_schema.PARTITIONS
WHERE TABLE_SCHEMA = 'saas_shared' AND TABLE_NAME = 'orders_partitioned';
```

### Partitionnement par LIST pour les gros tenants

```sql
-- ============================================================
-- PARTITIONNEMENT PAR LIST (TENANTS SP√âCIFIQUES)
-- ============================================================

-- Pour les cas o√π certains tenants dominent le volume
CREATE TABLE orders_list_partitioned (
    tenant_id INT UNSIGNED NOT NULL,
    order_id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    order_number VARCHAR(32) NOT NULL,
    total_amount DECIMAL(14,2) NOT NULL DEFAULT 0,
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    
    PRIMARY KEY (tenant_id, order_id)
) ENGINE=InnoDB
PARTITION BY LIST(tenant_id) (
    -- Gros tenants avec partitions d√©di√©es
    PARTITION p_tenant_1 VALUES IN (1),
    PARTITION p_tenant_2 VALUES IN (2),
    PARTITION p_tenant_3 VALUES IN (3),
    
    -- Tous les autres tenants
    PARTITION p_others VALUES IN (4, 5, 6, 7, 8, 9, 10)
    -- Note: LIST ne supporte pas DEFAULT, il faut lister explicitement
);

-- üÜï MariaDB 11.8 : Conversion partition en table autonome
-- Utile pour extraire un gros tenant vers sa propre base
ALTER TABLE orders_list_partitioned 
    EXCHANGE PARTITION p_tenant_1 WITH TABLE orders_tenant_1_standalone;
```

### Partition pruning automatique

```sql
-- ============================================================
-- V√âRIFICATION DU PARTITION PRUNING
-- ============================================================

-- Cette requ√™te ne scanne que la partition du tenant 1
EXPLAIN PARTITIONS
SELECT * FROM orders_partitioned
WHERE tenant_id = 1 AND status = 'pending';

/*
+----+-------------+---------------------+------------+------+...
| id | select_type | table               | partitions | type |...
+----+-------------+---------------------+------------+------+...
|  1 | SIMPLE      | orders_partitioned  | p1         | ref  |...  <-- Une seule partition
+----+-------------+---------------------+------------+------+...
*/

-- Cette requ√™te scanne toutes les partitions (pas de filtre tenant)
EXPLAIN PARTITIONS
SELECT * FROM orders_partitioned
WHERE status = 'pending';

/*
+----+-------------+---------------------+----------------------------------+------+...
| id | select_type | table               | partitions                       | type |...
+----+-------------+---------------------+----------------------------------+------+...
|  1 | SIMPLE      | orders_partitioned  | p0,p1,p2,p3,p4,p5,p6,p7,...,p15  | ALL  |...  <-- Toutes !
+----+-------------+---------------------+----------------------------------+------+...
*/
```

---

## Gestion des limites et quotas

### Enforcement des quotas

```sql
-- ============================================================
-- TRIGGERS POUR ENFORCEMENT DES QUOTAS
-- ============================================================

DELIMITER //

-- Trigger pour limiter le nombre d'utilisateurs
CREATE TRIGGER trg_users_quota_check
BEFORE INSERT ON users
FOR EACH ROW
BEGIN
    DECLARE v_current_count INT;
    DECLARE v_max_users INT;
    
    -- R√©cup√©ration des limites
    SELECT 
        (SELECT COUNT(*) FROM users WHERE tenant_id = NEW.tenant_id),
        max_users
    INTO v_current_count, v_max_users
    FROM tenants
    WHERE tenant_id = NEW.tenant_id;
    
    -- V√©rification du quota
    IF v_max_users IS NOT NULL AND v_current_count >= v_max_users THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'User quota exceeded for this tenant';
    END IF;
END //

-- Trigger pour v√©rifier le stockage (simplifi√©)
CREATE TRIGGER trg_check_storage_quota
BEFORE INSERT ON products
FOR EACH ROW
BEGIN
    DECLARE v_current_storage BIGINT;
    DECLARE v_max_storage BIGINT;
    
    SELECT max_storage_bytes INTO v_max_storage
    FROM tenants WHERE tenant_id = NEW.tenant_id;
    
    IF v_max_storage IS NOT NULL THEN
        -- Estimation du stockage actuel
        SELECT COALESCE(SUM(DATA_LENGTH + INDEX_LENGTH), 0)
        INTO v_current_storage
        FROM information_schema.TABLES
        WHERE TABLE_SCHEMA = DATABASE();
        
        -- Note: Ceci est une approximation, le stockage r√©el par tenant
        -- n√©cessite une table de m√©triques d√©di√©e
        
        IF v_current_storage >= v_max_storage THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Storage quota exceeded for this tenant';
        END IF;
    END IF;
END //

DELIMITER ;
```

### Proc√©dure de v√©rification des quotas

```sql
-- ============================================================
-- V√âRIFICATION DES QUOTAS EN TEMPS R√âEL
-- ============================================================

DELIMITER //

CREATE PROCEDURE check_tenant_quotas(
    IN p_tenant_id INT UNSIGNED,
    OUT p_users_pct DECIMAL(5,2),
    OUT p_storage_pct DECIMAL(5,2),
    OUT p_api_pct DECIMAL(5,2),
    OUT p_status VARCHAR(20)
)
BEGIN
    DECLARE v_max_users, v_current_users INT;
    DECLARE v_max_storage, v_current_storage BIGINT;
    DECLARE v_max_api, v_current_api INT;
    
    -- R√©cup√©ration des limites
    SELECT max_users, max_storage_bytes, max_api_requests_per_day
    INTO v_max_users, v_max_storage, v_max_api
    FROM tenants WHERE tenant_id = p_tenant_id;
    
    -- Comptage des utilisateurs
    SELECT COUNT(*) INTO v_current_users
    FROM users WHERE tenant_id = p_tenant_id AND status != 'deleted';
    
    -- Calcul du stockage (estimation bas√©e sur les donn√©es du tenant)
    -- En production, utiliser une table de m√©triques pr√©calcul√©es
    SELECT COALESCE(
        (SELECT SUM(LENGTH(COALESCE(metadata, '{}')) + 
                    LENGTH(COALESCE(notes, '')))
         FROM customers WHERE tenant_id = p_tenant_id) +
        (SELECT SUM(LENGTH(COALESCE(metadata, '{}')))
         FROM orders WHERE tenant_id = p_tenant_id) +
        (SELECT SUM(LENGTH(COALESCE(metadata, '{}')) + 
                    LENGTH(COALESCE(description, '')))
         FROM products WHERE tenant_id = p_tenant_id),
        0
    ) INTO v_current_storage;
    
    -- Calcul des pourcentages
    SET p_users_pct = CASE 
        WHEN v_max_users IS NULL THEN NULL
        ELSE ROUND(v_current_users * 100.0 / v_max_users, 2)
    END;
    
    SET p_storage_pct = CASE 
        WHEN v_max_storage IS NULL THEN NULL
        ELSE ROUND(v_current_storage * 100.0 / v_max_storage, 2)
    END;
    
    -- API calls (n√©cessite une table de comptage s√©par√©e)
    SET p_api_pct = NULL;  -- √Ä impl√©menter avec un compteur Redis ou similaire
    
    -- D√©termination du statut
    SET p_status = CASE
        WHEN COALESCE(p_users_pct, 0) >= 100 OR COALESCE(p_storage_pct, 0) >= 100 
            THEN 'exceeded'
        WHEN COALESCE(p_users_pct, 0) >= 90 OR COALESCE(p_storage_pct, 0) >= 90 
            THEN 'warning'
        ELSE 'ok'
    END;
    
END //

DELIMITER ;

-- Usage
CALL check_tenant_quotas(1, @users_pct, @storage_pct, @api_pct, @status);
SELECT @users_pct AS users_pct, @storage_pct AS storage_pct, @status AS quota_status;
```

---

## Performances et optimisations

### Configuration MariaDB optimis√©e

```ini
# my.cnf - Configuration pour sch√©ma partag√© multi-tenant

[mysqld]
# Buffer pool dimensionn√© pour contenir les donn√©es chaudes de tous les tenants
innodb_buffer_pool_size = 8G
innodb_buffer_pool_instances = 8

# Optimisation des index
innodb_adaptive_hash_index = ON
innodb_adaptive_hash_index_parts = 8

# Thread pool pour g√©rer la concurrence multi-tenant
thread_handling = pool-of-threads
thread_pool_size = 32
thread_pool_max_threads = 1000

# Statistiques d'index pour l'optimiseur
innodb_stats_persistent = ON
innodb_stats_auto_recalc = ON
innodb_stats_persistent_sample_pages = 100

# Query cache d√©sactiv√© (d√©pr√©ci√© et inefficace en multi-tenant)
query_cache_type = 0
query_cache_size = 0

# Logs lents pour identifier les requ√™tes probl√©matiques
slow_query_log = ON
long_query_time = 1
log_queries_not_using_indexes = ON

# Connexions
max_connections = 500
wait_timeout = 300
interactive_timeout = 300
```

### Requ√™tes optimis√©es

```sql
-- ============================================================
-- PATTERNS DE REQU√äTES OPTIMIS√âES
-- ============================================================

-- ‚úÖ BON : Pagination efficace avec tenant_id
SELECT order_id, order_number, total_amount, status, ordered_at
FROM orders
WHERE tenant_id = 1 
  AND status = 'pending'
  AND order_id > 12345  -- Pagination par curseur
ORDER BY order_id
LIMIT 20;

-- ‚ùå MAUVAIS : Pagination avec OFFSET (lent sur gros volumes)
-- SELECT * FROM orders WHERE tenant_id = 1 ORDER BY order_id LIMIT 20 OFFSET 100000;

-- ‚úÖ BON : Agr√©gation avec filtre tenant explicite
SELECT 
    DATE(ordered_at) AS order_date,
    COUNT(*) AS order_count,
    SUM(total_amount) AS daily_revenue
FROM orders
WHERE tenant_id = 1
  AND ordered_at >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
  AND status NOT IN ('cancelled', 'refunded')
GROUP BY DATE(ordered_at)
ORDER BY order_date DESC;

-- ‚úÖ BON : Jointure avec filtre tenant sur toutes les tables
SELECT 
    o.order_id,
    o.order_number,
    o.total_amount,
    c.first_name,
    c.last_name,
    c.email
FROM orders o
INNER JOIN customers c ON o.tenant_id = c.tenant_id 
                       AND o.customer_id = c.customer_id
WHERE o.tenant_id = 1
  AND o.status = 'confirmed'
ORDER BY o.ordered_at DESC
LIMIT 50;

-- ‚ùå MAUVAIS : Jointure sans filtre tenant explicite sur toutes les tables
-- (peut scanner des donn√©es d'autres tenants)
-- SELECT o.*, c.* FROM orders o JOIN customers c ON o.customer_id = c.customer_id;

-- ‚úÖ BON : Recherche full-text avec pr√©-filtre tenant
SELECT product_id, name, description, price,
       MATCH(name, description) AGAINST('wireless headphones') AS relevance
FROM products
WHERE tenant_id = 1
  AND status = 'active'
  AND MATCH(name, description) AGAINST('wireless headphones' IN NATURAL LANGUAGE MODE)
ORDER BY relevance DESC
LIMIT 20;
```

### Monitoring des performances par tenant

```sql
-- ============================================================
-- MONITORING DES PERFORMANCES
-- ============================================================

-- Identifier les tenants avec le plus de requ√™tes
SELECT 
    tenant_id,
    COUNT(*) AS query_count,
    AVG(TIMESTAMPDIFF(MICROSECOND, created_at, NOW())) AS avg_age_us
FROM orders
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 HOUR)
GROUP BY tenant_id
ORDER BY query_count DESC
LIMIT 10;

-- Taille des donn√©es par tenant
SELECT 
    t.tenant_slug,
    t.subscription_plan,
    COUNT(DISTINCT u.user_id) AS users,
    COUNT(DISTINCT p.product_id) AS products,
    COUNT(DISTINCT o.order_id) AS orders,
    COUNT(DISTINCT c.customer_id) AS customers
FROM tenants t
LEFT JOIN users u ON t.tenant_id = u.tenant_id
LEFT JOIN products p ON t.tenant_id = p.tenant_id
LEFT JOIN orders o ON t.tenant_id = o.tenant_id
LEFT JOIN customers c ON t.tenant_id = c.tenant_id
WHERE t.is_deleted = FALSE
GROUP BY t.tenant_id
ORDER BY (COUNT(DISTINCT u.user_id) + COUNT(DISTINCT p.product_id) + 
          COUNT(DISTINCT o.order_id) + COUNT(DISTINCT c.customer_id)) DESC;

-- Vue pour le dashboard de monitoring
CREATE OR REPLACE VIEW v_tenant_performance AS
SELECT 
    t.tenant_id,
    t.tenant_slug,
    t.subscription_plan,
    
    -- Volume de donn√©es
    (SELECT COUNT(*) FROM users WHERE tenant_id = t.tenant_id) AS user_count,
    (SELECT COUNT(*) FROM orders WHERE tenant_id = t.tenant_id) AS order_count,
    
    -- Activit√© r√©cente (24h)
    (SELECT COUNT(*) FROM orders 
     WHERE tenant_id = t.tenant_id 
       AND created_at >= DATE_SUB(NOW(), INTERVAL 24 HOUR)) AS orders_24h,
    
    -- Derni√®re activit√©
    (SELECT MAX(last_login_at) FROM users WHERE tenant_id = t.tenant_id) AS last_login,
    (SELECT MAX(created_at) FROM orders WHERE tenant_id = t.tenant_id) AS last_order

FROM tenants t
WHERE t.is_deleted = FALSE AND t.subscription_status = 'active';
```

---

## Migration entre patterns

### Migration vers Schema per Tenant

Si un tenant devient tr√®s gros ou n√©cessite plus d'isolation :

```sql
-- ============================================================
-- EXTRACTION D'UN TENANT VERS SON PROPRE SCH√âMA
-- ============================================================

DELIMITER //

CREATE PROCEDURE extract_tenant_to_schema(
    IN p_tenant_id INT UNSIGNED,
    IN p_new_schema_name VARCHAR(64)
)
BEGIN
    DECLARE v_tenant_slug VARCHAR(64);
    
    -- R√©cup√©ration des infos tenant
    SELECT tenant_slug INTO v_tenant_slug
    FROM tenants WHERE tenant_id = p_tenant_id;
    
    -- Cr√©ation du nouveau sch√©ma
    SET @sql = CONCAT('CREATE DATABASE IF NOT EXISTS `', p_new_schema_name, 
                      '` CHARACTER SET utf8mb4 COLLATE utf8mb4_uca1400_ai_ci');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Cr√©ation et copie de la table users
    SET @sql = CONCAT(
        'CREATE TABLE `', p_new_schema_name, '`.users AS ',
        'SELECT user_id, user_uuid, email, password_hash, first_name, last_name, ',
        'role, status, avatar_url, phone, timezone, locale, ',
        'email_verified_at, two_factor_enabled, last_login_at, ',
        'metadata, created_at, updated_at ',
        'FROM saas_shared.users WHERE tenant_id = ', p_tenant_id
    );
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Ajout des index et contraintes
    SET @sql = CONCAT(
        'ALTER TABLE `', p_new_schema_name, '`.users ',
        'ADD PRIMARY KEY (user_id), ',
        'ADD UNIQUE KEY uk_email (email), ',
        'ADD INDEX idx_status (status)'
    );
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- R√©p√©ter pour chaque table (products, customers, orders, etc.)
    -- ...
    
    -- Optionnel : Suppression des donn√©es du sch√©ma partag√©
    -- DELETE FROM saas_shared.users WHERE tenant_id = p_tenant_id;
    -- DELETE FROM saas_shared.orders WHERE tenant_id = p_tenant_id;
    -- ...
    
    SELECT CONCAT('Tenant ', v_tenant_slug, ' extracted to schema ', p_new_schema_name) AS result;
END //

DELIMITER ;

-- Usage
CALL extract_tenant_to_schema(1, 'tenant_acme_dedicated');
```

### Migration depuis Database per Tenant

```sql
-- ============================================================
-- CONSOLIDATION DE TENANTS VERS SCH√âMA PARTAG√â
-- ============================================================

DELIMITER //

CREATE PROCEDURE consolidate_tenant_from_database(
    IN p_source_db VARCHAR(64),
    IN p_target_tenant_id INT UNSIGNED
)
BEGIN
    -- Copie des utilisateurs
    SET @sql = CONCAT(
        'INSERT INTO saas_shared.users ',
        '(tenant_id, email, password_hash, first_name, last_name, role, status, created_at) ',
        'SELECT ', p_target_tenant_id, ', email, password_hash, first_name, last_name, role, status, created_at ',
        'FROM `', p_source_db, '`.users'
    );
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- R√©p√©ter pour chaque table avec mapping des IDs si n√©cessaire
    -- Utiliser des tables temporaires pour le mapping des cl√©s √©trang√®res
    
    SELECT CONCAT('Consolidated ', ROW_COUNT(), ' users from ', p_source_db) AS result;
END //

DELIMITER ;
```

---

## Avantages et inconv√©nients

### ‚úÖ Avantages

| Avantage | Description |
|----------|-------------|
| **Efficacit√© des ressources** | Une seule base, un seul pool de connexions, m√©moire partag√©e |
| **Scalabilit√© maximale** | Support de millions de tenants |
| **Provisioning instantan√©** | Cr√©ation de tenant = INSERT dans la table tenants |
| **Maintenance simplifi√©e** | Une seule base √† sauvegarder, monitorer, migrer |
| **Co√ªt minimal par tenant** | Overhead quasi nul |
| **Migrations unifi√©es** | Un script de migration s'applique √† tous les tenants |
| **Requ√™tes cross-tenant faciles** | Agr√©gations globales possibles (analytics, admin) |

### ‚ùå Inconv√©nients

| Inconv√©nient | Description | Mitigation |
|--------------|-------------|------------|
| **Isolation minimale** | Risque de fuite de donn√©es si oubli de filtre | Couche d'abstraction, tests automatis√©s |
| **Noisy neighbor** | Un tenant peut impacter les autres | Rate limiting, quotas, partitionnement |
| **Conformit√© limit√©e** | Difficile pour HIPAA, PCI-DSS stricts | Migration vers Database per Tenant |
| **Personnalisation impossible** | Sch√©ma identique pour tous | Colonnes JSON pour extensions |
| **Backup granulaire impossible** | Tout ou rien | Export SQL par tenant (lent) |
| **Complexit√© des index** | Tous les index doivent inclure tenant_id | Discipline de design |
| **Risque de s√©curit√©** | Bug = exposition de tous les tenants | Audit, tests de p√©n√©tration |

---

## Comparaison des patterns multi-tenant

| Crit√®re | Shared Schema | Schema per Tenant | Database per Tenant |
|---------|---------------|-------------------|---------------------|
| **Isolation** | ‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà |
| **Scalabilit√©** | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë | ‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë |
| **Co√ªt/tenant** | ‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë | ‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë |
| **Complexit√© ops** | ‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë |
| **Provisioning** | Instantan√© | Secondes | Minutes |
| **Migrations** | Une fois | N fois | N fois |
| **Personnalisation** | ‚ùå JSON uniquement | ‚ö†Ô∏è Limit√©e | ‚úÖ Totale |
| **Backup granulaire** | ‚ùå | ‚ö†Ô∏è Partiel | ‚úÖ |
| **Cross-tenant queries** | ‚úÖ Facile | ‚ö†Ô∏è F√©d√©ration | ‚ùå Impossible |
| **Conformit√© stricte** | ‚ùå | ‚ö†Ô∏è | ‚úÖ |
| **Nb tenants max** | Millions | ~10,000 | ~1,000 |

---

## Quand utiliser ce pattern ?

### ‚úÖ Recommand√© pour :

- **Applications B2C** avec millions d'utilisateurs
- **SaaS freemium** avec beaucoup de petits tenants
- **Startups** en phase de croissance rapide
- Applications o√π l'**efficacit√© des co√ªts** prime
- Syst√®mes avec **besoins uniformes** entre tenants
- Contextes o√π la **conformit√© stricte** n'est pas requise
- √âquipes avec **ressources DevOps limit√©es**
- Cas o√π les **requ√™tes cross-tenant** sont fr√©quentes (analytics)

### ‚ùå D√©conseill√© pour :

- **Exigences r√©glementaires strictes** (HIPAA, PCI-DSS, GDPR strict)
- Clients exigeant une **isolation physique** des donn√©es
- Applications avec **SLA diff√©renci√©s** par client
- Tenants avec **volumes de donn√©es tr√®s in√©gaux**
- Besoins de **personnalisation de sch√©ma** par tenant
- Environnements o√π un **bug pourrait exposer tous les tenants**

---

## ‚úÖ Points cl√©s √† retenir

- Le **Shared Schema** avec discriminateur est le pattern le plus **efficient en ressources** pour le multi-tenant
- Le **discriminateur** (`tenant_id`) doit √™tre pr√©sent dans **toutes les tables** et **tous les index**
- L'**isolation repose enti√®rement sur l'application** : un oubli de filtre expose tous les tenants
- Les **index composites** doivent **toujours** avoir `tenant_id` en **premi√®re position**
- Le **partitionnement** par tenant peut am√©liorer les performances et la maintenance
- Les **triggers** et **vues** peuvent aider √† enforcer l'isolation au niveau base
- Ce pattern supporte **des millions de tenants** avec un co√ªt marginal par tenant
- La **migration** vers d'autres patterns est possible si les besoins √©voluent
- Les **quotas et limites** doivent √™tre g√©r√©s au niveau applicatif ou par triggers
- Ce pattern est **id√©al pour B2C** et **SaaS √† grande √©chelle**

---

## üîó Ressources et r√©f√©rences

- üìñ [MariaDB Documentation - Partitioning](https://mariadb.com/kb/en/partitioning/)
- üìñ [MariaDB Documentation - Index Optimization](https://mariadb.com/kb/en/optimization-and-indexes/)
- üìñ [Multi-tenant Data Architecture - Microsoft](https://docs.microsoft.com/en-us/azure/architecture/guide/multitenant/considerations/tenancy-models)
- üìñ [Building Multi-tenant Applications with Django - Real Python](https://realpython.com/django-multitenancy/)
- üìñ [SaaS Tenant Isolation - AWS Well-Architected](https://docs.aws.amazon.com/wellarchitected/latest/saas-lens/tenant-isolation.html)
- üìñ [Row-Level Security Patterns - PostgreSQL (concepts applicables)](https://www.postgresql.org/docs/current/ddl-rowsecurity.html)

---

## ‚û°Ô∏è Section suivante

**20.5 G√©o-distribution** : D√©couvrez les strat√©gies de d√©ploiement g√©ographiquement distribu√© avec MariaDB, incluant la r√©plication cross-r√©gion, les architectures active-active, et la gestion de la latence pour les applications globales.

‚è≠Ô∏è [G√©o-distribution](/20-cas-usage-architectures/05-geo-distribution.md)
