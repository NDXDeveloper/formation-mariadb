üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.2.1 Database per Service

> **Niveau** : Interm√©diaire √† Avanc√©  
> **Dur√©e estim√©e** : 2 heures  
> **Pr√©requis** : Chapitre 13 (R√©plication), Chapitre 14 (Haute Disponibilit√©), Section 20.1 (OLTP vs OLAP), Section 20.2 (Architecture microservices)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :

- Comprendre le pattern "Database per Service" et ses implications architecturales
- Concevoir une strat√©gie de donn√©es adapt√©e aux microservices avec MariaDB
- Impl√©menter l'isolation des donn√©es tout en g√©rant les besoins de coh√©rence
- Choisir les m√©canismes appropri√©s pour la communication inter-services
- Anticiper et r√©soudre les d√©fis op√©rationnels li√©s √† ce pattern

---

## Introduction

Dans une architecture monolithique traditionnelle, une base de donn√©es unique centralise l'ensemble des donn√©es de l'application. Cette approche, bien que simple √† g√©rer, cr√©e un **couplage fort** entre les diff√©rents modules fonctionnels et devient rapidement un goulot d'√©tranglement √† mesure que l'application grandit.

Le pattern **Database per Service** (base de donn√©es par service) constitue l'un des piliers fondamentaux des architectures microservices. Il stipule que **chaque service poss√®de et g√®re exclusivement ses propres donn√©es**, les autres services ne pouvant y acc√©der que via l'API publique du service propri√©taire.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ARCHITECTURE MONOLITHIQUE                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ  ‚îÇ   Module    ‚îÇ   Module    ‚îÇ   Module    ‚îÇ   Module    ‚îÇ          ‚îÇ
‚îÇ  ‚îÇ  Commandes  ‚îÇ   Clients   ‚îÇ  Inventaire ‚îÇ  Paiements  ‚îÇ          ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îÇ         ‚îÇ             ‚îÇ             ‚îÇ             ‚îÇ                 ‚îÇ
‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îÇ
‚îÇ                              ‚ñº                                      ‚îÇ
‚îÇ                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                              ‚îÇ
‚îÇ                    ‚îÇ   Base Unique   ‚îÇ                              ‚îÇ
‚îÇ                    ‚îÇ    MariaDB      ‚îÇ                              ‚îÇ
‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

                              ‚ñº √âVOLUTION ‚ñº

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ARCHITECTURE MICROSERVICES                       ‚îÇ
‚îÇ                    (Database per Service)                           ‚îÇ
‚îÇ                                                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ   Service   ‚îÇ  ‚îÇ   Service   ‚îÇ  ‚îÇ   Service   ‚îÇ  ‚îÇ   Service   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  Commandes  ‚îÇ  ‚îÇ   Clients   ‚îÇ  ‚îÇ  Inventaire ‚îÇ  ‚îÇ  Paiements  ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ 
‚îÇ         ‚îÇ                ‚îÇ                ‚îÇ                ‚îÇ        ‚îÇ
‚îÇ         ‚ñº                ‚ñº                ‚ñº                ‚ñº        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ  MariaDB    ‚îÇ  ‚îÇ  MariaDB    ‚îÇ  ‚îÇ  MariaDB    ‚îÇ  ‚îÇ  MariaDB    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  Commandes  ‚îÇ  ‚îÇ   Clients   ‚îÇ  ‚îÇ  Inventaire ‚îÇ  ‚îÇ  Paiements  ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Cette transformation architecturale apporte une **autonomie technique et organisationnelle** consid√©rable, mais introduit √©galement des d√©fis significatifs en mati√®re de coh√©rence des donn√©es et de complexit√© op√©rationnelle.

---

## Principes fondamentaux du pattern

### Encapsulation stricte des donn√©es

Le principe cardinal du pattern Database per Service repose sur l'**encapsulation** : les tables, sch√©mas et donn√©es d'un service sont **priv√©s** et inaccessibles directement par les autres services.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     SERVICE COMMANDES                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                    API Publique                          ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  POST /orders    GET /orders/{id}    PUT /orders/{id}    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                            ‚îÇ                                   ‚îÇ
‚îÇ                            ‚ñº                                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                  Logique M√©tier                          ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ           (Validation, R√®gles, Workflow)                 ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                            ‚îÇ                                   ‚îÇ
‚îÇ                            ‚ñº                                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ              BASE DE DONN√âES PRIV√âE                      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   orders    ‚îÇ ‚îÇ order_items ‚îÇ ‚îÇ order_status_history‚îÇ ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ                    MariaDB 11.8                          ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                ‚îÇ
‚îÇ  ‚õî Acc√®s direct interdit aux autres services                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Cette encapsulation garantit que :

1. **Chaque service peut √©voluer ind√©pendamment** : modifications de sch√©ma sans coordination
2. **Les responsabilit√©s sont clairement d√©finies** : une seule √©quipe ma√Ætrise les donn√©es
3. **La scalabilit√© est granulaire** : chaque base peut √™tre dimensionn√©e selon ses besoins
4. **Les pannes sont isol√©es** : un probl√®me de base n'affecte qu'un seul service

### D√©finition des fronti√®res de service (Bounded Context)

L'identification des fronti√®res de service constitue l'√©tape la plus critique. Elle s'appuie g√©n√©ralement sur le concept de **Bounded Context** issu du Domain-Driven Design (DDD).

```sql
-- ‚úÖ BON : Donn√©es coh√©rentes au sein d'un m√™me contexte
-- Service Commandes : g√®re le cycle de vie complet d'une commande

CREATE TABLE orders (
    order_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    customer_id BIGINT UNSIGNED NOT NULL,  -- R√©f√©rence externe (ID seulement)
    order_date DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    status ENUM('pending', 'confirmed', 'shipped', 'delivered', 'cancelled') 
           DEFAULT 'pending',
    total_amount DECIMAL(15,2) NOT NULL,
    shipping_address_snapshot JSON NOT NULL,  -- Copie d√©normalis√©e
    INDEX idx_customer (customer_id),
    INDEX idx_status_date (status, order_date)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_uca1400_ai_ci;

CREATE TABLE order_items (
    item_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT UNSIGNED NOT NULL,
    product_id BIGINT UNSIGNED NOT NULL,    -- R√©f√©rence externe (ID seulement)
    product_name_snapshot VARCHAR(255) NOT NULL,  -- Copie au moment de la commande
    quantity INT UNSIGNED NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_uca1400_ai_ci;
```

üí° **Conseil** : Remarquez l'utilisation de **snapshots** (`shipping_address_snapshot`, `product_name_snapshot`). Le service Commandes stocke une copie des donn√©es au moment de la transaction, garantissant l'int√©grit√© historique m√™me si le client change d'adresse ou si le produit est modifi√© ult√©rieurement.

### Autonomie technologique

Chaque service peut th√©oriquement choisir la technologie de stockage la plus adapt√©e √† ses besoins. Cependant, dans un contexte MariaDB, cette libert√© se traduit souvent par le choix du **moteur de stockage** appropri√© :

| Service | Caract√©ristiques | Moteur recommand√© |
|---------|------------------|-------------------|
| **Commandes** | OLTP, transactions ACID, forte concurrence | InnoDB |
| **Catalogue** | Lecture intensive, recherche full-text | InnoDB + Full-Text |
| **Analytics** | Agr√©gations massives, OLAP | ColumnStore |
| **Sessions** | Acc√®s ultra-rapide, donn√©es √©ph√©m√®res | Memory / Aria |
| **Archives** | Stockage long terme, acc√®s rare | Archive / S3 Engine |
| **Recherche IA** | Embeddings vectoriels, similarit√© | InnoDB + VECTOR üÜï |

---

## Impl√©mentation avec MariaDB 11.8

### Strat√©gie d'isolation : instances vs sch√©mas

Deux approches principales permettent d'impl√©menter l'isolation des donn√©es :

#### Option 1 : Instances MariaDB s√©par√©es (recommand√© pour production)

Chaque service dispose de sa propre instance MariaDB, offrant une isolation maximale :

```yaml
# docker-compose.yml - Architecture Database per Service
version: '3.8'

services:
  # Service Commandes
  orders-service:
    image: orders-service:latest
    environment:
      DATABASE_URL: mysql://orders_user:${ORDERS_DB_PWD}@orders-db:3306/orders
    depends_on:
      - orders-db

  orders-db:
    image: mariadb:11.8
    environment:
      MARIADB_ROOT_PASSWORD: ${ORDERS_ROOT_PWD}
      MARIADB_DATABASE: orders
      MARIADB_USER: orders_user
      MARIADB_PASSWORD: ${ORDERS_DB_PWD}
    volumes:
      - orders-data:/var/lib/mysql
      - ./config/orders-my.cnf:/etc/mysql/conf.d/custom.cnf
    deploy:
      resources:
        limits:
          memory: 2G

  # Service Clients
  customers-service:
    image: customers-service:latest
    environment:
      DATABASE_URL: mysql://customers_user:${CUSTOMERS_DB_PWD}@customers-db:3306/customers
    depends_on:
      - customers-db

  customers-db:
    image: mariadb:11.8
    environment:
      MARIADB_ROOT_PASSWORD: ${CUSTOMERS_ROOT_PWD}
      MARIADB_DATABASE: customers
      MARIADB_USER: customers_user
      MARIADB_PASSWORD: ${CUSTOMERS_DB_PWD}
    volumes:
      - customers-data:/var/lib/mysql
      - ./config/customers-my.cnf:/etc/mysql/conf.d/custom.cnf
    deploy:
      resources:
        limits:
          memory: 1G

  # Service Inventaire
  inventory-service:
    image: inventory-service:latest
    environment:
      DATABASE_URL: mysql://inventory_user:${INVENTORY_DB_PWD}@inventory-db:3306/inventory
    depends_on:
      - inventory-db

  inventory-db:
    image: mariadb:11.8
    environment:
      MARIADB_ROOT_PASSWORD: ${INVENTORY_ROOT_PWD}
      MARIADB_DATABASE: inventory
      MARIADB_USER: inventory_user
      MARIADB_PASSWORD: ${INVENTORY_DB_PWD}
    volumes:
      - inventory-data:/var/lib/mysql
    deploy:
      resources:
        limits:
          memory: 1G

volumes:
  orders-data:
  customers-data:
  inventory-data:
```

**Avantages de l'isolation par instance** :
- Isolation compl√®te des ressources (CPU, m√©moire, I/O)
- Configurations sp√©cifiques par service
- Maintenance ind√©pendante (backups, upgrades)
- Scaling horizontal facilit√©

#### Option 2 : Sch√©mas s√©par√©s sur instance partag√©e (d√©veloppement / petits projets)

```sql
-- Cr√©ation des sch√©mas isol√©s sur une instance partag√©e
CREATE DATABASE orders_db CHARACTER SET utf8mb4 COLLATE utf8mb4_uca1400_ai_ci;
CREATE DATABASE customers_db CHARACTER SET utf8mb4 COLLATE utf8mb4_uca1400_ai_ci;
CREATE DATABASE inventory_db CHARACTER SET utf8mb4 COLLATE utf8mb4_uca1400_ai_ci;

-- Utilisateurs d√©di√©s avec acc√®s restreint
CREATE USER 'orders_svc'@'%' IDENTIFIED BY 'secure_password_1';
GRANT ALL PRIVILEGES ON orders_db.* TO 'orders_svc'@'%';

CREATE USER 'customers_svc'@'%' IDENTIFIED BY 'secure_password_2';
GRANT ALL PRIVILEGES ON customers_db.* TO 'customers_svc'@'%';

CREATE USER 'inventory_svc'@'%' IDENTIFIED BY 'secure_password_3';
GRANT ALL PRIVILEGES ON inventory_db.* TO 'inventory_svc'@'%';

-- V√©rification : aucun acc√®s crois√©
SHOW GRANTS FOR 'orders_svc'@'%';
-- +----------------------------------------------------------+
-- | Grants for orders_svc@%                                  |
-- +----------------------------------------------------------+
-- | GRANT USAGE ON *.* TO `orders_svc`@`%`                   |
-- | GRANT ALL PRIVILEGES ON `orders_db`.* TO `orders_svc`@`% |
-- +----------------------------------------------------------+
```

‚ö†Ô∏è **Attention** : Cette approche partage les ressources syst√®me. Un service consommant excessivement de m√©moire ou d'I/O impactera tous les autres. R√©servez-la aux environnements de d√©veloppement ou aux applications √† faible charge.

### Configuration optimis√©e par type de service

Chaque instance peut √™tre configur√©e selon son profil de charge :

```ini
# orders-my.cnf - Service OLTP haute concurrence
[mysqld]
# InnoDB optimis√© pour OLTP
innodb_buffer_pool_size = 1G
innodb_buffer_pool_instances = 4
innodb_log_file_size = 256M
innodb_flush_log_at_trx_commit = 1
innodb_flush_method = O_DIRECT

# Connexions
max_connections = 200
thread_pool_size = 16

# Transactions courtes
innodb_lock_wait_timeout = 10
transaction_isolation = READ-COMMITTED

# Logging
slow_query_log = ON
long_query_time = 0.5
```

```ini
# analytics-my.cnf - Service OLAP avec ColumnStore
[mysqld]
# ColumnStore pour analytics
plugin_load_add = ha_columnstore

# M√©moire pour requ√™tes analytiques
max_heap_table_size = 512M
tmp_table_size = 512M
join_buffer_size = 256M
sort_buffer_size = 64M

# Moins de connexions, requ√™tes longues
max_connections = 50
innodb_lock_wait_timeout = 300
```

---

## Gestion de la coh√©rence des donn√©es

Le pattern Database per Service abandonne les **transactions ACID distribu√©es** traditionnelles au profit de la **coh√©rence √©ventuelle** (eventual consistency). Cette section explore les patterns permettant de maintenir la coh√©rence m√©tier.

### Pattern Saga : orchestration vs chor√©graphie

Les **Sagas** d√©coupent une transaction m√©tier distribu√©e en une s√©quence de transactions locales, chacune publi√©e via des √©v√©nements.

#### Saga par chor√©graphie (event-driven)

Chaque service √©coute les √©v√©nements et r√©agit de mani√®re autonome :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SAGA CHOR√âGRAPHI√âE : Cr√©ation de commande            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

     Client                                                    
        ‚îÇ                                                      
        ‚îÇ POST /orders                                         
        ‚ñº                                                      
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                              
‚îÇ   COMMANDES   ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ OrderCreated ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      
‚îÇ   (pending)   ‚îÇ                       ‚îÇ                      
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                       ‚ñº                      
                               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               
                               ‚îÇ  INVENTAIRE   ‚îÇ               
                               ‚îÇ (r√©servation) ‚îÇ               
                               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               
                       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       
                       ‚ñº                               ‚ñº       
              InventoryReserved              InventoryInsufficient
                       ‚îÇ                               ‚îÇ       
                       ‚ñº                               ‚ñº       
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ   PAIEMENTS   ‚îÇ               ‚îÇ   COMMANDES   ‚îÇ
              ‚îÇ  (d√©bit)      ‚îÇ               ‚îÇ  (cancelled)  ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                
              ‚ñº               ‚ñº                                
       PaymentSucceeded  PaymentFailed                         
              ‚îÇ               ‚îÇ                                
              ‚ñº               ‚ñº                                
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                       
     ‚îÇ   COMMANDES   ‚îÇ ‚îÇ  INVENTAIRE   ‚îÇ                       
     ‚îÇ  (confirmed)  ‚îÇ ‚îÇ  (release)    ‚îÇ                       
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                       
```

**Impl√©mentation MariaDB avec √©v√©nements** :

```sql
-- Service Commandes : Table orders avec suivi d'√©tat
CREATE TABLE orders (
    order_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    customer_id BIGINT UNSIGNED NOT NULL,
    status ENUM('pending', 'inventory_reserved', 'payment_processing', 
                'confirmed', 'shipped', 'delivered', 
                'payment_failed', 'inventory_failed', 'cancelled') 
           DEFAULT 'pending',
    total_amount DECIMAL(15,2) NOT NULL,
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),
    
    -- Idempotency key pour √©viter les doublons
    idempotency_key VARCHAR(64) UNIQUE,
    
    INDEX idx_status (status),
    INDEX idx_created (created_at)
) ENGINE=InnoDB;

-- Outbox pattern : garantir la publication des √©v√©nements
CREATE TABLE order_events_outbox (
    event_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    aggregate_type VARCHAR(50) NOT NULL DEFAULT 'Order',
    aggregate_id BIGINT UNSIGNED NOT NULL,
    event_type VARCHAR(100) NOT NULL,
    payload JSON NOT NULL,
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    published_at DATETIME(6) NULL,
    
    INDEX idx_unpublished (published_at, created_at)
) ENGINE=InnoDB;

-- Transaction atomique : cr√©ation commande + √©v√©nement
DELIMITER //
CREATE PROCEDURE create_order(
    IN p_customer_id BIGINT UNSIGNED,
    IN p_items JSON,
    IN p_total DECIMAL(15,2),
    IN p_idempotency_key VARCHAR(64),
    OUT p_order_id BIGINT UNSIGNED
)
BEGIN
    DECLARE v_order_id BIGINT UNSIGNED;
    
    -- V√©rification idempotence
    SELECT order_id INTO v_order_id 
    FROM orders 
    WHERE idempotency_key = p_idempotency_key;
    
    IF v_order_id IS NOT NULL THEN
        SET p_order_id = v_order_id;
    ELSE
        START TRANSACTION;
        
        -- Cr√©ation de la commande
        INSERT INTO orders (customer_id, total_amount, idempotency_key)
        VALUES (p_customer_id, p_total, p_idempotency_key);
        
        SET v_order_id = LAST_INSERT_ID();
        
        -- √âv√©nement dans l'outbox (m√™me transaction)
        INSERT INTO order_events_outbox (aggregate_id, event_type, payload)
        VALUES (
            v_order_id,
            'OrderCreated',
            JSON_OBJECT(
                'order_id', v_order_id,
                'customer_id', p_customer_id,
                'items', p_items,
                'total_amount', p_total,
                'timestamp', NOW(6)
            )
        );
        
        COMMIT;
        SET p_order_id = v_order_id;
    END IF;
END //
DELIMITER ;
```

```sql
-- Service Inventaire : Gestion des r√©servations
CREATE TABLE inventory (
    product_id BIGINT UNSIGNED PRIMARY KEY,
    available_quantity INT UNSIGNED NOT NULL DEFAULT 0,
    reserved_quantity INT UNSIGNED NOT NULL DEFAULT 0,
    version INT UNSIGNED NOT NULL DEFAULT 0,  -- Optimistic locking
    
    CONSTRAINT chk_available CHECK (available_quantity >= 0),
    CONSTRAINT chk_reserved CHECK (reserved_quantity >= 0)
) ENGINE=InnoDB;

CREATE TABLE inventory_reservations (
    reservation_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT UNSIGNED NOT NULL UNIQUE,  -- Une r√©servation par commande
    product_id BIGINT UNSIGNED NOT NULL,
    quantity INT UNSIGNED NOT NULL,
    status ENUM('reserved', 'confirmed', 'released') DEFAULT 'reserved',
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    expires_at DATETIME(6) NOT NULL,
    
    INDEX idx_order (order_id),
    INDEX idx_expires (status, expires_at)
) ENGINE=InnoDB;

-- R√©servation avec optimistic locking
DELIMITER //
CREATE PROCEDURE reserve_inventory(
    IN p_order_id BIGINT UNSIGNED,
    IN p_product_id BIGINT UNSIGNED,
    IN p_quantity INT UNSIGNED,
    OUT p_success BOOLEAN,
    OUT p_message VARCHAR(255)
)
BEGIN
    DECLARE v_available INT UNSIGNED;
    DECLARE v_version INT UNSIGNED;
    DECLARE v_rows_affected INT;
    
    -- Lecture avec verrouillage
    SELECT available_quantity, version 
    INTO v_available, v_version
    FROM inventory 
    WHERE product_id = p_product_id
    FOR UPDATE;
    
    IF v_available IS NULL THEN
        SET p_success = FALSE;
        SET p_message = 'Product not found';
    ELSEIF v_available < p_quantity THEN
        SET p_success = FALSE;
        SET p_message = CONCAT('Insufficient inventory: ', v_available, ' available');
    ELSE
        START TRANSACTION;
        
        -- Mise √† jour avec version check (optimistic locking)
        UPDATE inventory 
        SET available_quantity = available_quantity - p_quantity,
            reserved_quantity = reserved_quantity + p_quantity,
            version = version + 1
        WHERE product_id = p_product_id AND version = v_version;
        
        SET v_rows_affected = ROW_COUNT();
        
        IF v_rows_affected = 0 THEN
            ROLLBACK;
            SET p_success = FALSE;
            SET p_message = 'Concurrent modification detected';
        ELSE
            -- Cr√©ation de la r√©servation (expire dans 15 minutes)
            INSERT INTO inventory_reservations 
                (order_id, product_id, quantity, expires_at)
            VALUES 
                (p_order_id, p_product_id, p_quantity, 
                 DATE_ADD(NOW(6), INTERVAL 15 MINUTE));
            
            COMMIT;
            SET p_success = TRUE;
            SET p_message = 'Inventory reserved successfully';
        END IF;
    END IF;
END //
DELIMITER ;
```

üí° **Conseil** : L'**Outbox Pattern** garantit que la modification de donn√©es et la publication de l'√©v√©nement sont atomiques. Un processus s√©par√© (CDC ou polling) lit la table outbox et publie vers le broker de messages.

### Gestion des compensations

Lorsqu'une √©tape de la Saga √©choue, des **actions compensatoires** annulent les effets des √©tapes pr√©c√©dentes :

```sql
-- Service Inventaire : Lib√©ration de r√©servation (compensation)
DELIMITER //
CREATE PROCEDURE release_reservation(
    IN p_order_id BIGINT UNSIGNED,
    OUT p_success BOOLEAN
)
BEGIN
    DECLARE v_product_id BIGINT UNSIGNED;
    DECLARE v_quantity INT UNSIGNED;
    
    -- R√©cup√©ration de la r√©servation
    SELECT product_id, quantity INTO v_product_id, v_quantity
    FROM inventory_reservations
    WHERE order_id = p_order_id AND status = 'reserved'
    FOR UPDATE;
    
    IF v_product_id IS NOT NULL THEN
        START TRANSACTION;
        
        -- Restauration du stock
        UPDATE inventory 
        SET available_quantity = available_quantity + v_quantity,
            reserved_quantity = reserved_quantity - v_quantity,
            version = version + 1
        WHERE product_id = v_product_id;
        
        -- Marquage de la r√©servation comme lib√©r√©e
        UPDATE inventory_reservations
        SET status = 'released'
        WHERE order_id = p_order_id;
        
        COMMIT;
        SET p_success = TRUE;
    ELSE
        SET p_success = FALSE;
    END IF;
END //
DELIMITER ;

-- Event scheduler pour lib√©rer les r√©servations expir√©es
CREATE EVENT cleanup_expired_reservations
ON SCHEDULE EVERY 5 MINUTE
DO
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_order_id BIGINT UNSIGNED;
    DECLARE cur CURSOR FOR 
        SELECT order_id FROM inventory_reservations 
        WHERE status = 'reserved' AND expires_at < NOW();
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur;
    read_loop: LOOP
        FETCH cur INTO v_order_id;
        IF done THEN LEAVE read_loop; END IF;
        
        CALL release_reservation(v_order_id, @success);
        
        -- Publication d'un √©v√©nement de compensation
        INSERT INTO inventory_events_outbox (aggregate_id, event_type, payload)
        VALUES (v_order_id, 'ReservationExpired', 
                JSON_OBJECT('order_id', v_order_id, 'timestamp', NOW(6)));
    END LOOP;
    CLOSE cur;
END;
```

### Pattern CQRS : s√©paration lecture/√©criture

Le pattern **Command Query Responsibility Segregation** (CQRS) s√©pare les mod√®les de lecture et d'√©criture, particuli√®rement adapt√© aux architectures microservices.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         PATTERN CQRS                                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

         Commands (√âcriture)                  Queries (Lecture)
              ‚îÇ                                     ‚îÇ
              ‚ñº                                     ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  Command Handler ‚îÇ               ‚îÇ    Query Handler     ‚îÇ
    ‚îÇ   (Validation,   ‚îÇ               ‚îÇ   (Projections,      ‚îÇ
    ‚îÇ    Business)     ‚îÇ               ‚îÇ    Agr√©gations)      ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ                                    ‚îÇ
             ‚ñº                                    ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ    MariaDB       ‚îÇ    Events     ‚îÇ      MariaDB         ‚îÇ
    ‚îÇ  Write Store     ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂   ‚îÇ    Read Store        ‚îÇ
    ‚îÇ   (InnoDB)       ‚îÇ    (CDC)      ‚îÇ   (Optimis√© lecture) ‚îÇ
    ‚îÇ  - Normalis√©     ‚îÇ               ‚îÇ   - D√©normalis√©      ‚îÇ
    ‚îÇ  - Transactions  ‚îÇ               ‚îÇ   - Pr√©-calcul√©      ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

```sql
-- Write Store : Mod√®le normalis√© pour les commandes
CREATE TABLE orders_write (
    order_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    customer_id BIGINT UNSIGNED NOT NULL,
    status VARCHAR(50) NOT NULL,
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    INDEX idx_customer (customer_id)
) ENGINE=InnoDB;

CREATE TABLE order_items_write (
    item_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT UNSIGNED NOT NULL,
    product_id BIGINT UNSIGNED NOT NULL,
    quantity INT UNSIGNED NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    FOREIGN KEY (order_id) REFERENCES orders_write(order_id)
) ENGINE=InnoDB;

-- Read Store : Mod√®le d√©normalis√© optimis√© pour les requ√™tes
CREATE TABLE orders_read (
    order_id BIGINT UNSIGNED PRIMARY KEY,
    customer_id BIGINT UNSIGNED NOT NULL,
    customer_name VARCHAR(255) NOT NULL,  -- D√©normalis√©
    customer_email VARCHAR(255) NOT NULL, -- D√©normalis√©
    status VARCHAR(50) NOT NULL,
    items_count INT UNSIGNED NOT NULL,    -- Pr√©-calcul√©
    total_amount DECIMAL(15,2) NOT NULL,  -- Pr√©-calcul√©
    items_summary JSON NOT NULL,          -- Agr√©gation embarqu√©e
    created_at DATETIME(6) NOT NULL,
    updated_at DATETIME(6) NOT NULL,
    
    INDEX idx_customer (customer_id),
    INDEX idx_status (status),
    INDEX idx_created (created_at DESC)
) ENGINE=InnoDB;

-- Projection : Mise √† jour du Read Store via trigger ou CDC
DELIMITER //
CREATE PROCEDURE project_order_to_read_store(IN p_order_id BIGINT UNSIGNED)
BEGIN
    INSERT INTO orders_read (
        order_id, customer_id, customer_name, customer_email,
        status, items_count, total_amount, items_summary, 
        created_at, updated_at
    )
    SELECT 
        o.order_id,
        o.customer_id,
        -- Ces donn√©es proviendraient normalement d'un appel API au service Customers
        'Placeholder Name' AS customer_name,
        'placeholder@email.com' AS customer_email,
        o.status,
        COUNT(oi.item_id) AS items_count,
        SUM(oi.quantity * oi.unit_price) AS total_amount,
        JSON_ARRAYAGG(
            JSON_OBJECT(
                'product_id', oi.product_id,
                'quantity', oi.quantity,
                'unit_price', oi.unit_price,
                'subtotal', oi.quantity * oi.unit_price
            )
        ) AS items_summary,
        o.created_at,
        NOW(6) AS updated_at
    FROM orders_write o
    LEFT JOIN order_items_write oi ON o.order_id = oi.order_id
    WHERE o.order_id = p_order_id
    GROUP BY o.order_id
    ON DUPLICATE KEY UPDATE
        status = VALUES(status),
        items_count = VALUES(items_count),
        total_amount = VALUES(total_amount),
        items_summary = VALUES(items_summary),
        updated_at = VALUES(updated_at);
END //
DELIMITER ;
```

---

## Communication inter-services

### Appels synchrones (API REST/gRPC)

Pour des requ√™tes n√©cessitant une r√©ponse imm√©diate, les services communiquent via HTTP ou gRPC :

```sql
-- Le service Commandes stocke une r√©f√©rence minimale
-- et enrichit via appel API si n√©cessaire
CREATE TABLE orders (
    order_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    customer_id BIGINT UNSIGNED NOT NULL,  -- ID uniquement
    -- Pas de customer_name, customer_email ici
    -- Ces donn√©es sont r√©cup√©r√©es via GET /customers/{id}
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    total_amount DECIMAL(15,2) NOT NULL,
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6)
) ENGINE=InnoDB;

-- Cache local pour r√©duire les appels inter-services
CREATE TABLE customer_cache (
    customer_id BIGINT UNSIGNED PRIMARY KEY,
    customer_data JSON NOT NULL,
    cached_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    ttl_seconds INT UNSIGNED DEFAULT 3600,
    
    INDEX idx_expiry ((cached_at + INTERVAL ttl_seconds SECOND))
) ENGINE=InnoDB;

-- Fonction pour v√©rifier la validit√© du cache
DELIMITER //
CREATE FUNCTION is_cache_valid(p_customer_id BIGINT UNSIGNED) 
RETURNS BOOLEAN
DETERMINISTIC
BEGIN
    DECLARE v_valid BOOLEAN;
    
    SELECT (cached_at + INTERVAL ttl_seconds SECOND) > NOW(6) INTO v_valid
    FROM customer_cache
    WHERE customer_id = p_customer_id;
    
    RETURN COALESCE(v_valid, FALSE);
END //
DELIMITER ;
```

‚ö†Ô∏è **Attention** : Les appels synchrones cr√©ent un **couplage temporel**. Si le service Customers est indisponible, le service Commandes ne peut pas enrichir ses r√©ponses. Impl√©mentez des **circuit breakers** et des **fallbacks** (ex: utiliser le cache m√™me expir√©).

### Communication asynchrone (Events)

L'approche √©v√©nementielle d√©couple les services dans le temps et am√©liore la r√©silience :

```sql
-- Service Customers : Publication d'√©v√©nements de mise √† jour
CREATE TABLE customer_events_outbox (
    event_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    customer_id BIGINT UNSIGNED NOT NULL,
    event_type ENUM('CustomerCreated', 'CustomerUpdated', 
                    'CustomerAddressChanged', 'CustomerDeleted') NOT NULL,
    payload JSON NOT NULL,
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    published_at DATETIME(6) NULL,
    
    INDEX idx_unpublished (published_at, created_at)
) ENGINE=InnoDB;

-- Trigger pour capturer les modifications
DELIMITER //
CREATE TRIGGER trg_customer_update_event
AFTER UPDATE ON customers
FOR EACH ROW
BEGIN
    -- D√©tection des changements significatifs
    IF OLD.email != NEW.email OR OLD.name != NEW.name THEN
        INSERT INTO customer_events_outbox (customer_id, event_type, payload)
        VALUES (
            NEW.customer_id,
            'CustomerUpdated',
            JSON_OBJECT(
                'customer_id', NEW.customer_id,
                'old_values', JSON_OBJECT('name', OLD.name, 'email', OLD.email),
                'new_values', JSON_OBJECT('name', NEW.name, 'email', NEW.email),
                'changed_at', NOW(6)
            )
        );
    END IF;
    
    IF OLD.shipping_address != NEW.shipping_address THEN
        INSERT INTO customer_events_outbox (customer_id, event_type, payload)
        VALUES (
            NEW.customer_id,
            'CustomerAddressChanged',
            JSON_OBJECT(
                'customer_id', NEW.customer_id,
                'old_address', OLD.shipping_address,
                'new_address', NEW.shipping_address,
                'changed_at', NOW(6)
            )
        );
    END IF;
END //
DELIMITER ;
```

```sql
-- Service Commandes : R√©ception et projection des √©v√©nements
CREATE TABLE customer_projections (
    customer_id BIGINT UNSIGNED PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL,
    shipping_address JSON,
    last_event_id BIGINT UNSIGNED NOT NULL,  -- Idempotence
    updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6)
) ENGINE=InnoDB;

-- Proc√©dure idempotente de traitement d'√©v√©nement
DELIMITER //
CREATE PROCEDURE process_customer_event(
    IN p_event_id BIGINT UNSIGNED,
    IN p_customer_id BIGINT UNSIGNED,
    IN p_event_type VARCHAR(50),
    IN p_payload JSON
)
BEGIN
    DECLARE v_last_processed BIGINT UNSIGNED;
    
    -- V√©rification idempotence
    SELECT last_event_id INTO v_last_processed
    FROM customer_projections
    WHERE customer_id = p_customer_id;
    
    IF v_last_processed IS NULL OR p_event_id > v_last_processed THEN
        INSERT INTO customer_projections (
            customer_id, name, email, shipping_address, last_event_id
        )
        VALUES (
            p_customer_id,
            JSON_UNQUOTE(JSON_EXTRACT(p_payload, '$.new_values.name')),
            JSON_UNQUOTE(JSON_EXTRACT(p_payload, '$.new_values.email')),
            JSON_EXTRACT(p_payload, '$.new_address'),
            p_event_id
        )
        ON DUPLICATE KEY UPDATE
            name = COALESCE(
                JSON_UNQUOTE(JSON_EXTRACT(p_payload, '$.new_values.name')), 
                name
            ),
            email = COALESCE(
                JSON_UNQUOTE(JSON_EXTRACT(p_payload, '$.new_values.email')), 
                email
            ),
            shipping_address = COALESCE(
                JSON_EXTRACT(p_payload, '$.new_address'), 
                shipping_address
            ),
            last_event_id = p_event_id;
    END IF;
END //
DELIMITER ;
```

---

## Requ√™tes distribu√©es et jointures

### Anti-pattern : jointures inter-bases

L'une des cons√©quences majeures du pattern Database per Service est l'**impossibilit√© de r√©aliser des jointures SQL traditionnelles** entre services.

```sql
-- ‚ùå IMPOSSIBLE : Les tables sont dans des bases/instances diff√©rentes
SELECT o.order_id, o.total_amount, c.name, c.email
FROM orders_db.orders o
JOIN customers_db.customers c ON o.customer_id = c.customer_id;
-- Error: Access denied ou table inexistante
```

### Solutions recommand√©es

#### 1. Composition API (API Composition Pattern)

Un service ou une API Gateway agr√®ge les donn√©es de plusieurs services :

```python
# Service de composition / BFF (Backend for Frontend)
# Pseudo-code illustratif

async def get_order_with_details(order_id: int) -> OrderDetails:
    # Appels parall√®les aux diff√©rents services
    order_task = orders_client.get_order(order_id)
    
    order = await order_task
    
    # Enrichissement avec donn√©es client (si non-null)
    if order.customer_id:
        customer = await customers_client.get_customer(order.customer_id)
        order.customer_name = customer.name
        order.customer_email = customer.email
    
    # Enrichissement avec d√©tails produits
    product_ids = [item.product_id for item in order.items]
    products = await catalog_client.get_products_batch(product_ids)
    
    for item in order.items:
        product = products.get(item.product_id)
        if product:
            item.product_name = product.name
            item.product_image_url = product.image_url
    
    return order
```

#### 2. D√©normalisation par √©v√©nements

Stocker des copies des donn√©es n√©cessaires localement :

```sql
-- Service Commandes : Vue enrichie maintenue par √©v√©nements
CREATE TABLE orders_enriched (
    order_id BIGINT UNSIGNED PRIMARY KEY,
    customer_id BIGINT UNSIGNED NOT NULL,
    
    -- Donn√©es copi√©es du service Customers (via √©v√©nements)
    customer_name VARCHAR(255),
    customer_email VARCHAR(255),
    
    -- Donn√©es de commande
    status VARCHAR(50) NOT NULL,
    total_amount DECIMAL(15,2) NOT NULL,
    created_at DATETIME(6) NOT NULL,
    
    -- M√©tadonn√©es de synchronisation
    customer_data_version BIGINT UNSIGNED,
    
    INDEX idx_customer (customer_id),
    INDEX idx_status (status)
) ENGINE=InnoDB;

-- Cette table est mise √† jour :
-- 1. √Ä la cr√©ation de commande (snapshot initial)
-- 2. Via les √©v√©nements CustomerUpdated (mise √† jour asynchrone)
```

#### 3. Moteur CONNECT pour cas exceptionnels

MariaDB propose le moteur **CONNECT** pour acc√©der √† des sources externes. √Ä utiliser avec pr√©caution pour des cas sp√©cifiques (migration, reporting) :

```sql
-- ‚ö†Ô∏è Usage exceptionnel : acc√®s cross-database pour reporting
-- Ne pas utiliser pour des requ√™tes applicatives courantes

INSTALL SONAME 'ha_connect';

CREATE TABLE customers_remote (
    customer_id BIGINT UNSIGNED,
    name VARCHAR(255),
    email VARCHAR(255)
)
ENGINE=CONNECT
TABLE_TYPE=MYSQL
CONNECTION='mysql://report_user:password@customers-db:3306/customers'
SRCDEF='SELECT customer_id, name, email FROM customers';

-- Requ√™te de reporting (lecture seule)
SELECT o.order_id, o.total_amount, cr.name
FROM orders o
JOIN customers_remote cr ON o.customer_id = cr.customer_id
WHERE o.created_at > DATE_SUB(NOW(), INTERVAL 7 DAY);
```

‚ö†Ô∏è **Attention** : Le moteur CONNECT introduit un couplage fort et des probl√®mes de performance. R√©servez-le aux cas de migration ou de reporting ponctuel, jamais pour des requ√™tes applicatives.

---

## Consid√©rations op√©rationnelles

### Gestion des transactions distribu√©es

Sans transactions ACID distribu√©es, garantir la coh√©rence requiert une conception soign√©e :

| Approche | Coh√©rence | Complexit√© | Cas d'usage |
|----------|-----------|------------|-------------|
| **Saga Chor√©graphi√©e** | √âventuelle | Moyenne | Services faiblement coupl√©s |
| **Saga Orchestr√©e** | √âventuelle | √âlev√©e | Workflows complexes |
| **CQRS + Event Sourcing** | √âventuelle | Tr√®s √©lev√©e | Audit, historique complet |
| **Two-Phase Commit (XA)** | Forte | Faible | √âviter si possible |

```sql
-- MariaDB supporte XA mais ce n'est g√©n√©ralement pas recommand√©
-- en architecture microservices (performance, couplage)

-- Exemple XA (√† √©viter en microservices)
XA START 'transaction_123';
INSERT INTO orders (customer_id, total_amount) VALUES (1, 99.99);
XA END 'transaction_123';
XA PREPARE 'transaction_123';
-- Coordination avec d'autres participants...
XA COMMIT 'transaction_123';
```

### Backup et restauration coh√©rente

Avec des bases distribu√©es, la **restauration coh√©rente √† un point dans le temps** devient complexe :

```bash
#!/bin/bash
# Script de backup coordonn√© multi-services

BACKUP_TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backups/${BACKUP_TIMESTAMP}"

mkdir -p "${BACKUP_DIR}"

# Backup parall√®le de tous les services
# Utilise mariabackup pour coh√©rence point-in-time

echo "Starting coordinated backup at ${BACKUP_TIMESTAMP}"

mariabackup --backup \
    --host=orders-db \
    --user=backup_user \
    --password="${ORDERS_BACKUP_PWD}" \
    --target-dir="${BACKUP_DIR}/orders" &
PID_ORDERS=$!

mariabackup --backup \
    --host=customers-db \
    --user=backup_user \
    --password="${CUSTOMERS_BACKUP_PWD}" \
    --target-dir="${BACKUP_DIR}/customers" &
PID_CUSTOMERS=$!

mariabackup --backup \
    --host=inventory-db \
    --user=backup_user \
    --password="${INVENTORY_BACKUP_PWD}" \
    --target-dir="${BACKUP_DIR}/inventory" &
PID_INVENTORY=$!

# Attente de tous les backups
wait $PID_ORDERS $PID_CUSTOMERS $PID_INVENTORY

# Enregistrement des positions de binlog pour corr√©lation
echo "Recording binlog positions..."
for service in orders customers inventory; do
    mysql -h ${service}-db -u backup_user -p"${!${service^^}_BACKUP_PWD}" \
        -e "SHOW MASTER STATUS\G" > "${BACKUP_DIR}/${service}/binlog_position.txt"
done

echo "Backup completed: ${BACKUP_DIR}"
```

üí° **Conseil** : Documentez les **d√©pendances √©v√©nementielles** entre services. Lors d'une restauration, vous devrez peut-√™tre rejouer les √©v√©nements dans l'ordre pour r√©tablir la coh√©rence.

### Monitoring distribu√©

Chaque instance n√©cessite un monitoring d√©di√© avec une vue consolid√©e :

```yaml
# prometheus/prometheus.yml - Configuration multi-instances
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'mariadb-orders'
    static_configs:
      - targets: ['orders-db-exporter:9104']
    relabel_configs:
      - source_labels: [__address__]
        target_label: service
        replacement: 'orders'

  - job_name: 'mariadb-customers'
    static_configs:
      - targets: ['customers-db-exporter:9104']
    relabel_configs:
      - source_labels: [__address__]
        target_label: service
        replacement: 'customers'

  - job_name: 'mariadb-inventory'
    static_configs:
      - targets: ['inventory-db-exporter:9104']
    relabel_configs:
      - source_labels: [__address__]
        target_label: service
        replacement: 'inventory'
```

```sql
-- Vue de sant√© par service (√† ex√©cuter sur chaque instance)
-- Expos√©e via une API de healthcheck

SELECT 
    'orders' AS service,
    @@hostname AS host,
    @@version AS mariadb_version,
    (SELECT COUNT(*) FROM information_schema.PROCESSLIST 
     WHERE COMMAND != 'Sleep') AS active_queries,
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Threads_connected') AS connections,
    (SELECT VARIABLE_VALUE FROM information_schema.GLOBAL_STATUS 
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests') AS buffer_pool_reads,
    NOW(6) AS checked_at;
```

---

## Avantages et inconv√©nients

### ‚úÖ Avantages

| Avantage | Description |
|----------|-------------|
| **Autonomie des √©quipes** | Chaque √©quipe ma√Ætrise son domaine de donn√©es |
| **Scalabilit√© ind√©pendante** | Dimensionnement adapt√© aux besoins de chaque service |
| **Isolation des pannes** | Un probl√®me de BDD n'affecte qu'un seul service |
| **Libert√© technologique** | Choix du moteur/configuration optimal par cas d'usage |
| **D√©ploiement ind√©pendant** | Migrations de sch√©ma sans coordination globale |
| **Performances optimis√©es** | Requ√™tes confin√©es √† des datasets sp√©cialis√©s |

### ‚ùå Inconv√©nients

| Inconv√©nient | Description | Mitigation |
|--------------|-------------|------------|
| **Complexit√© op√©rationnelle** | N bases √† g√©rer, monitorer, sauvegarder | Automatisation, IaC, Kubernetes Operators |
| **Coh√©rence √©ventuelle** | Pas de transactions ACID distribu√©es | Sagas, idempotence, r√©conciliation |
| **Duplication de donn√©es** | Copies locales pour √©viter les appels | √âv√©nements, versioning, TTL |
| **Co√ªt infrastructure** | N instances vs 1 instance partag√©e | Dimensionnement adapt√©, cloud √©lastique |
| **Requ√™tes complexes** | Impossible de joindre cross-services | CQRS, d√©normalisation, API composition |
| **Debugging distribu√©** | Traces r√©parties sur plusieurs syst√®mes | Tracing distribu√© (Jaeger, Zipkin) |

---

## Quand utiliser ce pattern ?

### ‚úÖ Recommand√© pour :

- Organisations avec **√©quipes autonomes** par domaine m√©tier
- Applications n√©cessitant une **scalabilit√© granulaire**
- Syst√®mes o√π l'**isolation des pannes** est critique
- Projets avec des **cycles de release ind√©pendants** par fonctionnalit√©
- Domaines avec des **patterns d'acc√®s tr√®s diff√©rents** (OLTP vs OLAP)

### ‚ùå D√©conseill√© pour :

- **Petites √©quipes** g√©rant l'ensemble de l'application
- Applications avec **nombreuses jointures cross-domaines**
- Projets o√π la **coh√©rence forte** est indispensable
- Budgets limit√©s ne permettant pas l'infrastructure distribu√©e
- √âquipes sans exp√©rience en **syst√®mes distribu√©s**

---

## ‚úÖ Points cl√©s √† retenir

- Le pattern **Database per Service** impose que chaque microservice poss√®de exclusivement ses donn√©es, accessibles uniquement via son API publique
- L'**encapsulation des donn√©es** permet l'autonomie des √©quipes, la scalabilit√© ind√©pendante et l'isolation des pannes
- Les **Sagas** remplacent les transactions ACID distribu√©es par une s√©quence de transactions locales coordonn√©es par √©v√©nements
- L'**Outbox Pattern** garantit l'atomicit√© entre modification de donn√©es et publication d'√©v√©nements
- Le pattern **CQRS** optimise les lectures via des mod√®les d√©normalis√©s aliment√©s par √©v√©nements
- Les **jointures cross-services** sont impossibles : utilisez l'API composition ou la d√©normalisation
- La **coh√©rence √©ventuelle** est inh√©rente : concevez pour l'idempotence et la r√©conciliation
- Le **co√ªt op√©rationnel** est significatif : automatisez via IaC, Kubernetes Operators, et monitoring centralis√©

---

## üîó Ressources et r√©f√©rences

- üìñ [MariaDB Documentation - Storage Engines](https://mariadb.com/kb/en/storage-engines/)
- üìñ [MariaDB Documentation - XA Transactions](https://mariadb.com/kb/en/xa-transactions/)
- üìñ [Pattern: Database per Service - microservices.io](https://microservices.io/patterns/data/database-per-service.html)
- üìñ [Pattern: Saga - microservices.io](https://microservices.io/patterns/data/saga.html)
- üìñ [Pattern: CQRS - Martin Fowler](https://martinfowler.com/bliki/CQRS.html)
- üìñ [Transactional Outbox Pattern - microservices.io](https://microservices.io/patterns/data/transactional-outbox.html)
- üìñ [Building Microservices - Sam Newman (O'Reilly)](https://www.oreilly.com/library/view/building-microservices-2nd/9781492034018/)

---

## ‚û°Ô∏è Section suivante

**20.2.2 Shared Database Pattern** : D√©couvrez l'approche alternative o√π plusieurs services partagent une m√™me base de donn√©es, ses cas d'usage l√©gitimes, et comment migrer progressivement vers une architecture plus d√©coupl√©e.

‚è≠Ô∏è [Shared database pattern](/20-cas-usage-architectures/02.2-shared-database.md)
