üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.4.2 Schema per Tenant

> **Niveau** : Interm√©diaire √† Avanc√©  
> **Dur√©e estim√©e** : 2h30  
> **Pr√©requis** : Chapitre 10 (S√©curit√© et Gestion des Utilisateurs), Section 20.4 (Architecture multi-tenant), Section 20.4.1 (Database per Tenant)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :

- Concevoir une architecture multi-tenant avec isolation par sch√©ma
- Impl√©menter un syst√®me de provisioning dynamique de sch√©mas avec MariaDB
- G√©rer efficacement les migrations de sch√©ma sur des centaines de tenants
- Mettre en place des contr√¥les de s√©curit√© et d'isolation appropri√©s
- Optimiser les performances dans un contexte de sch√©mas multiples
- Choisir entre Schema per Tenant et les autres patterns multi-tenant

---

## Introduction

Le pattern **Schema per Tenant** (un sch√©ma par locataire) repr√©sente un **compromis √©quilibr√©** entre l'isolation compl√®te du pattern Database per Tenant et l'efficacit√© op√©rationnelle du Shared Schema. Chaque tenant dispose de son propre sch√©ma (base de donn√©es logique) au sein d'une **instance MariaDB partag√©e**.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SCHEMA PER TENANT PATTERN                           ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ                    APPLICATION SaaS                             ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ         (Code unique, Routage par sch√©ma)                       ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                              ‚îÇ                                         ‚îÇ
‚îÇ              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                         ‚îÇ
‚îÇ              ‚îÇ               ‚îÇ               ‚îÇ                         ‚îÇ
‚îÇ              ‚ñº               ‚ñº               ‚ñº                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ                   INSTANCE MariaDB 11.8                           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ                                                                   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ tenant_acme ‚îÇ  ‚îÇtenant_globex‚îÇ  ‚îÇtenant_initech‚îÇ    ...        ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   (schema)  ‚îÇ  ‚îÇ   (schema)  ‚îÇ  ‚îÇ   (schema)   ‚îÇ               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ              ‚îÇ               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ  ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ  ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ ‚îÇ  users  ‚îÇ ‚îÇ  ‚îÇ ‚îÇ  users  ‚îÇ ‚îÇ  ‚îÇ ‚îÇ  users   ‚îÇ ‚îÇ               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ ‚îÇ  orders ‚îÇ ‚îÇ  ‚îÇ ‚îÇ  orders ‚îÇ ‚îÇ  ‚îÇ ‚îÇ  orders  ‚îÇ ‚îÇ               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ ‚îÇproducts ‚îÇ ‚îÇ  ‚îÇ ‚îÇproducts ‚îÇ ‚îÇ  ‚îÇ ‚îÇ products ‚îÇ ‚îÇ               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ  ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ  ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îÇ ‚îÇ
‚îÇ  ‚îÇ                                                                   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ                  Buffer Pool Partag√©                              ‚îÇ ‚îÇ
‚îÇ  ‚îÇ                  Connexions Partag√©es                             ‚îÇ ‚îÇ
‚îÇ  ‚îÇ                  Redo/Undo Logs Partag√©s                          ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  Isolation : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë Bonne (logique)                              ‚îÇ
‚îÇ  Co√ªt/tenant : ‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë Mod√©r√©                                     ‚îÇ
‚îÇ  Complexit√© ops : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë Moyenne                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Ce pattern est particuli√®rement adapt√© aux **SaaS B2B** avec un nombre mod√©r√© de tenants (quelques centaines √† quelques milliers), n√©cessitant une bonne isolation logique sans la complexit√© d'instances s√©par√©es.

---

## Principes fondamentaux

### Isolation logique vs physique

Contrairement au pattern Database per Tenant qui offre une isolation physique, le Schema per Tenant fournit une **isolation logique** :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    COMPARAISON DES NIVEAUX D'ISOLATION                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

DATABASE PER TENANT (Isolation physique)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Instance A     ‚îÇ  ‚îÇ   Instance B     ‚îÇ  ‚îÇ   Instance C     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ Tenant A   ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ Tenant B   ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ Tenant C   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ Buffer Pool‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ Buffer Pool‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ Buffer Pool‚îÇ  ‚îÇ
‚îÇ  ‚îÇ Redo Logs  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ Redo Logs  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ Redo Logs  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ Processus  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ Processus  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ Processus  ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚úÖ Isolation totale    ‚ùå Co√ªt √©lev√©    ‚ùå Complexit√© ops


SCHEMA PER TENANT (Isolation logique)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      Instance Unique                            ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ
‚îÇ  ‚îÇ  Schema A    ‚îÇ  ‚îÇ  Schema B    ‚îÇ  ‚îÇ  Schema C    ‚îÇ   ...     ‚îÇ
‚îÇ  ‚îÇ  (Tenant A)  ‚îÇ  ‚îÇ  (Tenant B)  ‚îÇ  ‚îÇ  (Tenant C)  ‚îÇ           ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ
‚îÇ                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ            Ressources Partag√©es                            ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Buffer Pool      ‚Ä¢ Thread Pool    ‚Ä¢ Redo/Undo Logs      ‚îÇ ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Connexions       ‚Ä¢ Query Cache    ‚Ä¢ Binary Logs         ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚ö†Ô∏è Isolation logique    ‚úÖ Co√ªt optimis√©    ‚úÖ Ops simplifi√©es
```

### Avantages de l'approche

| Aspect | B√©n√©fice |
|--------|----------|
| **Simplicit√© op√©rationnelle** | Une seule instance √† g√©rer, monitorer, sauvegarder |
| **Efficacit√© des ressources** | Buffer pool partag√©, meilleure utilisation m√©moire |
| **Provisioning rapide** | Cr√©ation de sch√©ma en millisecondes vs secondes/minutes |
| **Connexions mutualis√©es** | Pool de connexions unique pour tous les tenants |
| **Migrations group√©es** | Scripts SQL applicables s√©quentiellement |
| **Co√ªt r√©duit** | Infrastructure partag√©e entre tous les tenants |

### Sch√©ma de donn√©es type

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ORGANISATION DES SCH√âMAS                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         INSTANCE MariaDB                               ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  saas_platform (Sch√©ma de contr√¥le)                             ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ tenants           - M√©tadonn√©es des locataires               ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ tenant_events     - Historique des √©v√©nements                ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ subscriptions     - Plans et abonnements                     ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ schema_migrations - Suivi des migrations                     ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               ‚îÇ
‚îÇ  ‚îÇ tenant_acme   ‚îÇ  ‚îÇ tenant_globex ‚îÇ  ‚îÇ tenant_wayne  ‚îÇ   ...         ‚îÇ
‚îÇ  ‚îÇ               ‚îÇ  ‚îÇ               ‚îÇ  ‚îÇ               ‚îÇ               ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ users       ‚îÇ  ‚îÇ ‚Ä¢ users       ‚îÇ  ‚îÇ ‚Ä¢ users       ‚îÇ               ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ products    ‚îÇ  ‚îÇ ‚Ä¢ products    ‚îÇ  ‚îÇ ‚Ä¢ products    ‚îÇ               ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ orders      ‚îÇ  ‚îÇ ‚Ä¢ orders      ‚îÇ  ‚îÇ ‚Ä¢ orders      ‚îÇ               ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ invoices    ‚îÇ  ‚îÇ ‚Ä¢ invoices    ‚îÇ  ‚îÇ ‚Ä¢ invoices    ‚îÇ               ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ settings    ‚îÇ  ‚îÇ ‚Ä¢ settings    ‚îÇ  ‚îÇ ‚Ä¢ settings    ‚îÇ               ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  shared_data (Sch√©ma de donn√©es partag√©es - lecture seule)      ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ countries         - R√©f√©rentiel pays                         ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ currencies        - R√©f√©rentiel devises                      ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ tax_rates         - Taux de TVA par r√©gion                   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ feature_flags     - Flags de fonctionnalit√©s                 ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Impl√©mentation avec MariaDB 11.8

### Sch√©ma de contr√¥le (Control Plane)

```sql
-- ============================================================
-- SCH√âMA DE CONTR√îLE MULTI-TENANT
-- ============================================================

CREATE DATABASE saas_platform
    CHARACTER SET utf8mb4
    COLLATE utf8mb4_uca1400_ai_ci;  -- üÜï Collation UCA 14.0.0

USE saas_platform;

-- Table principale des tenants
CREATE TABLE tenants (
    tenant_id VARCHAR(36) PRIMARY KEY DEFAULT (UUID()),
    tenant_slug VARCHAR(64) UNIQUE NOT NULL,
    schema_name VARCHAR(64) UNIQUE NOT NULL,
    company_name VARCHAR(255) NOT NULL,
    
    -- Contact principal
    contact_email VARCHAR(255) NOT NULL,
    contact_name VARCHAR(255),
    
    -- Abonnement
    subscription_tier ENUM('free', 'starter', 'business', 'enterprise') 
                      DEFAULT 'free',
    subscription_status ENUM('trial', 'active', 'past_due', 'cancelled') 
                        DEFAULT 'trial',
    trial_ends_at DATETIME(6),
    
    -- √âtat op√©rationnel
    status ENUM('provisioning', 'active', 'suspended', 'maintenance', 
                'pending_deletion', 'deleted') DEFAULT 'provisioning',
    
    -- Limites par plan
    max_users INT UNSIGNED,
    max_storage_mb BIGINT UNSIGNED,
    max_api_requests_per_day INT UNSIGNED,
    
    -- Configuration tenant
    settings JSON DEFAULT '{}',
    feature_overrides JSON DEFAULT '{}',
    
    -- M√©tadonn√©es de sch√©ma
    schema_version VARCHAR(20) DEFAULT '0.0.0',
    last_migration_at DATETIME(6),
    
    -- Timestamps
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
               ON UPDATE CURRENT_TIMESTAMP(6),
    activated_at DATETIME(6),
    deleted_at DATETIME(6),
    
    INDEX idx_slug (tenant_slug),
    INDEX idx_status (status),
    INDEX idx_tier (subscription_tier),
    INDEX idx_schema (schema_name)
) ENGINE=InnoDB;

-- Historique des √©v√©nements
CREATE TABLE tenant_events (
    event_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    tenant_id VARCHAR(36) NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    event_data JSON,
    performed_by VARCHAR(255),
    ip_address VARCHAR(45),
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    
    INDEX idx_tenant (tenant_id),
    INDEX idx_type (event_type),
    INDEX idx_created (created_at DESC),
    
    FOREIGN KEY (tenant_id) REFERENCES tenants(tenant_id) ON DELETE CASCADE
) ENGINE=InnoDB;

-- Plans d'abonnement
CREATE TABLE subscription_plans (
    plan_id VARCHAR(36) PRIMARY KEY DEFAULT (UUID()),
    plan_name VARCHAR(50) UNIQUE NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    
    -- Limites
    max_users INT UNSIGNED,
    max_storage_mb BIGINT UNSIGNED,
    max_api_requests_per_day INT UNSIGNED,
    
    -- Features incluses
    features JSON NOT NULL DEFAULT '{}',
    
    -- Prix
    price_monthly_cents INT UNSIGNED NOT NULL DEFAULT 0,
    price_annual_cents INT UNSIGNED,
    
    -- M√©tadonn√©es
    is_public BOOLEAN DEFAULT TRUE,
    sort_order INT UNSIGNED DEFAULT 0,
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6)
) ENGINE=InnoDB;

-- Suivi des migrations par tenant
CREATE TABLE tenant_schema_migrations (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    tenant_id VARCHAR(36) NOT NULL,
    migration_version VARCHAR(20) NOT NULL,
    migration_name VARCHAR(255) NOT NULL,
    status ENUM('pending', 'running', 'completed', 'failed', 'skipped') 
           DEFAULT 'pending',
    started_at DATETIME(6),
    completed_at DATETIME(6),
    execution_time_ms INT UNSIGNED,
    error_message TEXT,
    checksum VARCHAR(64),
    
    UNIQUE KEY uk_tenant_version (tenant_id, migration_version),
    INDEX idx_status (status),
    INDEX idx_version (migration_version),
    
    FOREIGN KEY (tenant_id) REFERENCES tenants(tenant_id) ON DELETE CASCADE
) ENGINE=InnoDB;

-- Donn√©es initiales des plans
INSERT INTO subscription_plans 
    (plan_name, display_name, max_users, max_storage_mb, max_api_requests_per_day, 
     features, price_monthly_cents, sort_order)
VALUES
    ('free', 'Free', 3, 100, 1000, 
     '{"api_access": false, "export": false, "integrations": 0, "support": "community"}',
     0, 1),
    ('starter', 'Starter', 10, 1024, 10000, 
     '{"api_access": true, "export": true, "integrations": 3, "support": "email"}',
     1900, 2),
    ('business', 'Business', 50, 10240, 100000, 
     '{"api_access": true, "export": true, "integrations": 10, "support": "priority", "sso": false}',
     4900, 3),
    ('enterprise', 'Enterprise', NULL, NULL, NULL, 
     '{"api_access": true, "export": true, "integrations": -1, "support": "dedicated", "sso": true, "audit_logs": true}',
     19900, 4);
```

### Sch√©ma des donn√©es partag√©es

```sql
-- ============================================================
-- SCH√âMA DE DONN√âES PARTAG√âES (Lecture seule pour les tenants)
-- ============================================================

CREATE DATABASE shared_data
    CHARACTER SET utf8mb4
    COLLATE utf8mb4_uca1400_ai_ci;

USE shared_data;

-- R√©f√©rentiel pays
CREATE TABLE countries (
    country_code CHAR(2) PRIMARY KEY,
    country_code_iso3 CHAR(3) UNIQUE,
    name VARCHAR(100) NOT NULL,
    native_name VARCHAR(100),
    currency_code CHAR(3),
    phone_prefix VARCHAR(10),
    is_eu_member BOOLEAN DEFAULT FALSE,
    is_active BOOLEAN DEFAULT TRUE,
    
    INDEX idx_active (is_active)
) ENGINE=InnoDB;

-- R√©f√©rentiel devises
CREATE TABLE currencies (
    currency_code CHAR(3) PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    symbol VARCHAR(10) NOT NULL,
    decimal_places TINYINT UNSIGNED DEFAULT 2,
    is_active BOOLEAN DEFAULT TRUE
) ENGINE=InnoDB;

-- Taux de TVA par pays/r√©gion
CREATE TABLE tax_rates (
    tax_rate_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    country_code CHAR(2) NOT NULL,
    region_code VARCHAR(10),
    tax_type VARCHAR(30) NOT NULL,
    rate DECIMAL(6,4) NOT NULL,
    name VARCHAR(100),
    effective_from DATE NOT NULL,
    effective_until DATE,
    
    INDEX idx_country (country_code),
    INDEX idx_effective (effective_from, effective_until)
) ENGINE=InnoDB;

-- Feature flags globaux
CREATE TABLE feature_flags (
    flag_key VARCHAR(100) PRIMARY KEY,
    flag_name VARCHAR(255) NOT NULL,
    description TEXT,
    default_enabled BOOLEAN DEFAULT FALSE,
    rollout_percentage DECIMAL(5,2) DEFAULT 0,
    plans_enabled JSON,  -- Liste des plans o√π le flag est actif
    updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
               ON UPDATE CURRENT_TIMESTAMP(6)
) ENGINE=InnoDB;

-- Donn√©es initiales
INSERT INTO countries (country_code, country_code_iso3, name, currency_code, is_eu_member) VALUES
    ('FR', 'FRA', 'France', 'EUR', TRUE),
    ('DE', 'DEU', 'Germany', 'EUR', TRUE),
    ('GB', 'GBR', 'United Kingdom', 'GBP', FALSE),
    ('US', 'USA', 'United States', 'USD', FALSE),
    ('CA', 'CAN', 'Canada', 'CAD', FALSE),
    ('CH', 'CHE', 'Switzerland', 'CHF', FALSE);

INSERT INTO currencies (currency_code, name, symbol) VALUES
    ('EUR', 'Euro', '‚Ç¨'),
    ('USD', 'US Dollar', '$'),
    ('GBP', 'British Pound', '¬£'),
    ('CHF', 'Swiss Franc', 'CHF'),
    ('CAD', 'Canadian Dollar', 'CA$');
```

### Provisioning automatis√© d'un sch√©ma tenant

```sql
-- ============================================================
-- PROC√âDURE DE PROVISIONING D'UN NOUVEAU TENANT
-- ============================================================

USE saas_platform;

DELIMITER //

CREATE PROCEDURE provision_tenant(
    IN p_company_name VARCHAR(255),
    IN p_tenant_slug VARCHAR(64),
    IN p_contact_email VARCHAR(255),
    IN p_contact_name VARCHAR(255),
    IN p_subscription_tier VARCHAR(20),
    OUT p_tenant_id VARCHAR(36),
    OUT p_status VARCHAR(50),
    OUT p_message VARCHAR(500)
)
main_block: BEGIN
    DECLARE v_tenant_id VARCHAR(36);
    DECLARE v_schema_name VARCHAR(64);
    DECLARE v_max_users INT UNSIGNED;
    DECLARE v_max_storage BIGINT UNSIGNED;
    DECLARE v_max_api INT UNSIGNED;
    DECLARE v_trial_days INT DEFAULT 14;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 p_message = MESSAGE_TEXT;
        SET p_status = 'ERROR';
        SET p_tenant_id = NULL;
        ROLLBACK;
    END;
    
    -- ============================================================
    -- VALIDATION DES ENTR√âES
    -- ============================================================
    
    -- Validation du slug
    IF p_tenant_slug NOT REGEXP '^[a-z][a-z0-9_]{2,62}[a-z0-9]$' THEN
        SET p_status = 'INVALID_SLUG';
        SET p_message = 'Slug must be 4-64 chars, lowercase alphanumeric with underscores, start with letter';
        LEAVE main_block;
    END IF;
    
    -- V√©rification unicit√© slug
    IF EXISTS (SELECT 1 FROM tenants WHERE tenant_slug = p_tenant_slug) THEN
        SET p_status = 'SLUG_EXISTS';
        SET p_message = 'Tenant slug already exists';
        LEAVE main_block;
    END IF;
    
    -- V√©rification du plan
    SELECT max_users, max_storage_mb, max_api_requests_per_day
    INTO v_max_users, v_max_storage, v_max_api
    FROM subscription_plans
    WHERE plan_name = p_subscription_tier AND is_public = TRUE;
    
    IF v_max_users IS NULL AND p_subscription_tier NOT IN ('enterprise', 'free') THEN
        SET p_status = 'INVALID_PLAN';
        SET p_message = 'Invalid subscription plan';
        LEAVE main_block;
    END IF;
    
    -- ============================================================
    -- CR√âATION DU TENANT
    -- ============================================================
    
    START TRANSACTION;
    
    SET v_tenant_id = UUID();
    SET v_schema_name = CONCAT('tenant_', REPLACE(p_tenant_slug, '-', '_'));
    
    -- Insertion dans la table des tenants
    INSERT INTO tenants (
        tenant_id, tenant_slug, schema_name, company_name,
        contact_email, contact_name, subscription_tier,
        subscription_status, trial_ends_at,
        max_users, max_storage_mb, max_api_requests_per_day,
        status
    ) VALUES (
        v_tenant_id, p_tenant_slug, v_schema_name, p_company_name,
        p_contact_email, p_contact_name, p_subscription_tier,
        'trial', DATE_ADD(NOW(6), INTERVAL v_trial_days DAY),
        v_max_users, v_max_storage, v_max_api,
        'provisioning'
    );
    
    -- Cr√©ation du sch√©ma
    SET @create_schema = CONCAT(
        'CREATE DATABASE `', v_schema_name, '` ',
        'CHARACTER SET utf8mb4 COLLATE utf8mb4_uca1400_ai_ci'
    );
    PREPARE stmt FROM @create_schema;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Log de l'√©v√©nement
    INSERT INTO tenant_events (tenant_id, event_type, event_data, performed_by)
    VALUES (
        v_tenant_id,
        'tenant_created',
        JSON_OBJECT(
            'company_name', p_company_name,
            'schema_name', v_schema_name,
            'subscription_tier', p_subscription_tier,
            'trial_ends_at', DATE_ADD(NOW(6), INTERVAL v_trial_days DAY)
        ),
        'system/provisioning'
    );
    
    COMMIT;
    
    SET p_tenant_id = v_tenant_id;
    SET p_status = 'PROVISIONING';
    SET p_message = CONCAT('Tenant created. Schema: ', v_schema_name, '. Initialization required.');
    
END //

DELIMITER ;
```

### Initialisation du sch√©ma applicatif

```sql
-- ============================================================
-- PROC√âDURE D'INITIALISATION DU SCH√âMA TENANT
-- ============================================================

DELIMITER //

CREATE PROCEDURE initialize_tenant_schema(
    IN p_tenant_id VARCHAR(36),
    OUT p_status VARCHAR(50),
    OUT p_message VARCHAR(500)
)
main_block: BEGIN
    DECLARE v_schema_name VARCHAR(64);
    DECLARE v_current_status VARCHAR(50);
    DECLARE v_initial_version VARCHAR(20) DEFAULT '1.0.0';
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 p_message = MESSAGE_TEXT;
        SET p_status = 'ERROR';
        
        -- Log de l'erreur
        INSERT INTO tenant_events (tenant_id, event_type, event_data)
        VALUES (p_tenant_id, 'schema_init_failed', 
                JSON_OBJECT('error', p_message));
    END;
    
    -- R√©cup√©ration des informations
    SELECT schema_name, status INTO v_schema_name, v_current_status
    FROM tenants WHERE tenant_id = p_tenant_id;
    
    IF v_schema_name IS NULL THEN
        SET p_status = 'NOT_FOUND';
        SET p_message = 'Tenant not found';
        LEAVE main_block;
    END IF;
    
    IF v_current_status != 'provisioning' THEN
        SET p_status = 'INVALID_STATE';
        SET p_message = CONCAT('Invalid tenant status: ', v_current_status);
        LEAVE main_block;
    END IF;
    
    -- ============================================================
    -- CR√âATION DES TABLES APPLICATIVES
    -- ============================================================
    
    -- Table des utilisateurs
    SET @sql = CONCAT('
        CREATE TABLE `', v_schema_name, '`.users (
            user_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
            email VARCHAR(255) NOT NULL,
            password_hash VARCHAR(255),
            
            first_name VARCHAR(100),
            last_name VARCHAR(100),
            display_name VARCHAR(200) GENERATED ALWAYS AS (
                COALESCE(CONCAT(first_name, '' '', last_name), email)
            ) VIRTUAL,
            
            role ENUM(''owner'', ''admin'', ''member'', ''viewer'') DEFAULT ''member'',
            status ENUM(''pending'', ''active'', ''suspended'') DEFAULT ''pending'',
            
            avatar_url VARCHAR(500),
            phone VARCHAR(30),
            timezone VARCHAR(50) DEFAULT ''UTC'',
            locale VARCHAR(10) DEFAULT ''en'',
            
            email_verified_at DATETIME(6),
            last_login_at DATETIME(6),
            
            settings JSON DEFAULT ''{}'',
            
            created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
            updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
                       ON UPDATE CURRENT_TIMESTAMP(6),
            
            UNIQUE KEY uk_email (email),
            INDEX idx_status (status),
            INDEX idx_role (role)
        ) ENGINE=InnoDB
    ');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Table des produits/services
    SET @sql = CONCAT('
        CREATE TABLE `', v_schema_name, '`.products (
            product_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
            sku VARCHAR(64),
            name VARCHAR(255) NOT NULL,
            description TEXT,
            
            product_type ENUM(''physical'', ''digital'', ''service'') DEFAULT ''physical'',
            
            price DECIMAL(12,2) NOT NULL DEFAULT 0,
            currency_code CHAR(3) DEFAULT ''EUR'',
            tax_rate DECIMAL(6,4) DEFAULT 0,
            
            quantity_in_stock INT DEFAULT 0,
            track_inventory BOOLEAN DEFAULT TRUE,
            
            is_active BOOLEAN DEFAULT TRUE,
            
            metadata JSON DEFAULT ''{}'',
            
            created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
            updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
                       ON UPDATE CURRENT_TIMESTAMP(6),
            
            UNIQUE KEY uk_sku (sku),
            INDEX idx_active (is_active),
            INDEX idx_type (product_type),
            FULLTEXT INDEX ft_search (name, description)
        ) ENGINE=InnoDB
    ');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Table des clients
    SET @sql = CONCAT('
        CREATE TABLE `', v_schema_name, '`.customers (
            customer_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
            external_id VARCHAR(100),
            
            email VARCHAR(255),
            phone VARCHAR(30),
            
            company_name VARCHAR(255),
            first_name VARCHAR(100),
            last_name VARCHAR(100),
            
            billing_address JSON,
            shipping_address JSON,
            
            tax_id VARCHAR(50),
            notes TEXT,
            
            tags JSON DEFAULT ''[]'',
            metadata JSON DEFAULT ''{}'',
            
            created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
            updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
                       ON UPDATE CURRENT_TIMESTAMP(6),
            
            INDEX idx_email (email),
            INDEX idx_external (external_id),
            FULLTEXT INDEX ft_search (company_name, first_name, last_name)
        ) ENGINE=InnoDB
    ');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Table des commandes
    SET @sql = CONCAT('
        CREATE TABLE `', v_schema_name, '`.orders (
            order_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
            order_number VARCHAR(32) NOT NULL,
            
            customer_id BIGINT UNSIGNED,
            user_id BIGINT UNSIGNED,  -- Utilisateur qui a cr√©√© la commande
            
            status ENUM(''draft'', ''pending'', ''confirmed'', ''processing'',
                       ''shipped'', ''delivered'', ''cancelled'', ''refunded'') 
                   DEFAULT ''draft'',
            
            subtotal DECIMAL(14,2) NOT NULL DEFAULT 0,
            tax_amount DECIMAL(14,2) NOT NULL DEFAULT 0,
            shipping_amount DECIMAL(14,2) NOT NULL DEFAULT 0,
            discount_amount DECIMAL(14,2) NOT NULL DEFAULT 0,
            total_amount DECIMAL(14,2) GENERATED ALWAYS AS (
                subtotal + tax_amount + shipping_amount - discount_amount
            ) STORED,
            
            currency_code CHAR(3) DEFAULT ''EUR'',
            
            shipping_address JSON,
            billing_address JSON,
            
            notes TEXT,
            internal_notes TEXT,
            
            ordered_at DATETIME(6),
            shipped_at DATETIME(6),
            delivered_at DATETIME(6),
            
            metadata JSON DEFAULT ''{}'',
            
            created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
            updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
                       ON UPDATE CURRENT_TIMESTAMP(6),
            
            UNIQUE KEY uk_order_number (order_number),
            INDEX idx_customer (customer_id),
            INDEX idx_user (user_id),
            INDEX idx_status (status),
            INDEX idx_ordered (ordered_at DESC)
        ) ENGINE=InnoDB
    ');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Table des lignes de commande
    SET @sql = CONCAT('
        CREATE TABLE `', v_schema_name, '`.order_items (
            item_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
            order_id BIGINT UNSIGNED NOT NULL,
            product_id BIGINT UNSIGNED,
            
            name VARCHAR(255) NOT NULL,
            sku VARCHAR(64),
            description TEXT,
            
            quantity INT UNSIGNED NOT NULL DEFAULT 1,
            unit_price DECIMAL(12,2) NOT NULL,
            tax_rate DECIMAL(6,4) DEFAULT 0,
            discount_amount DECIMAL(12,2) DEFAULT 0,
            
            line_total DECIMAL(14,2) GENERATED ALWAYS AS (
                (quantity * unit_price) - discount_amount
            ) STORED,
            
            metadata JSON DEFAULT ''{}'',
            
            created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
            
            INDEX idx_order (order_id),
            INDEX idx_product (product_id)
        ) ENGINE=InnoDB
    ');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Table des param√®tres du tenant
    SET @sql = CONCAT('
        CREATE TABLE `', v_schema_name, '`.settings (
            setting_key VARCHAR(100) PRIMARY KEY,
            setting_value JSON NOT NULL,
            setting_type ENUM(''string'', ''number'', ''boolean'', ''json'') DEFAULT ''string'',
            description VARCHAR(500),
            is_sensitive BOOLEAN DEFAULT FALSE,
            updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
                       ON UPDATE CURRENT_TIMESTAMP(6),
            updated_by BIGINT UNSIGNED
        ) ENGINE=InnoDB
    ');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Param√®tres par d√©faut
    SET @sql = CONCAT('
        INSERT INTO `', v_schema_name, '`.settings (setting_key, setting_value, setting_type, description) VALUES
        (''company.name'', ''"'', p_company_name, ''"'', ''string'', ''Company display name''),
        (''currency.default'', ''"EUR"'', ''string'', ''Default currency code''),
        (''timezone.default'', ''"Europe/Paris"'', ''string'', ''Default timezone''),
        (''order.prefix'', ''"ORD"'', ''string'', ''Order number prefix''),
        (''order.next_number'', ''1001'', ''number'', ''Next order number'')
    ');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Table de m√©tadonn√©es du sch√©ma
    SET @sql = CONCAT('
        CREATE TABLE `', v_schema_name, '`._schema_info (
            info_key VARCHAR(50) PRIMARY KEY,
            info_value VARCHAR(255) NOT NULL,
            updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
                       ON UPDATE CURRENT_TIMESTAMP(6)
        ) ENGINE=InnoDB
    ');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    SET @sql = CONCAT('
        INSERT INTO `', v_schema_name, '`._schema_info (info_key, info_value) VALUES
        (''schema_version'', ''', v_initial_version, '''),
        (''tenant_id'', ''', p_tenant_id, '''),
        (''initialized_at'', NOW(6))
    ');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- ============================================================
    -- ACTIVATION DU TENANT
    -- ============================================================
    
    UPDATE tenants
    SET status = 'active',
        schema_version = v_initial_version,
        last_migration_at = NOW(6),
        activated_at = NOW(6)
    WHERE tenant_id = p_tenant_id;
    
    -- Enregistrement de la migration initiale
    INSERT INTO tenant_schema_migrations 
        (tenant_id, migration_version, migration_name, status, completed_at)
    VALUES 
        (p_tenant_id, v_initial_version, 'Initial schema creation', 'completed', NOW(6));
    
    -- Log de l'√©v√©nement
    INSERT INTO tenant_events (tenant_id, event_type, event_data, performed_by)
    VALUES (
        p_tenant_id,
        'tenant_activated',
        JSON_OBJECT('schema_version', v_initial_version),
        'system/provisioning'
    );
    
    SET p_status = 'SUCCESS';
    SET p_message = CONCAT('Schema initialized successfully. Version: ', v_initial_version);
    
END //

DELIMITER ;
```

**Utilisation du provisioning :**

```sql
-- Cr√©ation d'un nouveau tenant
CALL saas_platform.provision_tenant(
    'Acme Corporation',
    'acme_corp',
    'admin@acme.com',
    'John Doe',
    'business',
    @tenant_id,
    @status,
    @message
);

SELECT @tenant_id, @status, @message;
-- +--------------------------------------+--------------+--------------------------------------------------+
-- | @tenant_id                           | @status      | @message                                         |
-- +--------------------------------------+--------------+--------------------------------------------------+
-- | a1b2c3d4-e5f6-7890-abcd-ef1234567890 | PROVISIONING | Tenant created. Schema: tenant_acme_corp. Init...|
-- +--------------------------------------+--------------+--------------------------------------------------+

-- Initialisation du sch√©ma
CALL saas_platform.initialize_tenant_schema(
    @tenant_id,
    @status,
    @message
);

SELECT @status, @message;
-- +---------+------------------------------------------------+
-- | @status | @message                                       |
-- +---------+------------------------------------------------+
-- | SUCCESS | Schema initialized successfully. Version: 1.0.0|
-- +---------+------------------------------------------------+

-- V√©rification
SHOW DATABASES LIKE 'tenant_%';
-- +-------------------------+
-- | Database (tenant_%)     |
-- +-------------------------+
-- | tenant_acme_corp        |
-- +-------------------------+
```

---

## Gestion des connexions et routage

### Middleware de routage applicatif

```python
# tenant_middleware.py - Middleware de routage multi-tenant

import os
from typing import Optional, Dict, Any
from dataclasses import dataclass
from contextlib import contextmanager
from functools import lru_cache
import mariadb

@dataclass(frozen=True)
class TenantContext:
    """Contexte immuable du tenant pour la requ√™te courante."""
    tenant_id: str
    tenant_slug: str
    schema_name: str
    subscription_tier: str
    max_users: Optional[int]
    features: Dict[str, Any]

class TenantSchemaRouter:
    """
    Routeur de sch√©mas multi-tenant.
    
    G√®re le pool de connexions partag√© et le routage vers les sch√©mas.
    """
    
    def __init__(self, db_config: Dict[str, Any]):
        self.db_config = db_config
        self._pool = mariadb.ConnectionPool(
            pool_name="saas_pool",
            pool_size=20,
            pool_validation_interval=30,
            **db_config
        )
        self._platform_db = "saas_platform"
    
    @lru_cache(maxsize=500)
    def get_tenant_context(self, tenant_slug: str) -> Optional[TenantContext]:
        """
        R√©sout le contexte d'un tenant avec mise en cache.
        """
        conn = self._pool.get_connection()
        try:
            cursor = conn.cursor(dictionary=True)
            cursor.execute(f"""
                SELECT 
                    t.tenant_id,
                    t.tenant_slug,
                    t.schema_name,
                    t.subscription_tier,
                    t.max_users,
                    t.feature_overrides,
                    sp.features AS plan_features
                FROM {self._platform_db}.tenants t
                JOIN {self._platform_db}.subscription_plans sp 
                    ON t.subscription_tier = sp.plan_name
                WHERE t.tenant_slug = %s 
                  AND t.status = 'active'
            """, (tenant_slug,))
            
            row = cursor.fetchone()
            if not row:
                return None
            
            # Fusion des features (plan + overrides)
            features = row['plan_features'] or {}
            if row['feature_overrides']:
                features.update(row['feature_overrides'])
            
            return TenantContext(
                tenant_id=row['tenant_id'],
                tenant_slug=row['tenant_slug'],
                schema_name=row['schema_name'],
                subscription_tier=row['subscription_tier'],
                max_users=row['max_users'],
                features=features
            )
        finally:
            conn.close()
    
    def invalidate_cache(self, tenant_slug: str = None):
        """Invalide le cache pour un tenant ou tous les tenants."""
        if tenant_slug:
            # Invalider un tenant sp√©cifique (n√©cessite Python 3.9+)
            try:
                self.get_tenant_context.cache_clear()
            except AttributeError:
                pass
        else:
            self.get_tenant_context.cache_clear()
    
    @contextmanager
    def tenant_connection(self, tenant: TenantContext):
        """
        Context manager fournissant une connexion configur√©e pour le tenant.
        
        Usage:
            with router.tenant_connection(tenant) as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT * FROM users")
        """
        conn = self._pool.get_connection()
        try:
            # Configuration du sch√©ma par d√©faut pour cette connexion
            cursor = conn.cursor()
            cursor.execute(f"USE `{tenant.schema_name}`")
            cursor.close()
            
            yield conn
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            # Reset vers le sch√©ma platform avant de retourner au pool
            try:
                cursor = conn.cursor()
                cursor.execute(f"USE `{self._platform_db}`")
                cursor.close()
            except:
                pass
            conn.close()
    
    @contextmanager
    def cross_schema_connection(self, tenant: TenantContext):
        """
        Connexion permettant l'acc√®s au sch√©ma tenant ET aux donn√©es partag√©es.
        
        Les requ√™tes doivent pr√©fixer les tables :
        - tenant.schema_name.users
        - shared_data.countries
        """
        conn = self._pool.get_connection()
        try:
            yield conn
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            conn.close()


# Int√©gration FastAPI
from fastapi import FastAPI, Depends, HTTPException, Request
from starlette.middleware.base import BaseHTTPMiddleware

app = FastAPI()

# Configuration globale
router = TenantSchemaRouter({
    'host': os.environ.get('DB_HOST', 'localhost'),
    'port': int(os.environ.get('DB_PORT', 3306)),
    'user': os.environ['DB_USER'],
    'password': os.environ['DB_PASSWORD']
})

class TenantMiddleware(BaseHTTPMiddleware):
    """
    Middleware pour r√©soudre et attacher le tenant √† chaque requ√™te.
    """
    
    async def dispatch(self, request: Request, call_next):
        # Routes publiques sans tenant
        if request.url.path.startswith(('/health', '/docs', '/openapi')):
            return await call_next(request)
        
        # Extraction du tenant slug
        tenant_slug = self._extract_tenant_slug(request)
        
        if not tenant_slug:
            return JSONResponse(
                status_code=400,
                content={"error": "Tenant identifier required"}
            )
        
        # R√©solution du tenant
        tenant = router.get_tenant_context(tenant_slug)
        
        if not tenant:
            return JSONResponse(
                status_code=404,
                content={"error": f"Tenant not found: {tenant_slug}"}
            )
        
        # Attachement au state de la requ√™te
        request.state.tenant = tenant
        
        return await call_next(request)
    
    def _extract_tenant_slug(self, request: Request) -> Optional[str]:
        """Extrait le slug du tenant depuis la requ√™te."""
        
        # Strat√©gie 1: Header X-Tenant-ID
        if tenant_slug := request.headers.get('X-Tenant-ID'):
            return tenant_slug
        
        # Strat√©gie 2: Subdomain (acme.app.example.com)
        host = request.headers.get('host', '')
        parts = host.split('.')
        if len(parts) >= 3 and parts[0] not in ('www', 'api', 'app'):
            return parts[0]
        
        # Strat√©gie 3: Query parameter (pour debug)
        if tenant_slug := request.query_params.get('_tenant'):
            return tenant_slug
        
        return None

app.add_middleware(TenantMiddleware)


def get_current_tenant(request: Request) -> TenantContext:
    """Dependency pour obtenir le tenant courant."""
    if not hasattr(request.state, 'tenant'):
        raise HTTPException(status_code=500, detail="Tenant context not available")
    return request.state.tenant


# Exemple d'endpoint
@app.get("/api/users")
async def list_users(
    request: Request,
    tenant: TenantContext = Depends(get_current_tenant)
):
    """Liste les utilisateurs du tenant."""
    
    with router.tenant_connection(tenant) as conn:
        cursor = conn.cursor(dictionary=True)
        cursor.execute("""
            SELECT user_id, email, display_name, role, status, last_login_at
            FROM users
            WHERE status = 'active'
            ORDER BY created_at DESC
            LIMIT 100
        """)
        users = cursor.fetchall()
    
    return {"tenant": tenant.tenant_slug, "users": users}


@app.get("/api/orders/{order_id}")
async def get_order(
    order_id: int,
    tenant: TenantContext = Depends(get_current_tenant)
):
    """R√©cup√®re une commande avec les donn√©es de r√©f√©rence partag√©es."""
    
    with router.cross_schema_connection(tenant) as conn:
        cursor = conn.cursor(dictionary=True)
        
        # Requ√™te cross-schema : tenant + shared_data
        cursor.execute(f"""
            SELECT 
                o.order_id,
                o.order_number,
                o.total_amount,
                o.currency_code,
                c.symbol AS currency_symbol,
                o.status,
                o.ordered_at
            FROM `{tenant.schema_name}`.orders o
            LEFT JOIN shared_data.currencies c ON o.currency_code = c.currency_code
            WHERE o.order_id = %s
        """, (order_id,))
        
        order = cursor.fetchone()
    
    if not order:
        raise HTTPException(status_code=404, detail="Order not found")
    
    return {"order": order}
```

---

## Gestion des migrations multi-tenant

### Strat√©gie de migration s√©quentielle

```sql
-- ============================================================
-- SYST√àME DE MIGRATION MULTI-TENANT
-- ============================================================

USE saas_platform;

-- Table des d√©finitions de migration
CREATE TABLE schema_migration_definitions (
    migration_id VARCHAR(36) PRIMARY KEY DEFAULT (UUID()),
    version VARCHAR(20) NOT NULL UNIQUE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- Script SQL (peut √™tre stock√© ou r√©f√©renc√©)
    up_script MEDIUMTEXT NOT NULL,
    down_script MEDIUMTEXT,  -- Rollback script
    
    -- M√©tadonn√©es
    checksum VARCHAR(64) NOT NULL,  -- SHA256 du script
    is_breaking BOOLEAN DEFAULT FALSE,  -- N√©cessite une maintenance
    estimated_duration_sec INT UNSIGNED,
    min_supported_version VARCHAR(20),  -- Version minimum requise
    
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    created_by VARCHAR(255),
    
    INDEX idx_version (version)
) ENGINE=InnoDB;

-- ============================================================
-- PROC√âDURE D'APPLICATION D'UNE MIGRATION
-- ============================================================

DELIMITER //

CREATE PROCEDURE apply_migration_to_tenant(
    IN p_tenant_id VARCHAR(36),
    IN p_migration_version VARCHAR(20),
    OUT p_status VARCHAR(50),
    OUT p_message TEXT,
    OUT p_duration_ms INT UNSIGNED
)
main_block: BEGIN
    DECLARE v_schema_name VARCHAR(64);
    DECLARE v_current_version VARCHAR(20);
    DECLARE v_up_script MEDIUMTEXT;
    DECLARE v_migration_id VARCHAR(36);
    DECLARE v_start_time DATETIME(6);
    DECLARE v_tenant_status VARCHAR(50);
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 p_message = MESSAGE_TEXT;
        SET p_status = 'FAILED';
        SET p_duration_ms = TIMESTAMPDIFF(MICROSECOND, v_start_time, NOW(6)) / 1000;
        
        -- Mise √† jour du statut de migration
        UPDATE tenant_schema_migrations
        SET status = 'failed',
            completed_at = NOW(6),
            execution_time_ms = p_duration_ms,
            error_message = p_message
        WHERE tenant_id = p_tenant_id 
          AND migration_version = p_migration_version;
        
        ROLLBACK;
    END;
    
    SET v_start_time = NOW(6);
    
    -- R√©cup√©ration des informations tenant
    SELECT schema_name, schema_version, status
    INTO v_schema_name, v_current_version, v_tenant_status
    FROM tenants
    WHERE tenant_id = p_tenant_id;
    
    IF v_schema_name IS NULL THEN
        SET p_status = 'NOT_FOUND';
        SET p_message = 'Tenant not found';
        LEAVE main_block;
    END IF;
    
    IF v_tenant_status NOT IN ('active', 'suspended', 'maintenance') THEN
        SET p_status = 'INVALID_STATE';
        SET p_message = CONCAT('Cannot migrate tenant in state: ', v_tenant_status);
        LEAVE main_block;
    END IF;
    
    -- R√©cup√©ration du script de migration
    SELECT migration_id, up_script
    INTO v_migration_id, v_up_script
    FROM schema_migration_definitions
    WHERE version = p_migration_version;
    
    IF v_up_script IS NULL THEN
        SET p_status = 'MIGRATION_NOT_FOUND';
        SET p_message = CONCAT('Migration version not found: ', p_migration_version);
        LEAVE main_block;
    END IF;
    
    -- V√©rification que la migration n'est pas d√©j√† appliqu√©e
    IF EXISTS (
        SELECT 1 FROM tenant_schema_migrations
        WHERE tenant_id = p_tenant_id 
          AND migration_version = p_migration_version
          AND status = 'completed'
    ) THEN
        SET p_status = 'ALREADY_APPLIED';
        SET p_message = 'Migration already applied';
        LEAVE main_block;
    END IF;
    
    -- Enregistrement du d√©but de migration
    INSERT INTO tenant_schema_migrations 
        (tenant_id, migration_version, migration_name, status, started_at, checksum)
    SELECT 
        p_tenant_id, 
        version, 
        name, 
        'running', 
        NOW(6),
        checksum
    FROM schema_migration_definitions
    WHERE version = p_migration_version
    ON DUPLICATE KEY UPDATE
        status = 'running',
        started_at = NOW(6),
        error_message = NULL;
    
    -- ============================================================
    -- EX√âCUTION DU SCRIPT DE MIGRATION
    -- Le script doit utiliser le sch√©ma dynamiquement
    -- ============================================================
    
    -- Remplacement du placeholder {SCHEMA} par le nom r√©el
    SET v_up_script = REPLACE(v_up_script, '{SCHEMA}', v_schema_name);
    
    -- Ex√©cution (note: en production, utiliser un m√©canisme plus robuste)
    SET @migration_sql = v_up_script;
    PREPARE migration_stmt FROM @migration_sql;
    EXECUTE migration_stmt;
    DEALLOCATE PREPARE migration_stmt;
    
    -- Mise √† jour de la version dans le sch√©ma tenant
    SET @update_version = CONCAT(
        'UPDATE `', v_schema_name, '`._schema_info ',
        'SET info_value = ''', p_migration_version, ''' ',
        'WHERE info_key = ''schema_version'''
    );
    PREPARE stmt FROM @update_version;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Calcul de la dur√©e
    SET p_duration_ms = TIMESTAMPDIFF(MICROSECOND, v_start_time, NOW(6)) / 1000;
    
    -- Mise √† jour du tenant
    UPDATE tenants
    SET schema_version = p_migration_version,
        last_migration_at = NOW(6)
    WHERE tenant_id = p_tenant_id;
    
    -- Mise √† jour du statut de migration
    UPDATE tenant_schema_migrations
    SET status = 'completed',
        completed_at = NOW(6),
        execution_time_ms = p_duration_ms
    WHERE tenant_id = p_tenant_id 
      AND migration_version = p_migration_version;
    
    -- Log de l'√©v√©nement
    INSERT INTO tenant_events (tenant_id, event_type, event_data, performed_by)
    VALUES (
        p_tenant_id,
        'schema_migrated',
        JSON_OBJECT(
            'from_version', v_current_version,
            'to_version', p_migration_version,
            'duration_ms', p_duration_ms
        ),
        'system/migrations'
    );
    
    SET p_status = 'SUCCESS';
    SET p_message = CONCAT('Migration applied successfully in ', p_duration_ms, 'ms');
    
END //

-- ============================================================
-- PROC√âDURE DE MIGRATION DE TOUS LES TENANTS
-- ============================================================

CREATE PROCEDURE apply_migration_to_all_tenants(
    IN p_migration_version VARCHAR(20),
    IN p_batch_size INT,
    IN p_delay_between_tenants_ms INT,
    OUT p_total INT,
    OUT p_success INT,
    OUT p_failed INT,
    OUT p_skipped INT
)
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_tenant_id VARCHAR(36);
    DECLARE v_status VARCHAR(50);
    DECLARE v_message TEXT;
    DECLARE v_duration INT;
    
    DECLARE cur CURSOR FOR
        SELECT t.tenant_id
        FROM tenants t
        LEFT JOIN tenant_schema_migrations tsm 
            ON t.tenant_id = tsm.tenant_id 
            AND tsm.migration_version = p_migration_version
            AND tsm.status = 'completed'
        WHERE t.status IN ('active', 'suspended')
          AND tsm.tenant_id IS NULL  -- Migration non appliqu√©e
        ORDER BY t.created_at
        LIMIT p_batch_size;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    SET p_total = 0;
    SET p_success = 0;
    SET p_failed = 0;
    SET p_skipped = 0;
    SET p_batch_size = COALESCE(p_batch_size, 100);
    SET p_delay_between_tenants_ms = COALESCE(p_delay_between_tenants_ms, 100);
    
    OPEN cur;
    
    migration_loop: LOOP
        FETCH cur INTO v_tenant_id;
        IF done THEN LEAVE migration_loop; END IF;
        
        SET p_total = p_total + 1;
        
        -- Application de la migration
        CALL apply_migration_to_tenant(
            v_tenant_id, 
            p_migration_version,
            v_status,
            v_message,
            v_duration
        );
        
        CASE v_status
            WHEN 'SUCCESS' THEN SET p_success = p_success + 1;
            WHEN 'ALREADY_APPLIED' THEN SET p_skipped = p_skipped + 1;
            ELSE SET p_failed = p_failed + 1;
        END CASE;
        
        -- D√©lai entre les migrations pour √©viter la surcharge
        IF p_delay_between_tenants_ms > 0 THEN
            DO SLEEP(p_delay_between_tenants_ms / 1000);
        END IF;
        
    END LOOP;
    
    CLOSE cur;
    
END //

DELIMITER ;
```

### Exemple de d√©finition de migration

```sql
-- Enregistrement d'une nouvelle migration
INSERT INTO saas_platform.schema_migration_definitions 
    (version, name, description, up_script, down_script, checksum, estimated_duration_sec)
VALUES (
    '1.1.0',
    'Add customer tags and metadata',
    'Adds tags array and metadata JSON columns to customers table',
    -- UP SCRIPT (utilise {SCHEMA} comme placeholder)
    'ALTER TABLE `{SCHEMA}`.customers 
     ADD COLUMN tags JSON DEFAULT ''[]'' AFTER notes,
     ADD COLUMN metadata JSON DEFAULT ''{}'' AFTER tags;
     
     CREATE INDEX idx_tags ON `{SCHEMA}`.customers ((CAST(tags AS CHAR(100) ARRAY)));',
    -- DOWN SCRIPT (rollback)
    'ALTER TABLE `{SCHEMA}`.customers 
     DROP INDEX idx_tags,
     DROP COLUMN metadata,
     DROP COLUMN tags;',
    SHA2('migration_1.1.0_script', 256),
    5
);

-- Migration plus complexe
INSERT INTO saas_platform.schema_migration_definitions 
    (version, name, description, up_script, checksum, is_breaking, estimated_duration_sec)
VALUES (
    '1.2.0',
    'Add audit log table',
    'Creates audit_logs table for tracking changes',
    'CREATE TABLE `{SCHEMA}`.audit_logs (
        log_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
        entity_type VARCHAR(50) NOT NULL,
        entity_id BIGINT UNSIGNED NOT NULL,
        action ENUM(''create'', ''update'', ''delete'') NOT NULL,
        old_values JSON,
        new_values JSON,
        user_id BIGINT UNSIGNED,
        ip_address VARCHAR(45),
        user_agent VARCHAR(500),
        created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
        
        INDEX idx_entity (entity_type, entity_id),
        INDEX idx_user (user_id),
        INDEX idx_created (created_at DESC)
    ) ENGINE=InnoDB;',
    SHA2('migration_1.2.0_script', 256),
    FALSE,
    10
);

-- Application de la migration √† tous les tenants
CALL saas_platform.apply_migration_to_all_tenants(
    '1.1.0',  -- Version
    50,       -- Batch size
    200,      -- D√©lai entre tenants (ms)
    @total,
    @success,
    @failed,
    @skipped
);

SELECT @total AS total, @success AS success, @failed AS failed, @skipped AS skipped;
-- +-------+---------+--------+---------+
-- | total | success | failed | skipped |
-- +-------+---------+--------+---------+
-- |   150 |     148 |      1 |       1 |
-- +-------+---------+--------+---------+

-- V√©rification des √©checs
SELECT 
    t.tenant_slug,
    tsm.migration_version,
    tsm.status,
    tsm.error_message,
    tsm.execution_time_ms
FROM saas_platform.tenant_schema_migrations tsm
JOIN saas_platform.tenants t ON tsm.tenant_id = t.tenant_id
WHERE tsm.status = 'failed'
ORDER BY tsm.started_at DESC;
```

---

## S√©curit√© et isolation

### Contr√¥le d'acc√®s par sch√©ma

```sql
-- ============================================================
-- CONFIGURATION DE S√âCURIT√â MULTI-TENANT
-- ============================================================

-- Utilisateur applicatif principal (utilis√© par l'application)
CREATE USER 'saas_app'@'%' IDENTIFIED BY 'secure_app_password_2025';

-- Privil√®ges sur le sch√©ma de contr√¥le
GRANT SELECT, INSERT, UPDATE ON saas_platform.* TO 'saas_app'@'%';

-- Privil√®ges sur les donn√©es partag√©es (lecture seule)
GRANT SELECT ON shared_data.* TO 'saas_app'@'%';

-- Privil√®ges dynamiques sur les sch√©mas tenant
-- L'application doit avoir acc√®s √† tous les sch√©mas tenant_*

-- Option 1 : Wildcard (si support√© par votre version)
-- GRANT ALL ON `tenant\_%`.* TO 'saas_app'@'%';

-- Option 2 : Proc√©dure pour accorder les privil√®ges dynamiquement
DELIMITER //

CREATE PROCEDURE saas_platform.grant_tenant_access(
    IN p_username VARCHAR(64),
    IN p_host VARCHAR(64)
)
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_schema_name VARCHAR(64);
    
    DECLARE cur CURSOR FOR
        SELECT schema_name FROM saas_platform.tenants WHERE status != 'deleted';
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur;
    
    grant_loop: LOOP
        FETCH cur INTO v_schema_name;
        IF done THEN LEAVE grant_loop; END IF;
        
        SET @grant_sql = CONCAT(
            'GRANT SELECT, INSERT, UPDATE, DELETE ON `', v_schema_name, 
            '`.* TO ''', p_username, '''@''', p_host, ''''
        );
        PREPARE stmt FROM @grant_sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END LOOP;
    
    CLOSE cur;
    FLUSH PRIVILEGES;
END //

DELIMITER ;

-- Ex√©cution initiale
CALL saas_platform.grant_tenant_access('saas_app', '%');

-- ============================================================
-- UTILISATEURS RESTREINTS PAR TENANT (optionnel)
-- Pour des besoins de s√©curit√© renforc√©e
-- ============================================================

-- Proc√©dure pour cr√©er un utilisateur d√©di√© par tenant
DELIMITER //

CREATE PROCEDURE saas_platform.create_tenant_db_user(
    IN p_tenant_id VARCHAR(36),
    OUT p_username VARCHAR(64),
    OUT p_password VARCHAR(64)
)
BEGIN
    DECLARE v_schema_name VARCHAR(64);
    
    SELECT schema_name INTO v_schema_name
    FROM tenants WHERE tenant_id = p_tenant_id;
    
    SET p_username = CONCAT('usr_', LEFT(REPLACE(UUID(), '-', ''), 12));
    SET p_password = CONCAT(
        SUBSTRING(SHA2(RAND(), 256), 1, 20),
        SUBSTRING(SHA2(UUID(), 256), 1, 12)
    );
    
    -- Cr√©ation de l'utilisateur
    SET @create_user = CONCAT(
        'CREATE USER ''', p_username, '''@''%'' ',
        'IDENTIFIED BY ''', p_password, ''''
    );
    PREPARE stmt FROM @create_user;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Privil√®ges uniquement sur son sch√©ma
    SET @grant_sql = CONCAT(
        'GRANT SELECT, INSERT, UPDATE, DELETE ON `', v_schema_name, 
        '`.* TO ''', p_username, '''@''%'''
    );
    PREPARE stmt FROM @grant_sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Lecture seule sur shared_data
    SET @grant_shared = CONCAT(
        'GRANT SELECT ON shared_data.* TO ''', p_username, '''@''%'''
    );
    PREPARE stmt FROM @grant_shared;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    FLUSH PRIVILEGES;
END //

DELIMITER ;
```

### Pr√©vention des acc√®s cross-tenant

```sql
-- ============================================================
-- VUES DE S√âCURIT√â POUR PR√âVENIR LES ACC√àS CROIS√âS
-- ============================================================

-- Vue pour obtenir le sch√©ma du tenant courant (bas√© sur la session)
-- Note: N√©cessite que l'application d√©finisse une variable de session

DELIMITER //

CREATE FUNCTION saas_platform.get_current_tenant_schema()
RETURNS VARCHAR(64)
DETERMINISTIC
READS SQL DATA
BEGIN
    DECLARE v_schema VARCHAR(64);
    
    -- R√©cup√©ration depuis une variable de session d√©finie par l'application
    SET v_schema = @current_tenant_schema;
    
    IF v_schema IS NULL THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'Tenant context not set. Call set_tenant_context() first.';
    END IF;
    
    RETURN v_schema;
END //

CREATE PROCEDURE saas_platform.set_tenant_context(
    IN p_tenant_slug VARCHAR(64)
)
BEGIN
    DECLARE v_schema_name VARCHAR(64);
    DECLARE v_status VARCHAR(50);
    
    SELECT schema_name, status INTO v_schema_name, v_status
    FROM saas_platform.tenants
    WHERE tenant_slug = p_tenant_slug;
    
    IF v_schema_name IS NULL THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'Tenant not found';
    END IF;
    
    IF v_status != 'active' THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'Tenant is not active';
    END IF;
    
    SET @current_tenant_schema = v_schema_name;
    SET @current_tenant_slug = p_tenant_slug;
END //

DELIMITER ;

-- Usage depuis l'application :
-- CALL saas_platform.set_tenant_context('acme_corp');
-- SELECT * FROM tenant_acme_corp.users;
```

---

## Monitoring et observabilit√©

### M√©triques par tenant

```sql
-- ============================================================
-- MONITORING MULTI-TENANT
-- ============================================================

USE saas_platform;

-- Table de m√©triques d'utilisation
CREATE TABLE tenant_usage_metrics (
    metric_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    tenant_id VARCHAR(36) NOT NULL,
    metric_date DATE NOT NULL,
    
    -- M√©triques de volume
    user_count INT UNSIGNED DEFAULT 0,
    product_count INT UNSIGNED DEFAULT 0,
    order_count INT UNSIGNED DEFAULT 0,
    customer_count INT UNSIGNED DEFAULT 0,
    
    -- M√©triques de stockage
    data_size_bytes BIGINT UNSIGNED DEFAULT 0,
    index_size_bytes BIGINT UNSIGNED DEFAULT 0,
    total_size_bytes BIGINT UNSIGNED GENERATED ALWAYS AS 
                     (data_size_bytes + index_size_bytes) STORED,
    
    -- M√©triques d'activit√©
    api_requests_count INT UNSIGNED DEFAULT 0,
    query_count BIGINT UNSIGNED DEFAULT 0,
    
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
               ON UPDATE CURRENT_TIMESTAMP(6),
    
    UNIQUE KEY uk_tenant_date (tenant_id, metric_date),
    INDEX idx_date (metric_date),
    
    FOREIGN KEY (tenant_id) REFERENCES tenants(tenant_id)
) ENGINE=InnoDB;

-- ============================================================
-- PROC√âDURE DE COLLECTE DES M√âTRIQUES
-- ============================================================

DELIMITER //

CREATE PROCEDURE collect_tenant_metrics(IN p_tenant_id VARCHAR(36))
BEGIN
    DECLARE v_schema_name VARCHAR(64);
    DECLARE v_user_count, v_product_count, v_order_count, v_customer_count INT;
    DECLARE v_data_size, v_index_size BIGINT;
    
    SELECT schema_name INTO v_schema_name
    FROM tenants WHERE tenant_id = p_tenant_id AND status = 'active';
    
    IF v_schema_name IS NOT NULL THEN
        -- Comptage des utilisateurs
        SET @sql = CONCAT('SELECT COUNT(*) INTO @cnt FROM `', v_schema_name, '`.users');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        SET v_user_count = @cnt;
        
        -- Comptage des produits
        SET @sql = CONCAT('SELECT COUNT(*) INTO @cnt FROM `', v_schema_name, '`.products');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        SET v_product_count = @cnt;
        
        -- Comptage des commandes
        SET @sql = CONCAT('SELECT COUNT(*) INTO @cnt FROM `', v_schema_name, '`.orders');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        SET v_order_count = @cnt;
        
        -- Comptage des clients
        SET @sql = CONCAT('SELECT COUNT(*) INTO @cnt FROM `', v_schema_name, '`.customers');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        SET v_customer_count = @cnt;
        
        -- Taille du sch√©ma
        SELECT 
            COALESCE(SUM(data_length), 0),
            COALESCE(SUM(index_length), 0)
        INTO v_data_size, v_index_size
        FROM information_schema.TABLES
        WHERE table_schema = v_schema_name;
        
        -- Insertion/mise √† jour des m√©triques
        INSERT INTO tenant_usage_metrics (
            tenant_id, metric_date, 
            user_count, product_count, order_count, customer_count,
            data_size_bytes, index_size_bytes
        ) VALUES (
            p_tenant_id, CURDATE(),
            v_user_count, v_product_count, v_order_count, v_customer_count,
            v_data_size, v_index_size
        )
        ON DUPLICATE KEY UPDATE
            user_count = v_user_count,
            product_count = v_product_count,
            order_count = v_order_count,
            customer_count = v_customer_count,
            data_size_bytes = v_data_size,
            index_size_bytes = v_index_size,
            updated_at = NOW(6);
    END IF;
END //

-- Collecte pour tous les tenants actifs
CREATE PROCEDURE collect_all_tenant_metrics()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_tenant_id VARCHAR(36);
    
    DECLARE cur CURSOR FOR
        SELECT tenant_id FROM tenants WHERE status = 'active';
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur;
    collect_loop: LOOP
        FETCH cur INTO v_tenant_id;
        IF done THEN LEAVE collect_loop; END IF;
        
        CALL collect_tenant_metrics(v_tenant_id);
    END LOOP;
    CLOSE cur;
END //

DELIMITER ;

-- Event pour collecte quotidienne
CREATE EVENT evt_daily_metrics_collection
ON SCHEDULE EVERY 1 DAY
STARTS CURRENT_DATE + INTERVAL 3 HOUR
DO
    CALL saas_platform.collect_all_tenant_metrics();
```

### Vue de supervision globale

```sql
-- ============================================================
-- VUES DE MONITORING
-- ============================================================

-- Vue de sant√© des tenants
CREATE OR REPLACE VIEW saas_platform.v_tenant_health AS
SELECT 
    t.tenant_id,
    t.tenant_slug,
    t.company_name,
    t.subscription_tier,
    t.status,
    t.schema_version,
    
    -- M√©triques d'usage
    m.user_count,
    t.max_users,
    CASE 
        WHEN t.max_users IS NULL THEN NULL
        ELSE ROUND(m.user_count * 100.0 / t.max_users, 1)
    END AS user_quota_pct,
    
    ROUND(m.total_size_bytes / 1048576, 2) AS storage_mb,
    t.max_storage_mb,
    CASE 
        WHEN t.max_storage_mb IS NULL THEN NULL
        ELSE ROUND(m.total_size_bytes * 100.0 / (t.max_storage_mb * 1048576), 1)
    END AS storage_quota_pct,
    
    -- Statut du quota
    CASE
        WHEN t.max_users IS NOT NULL AND m.user_count >= t.max_users THEN 'users_exceeded'
        WHEN t.max_storage_mb IS NOT NULL AND m.total_size_bytes >= t.max_storage_mb * 1048576 THEN 'storage_exceeded'
        WHEN t.max_users IS NOT NULL AND m.user_count >= t.max_users * 0.9 THEN 'users_warning'
        WHEN t.max_storage_mb IS NOT NULL AND m.total_size_bytes >= t.max_storage_mb * 1048576 * 0.9 THEN 'storage_warning'
        ELSE 'healthy'
    END AS quota_status,
    
    -- Derni√®re activit√©
    (SELECT MAX(last_login_at) 
     FROM information_schema.TABLES 
     WHERE table_schema = t.schema_name) AS schema_exists,
    
    t.trial_ends_at,
    CASE 
        WHEN t.subscription_status = 'trial' AND t.trial_ends_at < NOW() THEN 'trial_expired'
        WHEN t.subscription_status = 'trial' AND t.trial_ends_at < DATE_ADD(NOW(), INTERVAL 3 DAY) THEN 'trial_ending_soon'
        ELSE t.subscription_status
    END AS effective_status

FROM saas_platform.tenants t
LEFT JOIN saas_platform.tenant_usage_metrics m 
    ON t.tenant_id = m.tenant_id AND m.metric_date = CURDATE()
WHERE t.status != 'deleted';

-- Vue des migrations en retard
CREATE OR REPLACE VIEW saas_platform.v_pending_migrations AS
SELECT 
    t.tenant_id,
    t.tenant_slug,
    t.schema_version AS current_version,
    smd.version AS pending_version,
    smd.name AS migration_name,
    smd.is_breaking,
    smd.estimated_duration_sec
FROM saas_platform.tenants t
CROSS JOIN saas_platform.schema_migration_definitions smd
LEFT JOIN saas_platform.tenant_schema_migrations tsm
    ON t.tenant_id = tsm.tenant_id 
    AND smd.version = tsm.migration_version
    AND tsm.status = 'completed'
WHERE t.status IN ('active', 'suspended')
  AND tsm.tenant_id IS NULL
  AND smd.version > t.schema_version
ORDER BY t.tenant_slug, smd.version;

-- Vue du dashboard global
CREATE OR REPLACE VIEW saas_platform.v_platform_dashboard AS
SELECT 
    COUNT(*) AS total_tenants,
    SUM(status = 'active') AS active_tenants,
    SUM(status = 'suspended') AS suspended_tenants,
    SUM(subscription_status = 'trial') AS trial_tenants,
    
    -- Par plan
    SUM(subscription_tier = 'free') AS free_tier,
    SUM(subscription_tier = 'starter') AS starter_tier,
    SUM(subscription_tier = 'business') AS business_tier,
    SUM(subscription_tier = 'enterprise') AS enterprise_tier,
    
    -- M√©triques agr√©g√©es
    (SELECT SUM(user_count) FROM tenant_usage_metrics WHERE metric_date = CURDATE()) AS total_users,
    (SELECT SUM(total_size_bytes) / 1073741824 FROM tenant_usage_metrics WHERE metric_date = CURDATE()) AS total_storage_gb,
    
    -- Croissance
    (SELECT COUNT(*) FROM tenants WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)) AS new_tenants_30d,
    (SELECT COUNT(*) FROM tenants WHERE status = 'deleted' AND deleted_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)) AS churned_30d
    
FROM saas_platform.tenants
WHERE status != 'deleted';
```

---

## Comparaison avec les autres patterns

| Crit√®re | Schema per Tenant | Database per Tenant | Shared Schema |
|---------|-------------------|---------------------|---------------|
| **Isolation** | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë Logique | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà Physique | ‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë Minimale |
| **Scalabilit√©** | ~10,000 tenants | ~1,000 tenants | Illimit√© |
| **Co√ªt/tenant** | ‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë Mod√©r√© | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë √âlev√© | ‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë Minimal |
| **Complexit√© ops** | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë Moyenne | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë √âlev√©e | ‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë Faible |
| **Provisioning** | Rapide (CREATE DATABASE) | Lent (instance) | Instantan√© (INSERT) |
| **Migrations** | S√©quentielles par sch√©ma | Instance par instance | Une seule fois |
| **Backup granulaire** | ‚ö†Ô∏è Partiel | ‚úÖ Total | ‚ùå Non |
| **Personnalisation** | ‚úÖ Possible | ‚úÖ Totale | ‚ùå Limit√©e |
| **Performance** | ‚ö†Ô∏è Ressources partag√©es | ‚úÖ D√©di√©e | ‚ö†Ô∏è Contention |
| **Conformit√©** | ‚úÖ Bonne | ‚úÖ Excellente | ‚ö†Ô∏è Limit√©e |

---

## Quand utiliser ce pattern ?

### ‚úÖ Recommand√© pour :

- **SaaS B2B** avec quelques centaines √† milliers de tenants
- Applications n√©cessitant une **bonne isolation** sans la complexit√© des instances s√©par√©es
- Tenants avec des **besoins similaires** (m√™me sch√©ma)
- **√âquipes DevOps r√©duites** cherchant √† minimiser la charge op√©rationnelle
- Environnements avec **budget contraint** mais besoins d'isolation
- Applications o√π les **migrations group√©es** sont acceptables
- Contextes r√©glementaires mod√©r√©s (pas HIPAA/PCI-DSS niveau le plus strict)

### ‚ùå D√©conseill√© pour :

- **Tr√®s grand nombre de tenants** (> 10,000) - overhead de gestion des sch√©mas
- Tenants n√©cessitant une **isolation physique stricte** (r√©glementation)
- Applications B2C avec **millions d'utilisateurs**
- Tenants avec des **SLA tr√®s diff√©rents** (performance garantie)
- Besoins de **personnalisation de sch√©ma** par tenant
- Environnements o√π les **ressources partag√©es** posent probl√®me

---

## ‚úÖ Points cl√©s √† retenir

- Le pattern **Schema per Tenant** offre un **compromis √©quilibr√©** entre isolation et efficacit√© op√©rationnelle
- Chaque tenant dispose de son **propre sch√©ma** (base de donn√©es logique) dans une instance partag√©e
- Les **ressources sont mutualis√©es** (buffer pool, connexions, logs) r√©duisant les co√ªts
- Le **provisioning est rapide** : cr√©ation de sch√©ma en millisecondes
- Les **migrations** doivent √™tre appliqu√©es s√©quentiellement √† chaque sch√©ma tenant
- La **s√©curit√©** repose sur une gestion rigoureuse des privil√®ges et du routage applicatif
- Le pattern supporte typiquement **jusqu'√† ~10,000 tenants** par instance
- Un **sch√©ma de contr√¥le central** g√®re les m√©tadonn√©es et la configuration des tenants
- Les **donn√©es partag√©es** (r√©f√©rentiels) peuvent √™tre dans un sch√©ma commun en lecture seule

---

## üîó Ressources et r√©f√©rences

- üìñ [MariaDB Documentation - CREATE DATABASE](https://mariadb.com/kb/en/create-database/)
- üìñ [MariaDB Documentation - GRANT](https://mariadb.com/kb/en/grant/)
- üìñ [MariaDB Documentation - Information Schema](https://mariadb.com/kb/en/information-schema/)
- üìñ [Multi-tenant Architecture Patterns - Microsoft](https://docs.microsoft.com/en-us/azure/architecture/guide/multitenant/considerations/tenancy-models)
- üìñ [SaaS Tenant Isolation Strategies - AWS](https://docs.aws.amazon.com/whitepapers/latest/saas-tenant-isolation-strategies/tenant-isolation-approaches.html)
- üìñ [Designing Multi-tenant Applications - Martin Fowler](https://martinfowler.com/articles/multitenancy.html)

---

## ‚û°Ô∏è Section suivante

**20.4.3 Shared Schema avec discriminateur** : D√©couvrez l'approche la plus efficace en termes de ressources o√π tous les tenants partagent les m√™mes tables, diff√©renci√©s par une colonne `tenant_id`, id√©ale pour les applications B2C et les SaaS avec un tr√®s grand nombre de petits tenants.

‚è≠Ô∏è [Shared schema avec discriminateur](/20-cas-usage-architectures/04.3-shared-schema.md)
