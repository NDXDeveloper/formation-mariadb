üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.4.1 Database per Tenant

> **Niveau** : Interm√©diaire √† Avanc√©  
> **Dur√©e estim√©e** : 2h30  
> **Pr√©requis** : Chapitre 10 (S√©curit√© et Gestion des Utilisateurs), Chapitre 12 (Sauvegarde et Restauration), Section 20.4 (Architecture multi-tenant)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :

- Concevoir une architecture multi-tenant avec isolation compl√®te par base de donn√©es
- Impl√©menter un syst√®me de provisioning automatis√© de tenants avec MariaDB
- G√©rer le cycle de vie des tenants (cr√©ation, migration, suspension, suppression)
- Mettre en place des strat√©gies de backup et restauration par tenant
- Appliquer des politiques de ressources diff√©renci√©es selon les plans tarifaires
- √âvaluer les avantages et inconv√©nients par rapport aux autres patterns multi-tenant

---

## Introduction

L'architecture **multi-tenant** (multi-locataire) est au c≈ìur des applications SaaS modernes. Elle permet √† une m√™me infrastructure applicative de servir plusieurs organisations clientes (tenants), chacune percevant l'application comme si elle lui √©tait d√©di√©e.

Le pattern **Database per Tenant** (une base de donn√©es par locataire) repr√©sente le niveau d'**isolation maximale** dans le spectre des architectures multi-tenant. Chaque tenant dispose de sa propre base de donn√©es, garantissant une s√©paration physique compl√®te des donn√©es.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    DATABASE PER TENANT PATTERN                        ‚îÇ
‚îÇ                                                                       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                    APPLICATION SaaS                             ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ         (Code unique, Configuration par tenant)                 ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                              ‚îÇ                                        ‚îÇ
‚îÇ              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                        ‚îÇ
‚îÇ              ‚îÇ               ‚îÇ               ‚îÇ                        ‚îÇ
‚îÇ              ‚ñº               ‚ñº               ‚ñº                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ  ‚îÇ   MariaDB     ‚îÇ ‚îÇ   MariaDB     ‚îÇ ‚îÇ   MariaDB     ‚îÇ                ‚îÇ
‚îÇ  ‚îÇ  tenant_acme  ‚îÇ ‚îÇ tenant_globex ‚îÇ ‚îÇ tenant_initech‚îÇ    ...         ‚îÇ
‚îÇ  ‚îÇ               ‚îÇ ‚îÇ               ‚îÇ ‚îÇ               ‚îÇ                ‚îÇ
‚îÇ  ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ                ‚îÇ
‚îÇ  ‚îÇ ‚îÇ  users    ‚îÇ ‚îÇ ‚îÇ ‚îÇ  users    ‚îÇ ‚îÇ ‚îÇ ‚îÇ  users    ‚îÇ ‚îÇ                ‚îÇ
‚îÇ  ‚îÇ ‚îÇ  orders   ‚îÇ ‚îÇ ‚îÇ ‚îÇ  orders   ‚îÇ ‚îÇ ‚îÇ ‚îÇ  orders   ‚îÇ ‚îÇ                ‚îÇ
‚îÇ  ‚îÇ ‚îÇ  products ‚îÇ ‚îÇ ‚îÇ ‚îÇ  products ‚îÇ ‚îÇ ‚îÇ ‚îÇ  products ‚îÇ ‚îÇ                ‚îÇ
‚îÇ  ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ                ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îÇ                                                                       ‚îÇ
‚îÇ  Isolation : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà Maximale                                    ‚îÇ
‚îÇ  Co√ªt/tenant : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë √âlev√©                                     ‚îÇ
‚îÇ  Complexit√© ops : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë √âlev√©e                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Ce pattern est particuli√®rement adapt√© aux contextes o√π les **exigences r√©glementaires**, les **besoins de personnalisation** ou les **garanties contractuelles** imposent une s√©paration stricte des donn√©es.

---

## Principes fondamentaux

### Isolation compl√®te des donn√©es

Chaque tenant poss√®de sa propre base de donn√©es avec un sch√©ma identique mais des donn√©es totalement ind√©pendantes :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ISOLATION DES DONN√âES                               ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ   Tenant A (ACME Corp)          Tenant B (Globex Inc)                  ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ   ‚îÇ db_tenant_acme      ‚îÇ       ‚îÇ db_tenant_globex    ‚îÇ                ‚îÇ
‚îÇ   ‚îÇ                     ‚îÇ       ‚îÇ                     ‚îÇ                ‚îÇ
‚îÇ   ‚îÇ users: 150          ‚îÇ       ‚îÇ users: 2,500        ‚îÇ                ‚îÇ
‚îÇ   ‚îÇ orders: 12,000      ‚îÇ       ‚îÇ orders: 450,000     ‚îÇ                ‚îÇ
‚îÇ   ‚îÇ products: 500       ‚îÇ       ‚îÇ products: 15,000    ‚îÇ                ‚îÇ
‚îÇ   ‚îÇ                     ‚îÇ       ‚îÇ                     ‚îÇ                ‚îÇ
‚îÇ   ‚îÇ Storage: 2 GB       ‚îÇ       ‚îÇ Storage: 85 GB      ‚îÇ                ‚îÇ
‚îÇ   ‚îÇ Config: custom      ‚îÇ       ‚îÇ Config: default     ‚îÇ                ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îÇ                                                                        ‚îÇ
‚îÇ   ‚úÖ Aucun risque de fuite de donn√©es entre tenants                    ‚îÇ
‚îÇ   ‚úÖ Chaque tenant peut avoir des configurations sp√©cifiques           ‚îÇ
‚îÇ   ‚úÖ Backup/Restore ind√©pendant par tenant                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Routage des connexions

L'application doit d√©terminer quelle base de donn√©es utiliser pour chaque requ√™te. Plusieurs strat√©gies de routage existent :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    STRAT√âGIES DE ROUTAGE                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

1. SUBDOMAIN ROUTING
   acme.myapp.com      ‚Üí db_tenant_acme
   globex.myapp.com    ‚Üí db_tenant_globex

2. PATH-BASED ROUTING
   myapp.com/t/acme/*  ‚Üí db_tenant_acme
   myapp.com/t/globex/* ‚Üí db_tenant_globex

3. HEADER-BASED ROUTING
   X-Tenant-ID: acme   ‚Üí db_tenant_acme
   X-Tenant-ID: globex ‚Üí db_tenant_globex

4. JWT CLAIM ROUTING
   token.tenant_id: "acme"   ‚Üí db_tenant_acme
   token.tenant_id: "globex" ‚Üí db_tenant_globex
```

---

## Impl√©mentation avec MariaDB 11.8

### Architecture de la base de gestion centrale

Une base de donn√©es centrale (Control Plane) g√®re les m√©tadonn√©es de tous les tenants :

```sql
-- ============================================================
-- BASE DE GESTION CENTRALE (Control Plane)
-- ============================================================

CREATE DATABASE saas_control_plane
    CHARACTER SET utf8mb4
    COLLATE utf8mb4_uca1400_ai_ci;

USE saas_control_plane;

-- Table principale des tenants
CREATE TABLE tenants (
    tenant_id VARCHAR(36) PRIMARY KEY DEFAULT (UUID()),
    tenant_slug VARCHAR(64) UNIQUE NOT NULL,  -- Identifiant URL-safe
    company_name VARCHAR(255) NOT NULL,
    
    -- Plan et facturation
    subscription_plan ENUM('free', 'starter', 'professional', 'enterprise') 
                      DEFAULT 'free',
    billing_email VARCHAR(255) NOT NULL,
    
    -- √âtat du tenant
    status ENUM('provisioning', 'active', 'suspended', 'pending_deletion', 'deleted') 
           DEFAULT 'provisioning',
    
    -- Configuration de connexion
    db_host VARCHAR(255) NOT NULL DEFAULT 'localhost',
    db_port INT UNSIGNED NOT NULL DEFAULT 3306,
    db_name VARCHAR(64) NOT NULL,
    db_user VARCHAR(64) NOT NULL,
    -- Le mot de passe est stock√© chiffr√© ou dans un secret manager
    db_password_encrypted VARBINARY(512),
    
    -- Limites selon le plan
    max_users INT UNSIGNED,
    max_storage_gb INT UNSIGNED,
    max_api_calls_per_day INT UNSIGNED,
    
    -- Personnalisation
    custom_domain VARCHAR(255),
    settings JSON,
    features_enabled JSON,  -- Feature flags par tenant
    
    -- Audit
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
               ON UPDATE CURRENT_TIMESTAMP(6),
    deleted_at DATETIME(6),
    
    INDEX idx_slug (tenant_slug),
    INDEX idx_status (status),
    INDEX idx_plan (subscription_plan),
    INDEX idx_custom_domain (custom_domain)
) ENGINE=InnoDB;

-- Historique des √©v√©nements tenant
CREATE TABLE tenant_events (
    event_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    tenant_id VARCHAR(36) NOT NULL,
    event_type ENUM(
        'created', 'activated', 'upgraded', 'downgraded',
        'suspended', 'reactivated', 'deletion_requested',
        'deleted', 'backup_created', 'backup_restored',
        'schema_migrated', 'config_changed'
    ) NOT NULL,
    event_data JSON,
    performed_by VARCHAR(255),
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    
    INDEX idx_tenant (tenant_id),
    INDEX idx_type (event_type),
    INDEX idx_created (created_at)
) ENGINE=InnoDB;

-- Plans et leurs limites
CREATE TABLE subscription_plans (
    plan_id VARCHAR(36) PRIMARY KEY DEFAULT (UUID()),
    plan_name VARCHAR(50) UNIQUE NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    
    -- Limites
    max_users INT UNSIGNED,
    max_storage_gb INT UNSIGNED,
    max_api_calls_per_day INT UNSIGNED,
    
    -- Features incluses
    features JSON NOT NULL,
    
    -- Tarification
    monthly_price_cents INT UNSIGNED NOT NULL,
    annual_price_cents INT UNSIGNED,
    
    is_active BOOLEAN DEFAULT TRUE,
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6)
) ENGINE=InnoDB;

-- Donn√©es initiales des plans
INSERT INTO subscription_plans 
    (plan_name, display_name, max_users, max_storage_gb, max_api_calls_per_day, 
     features, monthly_price_cents)
VALUES
    ('free', 'Free', 5, 1, 1000, 
     '{"api_access": false, "custom_domain": false, "sso": false, "support": "community"}', 
     0),
    ('starter', 'Starter', 25, 10, 10000, 
     '{"api_access": true, "custom_domain": false, "sso": false, "support": "email"}', 
     2900),
    ('professional', 'Professional', 100, 50, 100000, 
     '{"api_access": true, "custom_domain": true, "sso": false, "support": "priority"}', 
     9900),
    ('enterprise', 'Enterprise', NULL, NULL, NULL, 
     '{"api_access": true, "custom_domain": true, "sso": true, "support": "dedicated"}', 
     29900);
```

### Provisioning automatis√© d'un tenant

```sql
-- ============================================================
-- PROC√âDURE DE PROVISIONING D'UN NOUVEAU TENANT
-- ============================================================

DELIMITER //

CREATE PROCEDURE saas_control_plane.provision_tenant(
    IN p_company_name VARCHAR(255),
    IN p_tenant_slug VARCHAR(64),
    IN p_billing_email VARCHAR(255),
    IN p_subscription_plan VARCHAR(50),
    OUT p_tenant_id VARCHAR(36),
    OUT p_status VARCHAR(50),
    OUT p_message VARCHAR(500)
)
this_proc: BEGIN
    DECLARE v_tenant_id VARCHAR(36);
    DECLARE v_db_name VARCHAR(64);
    DECLARE v_db_user VARCHAR(64);
    DECLARE v_db_password VARCHAR(64);
    DECLARE v_plan_limits JSON;
    DECLARE v_max_users, v_max_storage, v_max_api INT UNSIGNED;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 p_message = MESSAGE_TEXT;
        SET p_status = 'ERROR';
        SET p_tenant_id = NULL;
        
        -- Log de l'erreur
        INSERT INTO tenant_events (tenant_id, event_type, event_data)
        VALUES (v_tenant_id, 'created', 
                JSON_OBJECT('status', 'failed', 'error', p_message));
        
        ROLLBACK;
    END;
    
    -- Validation du slug (alphanumeric, lowercase, hyphens)
    IF p_tenant_slug NOT REGEXP '^[a-z0-9][a-z0-9-]{2,62}[a-z0-9]$' THEN
        SET p_status = 'INVALID_SLUG';
        SET p_message = 'Tenant slug must be 4-64 chars, lowercase alphanumeric with hyphens';
        LEAVE this_proc;
    END IF;
    
    -- V√©rification unicit√© du slug
    IF EXISTS (SELECT 1 FROM tenants WHERE tenant_slug = p_tenant_slug) THEN
        SET p_status = 'SLUG_EXISTS';
        SET p_message = 'Tenant slug already exists';
        LEAVE this_proc;
    END IF;
    
    -- R√©cup√©ration des limites du plan
    SELECT max_users, max_storage_gb, max_api_calls_per_day
    INTO v_max_users, v_max_storage, v_max_api
    FROM subscription_plans
    WHERE plan_name = p_subscription_plan AND is_active = TRUE;
    
    IF v_max_users IS NULL AND p_subscription_plan != 'enterprise' THEN
        SET p_status = 'INVALID_PLAN';
        SET p_message = 'Invalid or inactive subscription plan';
        LEAVE this_proc;
    END IF;
    
    START TRANSACTION;
    
    -- G√©n√©ration des identifiants
    SET v_tenant_id = UUID();
    SET v_db_name = CONCAT('tenant_', REPLACE(p_tenant_slug, '-', '_'));
    SET v_db_user = CONCAT('usr_', LEFT(REPLACE(UUID(), '-', ''), 16));
    SET v_db_password = CONCAT(
        SUBSTRING(SHA2(RAND(), 256), 1, 16),
        SUBSTRING(SHA2(UUID(), 256), 1, 16)
    );
    
    -- Cr√©ation de l'entr√©e tenant
    INSERT INTO tenants (
        tenant_id, tenant_slug, company_name, billing_email,
        subscription_plan, status, db_name, db_user,
        db_password_encrypted, max_users, max_storage_gb, max_api_calls_per_day
    ) VALUES (
        v_tenant_id, p_tenant_slug, p_company_name, p_billing_email,
        p_subscription_plan, 'provisioning', v_db_name, v_db_user,
        AES_ENCRYPT(v_db_password, @@global.aes_encrypt_key),
        v_max_users, v_max_storage, v_max_api
    );
    
    -- Cr√©ation de la base de donn√©es du tenant
    SET @sql = CONCAT('CREATE DATABASE `', v_db_name, '` ',
                      'CHARACTER SET utf8mb4 COLLATE utf8mb4_uca1400_ai_ci');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Cr√©ation de l'utilisateur d√©di√©
    SET @sql = CONCAT('CREATE USER ''', v_db_user, '''@''%'' ',
                      'IDENTIFIED BY ''', v_db_password, '''');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Attribution des privil√®ges (uniquement sur sa base)
    SET @sql = CONCAT('GRANT ALL PRIVILEGES ON `', v_db_name, '`.* ',
                      'TO ''', v_db_user, '''@''%''');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    FLUSH PRIVILEGES;
    
    -- Log de l'√©v√©nement
    INSERT INTO tenant_events (tenant_id, event_type, event_data, performed_by)
    VALUES (v_tenant_id, 'created', 
            JSON_OBJECT(
                'company_name', p_company_name,
                'plan', p_subscription_plan,
                'db_name', v_db_name
            ), 
            'system');
    
    COMMIT;
    
    SET p_tenant_id = v_tenant_id;
    SET p_status = 'PROVISIONING';
    SET p_message = CONCAT('Tenant created. Database: ', v_db_name, 
                           '. Schema migration required.');
    
END //

DELIMITER ;
```

### Initialisation du sch√©ma tenant

```sql
-- ============================================================
-- PROC√âDURE D'INITIALISATION DU SCH√âMA TENANT
-- ============================================================

DELIMITER //

CREATE PROCEDURE saas_control_plane.initialize_tenant_schema(
    IN p_tenant_id VARCHAR(36),
    OUT p_status VARCHAR(50),
    OUT p_message VARCHAR(500)
)
this_proc: BEGIN
    DECLARE v_db_name VARCHAR(64);
    DECLARE v_tenant_status VARCHAR(50);
    DECLARE v_schema_version VARCHAR(20) DEFAULT '1.0.0';
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 p_message = MESSAGE_TEXT;
        SET p_status = 'ERROR';
        
        INSERT INTO tenant_events (tenant_id, event_type, event_data)
        VALUES (p_tenant_id, 'schema_migrated', 
                JSON_OBJECT('status', 'failed', 'error', p_message));
    END;
    
    -- R√©cup√©ration des informations tenant
    SELECT db_name, status INTO v_db_name, v_tenant_status
    FROM tenants WHERE tenant_id = p_tenant_id;
    
    IF v_db_name IS NULL THEN
        SET p_status = 'NOT_FOUND';
        SET p_message = 'Tenant not found';
        LEAVE this_proc;
    END IF;
    
    IF v_tenant_status != 'provisioning' THEN
        SET p_status = 'INVALID_STATE';
        SET p_message = 'Tenant is not in provisioning state';
        LEAVE this_proc;
    END IF;
    
    -- ============================================================
    -- CR√âATION DES TABLES DU SCH√âMA APPLICATIF
    -- ============================================================
    
    -- Table des utilisateurs du tenant
    SET @sql = CONCAT('
        CREATE TABLE `', v_db_name, '`.users (
            user_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
            email VARCHAR(255) NOT NULL UNIQUE,
            password_hash VARCHAR(255) NOT NULL,
            first_name VARCHAR(100),
            last_name VARCHAR(100),
            role ENUM(''admin'', ''manager'', ''user'', ''viewer'') DEFAULT ''user'',
            is_active BOOLEAN DEFAULT TRUE,
            last_login_at DATETIME(6),
            created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
            updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
                       ON UPDATE CURRENT_TIMESTAMP(6),
            
            INDEX idx_email (email),
            INDEX idx_role (role),
            INDEX idx_active (is_active)
        ) ENGINE=InnoDB
    ');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Table des produits
    SET @sql = CONCAT('
        CREATE TABLE `', v_db_name, '`.products (
            product_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
            sku VARCHAR(64) UNIQUE NOT NULL,
            name VARCHAR(255) NOT NULL,
            description TEXT,
            price DECIMAL(10,2) NOT NULL,
            quantity_in_stock INT UNSIGNED DEFAULT 0,
            is_active BOOLEAN DEFAULT TRUE,
            created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
            updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
                       ON UPDATE CURRENT_TIMESTAMP(6),
            
            INDEX idx_sku (sku),
            INDEX idx_active (is_active),
            FULLTEXT idx_search (name, description)
        ) ENGINE=InnoDB
    ');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Table des commandes
    SET @sql = CONCAT('
        CREATE TABLE `', v_db_name, '`.orders (
            order_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
            order_number VARCHAR(32) UNIQUE NOT NULL,
            user_id BIGINT UNSIGNED NOT NULL,
            status ENUM(''pending'', ''confirmed'', ''processing'', 
                       ''shipped'', ''delivered'', ''cancelled'') DEFAULT ''pending'',
            total_amount DECIMAL(12,2) NOT NULL,
            shipping_address JSON,
            notes TEXT,
            ordered_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
            updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
                       ON UPDATE CURRENT_TIMESTAMP(6),
            
            INDEX idx_user (user_id),
            INDEX idx_status (status),
            INDEX idx_ordered (ordered_at DESC)
        ) ENGINE=InnoDB
    ');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Table des lignes de commande
    SET @sql = CONCAT('
        CREATE TABLE `', v_db_name, '`.order_items (
            item_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
            order_id BIGINT UNSIGNED NOT NULL,
            product_id BIGINT UNSIGNED NOT NULL,
            quantity INT UNSIGNED NOT NULL,
            unit_price DECIMAL(10,2) NOT NULL,
            
            INDEX idx_order (order_id),
            INDEX idx_product (product_id)
        ) ENGINE=InnoDB
    ');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Table de m√©tadonn√©es du sch√©ma
    SET @sql = CONCAT('
        CREATE TABLE `', v_db_name, '`.schema_metadata (
            meta_key VARCHAR(64) PRIMARY KEY,
            meta_value TEXT NOT NULL,
            updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
                       ON UPDATE CURRENT_TIMESTAMP(6)
        ) ENGINE=InnoDB
    ');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- Enregistrement de la version du sch√©ma
    SET @sql = CONCAT('
        INSERT INTO `', v_db_name, '`.schema_metadata (meta_key, meta_value)
        VALUES (''schema_version'', ''', v_schema_version, '''),
               (''initialized_at'', NOW(6))
    ');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- ============================================================
    -- ACTIVATION DU TENANT
    -- ============================================================
    
    UPDATE tenants 
    SET status = 'active',
        updated_at = NOW(6)
    WHERE tenant_id = p_tenant_id;
    
    INSERT INTO tenant_events (tenant_id, event_type, event_data, performed_by)
    VALUES (p_tenant_id, 'activated', 
            JSON_OBJECT('schema_version', v_schema_version), 
            'system');
    
    SET p_status = 'SUCCESS';
    SET p_message = CONCAT('Tenant schema initialized. Version: ', v_schema_version);
    
END //

DELIMITER ;
```

**Utilisation du provisioning :**

```sql
-- Cr√©ation d'un nouveau tenant
CALL saas_control_plane.provision_tenant(
    'ACME Corporation',
    'acme-corp',
    'billing@acme.com',
    'professional',
    @tenant_id,
    @status,
    @message
);

SELECT @tenant_id, @status, @message;
-- +--------------------------------------+--------------+------------------------------------------+
-- | @tenant_id                           | @status      | @message                                 |
-- +--------------------------------------+--------------+------------------------------------------+
-- | 550e8400-e29b-41d4-a716-446655440000 | PROVISIONING | Tenant created. Database: tenant_acme... |
-- +--------------------------------------+--------------+------------------------------------------+

-- Initialisation du sch√©ma
CALL saas_control_plane.initialize_tenant_schema(
    @tenant_id,
    @status,
    @message
);

SELECT @status, @message;
-- +---------+-----------------------------------------------+
-- | @status | @message                                      |
-- +---------+-----------------------------------------------+
-- | SUCCESS | Tenant schema initialized. Version: 1.0.0     |
-- +---------+-----------------------------------------------+
```

---

## Routage des connexions applicatif

### Service de r√©solution de tenant

```python
# tenant_resolver.py - Service de r√©solution et connexion tenant

import os
import hashlib
from functools import lru_cache
from typing import Optional, Dict, Any
from dataclasses import dataclass
from contextlib import contextmanager
import mariadb
from cryptography.fernet import Fernet

@dataclass
class TenantConfig:
    tenant_id: str
    tenant_slug: str
    db_host: str
    db_port: int
    db_name: str
    db_user: str
    db_password: str
    subscription_plan: str
    max_users: Optional[int]
    max_storage_gb: Optional[int]
    features: Dict[str, Any]

class TenantResolver:
    """
    Service de r√©solution des tenants avec cache et pool de connexions.
    """
    
    def __init__(self, control_plane_config: Dict[str, Any]):
        self.control_plane_config = control_plane_config
        self._connection_pools: Dict[str, mariadb.ConnectionPool] = {}
        self._encryption_key = os.environ.get('TENANT_ENCRYPTION_KEY').encode()
        self._fernet = Fernet(self._encryption_key)
    
    @lru_cache(maxsize=1000)
    def resolve_by_slug(self, tenant_slug: str) -> Optional[TenantConfig]:
        """
        R√©sout un tenant par son slug avec mise en cache.
        """
        conn = mariadb.connect(**self.control_plane_config)
        try:
            cursor = conn.cursor(dictionary=True)
            cursor.execute("""
                SELECT 
                    t.tenant_id, t.tenant_slug, t.db_host, t.db_port,
                    t.db_name, t.db_user, t.db_password_encrypted,
                    t.subscription_plan, t.max_users, t.max_storage_gb,
                    t.features_enabled,
                    sp.features AS plan_features
                FROM tenants t
                JOIN subscription_plans sp ON t.subscription_plan = sp.plan_name
                WHERE t.tenant_slug = %s AND t.status = 'active'
            """, (tenant_slug,))
            
            row = cursor.fetchone()
            if not row:
                return None
            
            # D√©chiffrement du mot de passe
            decrypted_password = self._decrypt_password(
                row['db_password_encrypted']
            )
            
            # Fusion des features (plan + custom)
            features = row['plan_features'] or {}
            if row['features_enabled']:
                features.update(row['features_enabled'])
            
            return TenantConfig(
                tenant_id=row['tenant_id'],
                tenant_slug=row['tenant_slug'],
                db_host=row['db_host'],
                db_port=row['db_port'],
                db_name=row['db_name'],
                db_user=row['db_user'],
                db_password=decrypted_password,
                subscription_plan=row['subscription_plan'],
                max_users=row['max_users'],
                max_storage_gb=row['max_storage_gb'],
                features=features
            )
        finally:
            conn.close()
    
    def resolve_by_domain(self, domain: str) -> Optional[TenantConfig]:
        """
        R√©sout un tenant par son domaine personnalis√©.
        """
        conn = mariadb.connect(**self.control_plane_config)
        try:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT tenant_slug FROM tenants 
                WHERE custom_domain = %s AND status = 'active'
            """, (domain,))
            
            row = cursor.fetchone()
            if row:
                return self.resolve_by_slug(row[0])
            return None
        finally:
            conn.close()
    
    def _decrypt_password(self, encrypted: bytes) -> str:
        """D√©chiffre le mot de passe de la base tenant."""
        # En production, utiliser un service de gestion des secrets
        return self._fernet.decrypt(encrypted).decode()
    
    def get_connection_pool(self, tenant: TenantConfig) -> mariadb.ConnectionPool:
        """
        Retourne ou cr√©e un pool de connexions pour le tenant.
        """
        pool_key = f"{tenant.db_host}:{tenant.db_port}/{tenant.db_name}"
        
        if pool_key not in self._connection_pools:
            self._connection_pools[pool_key] = mariadb.ConnectionPool(
                pool_name=f"pool_{tenant.tenant_slug}",
                pool_size=5,
                pool_validation_interval=30,
                host=tenant.db_host,
                port=tenant.db_port,
                database=tenant.db_name,
                user=tenant.db_user,
                password=tenant.db_password,
                autocommit=False
            )
        
        return self._connection_pools[pool_key]
    
    @contextmanager
    def tenant_connection(self, tenant_slug: str):
        """
        Context manager pour obtenir une connexion tenant.
        
        Usage:
            with resolver.tenant_connection('acme-corp') as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT * FROM users")
        """
        tenant = self.resolve_by_slug(tenant_slug)
        if not tenant:
            raise ValueError(f"Tenant not found: {tenant_slug}")
        
        pool = self.get_connection_pool(tenant)
        conn = pool.get_connection()
        try:
            yield conn
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            conn.close()
    
    def invalidate_cache(self, tenant_slug: str):
        """Invalide le cache pour un tenant sp√©cifique."""
        self.resolve_by_slug.cache_clear()


# Exemple d'utilisation dans une API FastAPI
from fastapi import FastAPI, Depends, HTTPException, Request

app = FastAPI()
resolver = TenantResolver({
    'host': 'control-plane-db',
    'port': 3306,
    'database': 'saas_control_plane',
    'user': 'control_plane_user',
    'password': os.environ['CONTROL_PLANE_DB_PASSWORD']
})

def get_tenant(request: Request) -> TenantConfig:
    """Dependency pour r√©soudre le tenant depuis la requ√™te."""
    
    # Strat√©gie 1: Header X-Tenant-ID
    tenant_slug = request.headers.get('X-Tenant-ID')
    
    # Strat√©gie 2: Subdomain
    if not tenant_slug:
        host = request.headers.get('host', '')
        if '.' in host:
            tenant_slug = host.split('.')[0]
    
    if not tenant_slug:
        raise HTTPException(status_code=400, detail="Tenant not specified")
    
    tenant = resolver.resolve_by_slug(tenant_slug)
    if not tenant:
        raise HTTPException(status_code=404, detail="Tenant not found")
    
    return tenant


@app.get("/api/users")
def list_users(tenant: TenantConfig = Depends(get_tenant)):
    """Liste les utilisateurs du tenant."""
    
    with resolver.tenant_connection(tenant.tenant_slug) as conn:
        cursor = conn.cursor(dictionary=True)
        cursor.execute("""
            SELECT user_id, email, first_name, last_name, role, is_active
            FROM users WHERE is_active = TRUE
            ORDER BY created_at DESC
        """)
        return {"users": cursor.fetchall()}
```

### Middleware de routage avec MaxScale

Pour une architecture haute disponibilit√©, **MaxScale** peut g√©rer le routage vers les bases tenants :

```ini
# /etc/maxscale.cnf - Configuration multi-tenant avec MaxScale

[maxscale]
threads = auto
admin_host = 0.0.0.0
admin_port = 8989

# Service pour le Control Plane
[ControlPlane-Service]
type = service
router = readwritesplit
servers = control-primary, control-replica1
user = maxscale_user
password = maxscale_password

[ControlPlane-Listener]
type = listener
service = ControlPlane-Service
protocol = MariaDBClient
port = 3306
address = 0.0.0.0

# Template de service pour les tenants
# En production, g√©n√©r√© dynamiquement via l'API MaxScale

[Tenant-ACME-Service]
type = service
router = readwritesplit
servers = tenant-acme-primary, tenant-acme-replica1
user = maxscale_tenant_user
password = maxscale_tenant_password

[Tenant-ACME-Listener]
type = listener
service = Tenant-ACME-Service
protocol = MariaDBClient
port = 3307
address = 0.0.0.0

# Serveurs du Control Plane
[control-primary]
type = server
address = control-db-primary.internal
port = 3306
protocol = MariaDBBackend

[control-replica1]
type = server
address = control-db-replica1.internal
port = 3306
protocol = MariaDBBackend

# Serveurs tenant ACME
[tenant-acme-primary]
type = server
address = tenant-acme-primary.internal
port = 3306
protocol = MariaDBBackend

[tenant-acme-replica1]
type = server
address = tenant-acme-replica1.internal
port = 3306
protocol = MariaDBBackend
```

---

## Gestion du cycle de vie des tenants

### Suspension et r√©activation

```sql
-- ============================================================
-- GESTION DE LA SUSPENSION/R√âACTIVATION
-- ============================================================

DELIMITER //

CREATE PROCEDURE saas_control_plane.suspend_tenant(
    IN p_tenant_id VARCHAR(36),
    IN p_reason VARCHAR(500),
    IN p_performed_by VARCHAR(255),
    OUT p_status VARCHAR(50),
    OUT p_message VARCHAR(500)
)
BEGIN
    DECLARE v_current_status VARCHAR(50);
    DECLARE v_db_user VARCHAR(64);
    
    SELECT status, db_user INTO v_current_status, v_db_user
    FROM tenants WHERE tenant_id = p_tenant_id;
    
    IF v_current_status IS NULL THEN
        SET p_status = 'NOT_FOUND';
        SET p_message = 'Tenant not found';
    ELSEIF v_current_status != 'active' THEN
        SET p_status = 'INVALID_STATE';
        SET p_message = CONCAT('Cannot suspend tenant in state: ', v_current_status);
    ELSE
        -- R√©vocation des privil√®ges (le tenant ne peut plus se connecter)
        SET @sql = CONCAT('REVOKE ALL PRIVILEGES ON *.* FROM ''', 
                          v_db_user, '''@''%''');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        FLUSH PRIVILEGES;
        
        -- Mise √† jour du statut
        UPDATE tenants 
        SET status = 'suspended', updated_at = NOW(6)
        WHERE tenant_id = p_tenant_id;
        
        -- Log de l'√©v√©nement
        INSERT INTO tenant_events (tenant_id, event_type, event_data, performed_by)
        VALUES (p_tenant_id, 'suspended', 
                JSON_OBJECT('reason', p_reason), p_performed_by);
        
        SET p_status = 'SUCCESS';
        SET p_message = 'Tenant suspended successfully';
    END IF;
END //

CREATE PROCEDURE saas_control_plane.reactivate_tenant(
    IN p_tenant_id VARCHAR(36),
    IN p_performed_by VARCHAR(255),
    OUT p_status VARCHAR(50),
    OUT p_message VARCHAR(500)
)
BEGIN
    DECLARE v_current_status VARCHAR(50);
    DECLARE v_db_user VARCHAR(64);
    DECLARE v_db_name VARCHAR(64);
    
    SELECT status, db_user, db_name INTO v_current_status, v_db_user, v_db_name
    FROM tenants WHERE tenant_id = p_tenant_id;
    
    IF v_current_status IS NULL THEN
        SET p_status = 'NOT_FOUND';
        SET p_message = 'Tenant not found';
    ELSEIF v_current_status != 'suspended' THEN
        SET p_status = 'INVALID_STATE';
        SET p_message = CONCAT('Cannot reactivate tenant in state: ', v_current_status);
    ELSE
        -- Restauration des privil√®ges
        SET @sql = CONCAT('GRANT ALL PRIVILEGES ON `', v_db_name, 
                          '`.* TO ''', v_db_user, '''@''%''');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        FLUSH PRIVILEGES;
        
        -- Mise √† jour du statut
        UPDATE tenants 
        SET status = 'active', updated_at = NOW(6)
        WHERE tenant_id = p_tenant_id;
        
        -- Log de l'√©v√©nement
        INSERT INTO tenant_events (tenant_id, event_type, event_data, performed_by)
        VALUES (p_tenant_id, 'reactivated', NULL, p_performed_by);
        
        SET p_status = 'SUCCESS';
        SET p_message = 'Tenant reactivated successfully';
    END IF;
END //

DELIMITER ;
```

### Suppression s√©curis√©e (soft delete avec r√©tention)

```sql
-- ============================================================
-- SUPPRESSION AVEC P√âRIODE DE R√âTENTION
-- ============================================================

DELIMITER //

CREATE PROCEDURE saas_control_plane.request_tenant_deletion(
    IN p_tenant_id VARCHAR(36),
    IN p_performed_by VARCHAR(255),
    IN p_retention_days INT,  -- Nombre de jours avant suppression d√©finitive
    OUT p_status VARCHAR(50),
    OUT p_message VARCHAR(500)
)
BEGIN
    DECLARE v_current_status VARCHAR(50);
    DECLARE v_deletion_date DATETIME(6);
    
    SET v_retention_days = COALESCE(p_retention_days, 30);  -- 30 jours par d√©faut
    SET v_deletion_date = DATE_ADD(NOW(6), INTERVAL v_retention_days DAY);
    
    SELECT status INTO v_current_status
    FROM tenants WHERE tenant_id = p_tenant_id;
    
    IF v_current_status IS NULL THEN
        SET p_status = 'NOT_FOUND';
        SET p_message = 'Tenant not found';
    ELSEIF v_current_status IN ('pending_deletion', 'deleted') THEN
        SET p_status = 'INVALID_STATE';
        SET p_message = 'Tenant already pending deletion or deleted';
    ELSE
        -- Suspension imm√©diate
        CALL suspend_tenant(p_tenant_id, 'Deletion requested', p_performed_by, 
                           @suspend_status, @suspend_msg);
        
        -- Marquage pour suppression diff√©r√©e
        UPDATE tenants 
        SET status = 'pending_deletion',
            deleted_at = v_deletion_date,
            updated_at = NOW(6)
        WHERE tenant_id = p_tenant_id;
        
        -- Log de l'√©v√©nement
        INSERT INTO tenant_events (tenant_id, event_type, event_data, performed_by)
        VALUES (p_tenant_id, 'deletion_requested', 
                JSON_OBJECT(
                    'scheduled_deletion', v_deletion_date,
                    'retention_days', v_retention_days
                ), 
                p_performed_by);
        
        SET p_status = 'SUCCESS';
        SET p_message = CONCAT('Tenant scheduled for deletion on ', v_deletion_date);
    END IF;
END //

-- Event pour la suppression effective des tenants expir√©s
CREATE EVENT saas_control_plane.evt_purge_deleted_tenants
ON SCHEDULE EVERY 1 DAY
STARTS CURRENT_DATE + INTERVAL 2 HOUR  -- Ex√©cution √† 2h du matin
DO
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_tenant_id VARCHAR(36);
    DECLARE v_db_name VARCHAR(64);
    DECLARE v_db_user VARCHAR(64);
    
    DECLARE cur CURSOR FOR
        SELECT tenant_id, db_name, db_user
        FROM tenants
        WHERE status = 'pending_deletion' AND deleted_at <= NOW();
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur;
    
    purge_loop: LOOP
        FETCH cur INTO v_tenant_id, v_db_name, v_db_user;
        IF done THEN LEAVE purge_loop; END IF;
        
        -- Suppression de l'utilisateur
        SET @sql = CONCAT('DROP USER IF EXISTS ''', v_db_user, '''@''%''');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- Suppression de la base de donn√©es
        SET @sql = CONCAT('DROP DATABASE IF EXISTS `', v_db_name, '`');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- Mise √† jour du statut
        UPDATE tenants SET status = 'deleted' WHERE tenant_id = v_tenant_id;
        
        -- Log
        INSERT INTO tenant_events (tenant_id, event_type, performed_by)
        VALUES (v_tenant_id, 'deleted', 'system/scheduler');
    END LOOP;
    
    CLOSE cur;
END //

DELIMITER ;
```

### Annulation de suppression

```sql
-- Proc√©dure pour annuler une demande de suppression pendant la p√©riode de r√©tention
DELIMITER //

CREATE PROCEDURE saas_control_plane.cancel_tenant_deletion(
    IN p_tenant_id VARCHAR(36),
    IN p_performed_by VARCHAR(255),
    OUT p_status VARCHAR(50),
    OUT p_message VARCHAR(500)
)
BEGIN
    DECLARE v_current_status VARCHAR(50);
    
    SELECT status INTO v_current_status
    FROM tenants WHERE tenant_id = p_tenant_id;
    
    IF v_current_status != 'pending_deletion' THEN
        SET p_status = 'INVALID_STATE';
        SET p_message = 'Tenant is not pending deletion';
    ELSE
        -- R√©activation
        CALL reactivate_tenant(p_tenant_id, p_performed_by, @react_status, @react_msg);
        
        -- Nettoyage de la date de suppression
        UPDATE tenants 
        SET deleted_at = NULL, updated_at = NOW(6)
        WHERE tenant_id = p_tenant_id;
        
        INSERT INTO tenant_events (tenant_id, event_type, performed_by)
        VALUES (p_tenant_id, 'reactivated', p_performed_by);
        
        SET p_status = 'SUCCESS';
        SET p_message = 'Tenant deletion cancelled and reactivated';
    END IF;
END //

DELIMITER ;
```

---

## Migrations de sch√©ma multi-tenant

La gestion des migrations de sch√©ma est particuli√®rement complexe avec le pattern Database per Tenant, car chaque base doit √™tre migr√©e individuellement.

### Strat√©gie de migration progressive

```sql
-- ============================================================
-- GESTION DES MIGRATIONS MULTI-TENANT
-- ============================================================

USE saas_control_plane;

-- Table de suivi des migrations
CREATE TABLE schema_migrations (
    migration_id VARCHAR(36) PRIMARY KEY DEFAULT (UUID()),
    version VARCHAR(20) NOT NULL,
    description VARCHAR(500) NOT NULL,
    script_hash VARCHAR(64) NOT NULL,  -- SHA256 du script
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    
    UNIQUE KEY uk_version (version)
) ENGINE=InnoDB;

-- Suivi par tenant
CREATE TABLE tenant_migrations (
    tenant_id VARCHAR(36) NOT NULL,
    migration_id VARCHAR(36) NOT NULL,
    status ENUM('pending', 'running', 'completed', 'failed', 'rolled_back') 
           DEFAULT 'pending',
    started_at DATETIME(6),
    completed_at DATETIME(6),
    error_message TEXT,
    
    PRIMARY KEY (tenant_id, migration_id),
    INDEX idx_status (status),
    INDEX idx_migration (migration_id)
) ENGINE=InnoDB;

-- ============================================================
-- PROC√âDURE DE MIGRATION
-- ============================================================

DELIMITER //

CREATE PROCEDURE saas_control_plane.apply_migration_to_tenant(
    IN p_tenant_id VARCHAR(36),
    IN p_migration_version VARCHAR(20),
    OUT p_status VARCHAR(50),
    OUT p_message TEXT
)
this_proc: BEGIN
    DECLARE v_db_name VARCHAR(64);
    DECLARE v_migration_id VARCHAR(36);
    DECLARE v_current_version VARCHAR(20);
    DECLARE v_tenant_status VARCHAR(50);
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        GET DIAGNOSTICS CONDITION 1 p_message = MESSAGE_TEXT;
        SET p_status = 'FAILED';
        
        UPDATE tenant_migrations 
        SET status = 'failed', 
            completed_at = NOW(6),
            error_message = p_message
        WHERE tenant_id = p_tenant_id AND migration_id = v_migration_id;
    END;
    
    -- V√©rifications
    SELECT db_name, status INTO v_db_name, v_tenant_status
    FROM tenants WHERE tenant_id = p_tenant_id;
    
    IF v_db_name IS NULL THEN
        SET p_status = 'NOT_FOUND';
        SET p_message = 'Tenant not found';
        LEAVE this_proc;
    END IF;
    
    IF v_tenant_status NOT IN ('active', 'suspended') THEN
        SET p_status = 'INVALID_STATE';
        SET p_message = 'Tenant must be active or suspended for migration';
        LEAVE this_proc;
    END IF;
    
    -- R√©cup√©ration de l'ID de migration
    SELECT migration_id INTO v_migration_id
    FROM schema_migrations WHERE version = p_migration_version;
    
    IF v_migration_id IS NULL THEN
        SET p_status = 'INVALID_MIGRATION';
        SET p_message = 'Migration version not found';
        LEAVE this_proc;
    END IF;
    
    -- V√©rification que la migration n'est pas d√©j√† appliqu√©e
    IF EXISTS (
        SELECT 1 FROM tenant_migrations 
        WHERE tenant_id = p_tenant_id 
          AND migration_id = v_migration_id 
          AND status = 'completed'
    ) THEN
        SET p_status = 'ALREADY_APPLIED';
        SET p_message = 'Migration already applied to this tenant';
        LEAVE this_proc;
    END IF;
    
    -- Enregistrement du d√©but de migration
    INSERT INTO tenant_migrations (tenant_id, migration_id, status, started_at)
    VALUES (p_tenant_id, v_migration_id, 'running', NOW(6))
    ON DUPLICATE KEY UPDATE status = 'running', started_at = NOW(6);
    
    -- ============================================================
    -- APPLICATION DE LA MIGRATION (exemple : version 1.1.0)
    -- En production, le script serait charg√© depuis un fichier
    -- ============================================================
    
    IF p_migration_version = '1.1.0' THEN
        -- Ajout d'une colonne aux utilisateurs
        SET @sql = CONCAT('ALTER TABLE `', v_db_name, '`.users ',
                          'ADD COLUMN phone VARCHAR(20) AFTER email');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- Ajout d'un index
        SET @sql = CONCAT('CREATE INDEX idx_phone ON `', v_db_name, '`.users (phone)');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- Mise √† jour des m√©tadonn√©es
        SET @sql = CONCAT('UPDATE `', v_db_name, '`.schema_metadata ',
                          'SET meta_value = ''1.1.0'' WHERE meta_key = ''schema_version''');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    
    ELSEIF p_migration_version = '1.2.0' THEN
        -- Nouvelle table pour les cat√©gories
        SET @sql = CONCAT('
            CREATE TABLE `', v_db_name, '`.categories (
                category_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
                name VARCHAR(100) NOT NULL,
                parent_id BIGINT UNSIGNED,
                created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
                INDEX idx_parent (parent_id)
            ) ENGINE=InnoDB
        ');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- Ajout FK aux produits
        SET @sql = CONCAT('ALTER TABLE `', v_db_name, '`.products ',
                          'ADD COLUMN category_id BIGINT UNSIGNED, ',
                          'ADD INDEX idx_category (category_id)');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- Mise √† jour version
        SET @sql = CONCAT('UPDATE `', v_db_name, '`.schema_metadata ',
                          'SET meta_value = ''1.2.0'' WHERE meta_key = ''schema_version''');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END IF;
    
    -- Marquage comme compl√©t√©
    UPDATE tenant_migrations 
    SET status = 'completed', completed_at = NOW(6)
    WHERE tenant_id = p_tenant_id AND migration_id = v_migration_id;
    
    SET p_status = 'SUCCESS';
    SET p_message = CONCAT('Migration ', p_migration_version, ' applied successfully');
    
END //

-- Proc√©dure pour migrer tous les tenants actifs
CREATE PROCEDURE saas_control_plane.apply_migration_to_all_tenants(
    IN p_migration_version VARCHAR(20),
    OUT p_total INT,
    OUT p_success INT,
    OUT p_failed INT
)
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_tenant_id VARCHAR(36);
    DECLARE v_status VARCHAR(50);
    DECLARE v_message TEXT;
    
    DECLARE cur CURSOR FOR
        SELECT tenant_id FROM tenants 
        WHERE status IN ('active', 'suspended')
        ORDER BY created_at;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    SET p_total = 0;
    SET p_success = 0;
    SET p_failed = 0;
    
    OPEN cur;
    
    migration_loop: LOOP
        FETCH cur INTO v_tenant_id;
        IF done THEN LEAVE migration_loop; END IF;
        
        SET p_total = p_total + 1;
        
        CALL apply_migration_to_tenant(v_tenant_id, p_migration_version, 
                                       v_status, v_message);
        
        IF v_status = 'SUCCESS' OR v_status = 'ALREADY_APPLIED' THEN
            SET p_success = p_success + 1;
        ELSE
            SET p_failed = p_failed + 1;
        END IF;
    END LOOP;
    
    CLOSE cur;
END //

DELIMITER ;
```

**Utilisation des migrations :**

```sql
-- Enregistrement d'une nouvelle migration
INSERT INTO schema_migrations (version, description, script_hash)
VALUES ('1.1.0', 'Add phone column to users', SHA2('migration_script_content', 256));

INSERT INTO schema_migrations (version, description, script_hash)
VALUES ('1.2.0', 'Add categories table', SHA2('migration_script_content_v2', 256));

-- Application √† un tenant sp√©cifique
CALL saas_control_plane.apply_migration_to_tenant(
    '550e8400-e29b-41d4-a716-446655440000',
    '1.1.0',
    @status,
    @message
);
SELECT @status, @message;

-- Application √† tous les tenants
CALL saas_control_plane.apply_migration_to_all_tenants('1.2.0', @total, @success, @failed);
SELECT @total AS total_tenants, @success AS migrated, @failed AS failed;
-- +---------------+----------+--------+
-- | total_tenants | migrated | failed |
-- +---------------+----------+--------+
-- |           150 |      148 |      2 |
-- +---------------+----------+--------+

-- V√©rification des migrations en √©chec
SELECT t.tenant_slug, tm.status, tm.error_message
FROM tenant_migrations tm
JOIN tenants t ON tm.tenant_id = t.tenant_id
JOIN schema_migrations sm ON tm.migration_id = sm.migration_id
WHERE sm.version = '1.2.0' AND tm.status = 'failed';
```

üí° **Conseil** : Pour les migrations √† grande √©chelle, utilisez un syst√®me de migration d√©di√© comme **Flyway** ou **Liquibase** qui g√®re nativement les sc√©narios multi-tenant et les rollbacks.

---

## Backup et restauration par tenant

### Strat√©gie de backup individuel

```bash
#!/bin/bash
# backup_tenant.sh - Sauvegarde individuelle d'un tenant

set -euo pipefail

# Configuration
TENANT_SLUG="$1"
BACKUP_DIR="/backups/tenants/${TENANT_SLUG}"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
RETENTION_DAYS=30

# R√©cup√©ration des informations de connexion depuis le Control Plane
TENANT_INFO=$(mysql -h control-plane-db -u backup_user -p"${BACKUP_PASSWORD}" \
    -N -e "SELECT db_host, db_name, db_user, 
           CAST(AES_DECRYPT(db_password_encrypted, @@global.aes_encrypt_key) AS CHAR)
           FROM saas_control_plane.tenants 
           WHERE tenant_slug = '${TENANT_SLUG}' AND status != 'deleted'")

if [ -z "$TENANT_INFO" ]; then
    echo "Error: Tenant not found: ${TENANT_SLUG}"
    exit 1
fi

read -r DB_HOST DB_NAME DB_USER DB_PASSWORD <<< "$TENANT_INFO"

# Cr√©ation du r√©pertoire de backup
mkdir -p "${BACKUP_DIR}"

# Backup avec mariabackup (physique, coh√©rent)
BACKUP_PATH="${BACKUP_DIR}/${TIMESTAMP}_full"

echo "[$(date)] Starting backup for tenant: ${TENANT_SLUG}"

mariabackup --backup \
    --host="${DB_HOST}" \
    --user="${DB_USER}" \
    --password="${DB_PASSWORD}" \
    --databases="${DB_NAME}" \
    --target-dir="${BACKUP_PATH}" \
    --parallel=4

# Pr√©paration du backup
mariabackup --prepare --target-dir="${BACKUP_PATH}"

# Compression
tar -czf "${BACKUP_PATH}.tar.gz" -C "${BACKUP_DIR}" "${TIMESTAMP}_full"
rm -rf "${BACKUP_PATH}"

# Calcul du checksum
sha256sum "${BACKUP_PATH}.tar.gz" > "${BACKUP_PATH}.tar.gz.sha256"

# Enregistrement du backup dans le Control Plane
mysql -h control-plane-db -u backup_user -p"${BACKUP_PASSWORD}" <<EOF
INSERT INTO saas_control_plane.tenant_events 
    (tenant_id, event_type, event_data, performed_by)
SELECT 
    tenant_id,
    'backup_created',
    JSON_OBJECT(
        'backup_path', '${BACKUP_PATH}.tar.gz',
        'backup_size_bytes', $(stat -f%z "${BACKUP_PATH}.tar.gz" 2>/dev/null || stat -c%s "${BACKUP_PATH}.tar.gz"),
        'checksum', '$(cat "${BACKUP_PATH}.tar.gz.sha256" | cut -d' ' -f1)'
    ),
    'system/backup'
FROM saas_control_plane.tenants 
WHERE tenant_slug = '${TENANT_SLUG}';
EOF

# Nettoyage des anciens backups
find "${BACKUP_DIR}" -name "*.tar.gz" -mtime +${RETENTION_DAYS} -delete
find "${BACKUP_DIR}" -name "*.sha256" -mtime +${RETENTION_DAYS} -delete

echo "[$(date)] Backup completed: ${BACKUP_PATH}.tar.gz"
```

### Script de restauration

```bash
#!/bin/bash
# restore_tenant.sh - Restauration d'un tenant depuis un backup

set -euo pipefail

TENANT_SLUG="$1"
BACKUP_FILE="$2"  # Chemin vers le fichier .tar.gz
RESTORE_MODE="${3:-replace}"  # replace | new_tenant

# V√©rification du checksum
CHECKSUM_FILE="${BACKUP_FILE}.sha256"
if [ -f "$CHECKSUM_FILE" ]; then
    echo "Verifying backup integrity..."
    sha256sum -c "$CHECKSUM_FILE" || { echo "Checksum verification failed!"; exit 1; }
fi

# Extraction du backup
TEMP_DIR=$(mktemp -d)
tar -xzf "$BACKUP_FILE" -C "$TEMP_DIR"
BACKUP_DIR=$(ls -d "${TEMP_DIR}"/*/)

# R√©cup√©ration des informations tenant
TENANT_INFO=$(mysql -h control-plane-db -u restore_user -p"${RESTORE_PASSWORD}" \
    -N -e "SELECT db_host, db_name, db_user,
           CAST(AES_DECRYPT(db_password_encrypted, @@global.aes_encrypt_key) AS CHAR)
           FROM saas_control_plane.tenants 
           WHERE tenant_slug = '${TENANT_SLUG}'")

read -r DB_HOST DB_NAME DB_USER DB_PASSWORD <<< "$TENANT_INFO"

if [ "$RESTORE_MODE" = "replace" ]; then
    echo "[$(date)] Restoring tenant ${TENANT_SLUG} (replace mode)"
    
    # Arr√™t des connexions actives
    mysql -h "$DB_HOST" -u root -p"${ROOT_PASSWORD}" \
        -e "SELECT CONCAT('KILL ', id, ';') 
            FROM information_schema.PROCESSLIST 
            WHERE db = '${DB_NAME}'" | tail -n +2 | mysql -h "$DB_HOST" -u root -p"${ROOT_PASSWORD}"
    
    # Suppression de l'ancienne base
    mysql -h "$DB_HOST" -u root -p"${ROOT_PASSWORD}" \
        -e "DROP DATABASE IF EXISTS \`${DB_NAME}\`"
    
    # Restauration
    mariabackup --copy-back \
        --target-dir="${BACKUP_DIR}" \
        --datadir="/var/lib/mysql"
    
    # Ajustement des permissions
    chown -R mysql:mysql "/var/lib/mysql/${DB_NAME}"
    
elif [ "$RESTORE_MODE" = "new_tenant" ]; then
    NEW_DB_NAME="${DB_NAME}_restored_$(date +%Y%m%d)"
    echo "[$(date)] Restoring to new database: ${NEW_DB_NAME}"
    
    # Modification du nom de base dans le backup
    # (N√©cessite une manipulation des fichiers InnoDB)
    # Alternative : restaurer puis renommer
    
    mariabackup --copy-back \
        --target-dir="${BACKUP_DIR}" \
        --datadir="/var/lib/mysql"
    
    mysql -h "$DB_HOST" -u root -p"${ROOT_PASSWORD}" \
        -e "RENAME DATABASE \`${DB_NAME}\` TO \`${NEW_DB_NAME}\`"
fi

# Nettoyage
rm -rf "$TEMP_DIR"

# Log de l'√©v√©nement
mysql -h control-plane-db -u restore_user -p"${RESTORE_PASSWORD}" <<EOF
INSERT INTO saas_control_plane.tenant_events 
    (tenant_id, event_type, event_data, performed_by)
SELECT 
    tenant_id,
    'backup_restored',
    JSON_OBJECT(
        'backup_file', '${BACKUP_FILE}',
        'restore_mode', '${RESTORE_MODE}',
        'restored_at', NOW(6)
    ),
    'system/restore'
FROM saas_control_plane.tenants 
WHERE tenant_slug = '${TENANT_SLUG}';
EOF

echo "[$(date)] Restore completed successfully"
```

### Automatisation des backups

```yaml
# kubernetes/cronjob-tenant-backups.yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: tenant-backups
  namespace: saas-platform
spec:
  schedule: "0 2 * * *"  # Tous les jours √† 2h
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: backup-runner
            image: mariadb-backup-tools:11.8
            command:
            - /bin/bash
            - -c
            - |
              # R√©cup√©ration de tous les tenants actifs
              TENANTS=$(mysql -h $CONTROL_PLANE_HOST -u $BACKUP_USER -p"$BACKUP_PASSWORD" \
                -N -e "SELECT tenant_slug FROM saas_control_plane.tenants 
                       WHERE status IN ('active', 'suspended')")
              
              for tenant in $TENANTS; do
                echo "Backing up tenant: $tenant"
                /scripts/backup_tenant.sh "$tenant" || echo "Failed: $tenant"
              done
            env:
            - name: CONTROL_PLANE_HOST
              value: "control-plane-db.saas-platform.svc"
            - name: BACKUP_USER
              valueFrom:
                secretKeyRef:
                  name: backup-credentials
                  key: username
            - name: BACKUP_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: backup-credentials
                  key: password
            volumeMounts:
            - name: backup-storage
              mountPath: /backups
            - name: scripts
              mountPath: /scripts
          volumes:
          - name: backup-storage
            persistentVolumeClaim:
              claimName: tenant-backups-pvc
          - name: scripts
            configMap:
              name: backup-scripts
              defaultMode: 0755
          restartPolicy: OnFailure
```

---

## Gestion des ressources par plan tarifaire

### Resource Groups et quotas üÜï

MariaDB 11.8 permet d'allouer des ressources diff√©renci√©es :

```sql
-- ============================================================
-- CONFIGURATION DES RESOURCE GROUPS PAR PLAN
-- ============================================================

-- Plan Free : ressources limit√©es
CREATE RESOURCE GROUP rg_tenant_free
    TYPE = USER
    VCPU = 0-1
    THREAD_PRIORITY = 10;  -- Basse priorit√©

-- Plan Starter : ressources standard
CREATE RESOURCE GROUP rg_tenant_starter
    TYPE = USER
    VCPU = 0-3
    THREAD_PRIORITY = 5;

-- Plan Professional : ressources prioritaires
CREATE RESOURCE GROUP rg_tenant_professional
    TYPE = USER
    VCPU = 0-7
    THREAD_PRIORITY = 0;

-- Plan Enterprise : ressources maximales
CREATE RESOURCE GROUP rg_tenant_enterprise
    TYPE = USER
    VCPU = 0-15
    THREAD_PRIORITY = -5;  -- Haute priorit√©

-- Attribution automatique lors de la connexion
-- (via un trigger sur les connexions ou middleware applicatif)

-- Proc√©dure pour appliquer le Resource Group √† une session
DELIMITER //

CREATE PROCEDURE saas_control_plane.apply_tenant_resource_group(
    IN p_tenant_slug VARCHAR(64)
)
BEGIN
    DECLARE v_plan VARCHAR(50);
    DECLARE v_resource_group VARCHAR(64);
    
    SELECT subscription_plan INTO v_plan
    FROM tenants WHERE tenant_slug = p_tenant_slug;
    
    SET v_resource_group = CONCAT('rg_tenant_', v_plan);
    
    -- Application du Resource Group √† la session courante
    SET @sql = CONCAT('SET RESOURCE GROUP ', v_resource_group);
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END //

DELIMITER ;
```

### Monitoring des quotas

```sql
-- ============================================================
-- SUIVI DES QUOTAS PAR TENANT
-- ============================================================

USE saas_control_plane;

CREATE TABLE tenant_usage_metrics (
    metric_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    tenant_id VARCHAR(36) NOT NULL,
    metric_date DATE NOT NULL,
    
    -- M√©triques d'usage
    user_count INT UNSIGNED DEFAULT 0,
    storage_bytes BIGINT UNSIGNED DEFAULT 0,
    api_calls_count INT UNSIGNED DEFAULT 0,
    query_count BIGINT UNSIGNED DEFAULT 0,
    
    -- Timestamps
    created_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),
    updated_at DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6) 
               ON UPDATE CURRENT_TIMESTAMP(6),
    
    UNIQUE KEY uk_tenant_date (tenant_id, metric_date),
    INDEX idx_date (metric_date)
) ENGINE=InnoDB;

-- Vue d'alerte sur les d√©passements de quota
CREATE OR REPLACE VIEW v_quota_alerts AS
SELECT 
    t.tenant_id,
    t.tenant_slug,
    t.company_name,
    t.subscription_plan,
    
    -- Utilisateurs
    m.user_count,
    t.max_users,
    CASE 
        WHEN t.max_users IS NULL THEN 'unlimited'
        WHEN m.user_count >= t.max_users THEN 'exceeded'
        WHEN m.user_count >= t.max_users * 0.9 THEN 'warning'
        ELSE 'ok'
    END AS users_status,
    
    -- Stockage
    ROUND(m.storage_bytes / 1073741824, 2) AS storage_gb,
    t.max_storage_gb,
    CASE 
        WHEN t.max_storage_gb IS NULL THEN 'unlimited'
        WHEN m.storage_bytes >= t.max_storage_gb * 1073741824 THEN 'exceeded'
        WHEN m.storage_bytes >= t.max_storage_gb * 1073741824 * 0.9 THEN 'warning'
        ELSE 'ok'
    END AS storage_status,
    
    -- API calls
    m.api_calls_count,
    t.max_api_calls_per_day,
    CASE 
        WHEN t.max_api_calls_per_day IS NULL THEN 'unlimited'
        WHEN m.api_calls_count >= t.max_api_calls_per_day THEN 'exceeded'
        WHEN m.api_calls_count >= t.max_api_calls_per_day * 0.9 THEN 'warning'
        ELSE 'ok'
    END AS api_status
    
FROM tenants t
LEFT JOIN tenant_usage_metrics m ON t.tenant_id = m.tenant_id 
    AND m.metric_date = CURDATE()
WHERE t.status = 'active';

-- Proc√©dure de collecte des m√©triques
DELIMITER //

CREATE PROCEDURE saas_control_plane.collect_tenant_metrics(
    IN p_tenant_id VARCHAR(36)
)
BEGIN
    DECLARE v_db_name VARCHAR(64);
    DECLARE v_user_count INT UNSIGNED;
    DECLARE v_storage_bytes BIGINT UNSIGNED;
    
    SELECT db_name INTO v_db_name
    FROM tenants WHERE tenant_id = p_tenant_id;
    
    IF v_db_name IS NOT NULL THEN
        -- Comptage des utilisateurs
        SET @sql = CONCAT('SELECT COUNT(*) INTO @cnt FROM `', v_db_name, '`.users');
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        SET v_user_count = @cnt;
        
        -- Calcul du stockage
        SELECT SUM(data_length + index_length) INTO v_storage_bytes
        FROM information_schema.TABLES
        WHERE table_schema = v_db_name;
        
        -- Mise √† jour des m√©triques
        INSERT INTO tenant_usage_metrics (tenant_id, metric_date, user_count, storage_bytes)
        VALUES (p_tenant_id, CURDATE(), v_user_count, COALESCE(v_storage_bytes, 0))
        ON DUPLICATE KEY UPDATE
            user_count = v_user_count,
            storage_bytes = COALESCE(v_storage_bytes, 0),
            updated_at = NOW(6);
    END IF;
END //

DELIMITER ;

-- Event pour collecte quotidienne
CREATE EVENT evt_collect_all_tenant_metrics
ON SCHEDULE EVERY 1 HOUR
DO
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_tenant_id VARCHAR(36);
    
    DECLARE cur CURSOR FOR
        SELECT tenant_id FROM tenants WHERE status = 'active';
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur;
    collect_loop: LOOP
        FETCH cur INTO v_tenant_id;
        IF done THEN LEAVE collect_loop; END IF;
        CALL collect_tenant_metrics(v_tenant_id);
    END LOOP;
    CLOSE cur;
END;
```

---

## Avantages et inconv√©nients

### ‚úÖ Avantages

| Avantage | Description |
|----------|-------------|
| **Isolation maximale** | Aucun risque de fuite de donn√©es entre tenants |
| **Personnalisation compl√®te** | Configuration, sch√©ma, extensions par tenant |
| **Performance pr√©visible** | Pas d'effet "noisy neighbor" |
| **Conformit√© r√©glementaire** | Facilite GDPR, HIPAA, SOC 2 (donn√©es s√©par√©es) |
| **Backup/Restore granulaire** | Op√©rations ind√©pendantes par tenant |
| **Scaling individuel** | Ressources ajustables par tenant (plans premium) |
| **S√©curit√© renforc√©e** | Utilisateurs DB d√©di√©s, privil√®ges isol√©s |

### ‚ùå Inconv√©nients

| Inconv√©nient | Description | Mitigation |
|--------------|-------------|------------|
| **Co√ªt infrastructure** | N bases au lieu d'une | Consolidation sur instances partag√©es |
| **Complexit√© op√©rationnelle** | N backups, N migrations, N monitorings | Automatisation pouss√©e, IaC |
| **Overhead de connexions** | Pool par tenant | Poolers externes (ProxySQL, MaxScale) |
| **Provisioning plus long** | Cr√©ation DB + sch√©ma + user | Parall√©lisation, templates |
| **Agr√©gations cross-tenant** | Impossible directement | ETL vers data warehouse d√©di√© |
| **Co√ªt de maintenance** | Plus de bases √† maintenir | Scripts d'automatisation |

---

## Comparaison avec les autres patterns multi-tenant

| Crit√®re | Database per Tenant | Schema per Tenant | Shared Schema |
|---------|---------------------|-------------------|---------------|
| **Isolation donn√©es** | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë | ‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë |
| **Co√ªt/tenant** | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë | ‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë | ‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë |
| **Complexit√© ops** | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë | ‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë |
| **Personnalisation** | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë | ‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë |
| **Performance** | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë | ‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë |
| **Scaling** | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë |
| **Onboarding** | ‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë | ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà |
| **Nb tenants max** | ~1,000 | ~10,000 | Illimit√© |

---

## Quand utiliser ce pattern ?

### ‚úÖ Recommand√© pour :

- **Exigences r√©glementaires strictes** (HIPAA, GDPR, donn√©es sensibles)
- **SLA diff√©renci√©s** par client (performance garantie)
- **Grands comptes** avec besoins de personnalisation
- **Donn√©es critiques** n√©cessitant isolation physique
- **Nombre limit√© de tenants** (< 1,000)
- **Plans Enterprise** avec ressources d√©di√©es
- **Industries r√©glement√©es** (sant√©, finance, gouvernement)

### ‚ùå D√©conseill√© pour :

- **Grand nombre de tenants** (> 10,000) - overhead prohibitif
- **Plans freemium** avec beaucoup de petits tenants
- **Applications B2C** avec millions d'utilisateurs
- **Tenants √† usage faible** (gaspillage de ressources)
- **√âquipes DevOps r√©duites** (charge op√©rationnelle √©lev√©e)

---

## ‚úÖ Points cl√©s √† retenir

- Le pattern **Database per Tenant** offre l'**isolation maximale** mais au prix d'une **complexit√© op√©rationnelle** accrue
- Une **base de contr√¥le centrale** (Control Plane) g√®re les m√©tadonn√©es de tous les tenants
- Le **provisioning automatis√©** est essentiel : cr√©ation de base, utilisateur, sch√©ma, privil√®ges
- Le **routage des connexions** peut se faire par subdomain, header, JWT ou path
- Les **migrations de sch√©ma** doivent √™tre appliqu√©es individuellement √† chaque tenant
- Les **backups et restaurations** sont granulaires et ind√©pendants par tenant
- Les **Resource Groups** MariaDB 11.8 permettent une allocation diff√©renci√©e des ressources
- Le **monitoring des quotas** par plan tarifaire assure le respect des limites contractuelles
- Ce pattern est adapt√© aux **contextes r√©glement√©s** ou aux **clients enterprise**

---

## üîó Ressources et r√©f√©rences

- üìñ [MariaDB Documentation - CREATE DATABASE](https://mariadb.com/kb/en/create-database/)
- üìñ [MariaDB Documentation - User Account Management](https://mariadb.com/kb/en/user-account-management/)
- üìñ [MariaDB Documentation - Resource Groups](https://mariadb.com/kb/en/resource-groups/)
- üìñ [Mariabackup Overview](https://mariadb.com/kb/en/mariabackup-overview/)
- üìñ [Multi-tenant SaaS patterns - Microsoft Azure](https://docs.microsoft.com/en-us/azure/architecture/guide/multitenant/overview)
- üìñ [Building Multi-Tenant Applications - AWS](https://docs.aws.amazon.com/whitepapers/latest/saas-architecture-fundamentals/multi-tenant-database-architecture.html)

---

## ‚û°Ô∏è Section suivante

**20.4.2 Schema per Tenant** : D√©couvrez une approche interm√©diaire o√π chaque tenant dispose de son propre sch√©ma au sein d'une instance MariaDB partag√©e, offrant un bon compromis entre isolation et efficacit√© op√©rationnelle.

‚è≠Ô∏è [Schema per tenant](/20-cas-usage-architectures/04.2-schema-per-tenant.md)
