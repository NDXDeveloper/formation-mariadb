üîù Retour au [Sommaire](/SOMMAIRE.md)

# 2.2.4 Types de donn√©es binaires

> **Niveau** : D√©butant
> **Dur√©e estim√©e** : 1 heure
> **Pr√©requis** : Section 2.2.3 (Types temporels)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre les diff√©rences entre BINARY, VARBINARY et BLOB
- Choisir le type binaire appropri√© selon vos besoins
- Stocker et r√©cup√©rer des donn√©es binaires (images, fichiers)
- Conna√Ætre les avantages et inconv√©nients du stockage binaire en base
- Utiliser les bonnes pratiques pour g√©rer des fichiers
- √âviter les pi√®ges de performance li√©s aux donn√©es binaires

---

## Introduction

Les **types de donn√©es binaires** permettent de stocker des donn√©es brutes (raw bytes) dans MariaDB : images, fichiers PDF, documents Office, archives ZIP, etc.

Contrairement aux types texte :
- Pas d'encodage de caract√®res (charset)
- Pas de collation
- Comparaison byte par byte
- Stockage exact des octets

üí° **Question importante** : Faut-il stocker des fichiers en base de donn√©es ?

**Arguments POUR** :
- ‚úÖ Coh√©rence transactionnelle (ACID)
- ‚úÖ Backup unique (base + fichiers)
- ‚úÖ Contr√¥le d'acc√®s unifi√©
- ‚úÖ Simplicit√© de d√©ploiement

**Arguments CONTRE** :
- ‚ùå Impact sur les performances
- ‚ùå Taille de la base augmente rapidement
- ‚ùå Backup plus lent et volumineux
- ‚ùå Pas de CDN/cache natif
- ‚ùå Difficile de servir directement (pas de HTTP)

‚ö†Ô∏è **Recommandation g√©n√©rale** : Pour les fichiers > 1 MB, privil√©gier le stockage sur filesystem ou object storage (S3) avec r√©f√©rence en base.

---

## Vue d'ensemble des types binaires

| Type | Longueur max | Pr√©fixe | Stockage | Usage |
|------|--------------|---------|----------|-------|
| **BINARY(M)** | 255 octets | - | Fixe (M octets) | Hash, signatures fixes |
| **VARBINARY(M)** | 65,535 octets | 1-2 octets | Variable | Petits fichiers |
| **TINYBLOB** | 255 octets | 1 octet | Variable | Tr√®s petits fichiers |
| **BLOB** | 65,535 octets (~64 KB) | 2 octets | Variable | Images moyennes |
| **MEDIUMBLOB** | 16,777,215 octets (~16 MB) | 3 octets | Variable | Documents, PDF |
| **LONGBLOB** | 4,294,967,295 octets (~4 GB) | 4 octets | Variable | Gros fichiers |

### Correspondance avec types texte

| Type binaire | Type texte √©quivalent |
|--------------|----------------------|
| BINARY(M) | CHAR(M) |
| VARBINARY(M) | VARCHAR(M) |
| TINYBLOB | TINYTEXT |
| BLOB | TEXT |
| MEDIUMBLOB | MEDIUMTEXT |
| LONGBLOB | LONGTEXT |

La diff√©rence principale : **binaire = octets bruts**, **texte = caract√®res avec charset**.

---

## BINARY - Donn√©es binaires de longueur fixe

### Caract√©ristiques

**BINARY(M)** stocke exactement M octets de donn√©es binaires.

- **Taille** : M octets (0-255)
- **Padding** : Compl√©t√© avec `0x00` (z√©ro binaire) si n√©cessaire
- **Usage** : Hash MD5/SHA, UUID binaire, signatures

```sql
-- Cr√©ation d'une table avec BINARY
CREATE TABLE tokens_session (
    token_id INT PRIMARY KEY AUTO_INCREMENT,
    utilisateur_id INT NOT NULL,
    token_hash BINARY(32),                      -- SHA-256 = 32 octets
    salt BINARY(16),                            -- Salt = 16 octets
    date_creation TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_expiration TIMESTAMP,
    INDEX idx_token (token_hash)
);

-- Insertion de hash binaires (exemple avec SHA2)
INSERT INTO tokens_session (utilisateur_id, token_hash, salt, date_expiration) VALUES
    (1001,
     UNHEX(SHA2('mon_token_secret_123', 256)),  -- SHA-256 en binaire
     UNHEX(MD5(RAND())),                        -- Salt al√©atoire
     DATE_ADD(NOW(), INTERVAL 1 HOUR)
    );

-- Recherche par token (comparaison binaire exacte)
SELECT utilisateur_id, date_expiration
FROM tokens_session
WHERE token_hash = UNHEX(SHA2('mon_token_secret_123', 256))
  AND date_expiration > NOW();
```

### Conversion hexad√©cimal ‚Üî binaire

```sql
-- HEX() : Binaire ‚Üí Hexad√©cimal
-- UNHEX() : Hexad√©cimal ‚Üí Binaire

SELECT
    HEX('ABC') AS hex_from_text,                -- 414243
    UNHEX('414243') AS binary_from_hex,         -- ABC
    HEX(BINARY('ABC')) AS hex_from_binary;      -- 414243

-- Exemple avec hash
SELECT
    SHA2('password123', 256) AS hash_hex,                           -- Hex (64 caract√®res)
    UNHEX(SHA2('password123', 256)) AS hash_binary,                 -- Binaire (32 octets)
    HEX(UNHEX(SHA2('password123', 256))) AS hash_hex_retour;        -- Retour en hex
```

üí° **Cas d'usage BINARY** :
- ‚úÖ Hash de mots de passe (bcrypt, SHA-256)
- ‚úÖ UUID au format binaire (16 octets vs 36 caract√®res)
- ‚úÖ Cl√©s cryptographiques
- ‚úÖ Signatures num√©riques
- ‚úÖ Checksums, empreintes

---

## VARBINARY - Donn√©es binaires de longueur variable

### Caract√©ristiques

**VARBINARY(M)** stocke jusqu'√† M octets de donn√©es binaires.

- **Taille** : 0 √† 65,535 octets (+ 1-2 octets de pr√©fixe)
- **Variable** : N'occupe que l'espace n√©cessaire
- **Pas de padding** : Contrairement √† BINARY

```sql
-- Cr√©ation d'une table avec VARBINARY
CREATE TABLE signatures_documents (
    signature_id INT PRIMARY KEY AUTO_INCREMENT,
    document_id INT NOT NULL,
    signature_binaire VARBINARY(1024),          -- Signature jusqu'√† 1 KB
    algorithme VARCHAR(50),                     -- RSA, DSA, ECDSA
    date_signature TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (document_id) REFERENCES documents(document_id)
);

-- Insertion d'une signature
INSERT INTO signatures_documents (document_id, signature_binaire, algorithme) VALUES
    (101, UNHEX('A1B2C3D4E5F6...'), 'RSA-2048');

-- V√©rification de la taille
SELECT
    signature_id,
    LENGTH(signature_binaire) AS taille_octets,
    algorithme
FROM signatures_documents;
```

### Comparaison BINARY vs VARBINARY

```sql
-- D√©monstration de la diff√©rence de stockage
CREATE TABLE demo_binary_vs_varbinary (
    id INT PRIMARY KEY AUTO_INCREMENT,
    data_binary BINARY(100),                    -- Toujours 100 octets
    data_varbinary VARBINARY(100)               -- Variable jusqu'√† 100
);

-- Insertion de donn√©es courtes
INSERT INTO demo_binary_vs_varbinary (data_binary, data_varbinary) VALUES
    ('ABC', 'ABC');

-- V√©rification de l'espace utilis√©
SELECT
    id,
    LENGTH(data_binary) AS taille_binary,       -- 100 octets (padding avec 0x00)
    LENGTH(data_varbinary) AS taille_varbinary, -- 3 octets (taille r√©elle)
    HEX(data_binary) AS hex_binary,
    HEX(data_varbinary) AS hex_varbinary
FROM demo_binary_vs_varbinary;

-- R√©sultat :
-- taille_binary: 100
-- taille_varbinary: 3
-- hex_binary: 414243000000... (97 z√©ros binaires)
-- hex_varbinary: 414243
```

üí° **Cas d'usage VARBINARY** :
- ‚úÖ Petites images (thumbnails, ic√¥nes)
- ‚úÖ Certificats SSL/TLS
- ‚úÖ Tokens d'API (longueur variable)
- ‚úÖ Donn√©es crypt√©es de taille variable

---

## BLOB - Binary Large Objects

Les types BLOB permettent de stocker des objets binaires de grande taille.

### Les 4 types BLOB

```sql
-- Cr√©ation d'une table avec tous les types BLOB
CREATE TABLE demo_blobs (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nom VARCHAR(100),

    -- TINYBLOB : Tr√®s petit (255 octets max)
    icon_tiny TINYBLOB,                         -- Petite ic√¥ne

    -- BLOB : Standard (64 KB max)
    image_small BLOB,                           -- Image petite/moyenne

    -- MEDIUMBLOB : Moyen (16 MB max)
    document_pdf MEDIUMBLOB,                    -- Document PDF, Office

    -- LONGBLOB : Tr√®s grand (4 GB max)
    video_backup LONGBLOB,                      -- Vid√©o (d√©conseill√© !)

    taille_tiny INT AS (LENGTH(icon_tiny)) STORED,
    taille_small INT AS (LENGTH(image_small)) STORED,
    taille_pdf INT AS (LENGTH(document_pdf)) STORED,
    taille_video INT AS (LENGTH(video_backup)) STORED
);
```

### BLOB vs TEXT

```sql
-- Comparaison BLOB vs TEXT
CREATE TABLE comparaison_blob_text (
    id INT PRIMARY KEY AUTO_INCREMENT,

    -- BLOB : Donn√©es binaires (pas de charset)
    data_blob BLOB,

    -- TEXT : Donn√©es textuelles (avec charset)
    data_text TEXT CHARACTER SET utf8mb4
);

-- Insertion de donn√©es
INSERT INTO comparaison_blob_text (data_blob, data_text) VALUES
    ('Donn√©es binaires', 'Donn√©es textuelles');

-- BLOB est sensible √† la casse binaire
SELECT * FROM comparaison_blob_text WHERE data_blob = 'donn√©es binaires';  -- Pas trouv√©
SELECT * FROM comparaison_blob_text WHERE data_blob = 'Donn√©es binaires';  -- Trouv√©

-- TEXT suit la collation (insensible par d√©faut)
SELECT * FROM comparaison_blob_text WHERE data_text = 'donn√©es textuelles';  -- Trouv√©
SELECT * FROM comparaison_blob_text WHERE data_text = 'Donn√©es textuelles';  -- Trouv√©
```

üí° **BLOB vs TEXT** :
- **BLOB** : Comparaison binaire stricte (case-sensitive)
- **TEXT** : Comparaison selon collation (peut √™tre case-insensitive)

---

## Stockage et r√©cup√©ration de fichiers

### Exemple : Stockage d'images

```sql
-- Table pour stocker des avatars utilisateurs
CREATE TABLE avatars_utilisateurs (
    avatar_id INT PRIMARY KEY AUTO_INCREMENT,
    utilisateur_id INT UNIQUE NOT NULL,
    nom_fichier VARCHAR(255) NOT NULL,
    type_mime VARCHAR(100) NOT NULL,            -- image/jpeg, image/png
    taille_octets INT,
    image_data MEDIUMBLOB NOT NULL,             -- Image jusqu'√† 16 MB
    date_upload TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_utilisateur (utilisateur_id)
);

-- Insertion d'une image (exemple avec LOAD_FILE - n√©cessite FILE privilege)
-- Note : LOAD_FILE fonctionne uniquement si le serveur a acc√®s au fichier
INSERT INTO avatars_utilisateurs (utilisateur_id, nom_fichier, type_mime, taille_octets, image_data)
VALUES (
    1001,
    'avatar_1001.jpg',
    'image/jpeg',
    45678,
    LOAD_FILE('/tmp/avatar_1001.jpg')          -- Charge depuis filesystem
);

-- V√©rification
SELECT
    avatar_id,
    utilisateur_id,
    nom_fichier,
    type_mime,
    LENGTH(image_data) AS taille_reelle,
    taille_octets,
    date_upload
FROM avatars_utilisateurs;
```

### Encodage Base64 pour l'insertion

En pratique, les applications n'utilisent pas `LOAD_FILE` mais ins√®rent des donn√©es binaires via leur driver :

```sql
-- Exemple d'insertion avec donn√©es hexad√©cimales
INSERT INTO avatars_utilisateurs (utilisateur_id, nom_fichier, type_mime, image_data)
VALUES (
    1002,
    'avatar_1002.png',
    'image/png',
    UNHEX('89504E47...')                        -- Donn√©es hex de l'image PNG
);

-- R√©cup√©ration en hexad√©cimal
SELECT
    utilisateur_id,
    nom_fichier,
    HEX(SUBSTRING(image_data, 1, 20)) AS debut_hex_data
FROM avatars_utilisateurs
WHERE utilisateur_id = 1002;
```

üí° **Dans les applications** :

```python
# Python avec mysql-connector
import mysql.connector
import base64

# Lire le fichier
with open('avatar.jpg', 'rb') as f:
    image_data = f.read()

# Ins√©rer en base
cursor.execute("""
    INSERT INTO avatars_utilisateurs
    (utilisateur_id, nom_fichier, type_mime, image_data)
    VALUES (%s, %s, %s, %s)
""", (1003, 'avatar.jpg', 'image/jpeg', image_data))

# R√©cup√©rer depuis la base
cursor.execute("SELECT image_data FROM avatars_utilisateurs WHERE utilisateur_id = %s", (1003,))
image_data = cursor.fetchone()[0]

# Sauvegarder
with open('avatar_retrieved.jpg', 'wb') as f:
    f.write(image_data)
```

---

## Exemple pratique : Syst√®me de gestion de documents

```sql
-- Table principale des documents
CREATE TABLE documents (
    document_id INT PRIMARY KEY AUTO_INCREMENT,
    titre VARCHAR(200) NOT NULL,
    description TEXT,
    categorie ENUM('facture', 'contrat', 'rapport', 'autre'),
    proprietaire_id INT NOT NULL,
    date_creation TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_proprietaire (proprietaire_id),
    INDEX idx_categorie (categorie)
);

-- Table s√©par√©e pour les fichiers binaires
CREATE TABLE documents_fichiers (
    fichier_id INT PRIMARY KEY AUTO_INCREMENT,
    document_id INT NOT NULL,
    nom_fichier VARCHAR(255) NOT NULL,
    extension VARCHAR(10),
    type_mime VARCHAR(100),
    taille_octets INT,
    contenu_binaire MEDIUMBLOB NOT NULL,
    hash_md5 BINARY(16),                        -- Pour d√©duplication
    date_upload TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (document_id) REFERENCES documents(document_id) ON DELETE CASCADE,
    INDEX idx_document (document_id),
    INDEX idx_hash (hash_md5)
);

-- Insertion d'un document avec fichier
START TRANSACTION;

-- 1. Cr√©er le document
INSERT INTO documents (titre, description, categorie, proprietaire_id)
VALUES ('Facture D√©cembre 2025', 'Facture mensuelle', 'facture', 1001);

SET @doc_id = LAST_INSERT_ID();

-- 2. Ajouter le fichier
INSERT INTO documents_fichiers (document_id, nom_fichier, extension, type_mime, taille_octets, contenu_binaire, hash_md5)
VALUES (
    @doc_id,
    'facture_dec_2025.pdf',
    'pdf',
    'application/pdf',
    125000,
    UNHEX('255044462D...'),                     -- Contenu PDF en hex
    UNHEX(MD5('contenu_du_fichier'))           -- Hash pour d√©duplication
);

COMMIT;

-- Requ√™te : Liste des documents avec taille totale
SELECT
    d.document_id,
    d.titre,
    d.categorie,
    COUNT(df.fichier_id) AS nombre_fichiers,
    SUM(df.taille_octets) AS taille_totale_octets,
    ROUND(SUM(df.taille_octets) / 1024 / 1024, 2) AS taille_totale_mb
FROM documents d
LEFT JOIN documents_fichiers df ON d.document_id = df.document_id
GROUP BY d.document_id, d.titre, d.categorie;

-- D√©duplication : Trouver les fichiers identiques
SELECT
    hash_md5,
    COUNT(*) AS nombre_doublons,
    MAX(nom_fichier) AS exemple_fichier,
    SUM(taille_octets) AS espace_total
FROM documents_fichiers
GROUP BY hash_md5
HAVING COUNT(*) > 1;
```

---

## Alternative : Stockage hybride (recommand√©)

### Approche hybride : M√©tadonn√©es en base, fichiers sur filesystem

```sql
-- Table avec chemins de fichiers (pas de BLOB)
CREATE TABLE documents_filesystem (
    document_id INT PRIMARY KEY AUTO_INCREMENT,
    titre VARCHAR(200) NOT NULL,
    nom_fichier VARCHAR(255) NOT NULL,
    chemin_fichier VARCHAR(500) NOT NULL,       -- /storage/documents/2025/12/file.pdf
    url_publique VARCHAR(500),                  -- https://cdn.example.com/docs/file.pdf
    type_mime VARCHAR(100),
    taille_octets BIGINT,
    hash_sha256 BINARY(32),                     -- Pour v√©rification int√©grit√©
    date_creation TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_modification TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_hash (hash_sha256)
);

-- Insertion (fichier stock√© sur filesystem)
INSERT INTO documents_filesystem
(titre, nom_fichier, chemin_fichier, url_publique, type_mime, taille_octets, hash_sha256)
VALUES (
    'Rapport annuel 2025',
    'rapport_2025.pdf',
    '/storage/documents/2025/12/rapport_2025.pdf',
    'https://cdn.example.com/docs/rapport_2025.pdf',
    'application/pdf',
    2500000,
    UNHEX(SHA2('/storage/documents/2025/12/rapport_2025.pdf', 256))
);

-- Avantages :
-- ‚úÖ Base de donn√©es l√©g√®re
-- ‚úÖ Backup s√©par√© (base + filesystem)
-- ‚úÖ Servir via CDN/Nginx directement
-- ‚úÖ Meilleures performances
-- ‚úÖ √âvolutivit√© (S3, MinIO, etc.)
```

### Comparaison : BLOB vs Filesystem

| Crit√®re | BLOB en base | Filesystem + r√©f√©rence |
|---------|--------------|------------------------|
| **Coh√©rence transactionnelle** | ‚úÖ Garantie | ‚ö†Ô∏è √Ä g√©rer manuellement |
| **Performance SELECT** | ‚ùå Lent si gros fichiers | ‚úÖ Rapide |
| **Taille de backup** | ‚ùå Tr√®s volumineux | ‚úÖ S√©par√© |
| **R√©plication** | ‚úÖ Automatique | ‚ö†Ô∏è √Ä g√©rer |
| **Scalabilit√©** | ‚ùå Limit√©e | ‚úÖ Illimit√©e (S3, CDN) |
| **Servir HTTP** | ‚ùå N√©cessite proxy | ‚úÖ Direct (Nginx, CDN) |
| **D√©duplication** | ‚úÖ Facile (hash) | ‚ö†Ô∏è √Ä impl√©menter |
| **Simplicit√©** | ‚úÖ Simple | ‚ö†Ô∏è Plus complexe |

üí° **R√®gle g√©n√©rale** :
- **Fichiers < 100 KB** : BLOB acceptable
- **Fichiers 100 KB - 1 MB** : Cas par cas
- **Fichiers > 1 MB** : Filesystem + r√©f√©rence (recommand√©)

---

## Index sur colonnes BLOB

### Limitation importante

Les colonnes BLOB ne peuvent pas √™tre index√©es directement (comme TEXT) :

```sql
-- ‚ùå ERREUR : Index direct sur BLOB impossible
CREATE TABLE erreur_index_blob (
    id INT PRIMARY KEY,
    fichier BLOB,
    INDEX idx_fichier (fichier)                 -- ERREUR !
);
-- ERROR: BLOB/TEXT column 'fichier' used in key specification without a key length

-- ‚úÖ SOLUTION 1 : Index avec pr√©fixe (comparaison partielle)
CREATE TABLE index_blob_prefixe (
    id INT PRIMARY KEY,
    fichier BLOB,
    INDEX idx_fichier_prefixe (fichier(100))    -- Index sur les 100 premiers octets
);

-- ‚úÖ SOLUTION 2 : Colonne virtuelle avec hash (recommand√©)
CREATE TABLE index_blob_hash (
    id INT PRIMARY KEY,
    fichier BLOB,
    hash_fichier BINARY(32) AS (UNHEX(SHA2(fichier, 256))) STORED,
    INDEX idx_hash (hash_fichier)               -- Index sur le hash
);

-- Recherche par hash
SELECT id FROM index_blob_hash
WHERE hash_fichier = UNHEX(SHA2('contenu_recherche', 256));
```

---

## Fonctions utiles pour donn√©es binaires

### Fonctions de conversion

```sql
-- HEX() et UNHEX()
SELECT
    HEX('Hello') AS texte_vers_hex,             -- 48656C6C6F
    UNHEX('48656C6C6F') AS hex_vers_binaire;    -- Hello

-- BIN() : D√©cimal vers binaire (repr√©sentation)
SELECT
    BIN(10) AS binaire_representation,          -- 1010 (string, pas binary)
    CONV(10, 10, 2) AS conversion_base;         -- 1010

-- LENGTH() et OCTET_LENGTH()
SELECT
    LENGTH(BINARY('Hello')) AS longueur,        -- 5 octets
    BIT_LENGTH(BINARY('Hello')) AS bits;        -- 40 bits
```

### Fonctions de hachage

```sql
-- MD5 : Hash 128 bits (16 octets)
SELECT
    MD5('password') AS md5_hex,                 -- 32 caract√®res hex
    UNHEX(MD5('password')) AS md5_binary,       -- 16 octets
    LENGTH(UNHEX(MD5('password'))) AS taille;   -- 16

-- SHA1 : Hash 160 bits (20 octets)
SELECT
    SHA1('password') AS sha1_hex,               -- 40 caract√®res hex
    UNHEX(SHA1('password')) AS sha1_binary;     -- 20 octets

-- SHA2 : Hash 224/256/384/512 bits
SELECT
    SHA2('password', 256) AS sha256_hex,        -- 64 caract√®res hex
    UNHEX(SHA2('password', 256)) AS sha256_bin, -- 32 octets
    SHA2('password', 512) AS sha512_hex;        -- 128 caract√®res hex (64 octets)
```

### Fonctions de manipulation

```sql
-- SUBSTRING() : Extraction de partie
SELECT
    HEX(SUBSTRING(UNHEX('AABBCCDDEE'), 2, 2)) AS extrait;  -- BBCC

-- CONCAT() : Concat√©nation binaire
SELECT
    HEX(CONCAT(UNHEX('AABB'), UNHEX('CCDD'))) AS concatene;  -- AABBCCDD

-- LEFT(), RIGHT()
SELECT
    HEX(LEFT(UNHEX('AABBCCDD'), 2)) AS gauche,   -- AABB
    HEX(RIGHT(UNHEX('AABBCCDD'), 2)) AS droite;  -- CCDD

-- REVERSE() : Inversion d'octets
SELECT
    HEX(REVERSE(UNHEX('AABBCCDD'))) AS inverse;  -- DDCCBBAA
```

---

## Consid√©rations de performance

### Impact sur la taille de la base

```sql
-- Table de d√©monstration
CREATE TABLE demo_performance_blob (
    id INT PRIMARY KEY AUTO_INCREMENT,
    nom VARCHAR(100),
    petite_image BLOB,                          -- 50 KB moyenne
    grande_image MEDIUMBLOB                     -- 2 MB moyenne
);

-- Ins√©rer 1000 lignes avec images
-- Taille estim√©e : 1000 √ó (50 KB + 2 MB) ‚âà 2 GB

-- Impact sur les op√©rations
-- SELECT * FROM demo_performance_blob LIMIT 10;
-- ‚Üí Charge 10 √ó 2 MB = 20 MB en m√©moire !

-- ‚úÖ MEILLEURE PRATIQUE : S√©lection sans BLOB
SELECT id, nom FROM demo_performance_blob LIMIT 10;
-- ‚Üí Charge seulement quelques KB

-- Charger le BLOB uniquement quand n√©cessaire
SELECT grande_image
FROM demo_performance_blob
WHERE id = 123;
```

### Impact sur les backups

```sql
-- Taille de table avec BLOB
SELECT
    table_name,
    ROUND((data_length + index_length) / 1024 / 1024, 2) AS taille_mb
FROM information_schema.tables
WHERE table_schema = 'ma_base'
  AND table_name = 'avatars_utilisateurs';

-- Exemple de r√©sultat : 3500 MB pour 1000 avatars de 3 MB chacun
-- Backup mysqldump : Tr√®s lent, fichier √©norme
```

### Optimisations

```sql
-- 1. Table s√©par√©e pour BLOB (recommand√©)
CREATE TABLE documents_metadata (
    document_id INT PRIMARY KEY AUTO_INCREMENT,
    titre VARCHAR(200),
    description TEXT,
    taille_octets INT,
    date_creation TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE documents_content (
    document_id INT PRIMARY KEY,
    contenu MEDIUMBLOB,
    FOREIGN KEY (document_id) REFERENCES documents_metadata(document_id)
);

-- 2. Compression des donn√©es binaires
-- Utiliser COMPRESS() / UNCOMPRESS()
CREATE TABLE documents_compressed (
    document_id INT PRIMARY KEY AUTO_INCREMENT,
    nom_fichier VARCHAR(255),
    contenu_compresse MEDIUMBLOB,              -- Donn√©es compress√©es
    taille_originale INT,
    taille_compressee INT
);

INSERT INTO documents_compressed (nom_fichier, contenu_compresse, taille_originale, taille_compressee)
VALUES (
    'rapport.txt',
    COMPRESS('Contenu tr√®s long du rapport... r√©p√©t√© 1000 fois...'),
    50000,
    5000                                        -- Ratio compression 10:1
);

-- D√©compression √† la lecture
SELECT
    nom_fichier,
    UNCOMPRESS(contenu_compresse) AS contenu_original,
    taille_originale,
    taille_compressee,
    ROUND((taille_compressee / taille_originale) * 100, 2) AS taux_compression_pct
FROM documents_compressed;

-- 3. Configuration InnoDB pour BLOB
-- Dans my.cnf :
-- innodb_log_file_size = 512M          # Pour grandes transactions
-- max_allowed_packet = 64M             # Pour insertion gros fichiers
```

---

## Pi√®ges courants √† √©viter

### 1. Charger tous les BLOB dans un SELECT

```sql
-- ‚ùå MAUVAIS : Charge tous les BLOB en m√©moire
SELECT * FROM avatars_utilisateurs LIMIT 100;
-- ‚Üí Charge 100 √ó 3 MB = 300 MB !

-- ‚úÖ BON : S√©lectionner uniquement les m√©tadonn√©es
SELECT avatar_id, utilisateur_id, nom_fichier, taille_octets
FROM avatars_utilisateurs
LIMIT 100;

-- Charger le BLOB uniquement si n√©cessaire
SELECT image_data
FROM avatars_utilisateurs
WHERE avatar_id = 42;
```

### 2. Oublier la limite max_allowed_packet

```sql
-- ‚ùå ERREUR si fichier trop gros
-- ERROR: Got a packet bigger than 'max_allowed_packet' bytes

-- ‚úÖ SOLUTION : Augmenter la limite
-- Dans my.cnf ou au runtime :
SET GLOBAL max_allowed_packet = 67108864;      -- 64 MB
SET SESSION max_allowed_packet = 67108864;

-- V√©rification
SHOW VARIABLES LIKE 'max_allowed_packet';
```

### 3. Ne pas indexer les m√©tadonn√©es

```sql
-- ‚ùå MAUVAIS : Pas d'index
CREATE TABLE documents_lent (
    id INT PRIMARY KEY,
    utilisateur_id INT,                         -- Pas d'index !
    type_mime VARCHAR(100),                     -- Pas d'index !
    fichier MEDIUMBLOB
);

-- Requ√™te lente
SELECT id FROM documents_lent
WHERE utilisateur_id = 1001 AND type_mime = 'application/pdf';

-- ‚úÖ BON : Index sur colonnes de recherche
CREATE TABLE documents_rapide (
    id INT PRIMARY KEY,
    utilisateur_id INT,
    type_mime VARCHAR(100),
    fichier MEDIUMBLOB,
    INDEX idx_utilisateur_type (utilisateur_id, type_mime)
);
```

### 4. Stocker de gros fichiers en base

```sql
-- ‚ùå TR√àS MAUVAIS : Vid√©os en base
CREATE TABLE videos (
    id INT PRIMARY KEY,
    titre VARCHAR(200),
    video_data LONGBLOB                         -- 500 MB - 2 GB par vid√©o !
);

-- Impact :
-- - Base de donn√©es √©norme
-- - Backup extr√™mement lent
-- - Performances catastrophiques
-- - Impossible de streamer efficacement

-- ‚úÖ BON : R√©f√©rences seulement
CREATE TABLE videos_references (
    id INT PRIMARY KEY,
    titre VARCHAR(200),
    fichier_path VARCHAR(500),                  -- /videos/2025/video_123.mp4
    url_cdn VARCHAR(500),                       -- https://cdn.example.com/videos/123.mp4
    taille_octets BIGINT,
    duree_secondes INT
);
```

### 5. Comparer des BLOB sans hash

```sql
-- ‚ùå LENT : Comparaison directe de gros BLOB
SELECT COUNT(*) FROM documents_fichiers df1
JOIN documents_fichiers df2
  ON df1.contenu_binaire = df2.contenu_binaire          -- Tr√®s lent !
WHERE df1.fichier_id < df2.fichier_id;

-- ‚úÖ RAPIDE : Comparaison via hash
SELECT COUNT(*) FROM documents_fichiers df1
JOIN documents_fichiers df2
  ON df1.hash_md5 = df2.hash_md5                        -- Index utilis√©
WHERE df1.fichier_id < df2.fichier_id;
```

---

## ‚úÖ Points cl√©s √† retenir

- **BINARY(M)** : Longueur fixe, hash, signatures (0-255 octets)
- **VARBINARY(M)** : Longueur variable, petits fichiers (0-64 KB)
- **BLOB** : Objets binaires, 4 tailles (TINY, BLOB, MEDIUM, LONG)
- **Comparaison** : Binaire (byte-by-byte), pas de charset/collation
- **Index** : Impossible direct, utiliser hash ou pr√©fixe
- **Performance** : Ne pas charger BLOB inutilement (SELECT colonnes sp√©cifiques)
- **Recommandation** : Fichiers > 1 MB ‚Üí Filesystem + r√©f√©rence
- **Alternative** : Table s√©par√©e pour BLOB (optimisation)
- **Hash** : MD5 (16 octets), SHA-256 (32 octets) pour d√©duplication
- **max_allowed_packet** : Limite √† configurer pour gros fichiers

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB
- [üìñ Binary Data Types](https://mariadb.com/kb/en/binary/)
- [üìñ BINARY and VARBINARY](https://mariadb.com/kb/en/binary/)
- [üìñ BLOB and TEXT Types](https://mariadb.com/kb/en/blob/)
- [üìñ LOAD_FILE()](https://mariadb.com/kb/en/load_file/)
- [üìñ HEX() and UNHEX()](https://mariadb.com/kb/en/hex/)
- [üìñ Encryption and Compression Functions](https://mariadb.com/kb/en/encryption-hashing-and-compression-functions/)

### Bonnes pratiques
- [Binary Large Objects Best Practices](https://use-the-index-luke.com/)
- [Why you should not store files in database](https://stackoverflow.com/questions/3748/storing-images-in-db-yea-or-nay)

---

## ‚û°Ô∏è Section suivante

**[2.2.5 Types sp√©cifiques MariaDB (JSON, UUID, INET6)](/02-bases-du-sql/02.5-types-specifiques-mariadb.md)**

D√©couvrez les types de donn√©es modernes et sp√©cifiques √† MariaDB : **JSON** pour donn√©es semi-structur√©es, **UUID** pour identifiants uniques universels, **INET6** pour adresses IPv6, et une introduction au nouveau type **VECTOR** üÜï pour l'intelligence artificielle et le machine learning.

---


‚è≠Ô∏è [Sp√©cifiques MariaDB (JSON, UUID, INET6)](/02-bases-du-sql/02.5-types-specifiques-mariadb.md)
