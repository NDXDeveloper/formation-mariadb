üîù Retour au [Sommaire](/SOMMAIRE.md)

# 2.2.5 Types sp√©cifiques MariaDB (JSON, UUID, INET6)

> **Niveau** : D√©butant
> **Dur√©e estim√©e** : 1.5 heures
> **Pr√©requis** : Section 2.2.4 (Types binaires)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Stocker et manipuler des donn√©es JSON dans MariaDB
- Utiliser le type UUID pour des identifiants uniques universels
- G√©rer des adresses IPv6 avec le type INET6
- Comprendre l'utilit√© du nouveau type VECTOR pour l'IA
- Choisir le type appropri√© selon vos besoins
- √âviter les pi√®ges courants avec ces types modernes

---

## Introduction

MariaDB propose des **types de donn√©es sp√©cifiques** qui r√©pondent √† des besoins modernes :

- **JSON** : Donn√©es semi-structur√©es, APIs REST, documents flexibles
- **UUID** : Identifiants uniques universels pour syst√®mes distribu√©s
- **INET6** : Adresses IPv4 et IPv6 optimis√©es
- **VECTOR** üÜï : Embeddings pour intelligence artificielle (ML/IA)

Ces types permettent de g√©rer efficacement des cas d'usage qui n√©cessitaient auparavant des solutions complexes.

üÜï **MariaDB 11.8** : Introduction du type **VECTOR** pour le stockage d'embeddings et la recherche vectorielle, permettant l'int√©gration native d'applications IA/ML avec MariaDB.

---

## JSON - Donn√©es semi-structur√©es

### Qu'est-ce que JSON ?

**JSON (JavaScript Object Notation)** est un format de donn√©es textuelles structur√©, largement utilis√© pour :
- APIs REST et microservices
- Donn√©es flexibles (sch√©ma variable)
- Configuration d'applications
- Logs structur√©s
- Donn√©es provenant de sources externes

```json
{
  "nom": "Dupont",
  "prenom": "Marie",
  "age": 32,
  "adresse": {
    "rue": "123 rue de la Paix",
    "ville": "Paris",
    "code_postal": "75001"
  },
  "hobbies": ["lecture", "voyages", "photographie"]
}
```

### Type JSON dans MariaDB

MariaDB stocke JSON comme **LONGTEXT** avec validation de syntaxe :

```sql
-- Cr√©ation d'une table avec colonne JSON
CREATE TABLE utilisateurs_json (
    utilisateur_id INT PRIMARY KEY AUTO_INCREMENT,
    nom VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,

    -- Colonne JSON pour donn√©es flexibles
    profil JSON,                                -- Informations variables
    preferences JSON,                           -- Pr√©f√©rences utilisateur
    metadata JSON,                              -- M√©tadonn√©es diverses

    date_creation TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_email (email)
);

-- Insertion avec donn√©es JSON
INSERT INTO utilisateurs_json (nom, email, profil, preferences) VALUES
    (
        'Alice Dupont',
        'alice@example.com',
        JSON_OBJECT(
            'age', 32,
            'ville', 'Paris',
            'profession', 'D√©veloppeuse',
            'bio', 'Passionn√©e de technologie'
        ),
        JSON_OBJECT(
            'theme', 'dark',
            'langue', 'fr',
            'notifications', TRUE
        )
    );

-- Insertion avec syntaxe JSON directe
INSERT INTO utilisateurs_json (nom, email, profil, preferences) VALUES
    (
        'Bob Martin',
        'bob@example.com',
        '{"age": 28, "ville": "Lyon", "profession": "Designer"}',
        '{"theme": "light", "langue": "fr", "notifications": false}'
    );

-- Consultation
SELECT
    nom,
    profil,
    preferences
FROM utilisateurs_json;
```

### Validation JSON

MariaDB valide automatiquement la syntaxe JSON :

```sql
-- ‚úÖ JSON valide - OK
INSERT INTO utilisateurs_json (nom, email, profil) VALUES
    ('Charlie', 'charlie@example.com', '{"age": 25, "ville": "Marseille"}');

-- ‚ùå JSON invalide - ERREUR
INSERT INTO utilisateurs_json (nom, email, profil) VALUES
    ('David', 'david@example.com', '{age: 25, ville: "Nice"}');
-- ERROR: Invalid JSON text in argument 1 to function json_valid

-- V√©rification manuelle avec JSON_VALID()
SELECT
    '{"valid": "json"}' AS test1,
    JSON_VALID('{"valid": "json"}') AS est_valide1,

    '{invalid: json}' AS test2,
    JSON_VALID('{invalid: json}') AS est_valide2;
```

---

## Fonctions JSON essentielles

### Cr√©ation de JSON

```sql
-- JSON_OBJECT : Cr√©er un objet JSON
SELECT JSON_OBJECT(
    'nom', 'Dupont',
    'prenom', 'Marie',
    'age', 32
) AS objet_json;
-- R√©sultat : {"nom": "Dupont", "prenom": "Marie", "age": 32}

-- JSON_ARRAY : Cr√©er un tableau JSON
SELECT JSON_ARRAY('rouge', 'vert', 'bleu', 123, TRUE) AS tableau_json;
-- R√©sultat : ["rouge", "vert", "bleu", 123, true]

-- JSON_MERGE : Fusionner des objets JSON
SELECT JSON_MERGE(
    '{"nom": "Dupont"}',
    '{"prenom": "Marie"}',
    '{"age": 32}'
) AS fusion;
-- R√©sultat : {"nom": "Dupont", "prenom": "Marie", "age": 32}
```

### Extraction de donn√©es JSON

```sql
-- JSON_EXTRACT : Extraire une valeur (syntaxe JSONPath)
SELECT
    nom,
    profil,
    JSON_EXTRACT(profil, '$.age') AS age,
    JSON_EXTRACT(profil, '$.ville') AS ville,
    JSON_EXTRACT(profil, '$.profession') AS profession
FROM utilisateurs_json;

-- Op√©rateur raccourci -> (alias de JSON_EXTRACT)
SELECT
    nom,
    profil->>'$.age' AS age,                    -- -> retourne JSON
    profil->>'$.ville' AS ville,                -- ->> retourne TEXT
    profil->>'$.profession' AS profession
FROM utilisateurs_json;

-- Extraction de tableaux
SELECT JSON_EXTRACT('["rouge", "vert", "bleu"]', '$[0]') AS premier;      -- "rouge"
SELECT JSON_EXTRACT('["rouge", "vert", "bleu"]', '$[1]') AS deuxieme;     -- "vert"
SELECT JSON_EXTRACT('["rouge", "vert", "bleu"]', '$[*]') AS tous;         -- Tous

-- Extraction imbriqu√©e
SELECT JSON_EXTRACT(
    '{"utilisateur": {"nom": "Dupont", "adresse": {"ville": "Paris"}}}',
    '$.utilisateur.adresse.ville'
) AS ville;  -- "Paris"
```

### Modification de JSON

```sql
-- JSON_SET : D√©finir/modifier une valeur
UPDATE utilisateurs_json
SET profil = JSON_SET(
    profil,
    '$.age', 33,                                -- Modifier l'√¢ge
    '$.telephone', '0123456789'                 -- Ajouter t√©l√©phone
)
WHERE nom = 'Alice Dupont';

-- JSON_INSERT : Ajouter si n'existe pas (ne modifie pas si existe)
UPDATE utilisateurs_json
SET profil = JSON_INSERT(
    profil,
    '$.avatar', 'default.png',                  -- Ajoute si absent
    '$.age', 99                                 -- N'ajoute PAS (existe d√©j√†)
)
WHERE nom = 'Alice Dupont';

-- JSON_REPLACE : Modifier seulement si existe
UPDATE utilisateurs_json
SET profil = JSON_REPLACE(
    profil,
    '$.age', 34,                                -- Modifie (existe)
    '$.nouveau', 'valeur'                       -- N'ajoute PAS (n'existe pas)
)
WHERE nom = 'Alice Dupont';

-- JSON_REMOVE : Supprimer une cl√©
UPDATE utilisateurs_json
SET profil = JSON_REMOVE(profil, '$.telephone')
WHERE nom = 'Alice Dupont';

-- JSON_ARRAY_APPEND : Ajouter dans un tableau
UPDATE utilisateurs_json
SET metadata = JSON_ARRAY_APPEND(
    COALESCE(metadata, '{"tags": []}'),
    '$.tags', 'nouveau_tag'
)
WHERE nom = 'Alice Dupont';
```

### Recherche dans JSON

```sql
-- Recherche par valeur JSON
SELECT * FROM utilisateurs_json
WHERE JSON_EXTRACT(profil, '$.ville') = 'Paris';

-- Avec op√©rateur ->
SELECT * FROM utilisateurs_json
WHERE profil->>'$.ville' = 'Paris';

-- JSON_CONTAINS : V√©rifier si contient une valeur
SELECT * FROM utilisateurs_json
WHERE JSON_CONTAINS(profil, '"Paris"', '$.ville');

-- JSON_SEARCH : Chercher une valeur dans tout le JSON
SELECT
    nom,
    JSON_SEARCH(profil, 'one', 'Paris') AS chemin
FROM utilisateurs_json;
-- Retourne le chemin JSONPath : "$.ville"

-- Requ√™te avec LIKE sur JSON
SELECT * FROM utilisateurs_json
WHERE profil LIKE '%Paris%';                    -- Fonctionne mais lent

-- JSON_CONTAINS_PATH : V√©rifier si un chemin existe
SELECT * FROM utilisateurs_json
WHERE JSON_CONTAINS_PATH(profil, 'one', '$.telephone');
```

---

## Indexation de colonnes JSON

### Probl√®me : Pas d'index direct sur JSON

```sql
-- ‚ùå Impossible d'indexer directement une colonne JSON
CREATE TABLE test_index_json (
    id INT PRIMARY KEY,
    data JSON,
    INDEX idx_data (data)                       -- ERREUR !
);
-- ERROR: JSON column 'data' cannot be used in key specification
```

### Solution 1 : Colonnes virtuelles (recommand√©)

```sql
-- ‚úÖ Cr√©er des colonnes virtuelles extraites du JSON
CREATE TABLE utilisateurs_json_indexed (
    utilisateur_id INT PRIMARY KEY AUTO_INCREMENT,
    nom VARCHAR(100) NOT NULL,
    profil JSON,

    -- Colonnes virtuelles pour indexation
    ville_virtuelle VARCHAR(100) AS (profil->>'$.ville') VIRTUAL,
    age_virtuel INT AS (profil->>'$.age') VIRTUAL,

    -- Index sur colonnes virtuelles
    INDEX idx_ville (ville_virtuelle),
    INDEX idx_age (age_virtuel)
);

-- Insertion
INSERT INTO utilisateurs_json_indexed (nom, profil) VALUES
    ('Alice', '{"age": 32, "ville": "Paris"}'),
    ('Bob', '{"age": 28, "ville": "Lyon"}');

-- Requ√™te : L'index est utilis√© !
EXPLAIN SELECT * FROM utilisateurs_json_indexed
WHERE ville_virtuelle = 'Paris';
-- Utilise idx_ville
```

### Solution 2 : Colonnes STORED

```sql
-- Colonnes STORED (valeur calcul√©e stock√©e physiquement)
CREATE TABLE produits_json (
    produit_id INT PRIMARY KEY AUTO_INCREMENT,
    nom VARCHAR(200),
    details JSON,

    -- Colonnes STORED pour performances
    prix DECIMAL(10,2) AS (details->>'$.prix') STORED,
    categorie VARCHAR(50) AS (details->>'$.categorie') STORED,
    en_stock BOOLEAN AS (CAST(details->>'$.stock' AS UNSIGNED) > 0) STORED,

    INDEX idx_prix (prix),
    INDEX idx_categorie (categorie),
    INDEX idx_stock (en_stock)
);

-- Diff√©rence VIRTUAL vs STORED :
-- VIRTUAL : Calcul√© √† chaque lecture (pas d'espace disque)
-- STORED : Calcul√© une fois, stock√© (utilise espace disque, plus rapide)
```

---

## Exemples pratiques avec JSON

### Exemple 1 : Syst√®me de param√®tres utilisateur

```sql
-- Table de pr√©f√©rences utilisateur
CREATE TABLE user_preferences (
    user_id INT PRIMARY KEY,
    settings JSON NOT NULL DEFAULT '{}',
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Initialisation avec param√®tres par d√©faut
INSERT INTO user_preferences (user_id, settings) VALUES
    (1001, JSON_OBJECT(
        'theme', 'light',
        'langue', 'fr',
        'notifications', JSON_OBJECT(
            'email', TRUE,
            'push', TRUE,
            'sms', FALSE
        ),
        'display', JSON_OBJECT(
            'items_per_page', 20,
            'show_avatars', TRUE
        )
    ));

-- Modifier un param√®tre sp√©cifique
UPDATE user_preferences
SET settings = JSON_SET(settings, '$.theme', 'dark')
WHERE user_id = 1001;

-- Modifier une notification imbriqu√©e
UPDATE user_preferences
SET settings = JSON_SET(settings, '$.notifications.email', FALSE)
WHERE user_id = 1001;

-- R√©cup√©rer tous les param√®tres
SELECT
    user_id,
    settings->>'$.theme' AS theme,
    settings->>'$.langue' AS langue,
    settings->>'$.notifications.email' AS notif_email,
    settings->>'$.display.items_per_page' AS items_par_page
FROM user_preferences
WHERE user_id = 1001;
```

### Exemple 2 : Catalogue de produits flexible

```sql
-- Produits avec attributs variables selon cat√©gorie
CREATE TABLE catalogue_produits (
    produit_id INT PRIMARY KEY AUTO_INCREMENT,
    nom VARCHAR(200) NOT NULL,
    categorie VARCHAR(50) NOT NULL,
    prix DECIMAL(10,2) NOT NULL,

    -- JSON pour attributs sp√©cifiques √† la cat√©gorie
    attributs JSON,

    -- Colonnes virtuelles pour recherche
    marque VARCHAR(100) AS (attributs->>'$.marque') VIRTUAL,

    date_ajout TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_categorie (categorie),
    INDEX idx_marque (marque)
);

-- Produit √©lectronique
INSERT INTO catalogue_produits (nom, categorie, prix, attributs) VALUES
    (
        'Smartphone XYZ',
        'Electronique',
        599.99,
        JSON_OBJECT(
            'marque', 'TechBrand',
            'modele', 'XYZ-2025',
            'couleurs', JSON_ARRAY('noir', 'blanc', 'bleu'),
            'specs', JSON_OBJECT(
                'ecran', '6.5 pouces',
                'ram', '8 GB',
                'stockage', '256 GB',
                'batterie', '5000 mAh'
            )
        )
    );

-- V√™tement (attributs diff√©rents)
INSERT INTO catalogue_produits (nom, categorie, prix, attributs) VALUES
    (
        'T-Shirt Premium',
        'Vetements',
        29.99,
        JSON_OBJECT(
            'marque', 'FashionCo',
            'tailles', JSON_ARRAY('S', 'M', 'L', 'XL'),
            'couleurs', JSON_ARRAY('noir', 'blanc', 'rouge'),
            'matiere', '100% coton bio',
            'entretien', JSON_ARRAY('Lavage 30¬∞', 'Pas de s√®che-linge')
        )
    );

-- Recherche multicrit√®res
SELECT
    nom,
    categorie,
    prix,
    attributs->>'$.marque' AS marque,
    attributs
FROM catalogue_produits
WHERE categorie = 'Electronique'
  AND JSON_CONTAINS(attributs->>'$.specs', '"8 GB"', '$.ram');

-- Recherche par disponibilit√© de couleur
SELECT nom, prix
FROM catalogue_produits
WHERE JSON_CONTAINS(attributs, '"noir"', '$.couleurs');
```

### Exemple 3 : Logs d'√©v√©nements

```sql
-- Logs avec contexte JSON
CREATE TABLE event_logs (
    log_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    event_type VARCHAR(50) NOT NULL,
    user_id INT,
    event_data JSON NOT NULL,
    timestamp_log TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6),

    -- Colonnes virtuelles pour filtrage rapide
    ip_address VARCHAR(45) AS (event_data->>'$.ip') VIRTUAL,
    user_agent VARCHAR(255) AS (event_data->>'$.user_agent') VIRTUAL,

    INDEX idx_event_type (event_type),
    INDEX idx_user (user_id),
    INDEX idx_timestamp (timestamp_log),
    INDEX idx_ip (ip_address)
);

-- Log de connexion
INSERT INTO event_logs (event_type, user_id, event_data) VALUES
    (
        'user_login',
        1001,
        JSON_OBJECT(
            'ip', '192.168.1.100',
            'user_agent', 'Mozilla/5.0...',
            'success', TRUE,
            'method', '2FA',
            'location', JSON_OBJECT('country', 'FR', 'city', 'Paris')
        )
    );

-- Log d'erreur
INSERT INTO event_logs (event_type, user_id, event_data) VALUES
    (
        'api_error',
        1002,
        JSON_OBJECT(
            'endpoint', '/api/v1/users',
            'method', 'POST',
            'status_code', 500,
            'error_message', 'Database connection failed',
            'stack_trace', 'Error at line 42...'
        )
    );

-- Analyse des logs
SELECT
    event_type,
    COUNT(*) AS nombre_events,
    COUNT(DISTINCT user_id) AS utilisateurs_uniques
FROM event_logs
WHERE timestamp_log >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
GROUP BY event_type
ORDER BY nombre_events DESC;

-- Recherche d'erreurs sp√©cifiques
SELECT
    log_id,
    event_type,
    event_data->>'$.endpoint' AS endpoint,
    event_data->>'$.status_code' AS code,
    event_data->>'$.error_message' AS erreur,
    timestamp_log
FROM event_logs
WHERE event_type = 'api_error'
  AND CAST(event_data->>'$.status_code' AS UNSIGNED) >= 500
ORDER BY timestamp_log DESC
LIMIT 10;
```

---

## UUID - Identifiants uniques universels

### Qu'est-ce qu'un UUID ?

**UUID (Universally Unique IDentifier)** est un identifiant de 128 bits garanti unique :

```
Format standard : 550e8400-e29b-41d4-a716-446655440000
                  8-4-4-4-12 caract√®res hexad√©cimaux
```

**Avantages** :
- ‚úÖ Uniques globalement (pas de collision)
- ‚úÖ G√©n√©rables c√¥t√© client (pas besoin d'AUTO_INCREMENT)
- ‚úÖ Id√©al pour syst√®mes distribu√©s
- ‚úÖ Pas de s√©quence pr√©visible (s√©curit√©)

**Inconv√©nients** :
- ‚ùå Plus volumineux (36 caract√®res vs INT 4 octets)
- ‚ùå Moins performant pour les index
- ‚ùå Pas d'ordre naturel (sauf UUID v7)

### Stockage UUID dans MariaDB

```sql
-- Option 1 : CHAR(36) - Format texte standard
CREATE TABLE sessions_uuid_char (
    session_id CHAR(36) PRIMARY KEY,            -- UUID format texte
    user_id INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP
);

-- G√©n√©ration UUID avec UUID()
INSERT INTO sessions_uuid_char (session_id, user_id, expires_at) VALUES
    (UUID(), 1001, DATE_ADD(NOW(), INTERVAL 1 HOUR)),
    (UUID(), 1002, DATE_ADD(NOW(), INTERVAL 1 HOUR));

SELECT * FROM sessions_uuid_char;
-- session_id: 550e8400-e29b-41d4-a716-446655440000

-- Option 2 : BINARY(16) - Format binaire optimis√©
CREATE TABLE sessions_uuid_binary (
    session_id BINARY(16) PRIMARY KEY,          -- UUID format binaire
    user_id INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Conversion texte ‚Üî binaire avec UUID_TO_BIN() et BIN_TO_UUID()
INSERT INTO sessions_uuid_binary (session_id, user_id) VALUES
    (UUID_TO_BIN(UUID()), 1001),
    (UUID_TO_BIN(UUID()), 1002);

-- Lecture avec conversion
SELECT
    BIN_TO_UUID(session_id) AS session_id_readable,
    user_id,
    created_at
FROM sessions_uuid_binary;
```

### Comparaison CHAR(36) vs BINARY(16)

```sql
-- D√©monstration des diff√©rences
CREATE TABLE demo_uuid_storage (
    id INT PRIMARY KEY AUTO_INCREMENT,
    uuid_text CHAR(36),                         -- 36 octets
    uuid_binary BINARY(16)                      -- 16 octets
);

INSERT INTO demo_uuid_storage (uuid_text, uuid_binary) VALUES
    (UUID(), UUID_TO_BIN(UUID()));

SELECT
    uuid_text,
    LENGTH(uuid_text) AS taille_text,           -- 36 octets
    HEX(uuid_binary) AS uuid_binary_hex,
    LENGTH(uuid_binary) AS taille_binary,       -- 16 octets
    BIN_TO_UUID(uuid_binary) AS uuid_binary_readable
FROM demo_uuid_storage;

-- R√©sultat :
-- taille_text: 36 octets
-- taille_binary: 16 octets
-- √âconomie : 55% d'espace
```

üí° **Recommandation** :
- **BINARY(16)** : Meilleure performance, moins d'espace (recommand√©)
- **CHAR(36)** : Lisible humainement, compatible avec syst√®mes externes

### UUID versions

```sql
-- MariaDB g√©n√®re des UUID v1 par d√©faut
SELECT UUID() AS uuid_v1;
-- Bas√© sur timestamp + adresse MAC

-- UUID v4 (al√©atoire) avec SYS_GUID() - non disponible natif
-- Utiliser application c√¥t√© client pour v4/v7

-- Comparaison avec AUTO_INCREMENT
CREATE TABLE demo_id_comparison (
    -- AUTO_INCREMENT : 4 octets, s√©quentiel
    id_auto INT PRIMARY KEY AUTO_INCREMENT,

    -- UUID binaire : 16 octets, non s√©quentiel
    id_uuid BINARY(16) UNIQUE DEFAULT (UUID_TO_BIN(UUID())),

    nom VARCHAR(100)
);

-- Performance des index
-- AUTO_INCREMENT : Insertion s√©quentielle (tr√®s rapide)
-- UUID : Insertion al√©atoire (fragmentation, plus lent)
```

---

## INET6 - Adresses IPv4 et IPv6

### Qu'est-ce qu'INET6 ?

**INET6** est un type optimis√© pour stocker des adresses IP :
- IPv4 : 4 octets (ex: 192.168.1.1)
- IPv6 : 16 octets (ex: 2001:0db8:85a3::8a2e:0370:7334)

Stock√© en **VARBINARY(16)** avec fonctions de conversion.

```sql
-- Cr√©ation d'une table avec INET6
CREATE TABLE connexions_ip (
    connexion_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    ip_address INET6 NOT NULL,                  -- Type INET6
    user_agent VARCHAR(255),
    connexion_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_ip (ip_address),
    INDEX idx_user (user_id)
);

-- Insertion avec adresses IPv4
INSERT INTO connexions_ip (user_id, ip_address, user_agent) VALUES
    (1001, INET6_ATON('192.168.1.100'), 'Mozilla/5.0...'),
    (1002, INET6_ATON('10.0.0.50'), 'Chrome/120.0...');

-- Insertion avec adresses IPv6
INSERT INTO connexions_ip (user_id, ip_address, user_agent) VALUES
    (1003, INET6_ATON('2001:0db8:85a3::8a2e:0370:7334'), 'Safari/17.0...'),
    (1004, INET6_ATON('::1'), 'Firefox/121.0...');  -- IPv6 localhost

-- Lecture avec conversion
SELECT
    connexion_id,
    user_id,
    INET6_NTOA(ip_address) AS ip_readable,
    user_agent,
    connexion_timestamp
FROM connexions_ip;
```

### Fonctions INET6

```sql
-- INET6_ATON : Texte ‚Üí Binaire
SELECT
    INET6_ATON('192.168.1.1') AS ipv4_binary,
    HEX(INET6_ATON('192.168.1.1')) AS ipv4_hex,
    INET6_ATON('2001:db8::1') AS ipv6_binary;

-- INET6_NTOA : Binaire ‚Üí Texte
SELECT
    INET6_NTOA(INET6_ATON('192.168.1.1')) AS ipv4_text,
    INET6_NTOA(INET6_ATON('2001:db8::1')) AS ipv6_text;

-- IS_IPV4, IS_IPV6 : V√©rification
SELECT
    IS_IPV4('192.168.1.1') AS est_ipv4,         -- 1 (TRUE)
    IS_IPV6('192.168.1.1') AS est_ipv6,         -- 0 (FALSE)
    IS_IPV4('2001:db8::1') AS est_ipv4_v6,      -- 0
    IS_IPV6('2001:db8::1') AS est_ipv6_v6;      -- 1

-- IS_IPV4_COMPAT, IS_IPV4_MAPPED
SELECT
    IS_IPV4_COMPAT(INET6_ATON('::192.168.1.1')) AS compat,
    IS_IPV4_MAPPED(INET6_ATON('::ffff:192.168.1.1')) AS mapped;
```

### Comparaison avec VARCHAR

```sql
-- INET6 vs VARCHAR pour stockage d'IP
CREATE TABLE demo_ip_storage (
    id INT PRIMARY KEY AUTO_INCREMENT,

    -- Stockage texte : 39 octets max (IPv6)
    ip_varchar VARCHAR(45),

    -- Stockage INET6 : 16 octets max (optimis√©)
    ip_inet6 INET6
);

INSERT INTO demo_ip_storage (ip_varchar, ip_inet6) VALUES
    ('192.168.1.1', INET6_ATON('192.168.1.1')),
    ('2001:db8::1', INET6_ATON('2001:db8::1'));

SELECT
    ip_varchar,
    LENGTH(ip_varchar) AS taille_varchar,
    INET6_NTOA(ip_inet6) AS ip_inet6_readable,
    LENGTH(ip_inet6) AS taille_inet6
FROM demo_ip_storage;

-- Avantages INET6 :
-- ‚úÖ Validation automatique
-- ‚úÖ Stockage optimis√© (4 ou 16 octets vs 45)
-- ‚úÖ Comparaisons plus rapides
-- ‚úÖ Index plus petits
```

### Exemple : Analyse de logs r√©seau

```sql
-- Table de logs avec analyse d'IP
CREATE TABLE network_logs (
    log_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    ip_source INET6 NOT NULL,
    ip_destination INET6 NOT NULL,
    port_source SMALLINT UNSIGNED,
    port_destination SMALLINT UNSIGNED,
    protocole ENUM('TCP', 'UDP', 'ICMP'),
    octets_transferes BIGINT UNSIGNED,
    timestamp_log TIMESTAMP(3) DEFAULT CURRENT_TIMESTAMP(3),
    INDEX idx_ip_source (ip_source),
    INDEX idx_timestamp (timestamp_log)
);

-- Insertion de logs
INSERT INTO network_logs
(ip_source, ip_destination, port_source, port_destination, protocole, octets_transferes)
VALUES
    (INET6_ATON('192.168.1.100'), INET6_ATON('8.8.8.8'), 54321, 53, 'UDP', 512),
    (INET6_ATON('2001:db8::1'), INET6_ATON('2001:db8::2'), 443, 8080, 'TCP', 15000);

-- Analyse : Top 10 IP sources par trafic
SELECT
    INET6_NTOA(ip_source) AS ip_source,
    COUNT(*) AS nombre_connexions,
    SUM(octets_transferes) AS total_octets,
    ROUND(SUM(octets_transferes) / 1024 / 1024, 2) AS total_mb
FROM network_logs
WHERE timestamp_log >= DATE_SUB(NOW(), INTERVAL 1 HOUR)
GROUP BY ip_source
ORDER BY total_octets DESC
LIMIT 10;

-- Filtrage par plage d'IP (n√©cessite conversion)
SELECT
    INET6_NTOA(ip_source) AS ip,
    COUNT(*) AS connexions
FROM network_logs
WHERE ip_source >= INET6_ATON('192.168.1.0')
  AND ip_source <= INET6_ATON('192.168.1.255')
GROUP BY ip_source;
```

---

## VECTOR - Embeddings pour IA (Introduction)

üÜï **MariaDB 11.8** : Nouveau type **VECTOR** pour l'intelligence artificielle et le machine learning.

### Qu'est-ce qu'un VECTOR ?

Un **VECTOR** est un tableau de nombres flottants (embeddings) utilis√© en IA pour :
- Recherche s√©mantique
- Similarit√© de documents
- Recommandations
- Classification ML
- RAG (Retrieval Augmented Generation)

```sql
-- Exemple simple de VECTOR (aper√ßu)
CREATE TABLE documents_embeddings (
    doc_id INT PRIMARY KEY AUTO_INCREMENT,
    titre VARCHAR(200),
    contenu TEXT,

    -- VECTOR pour recherche s√©mantique
    embedding VECTOR(1536),                     -- 1536 dimensions (OpenAI)

    date_creation TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Note : Syntaxe simplifi√©e pour introduction
-- D√©tails complets dans le chapitre 18.10
```

üí° **√Ä retenir** :
- Type VECTOR nouveau dans MariaDB 11.8
- Permet la recherche vectorielle native
- Index HNSW pour performances
- **Voir section 18.10** pour d√©tails complets sur MariaDB Vector

---

## Choix du type appropri√©

### Arbre de d√©cision

```
Quel type de donn√©es devez-vous stocker ?

‚îú‚îÄ Donn√©es structur√©es variables ?
‚îÇ   ‚îî‚îÄ JSON (flexible, semi-structur√©)
‚îÇ
‚îú‚îÄ Identifiant unique universel ?
‚îÇ   ‚îú‚îÄ Syst√®me distribu√© ‚Üí UUID (BINARY(16))
‚îÇ   ‚îî‚îÄ Syst√®me centralis√© ‚Üí AUTO_INCREMENT (INT)
‚îÇ
‚îú‚îÄ Adresse IP ?
‚îÇ   ‚îî‚îÄ INET6 (IPv4 + IPv6 optimis√©)
‚îÇ
‚îî‚îÄ Embeddings ML/IA ?
    ‚îî‚îÄ VECTOR (recherche s√©mantique) üÜï
```

### Tableau comparatif

| Type | Taille | Cas d'usage | Performance index |
|------|--------|-------------|-------------------|
| **JSON** | Variable | Donn√©es flexibles, APIs | ‚ö†Ô∏è Via colonnes virtuelles |
| **UUID (CHAR)** | 36 octets | ID distribu√©s (lisible) | ‚ùå Lent (random) |
| **UUID (BINARY)** | 16 octets | ID distribu√©s (optimal) | ‚ö†Ô∏è Moyen (random) |
| **INET6** | 4-16 octets | Adresses IP | ‚úÖ Bon |
| **VECTOR** | Variable | Embeddings IA | ‚úÖ HNSW index |

---

## Pi√®ges courants √† √©viter

### 1. Recherche dans JSON sans index

```sql
-- ‚ùå LENT : Recherche dans JSON sans index
SELECT * FROM utilisateurs_json
WHERE profil->>'$.ville' = 'Paris';
-- Scan complet de table !

-- ‚úÖ RAPIDE : Colonne virtuelle index√©e
ALTER TABLE utilisateurs_json
ADD COLUMN ville VARCHAR(100) AS (profil->>'$.ville') VIRTUAL,
ADD INDEX idx_ville (ville);

SELECT * FROM utilisateurs_json
WHERE ville = 'Paris';
-- Utilise l'index !
```

### 2. UUID comme cl√© primaire sans optimisation

```sql
-- ‚ùå PROBL√àME : UUID al√©atoire = fragmentation index
CREATE TABLE orders_uuid_bad (
    order_id CHAR(36) PRIMARY KEY DEFAULT (UUID()),
    -- Insertions al√©atoires dans l'index B-tree
);

-- ‚úÖ MEILLEUR : UUID binaire + √©ventuellement s√©quentiel
CREATE TABLE orders_uuid_better (
    order_id BINARY(16) PRIMARY KEY DEFAULT (UUID_TO_BIN(UUID())),
    -- Plus compact, moins de fragmentation
);

-- ‚úÖ OPTIMAL : AUTO_INCREMENT si pas de distribution
CREATE TABLE orders_optimal (
    order_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    -- Insertions s√©quentielles (tr√®s rapide)
);
```

### 3. Stocker IP en VARCHAR

```sql
-- ‚ùå MAUVAIS : IP en VARCHAR
CREATE TABLE logs_bad (
    ip VARCHAR(45)                              -- 45 octets, pas de validation
);

INSERT INTO logs_bad VALUES ('192.168.1.1');
INSERT INTO logs_bad VALUES ('invalid_ip');     -- Accept√© !

-- ‚úÖ BON : IP avec INET6
CREATE TABLE logs_good (
    ip INET6                                    -- 4-16 octets, validation auto
);

INSERT INTO logs_good VALUES (INET6_ATON('192.168.1.1'));
INSERT INTO logs_good VALUES (INET6_ATON('invalid_ip'));    -- ERREUR
```

### 4. JSON trop volumineux

```sql
-- ‚ùå PROBL√àME : Stocker gros objets en JSON
CREATE TABLE documents_bad (
    doc_id INT PRIMARY KEY,
    contenu_complet JSON                        -- 10 MB de JSON !
);

-- Impact : SELECT lent, m√©moire, backup

-- ‚úÖ SOLUTION : S√©parer donn√©es fr√©quentes et rares
CREATE TABLE documents_good (
    doc_id INT PRIMARY KEY,
    titre VARCHAR(200),
    auteur VARCHAR(100),

    -- JSON seulement pour m√©tadonn√©es l√©g√®res
    metadata JSON,                              -- < 10 KB

    -- Contenu dans table s√©par√©e
    INDEX idx_titre (titre)
);

CREATE TABLE documents_content (
    doc_id INT PRIMARY KEY,
    contenu_complet MEDIUMTEXT,                 -- Table s√©par√©e
    FOREIGN KEY (doc_id) REFERENCES documents_good(doc_id)
);
```

### 5. Ne pas valider JSON avant insertion

```sql
-- ‚ùå RISQUE : Ins√©rer sans validation
INSERT INTO utilisateurs_json (nom, email, profil) VALUES
    ('Test', 'test@example.com', '{invalid json}');
-- ERROR √† l'insertion !

-- ‚úÖ BON : Valider c√¥t√© application
-- Python exemple
import json

def insert_user(nom, email, profil_dict):
    # Valider que c'est un dict valide
    try:
        profil_json = json.dumps(profil_dict)
        cursor.execute(
            "INSERT INTO utilisateurs_json (nom, email, profil) VALUES (%s, %s, %s)",
            (nom, email, profil_json)
        )
    except json.JSONDecodeError as e:
        print(f"Invalid JSON: {e}")
```

---

## ‚úÖ Points cl√©s √† retenir

- **JSON** : Donn√©es semi-structur√©es, validation automatique, index via colonnes virtuelles
- **UUID** : Identifiants uniques universels, BINARY(16) recommand√© (vs CHAR(36))
- **INET6** : Adresses IPv4/IPv6 optimis√©es, validation automatique, 4-16 octets
- **VECTOR** üÜï : Embeddings IA (MariaDB 11.8), voir chapitre 18.10
- **Fonctions JSON** : JSON_EXTRACT (->), JSON_SET, JSON_ARRAY, JSON_OBJECT
- **Colonnes virtuelles** : Indispensables pour indexer JSON
- **UUID performance** : AUTO_INCREMENT plus rapide si pas de distribution
- **INET6 vs VARCHAR** : INET6 plus compact et valid√©
- JSON_VALID() pour v√©rifier syntaxe JSON
- Ne pas stocker de gros objets en JSON

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB
- [üìñ JSON Data Type](https://mariadb.com/kb/en/json-data-type/)
- [üìñ JSON Functions](https://mariadb.com/kb/en/json-functions/)
- [üìñ UUID()](https://mariadb.com/kb/en/uuid/)
- [üìñ INET6](https://mariadb.com/kb/en/inet6/)
- [üìñ INET6_ATON() and INET6_NTOA()](https://mariadb.com/kb/en/inet6_aton/)
- [üìñ Generated Columns](https://mariadb.com/kb/en/generated-columns/)
- [üìñ MariaDB Vector (11.8)](https://mariadb.com/kb/en/vector-overview/)

### Standards et sp√©cifications
- [RFC 4122 - UUID](https://www.rfc-editor.org/rfc/rfc4122)
- [JSON Standard (ECMA-404)](https://www.json.org/)
- [IPv6 Addressing](https://www.ietf.org/rfc/rfc4291.txt)

---

## ‚û°Ô∏è Section suivante

**[2.3 Cr√©ation et gestion des bases de donn√©es](/02-bases-du-sql/03-creation-gestion-bases.md)**

Maintenant que vous ma√Ætrisez les types de donn√©es MariaDB, apprenez √† cr√©er et g√©rer des bases de donn√©es : commandes CREATE DATABASE, ALTER DATABASE, DROP DATABASE, gestion des charsets (utf8mb4 par d√©faut en 11.8 üÜï), et bonnes pratiques d'organisation.

---


‚è≠Ô∏è [Cr√©ation et gestion des bases de donn√©es](/02-bases-du-sql/03-creation-gestion-bases.md)
