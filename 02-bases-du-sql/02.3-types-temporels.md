üîù Retour au [Sommaire](/SOMMAIRE.md)

# 2.2.3 Types de donn√©es temporels

> **Niveau** : D√©butant
> **Dur√©e estim√©e** : 1.5 heures
> **Pr√©requis** : Section 2.2.2 (Types de texte)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Distinguer DATE, DATETIME, TIMESTAMP et choisir le type appropri√©
- Comprendre le probl√®me Y2038 et son extension en 2106 avec MariaDB 11.8
- Utiliser les types TIME et YEAR correctement
- Manipuler les fuseaux horaires avec TIMESTAMP
- Ma√Ætriser les fonctions de date et heure essentielles
- √âviter les pi√®ges courants li√©s aux types temporels

---

## Introduction

Les **types temporels** permettent de stocker des dates, heures et intervalles de temps dans MariaDB. Le choix du bon type impacte :

- üíæ **L'espace de stockage** : DATE = 3 octets, DATETIME = 8 octets
- üïí **La pr√©cision** : Secondes, millisecondes, microsecondes
- üåç **Les fuseaux horaires** : TIMESTAMP les g√®re, DATETIME non
- üìÖ **La plage de dates** : De 1000 √† 9999 selon le type

üÜï **MariaDB 11.8** : Extension majeure du type **TIMESTAMP** qui supporte maintenant les dates jusqu'en **2106** au lieu de 2038, r√©solvant ainsi le probl√®me Y2038 (Year 2038 problem).

---

## Vue d'ensemble des types temporels

| Type | Taille | Plage | Pr√©cision | Fuseau horaire | Usage principal |
|------|--------|-------|-----------|----------------|-----------------|
| **DATE** | 3 octets | 1000-01-01 √† 9999-12-31 | Jour | Non | Dates seules |
| **TIME** | 3-6 octets | -838:59:59 √† 838:59:59 | Microseconde | Non | Heures/dur√©es |
| **YEAR** | 1 octet | 1901 √† 2155 | Ann√©e | Non | Ann√©es seules |
| **DATETIME** | 5-8 octets | 1000-01-01 00:00:00 √† 9999-12-31 23:59:59 | Microseconde | Non | Date + heure fixe |
| **TIMESTAMP** | 4-7 octets | 1970-01-01 00:00:01 UTC √† **2106-02-07 06:28:15 UTC** üÜï | Microseconde | Oui | Date + heure avec TZ |

üí° **R√®gle simple** :
- Date seule ‚Üí **DATE**
- Date + heure fixe ‚Üí **DATETIME**
- Date + heure avec fuseau horaire ‚Üí **TIMESTAMP**

---

## DATE - Dates sans heure

### Caract√©ristiques

**DATE** stocke une date au format `YYYY-MM-DD`.

- **Taille** : 3 octets
- **Plage** : 1000-01-01 √† 9999-12-31
- **Pr√©cision** : Jour uniquement
- **Format** : Toujours YYYY-MM-DD en interne

```sql
-- Cr√©ation d'une table avec DATE
CREATE TABLE evenements (
    evenement_id INT PRIMARY KEY AUTO_INCREMENT,
    nom VARCHAR(100) NOT NULL,
    date_debut DATE NOT NULL,                   -- Date de d√©but
    date_fin DATE,                              -- Date de fin (optionnelle)
    date_creation DATE DEFAULT (CURRENT_DATE),  -- Date du jour par d√©faut
    INDEX idx_date_debut (date_debut)
);

-- Insertion avec diff√©rents formats (tous convertis en YYYY-MM-DD)
INSERT INTO evenements (nom, date_debut, date_fin) VALUES
    ('Conf√©rence MariaDB', '2025-06-15', '2025-06-17'),        -- Format standard
    ('Formation SQL', '2025-07-01', '2025-07-05'),
    ('Webinaire', CURRENT_DATE, NULL);                         -- Date du jour

-- Insertion avec fonctions de date
INSERT INTO evenements (nom, date_debut, date_fin) VALUES
    ('Maintenance serveur', DATE('2025-12-20 10:30:00'), DATE('2025-12-20'));

-- Consultation
SELECT * FROM evenements WHERE date_debut >= '2025-06-01';
SELECT * FROM evenements WHERE date_debut BETWEEN '2025-06-01' AND '2025-06-30';
```

### Op√©rations avec DATE

```sql
-- Calcul de dur√©e entre deux dates
SELECT
    nom,
    date_debut,
    date_fin,
    DATEDIFF(date_fin, date_debut) AS duree_jours,
    TIMESTAMPDIFF(WEEK, date_debut, date_fin) AS duree_semaines
FROM evenements
WHERE date_fin IS NOT NULL;

-- Ajout/soustraction de jours
SELECT
    nom,
    date_debut,
    DATE_ADD(date_debut, INTERVAL 7 DAY) AS une_semaine_apres,
    DATE_SUB(date_debut, INTERVAL 1 MONTH) AS un_mois_avant
FROM evenements;

-- Extraction de composants
SELECT
    nom,
    date_debut,
    YEAR(date_debut) AS annee,
    MONTH(date_debut) AS mois,
    DAY(date_debut) AS jour,
    DAYNAME(date_debut) AS jour_semaine,
    WEEK(date_debut) AS numero_semaine
FROM evenements;
```

üí° **Cas d'usage DATE** :
- ‚úÖ Date de naissance
- ‚úÖ Date d'inscription
- ‚úÖ Date de livraison
- ‚úÖ Date d'expiration
- ‚úÖ Dates historiques
- ‚ùå Logs avec horodatage (utiliser DATETIME ou TIMESTAMP)

---

## TIME - Heures et dur√©es

### Caract√©ristiques

**TIME** stocke une heure ou une dur√©e au format `HH:MM:SS`.

- **Taille** : 3 octets (6 octets avec microsecondes)
- **Plage** : -838:59:59 √† 838:59:59 (n√©gatif pour dur√©es)
- **Pr√©cision** : Jusqu'√† la microseconde (6 d√©cimales)
- **Format** : HH:MM:SS ou HHH:MM:SS pour dur√©es

```sql
-- Cr√©ation d'une table avec TIME
CREATE TABLE horaires_ouverture (
    jour_semaine ENUM('Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'),
    heure_ouverture TIME NOT NULL,
    heure_fermeture TIME NOT NULL,
    PRIMARY KEY (jour_semaine)
);

-- Insertion d'horaires
INSERT INTO horaires_ouverture VALUES
    ('Lundi', '09:00:00', '18:00:00'),
    ('Mardi', '09:00:00', '18:00:00'),
    ('Mercredi', '09:00:00', '18:00:00'),
    ('Jeudi', '09:00:00', '20:00:00'),
    ('Vendredi', '09:00:00', '18:00:00'),
    ('Samedi', '10:00:00', '17:00:00'),
    ('Dimanche', '00:00:00', '00:00:00');  -- Ferm√©

-- V√©rifier si un magasin est ouvert maintenant
SELECT
    jour_semaine,
    heure_ouverture,
    heure_fermeture,
    CURRENT_TIME BETWEEN heure_ouverture AND heure_fermeture AS est_ouvert
FROM horaires_ouverture
WHERE jour_semaine = DAYNAME(CURRENT_DATE);
```

### TIME pour les dur√©es

```sql
-- Table de suivi du temps de travail
CREATE TABLE temps_travail (
    employe_id INT,
    date_travail DATE,
    heures_travaillees TIME,                    -- Dur√©e de travail
    PRIMARY KEY (employe_id, date_travail)
);

-- Insertion de dur√©es
INSERT INTO temps_travail VALUES
    (101, '2025-12-10', '08:30:00'),            -- 8h30 de travail
    (101, '2025-12-11', '09:15:00'),            -- 9h15
    (102, '2025-12-10', '07:45:00');            -- 7h45

-- Calcul du total d'heures (converti en secondes puis heures)
SELECT
    employe_id,
    SEC_TO_TIME(SUM(TIME_TO_SEC(heures_travaillees))) AS total_heures
FROM temps_travail
GROUP BY employe_id;

-- R√©sultat pour employe_id 101 : 17:45:00 (17h45)
```

### TIME avec microsecondes

```sql
-- Pr√©cision microseconde pour mesures fines
CREATE TABLE mesures_performance (
    mesure_id INT PRIMARY KEY AUTO_INCREMENT,
    nom_operation VARCHAR(100),
    temps_execution TIME(6),                    -- 6 d√©cimales = microsecondes
    date_mesure DATETIME(6)
);

-- Insertion avec microsecondes
INSERT INTO mesures_performance (nom_operation, temps_execution, date_mesure) VALUES
    ('Requ√™te SELECT', '00:00:00.001234', NOW(6)),    -- 1.234 millisecondes
    ('Requ√™te INSERT', '00:00:00.000567', NOW(6));    -- 0.567 milliseconde

SELECT * FROM mesures_performance;
```

üí° **Cas d'usage TIME** :
- ‚úÖ Horaires d'ouverture/fermeture
- ‚úÖ Dur√©es de travail
- ‚úÖ Temps de r√©ponse/ex√©cution
- ‚úÖ Minuteurs, chronom√®tres
- ‚ö†Ô∏è Peut stocker des dur√©es > 24h (jusqu'√† 838h)

---

## YEAR - Ann√©es uniquement

### Caract√©ristiques

**YEAR** stocke une ann√©e sur 4 chiffres.

- **Taille** : 1 octet
- **Plage** : 1901 √† 2155
- **Format** : YYYY uniquement
- **Optimisation** : √âconomie d'espace pour ann√©es seules

```sql
-- Cr√©ation d'une table avec YEAR
CREATE TABLE vehicules (
    vehicule_id INT PRIMARY KEY AUTO_INCREMENT,
    marque VARCHAR(50),
    modele VARCHAR(50),
    annee_fabrication YEAR NOT NULL,            -- Ann√©e de fabrication
    annee_achat YEAR,                           -- Ann√©e d'achat
    INDEX idx_annee (annee_fabrication)
);

-- Insertion d'ann√©es
INSERT INTO vehicules (marque, modele, annee_fabrication, annee_achat) VALUES
    ('Renault', 'Clio', 2020, 2021),
    ('Peugeot', '308', 2022, 2022),
    ('Citro√´n', 'C3', 2019, 2020);

-- Requ√™tes sur les ann√©es
SELECT * FROM vehicules WHERE annee_fabrication >= 2020;
SELECT * FROM vehicules WHERE annee_fabrication BETWEEN 2019 AND 2021;

-- Calcul d'√¢ge du v√©hicule
SELECT
    marque,
    modele,
    annee_fabrication,
    YEAR(CURRENT_DATE) - annee_fabrication AS age_annees
FROM vehicules;
```

üí° **Cas d'usage YEAR** :
- ‚úÖ Ann√©e de naissance (si pr√©cision jour non n√©cessaire)
- ‚úÖ Ann√©e de fabrication
- ‚úÖ Ann√©e scolaire
- ‚úÖ Mill√©sime (vin, whisky)
- ‚ùå Si besoin date compl√®te (utiliser DATE)

‚ö†Ô∏è **Limitation** : Ne stocke que des ann√©es entre 1901 et 2155. Pour des ann√©es historiques anciennes, utiliser INT ou SMALLINT.

---

## DATETIME - Date et heure sans fuseau horaire

### Caract√©ristiques

**DATETIME** stocke une date et heure au format `YYYY-MM-DD HH:MM:SS`.

- **Taille** : 5 octets (8 octets avec microsecondes)
- **Plage** : 1000-01-01 00:00:00 √† 9999-12-31 23:59:59
- **Pr√©cision** : Jusqu'√† la microseconde
- **Fuseau horaire** : Non g√©r√© (valeur "brute")

```sql
-- Cr√©ation d'une table avec DATETIME
CREATE TABLE publications (
    publication_id INT PRIMARY KEY AUTO_INCREMENT,
    titre VARCHAR(200) NOT NULL,
    auteur VARCHAR(100),
    date_creation DATETIME DEFAULT CURRENT_TIMESTAMP,           -- Date/heure cr√©ation
    date_modification DATETIME ON UPDATE CURRENT_TIMESTAMP,     -- Mise √† jour auto
    date_publication DATETIME,                                  -- Date publication planifi√©e
    INDEX idx_creation (date_creation),
    INDEX idx_publication (date_publication)
);

-- Insertion avec DATETIME
INSERT INTO publications (titre, auteur, date_publication) VALUES
    ('Introduction √† MariaDB 11.8', 'Alice Dupont', '2025-06-15 10:00:00'),
    ('Guide SQL avanc√©', 'Bob Martin', '2025-07-01 14:30:00'),
    ('Performance MariaDB', 'Charlie Durand', NOW());           -- Date/heure actuelle

-- Consultation avec filtres temporels
SELECT * FROM publications
WHERE date_publication >= '2025-06-01 00:00:00'
  AND date_publication < '2025-07-01 00:00:00';

-- Publications des 7 derniers jours
SELECT * FROM publications
WHERE date_creation >= DATE_SUB(NOW(), INTERVAL 7 DAY);
```

### DATETIME avec microsecondes

```sql
-- Pr√©cision microseconde pour logs pr√©cis
CREATE TABLE logs_systeme (
    log_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    niveau VARCHAR(10),
    message TEXT,
    timestamp_log DATETIME(6) DEFAULT CURRENT_TIMESTAMP(6),     -- 6 d√©cimales
    INDEX idx_timestamp (timestamp_log)
);

-- Insertion avec pr√©cision microseconde
INSERT INTO logs_systeme (niveau, message) VALUES
    ('INFO', 'D√©marrage du serveur'),
    ('DEBUG', 'Connexion base de donn√©es'),
    ('ERROR', 'Erreur de connexion');

-- Affichage avec microsecondes
SELECT
    niveau,
    message,
    timestamp_log,
    DATE_FORMAT(timestamp_log, '%Y-%m-%d %H:%i:%s.%f') AS timestamp_formate
FROM logs_systeme;

-- R√©sultat : 2025-12-12 14:30:45.123456
```

### Op√©rations avec DATETIME

```sql
-- Calculs de dur√©e
SELECT
    titre,
    date_creation,
    date_modification,
    TIMESTAMPDIFF(MINUTE, date_creation, date_modification) AS minutes_ecoulees,
    TIMESTAMPDIFF(HOUR, date_creation, date_modification) AS heures_ecoulees,
    TIMESTAMPDIFF(DAY, date_creation, date_modification) AS jours_ecoules
FROM publications
WHERE date_modification IS NOT NULL;

-- Ajout/soustraction d'intervalles
SELECT
    titre,
    date_publication,
    DATE_ADD(date_publication, INTERVAL 1 HOUR) AS une_heure_apres,
    DATE_ADD(date_publication, INTERVAL 3 DAY) AS trois_jours_apres,
    DATE_SUB(date_publication, INTERVAL 1 WEEK) AS une_semaine_avant
FROM publications;

-- Extraction de composants
SELECT
    titre,
    date_creation,
    DATE(date_creation) AS date_seule,
    TIME(date_creation) AS heure_seule,
    YEAR(date_creation) AS annee,
    MONTH(date_creation) AS mois,
    DAY(date_creation) AS jour,
    HOUR(date_creation) AS heure,
    MINUTE(date_creation) AS minute,
    SECOND(date_creation) AS seconde
FROM publications;
```

üí° **Cas d'usage DATETIME** :
- ‚úÖ Dates de cr√©ation/modification d'enregistrements
- ‚úÖ Dates de publication planifi√©es
- ‚úÖ Historique d'√©v√©nements
- ‚úÖ Rendez-vous, r√©servations
- ‚úÖ Logs applicatifs (sans besoin de fuseau horaire)
- ‚ùå Si fuseau horaire important (utiliser TIMESTAMP)

---

## TIMESTAMP - Date et heure avec fuseau horaire

### Caract√©ristiques

**TIMESTAMP** stocke un instant dans le temps avec gestion du fuseau horaire.

- **Taille** : 4 octets (7 octets avec microsecondes)
- **Plage** : 1970-01-01 00:00:01 UTC √† **2106-02-07 06:28:15 UTC** üÜï
- **Pr√©cision** : Jusqu'√† la microseconde
- **Fuseau horaire** : Stock√© en UTC, converti selon session
- **Valeur sp√©ciale** : Peut √™tre NULL ou '0000-00-00 00:00:00'

üÜï **MariaDB 11.8** : Extension majeure du TIMESTAMP qui r√©sout le **probl√®me Y2038** :
- Avant : limite au 19 janvier 2038 (32 bits sign√©s)
- Apr√®s : supporte jusqu'au 7 f√©vrier 2106 (am√©lioration significative)

```sql
-- Afficher la configuration du fuseau horaire
SELECT @@system_time_zone, @@session.time_zone;

-- Cr√©er une table avec TIMESTAMP
CREATE TABLE connexions_utilisateurs (
    connexion_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    utilisateur_id INT NOT NULL,
    adresse_ip VARCHAR(45),
    timestamp_connexion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,    -- Auto-rempli
    timestamp_deconnexion TIMESTAMP NULL,                       -- Peut √™tre NULL
    INDEX idx_timestamp (timestamp_connexion),
    INDEX idx_utilisateur (utilisateur_id)
);

-- Insertion avec TIMESTAMP automatique
INSERT INTO connexions_utilisateurs (utilisateur_id, adresse_ip) VALUES
    (1001, '192.168.1.100'),
    (1002, '192.168.1.101');

-- Mise √† jour de la d√©connexion
UPDATE connexions_utilisateurs
SET timestamp_deconnexion = CURRENT_TIMESTAMP
WHERE connexion_id = 1;

-- Consultation
SELECT * FROM connexions_utilisateurs;
```

### Conversion de fuseau horaire

```sql
-- D√©monstration de la conversion automatique
CREATE TABLE demo_timezone (
    id INT PRIMARY KEY AUTO_INCREMENT,
    evenement VARCHAR(100),
    ts_utc TIMESTAMP                            -- Stock√© en UTC
);

-- Insertion (stock√© en UTC automatiquement)
INSERT INTO demo_timezone (evenement, ts_utc) VALUES
    ('Cr√©ation enregistrement', CURRENT_TIMESTAMP);

-- Lecture avec fuseau horaire de session
SELECT
    evenement,
    ts_utc,
    CONVERT_TZ(ts_utc, '+00:00', '+01:00') AS heure_paris,
    CONVERT_TZ(ts_utc, '+00:00', '-05:00') AS heure_new_york,
    CONVERT_TZ(ts_utc, '+00:00', '+09:00') AS heure_tokyo
FROM demo_timezone;

-- Changer le fuseau horaire de la session
SET time_zone = '+01:00';  -- Paris
SELECT ts_utc FROM demo_timezone;  -- Affich√© en heure de Paris

SET time_zone = '-05:00';  -- New York
SELECT ts_utc FROM demo_timezone;  -- Affich√© en heure de New York
```

### TIMESTAMP avec auto-update

```sql
-- Table avec timestamps automatiques
CREATE TABLE articles_blog (
    article_id INT PRIMARY KEY AUTO_INCREMENT,
    titre VARCHAR(200) NOT NULL,
    contenu TEXT,

    -- Timestamp de cr√©ation (d√©fini une seule fois)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- Timestamp de modification (mis √† jour automatiquement)
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                        ON UPDATE CURRENT_TIMESTAMP,

    INDEX idx_created (created_at),
    INDEX idx_updated (updated_at)
);

-- Insertion : created_at et updated_at remplis automatiquement
INSERT INTO articles_blog (titre, contenu) VALUES
    ('Premier article', 'Contenu du premier article...');

-- Attendre quelques secondes...

-- Modification : updated_at mis √† jour automatiquement
UPDATE articles_blog
SET contenu = 'Contenu modifi√©...'
WHERE article_id = 1;

-- V√©rification : created_at reste identique, updated_at a chang√©
SELECT
    article_id,
    titre,
    created_at,
    updated_at,
    TIMESTAMPDIFF(SECOND, created_at, updated_at) AS secondes_depuis_creation
FROM articles_blog;
```

### Extension TIMESTAMP jusqu'en 2106

üÜï **MariaDB 11.8** : Le probl√®me Y2038 est r√©solu !

```sql
-- D√©monstration de l'extension jusqu'en 2106
CREATE TABLE evenements_futurs (
    evenement_id INT PRIMARY KEY AUTO_INCREMENT,
    nom VARCHAR(100),
    date_evenement TIMESTAMP
);

-- ‚úÖ Maintenant possible : dates apr√®s 2038
INSERT INTO evenements_futurs (nom, date_evenement) VALUES
    ('√âv√©nement 2040', '2040-01-01 00:00:00'),
    ('√âv√©nement 2050', '2050-06-15 12:00:00'),
    ('√âv√©nement 2100', '2100-12-31 23:59:59'),
    ('Limite 2106', '2106-02-07 06:28:15');      -- Date limite maximale

-- ‚ùå Avant MariaDB 11.8, ceci aurait √©chou√© apr√®s 2038-01-19 03:14:07

SELECT
    nom,
    date_evenement,
    YEAR(date_evenement) AS annee
FROM evenements_futurs
ORDER BY date_evenement;
```

üí° **Impact de l'extension TIMESTAMP** :
- ‚úÖ Applications long-terme (contrats, abonnements)
- ‚úÖ Planification √† tr√®s long terme
- ‚úÖ Syst√®mes critiques (spatial, militaire)
- ‚ö†Ô∏è Compatibilit√© : V√©rifier migration depuis anciennes versions

---

## DATETIME vs TIMESTAMP : Quel type choisir ?

### Comparaison d√©taill√©e

| Crit√®re | DATETIME | TIMESTAMP |
|---------|----------|-----------|
| **Taille** | 5-8 octets | 4-7 octets |
| **Plage** | 1000 √† 9999 | 1970 √† 2106 üÜï |
| **Fuseau horaire** | ‚ùå Non g√©r√© | ‚úÖ Converti automatiquement |
| **Valeur NULL** | ‚úÖ Possible | ‚úÖ Possible |
| **Default** | ‚úÖ Oui | ‚úÖ Oui |
| **Auto-update** | ‚ùå Non | ‚úÖ ON UPDATE CURRENT_TIMESTAMP |
| **Stockage** | Valeur litt√©rale | Secondes depuis epoch (UTC) |
| **Usage** | Date/heure "fixe" | Date/heure "mobile" (TZ) |

### Arbre de d√©cision

```
Besoin de stocker une date/heure ?
‚îÇ
‚îú‚îÄ Besoin de g√©rer des fuseaux horaires ?
‚îÇ   ‚îú‚îÄ OUI ‚Üí TIMESTAMP (converti selon session)
‚îÇ   ‚îî‚îÄ NON ‚Üí DATETIME (valeur fixe)
‚îÇ
‚îú‚îÄ Plage de dates requise ?
‚îÇ   ‚îú‚îÄ Avant 1970 ‚Üí DATETIME (jusqu'√† 1000)
‚îÇ   ‚îú‚îÄ 1970-2106 ‚Üí TIMESTAMP ou DATETIME
‚îÇ   ‚îî‚îÄ Apr√®s 2106 ‚Üí DATETIME (jusqu'√† 9999)
‚îÇ
‚îú‚îÄ Besoin d'auto-update sur modification ?
‚îÇ   ‚îú‚îÄ OUI ‚Üí TIMESTAMP avec ON UPDATE
‚îÇ   ‚îî‚îÄ NON ‚Üí DATETIME
‚îÇ
‚îî‚îÄ Optimisation espace ?
    ‚îú‚îÄ Important ‚Üí TIMESTAMP (4 octets)
    ‚îî‚îÄ Moins important ‚Üí DATETIME (5 octets)
```

### Exemples comparatifs

```sql
-- Table de d√©monstration
CREATE TABLE demo_datetime_vs_timestamp (
    id INT PRIMARY KEY AUTO_INCREMENT,
    evenement VARCHAR(100),

    -- DATETIME : Valeur fixe, pas de conversion TZ
    datetime_col DATETIME DEFAULT CURRENT_TIMESTAMP,

    -- TIMESTAMP : Stock√© en UTC, converti selon session
    timestamp_col TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Insertion
INSERT INTO demo_datetime_vs_timestamp (evenement) VALUES
    ('Test de comparaison');

-- Lecture avec TZ par d√©faut (supposons UTC)
SELECT * FROM demo_datetime_vs_timestamp;
-- datetime_col  : 2025-12-12 14:30:00 (fixe)
-- timestamp_col : 2025-12-12 14:30:00 (affich√© en UTC)

-- Changer le fuseau horaire de la session
SET time_zone = '+02:00';

-- Relire les donn√©es
SELECT * FROM demo_datetime_vs_timestamp;
-- datetime_col  : 2025-12-12 14:30:00 (inchang√©, fixe)
-- timestamp_col : 2025-12-12 16:30:00 (converti : +2h)
```

üí° **Recommandations pratiques** :
- **Logs syst√®me** ‚Üí TIMESTAMP (important d'avoir UTC)
- **Connexions utilisateurs** ‚Üí TIMESTAMP (multi-timezone)
- **Rendez-vous, r√©servations** ‚Üí DATETIME (heure "locale" fixe)
- **Dates historiques** ‚Üí DATETIME (peut aller avant 1970)
- **Audit trails** ‚Üí TIMESTAMP (tra√ßabilit√© UTC)

---

## Fonctions de date et heure essentielles

### Obtenir la date/heure actuelle

```sql
-- Diff√©rentes fonctions pour obtenir la date/heure
SELECT
    CURRENT_DATE AS date_aujourdhui,            -- DATE uniquement
    CURRENT_TIME AS heure_actuelle,             -- TIME uniquement
    CURRENT_TIMESTAMP AS datetime_actuel,       -- DATETIME complet
    NOW() AS now_fonction,                      -- √âquivalent √† CURRENT_TIMESTAMP
    UTC_TIMESTAMP() AS utc_timestamp,           -- Timestamp UTC
    UNIX_TIMESTAMP() AS unix_timestamp,         -- Secondes depuis epoch
    SYSDATE() AS sysdate;                       -- Date/heure √† l'instant d'ex√©cution

-- Diff√©rence NOW() vs SYSDATE()
-- NOW() : fix√© au d√©but de la requ√™te
-- SYSDATE() : calcul√© √† chaque appel (plus lent)
```

### Formatage et parsing

```sql
-- DATE_FORMAT : Formater une date
SELECT
    NOW() AS datetime_brut,
    DATE_FORMAT(NOW(), '%d/%m/%Y') AS format_fr,                -- 12/12/2025
    DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s') AS format_iso,      -- 2025-12-12 14:30:45
    DATE_FORMAT(NOW(), '%W %d %M %Y') AS format_long,           -- Thursday 12 December 2025
    DATE_FORMAT(NOW(), '%d %b %Y √† %Hh%i') AS format_custom;    -- 12 Dec 2025 √† 14h30

-- STR_TO_DATE : Parser une cha√Æne en date
SELECT
    STR_TO_DATE('12/12/2025', '%d/%m/%Y') AS date_parsed,
    STR_TO_DATE('2025-12-12 14:30:00', '%Y-%m-%d %H:%i:%s') AS datetime_parsed;
```

### Extraction de composants

```sql
-- Extraire des parties d'une date/heure
SELECT
    NOW() AS datetime_complet,
    DATE(NOW()) AS date_seule,
    TIME(NOW()) AS heure_seule,
    YEAR(NOW()) AS annee,
    QUARTER(NOW()) AS trimestre,
    MONTH(NOW()) AS mois,
    WEEK(NOW()) AS semaine,
    DAY(NOW()) AS jour,
    DAYOFWEEK(NOW()) AS jour_semaine_numero,    -- 1=Dimanche, 7=Samedi
    DAYOFMONTH(NOW()) AS jour_mois,
    DAYOFYEAR(NOW()) AS jour_annee,
    HOUR(NOW()) AS heure,
    MINUTE(NOW()) AS minute,
    SECOND(NOW()) AS seconde,
    MICROSECOND(NOW(6)) AS microseconde,
    DAYNAME(NOW()) AS nom_jour,                 -- Thursday
    MONTHNAME(NOW()) AS nom_mois;               -- December
```

### Calculs et intervalles

```sql
-- Addition et soustraction d'intervalles
SELECT
    NOW() AS maintenant,

    -- Ajout
    DATE_ADD(NOW(), INTERVAL 1 DAY) AS demain,
    DATE_ADD(NOW(), INTERVAL 1 WEEK) AS dans_une_semaine,
    DATE_ADD(NOW(), INTERVAL 1 MONTH) AS dans_un_mois,
    DATE_ADD(NOW(), INTERVAL 1 YEAR) AS dans_un_an,
    DATE_ADD(NOW(), INTERVAL 2 HOUR) AS dans_2h,
    DATE_ADD(NOW(), INTERVAL 30 MINUTE) AS dans_30min,

    -- Soustraction
    DATE_SUB(NOW(), INTERVAL 1 DAY) AS hier,
    DATE_SUB(NOW(), INTERVAL 7 DAY) AS il_y_a_7_jours,

    -- Intervalles combin√©s
    DATE_ADD(NOW(), INTERVAL '1 2:30:00' DAY_SECOND) AS dans_1j_2h30;

-- TIMESTAMPDIFF : Calculer la diff√©rence entre deux dates
SELECT
    TIMESTAMPDIFF(SECOND, '2025-12-01 10:00:00', '2025-12-01 10:05:30') AS diff_secondes,
    TIMESTAMPDIFF(MINUTE, '2025-12-01 10:00:00', '2025-12-01 10:05:30') AS diff_minutes,
    TIMESTAMPDIFF(HOUR, '2025-12-01 00:00:00', '2025-12-02 00:00:00') AS diff_heures,
    TIMESTAMPDIFF(DAY, '2025-12-01', '2025-12-12') AS diff_jours,
    TIMESTAMPDIFF(MONTH, '2025-01-01', '2025-12-01') AS diff_mois,
    TIMESTAMPDIFF(YEAR, '2020-01-01', '2025-12-12') AS diff_annees;

-- DATEDIFF : Diff√©rence en jours (DATE uniquement)
SELECT
    DATEDIFF('2025-12-31', '2025-12-01') AS jours_restants,     -- 30
    DATEDIFF('2025-01-01', '2025-12-31') AS jours_ecoules;      -- -364
```

### Fonctions utilitaires

```sql
-- LAST_DAY : Dernier jour du mois
SELECT
    LAST_DAY('2025-12-12') AS dernier_jour_decembre,            -- 2025-12-31
    LAST_DAY('2024-02-15') AS dernier_jour_fevrier;             -- 2024-02-29 (bissextile)

-- MAKEDATE, MAKETIME : Construire des dates/heures
SELECT
    MAKEDATE(2025, 1) AS premier_jour_annee,                    -- 2025-01-01
    MAKEDATE(2025, 100) AS centieme_jour,                       -- 2025-04-10
    MAKETIME(14, 30, 45) AS heure_construite;                   -- 14:30:45

-- FROM_UNIXTIME, UNIX_TIMESTAMP : Conversion timestamps Unix
SELECT
    UNIX_TIMESTAMP('2025-12-12 14:30:00') AS unix_ts,           -- 1765464600
    FROM_UNIXTIME(1765464600) AS datetime_from_unix;            -- 2025-12-12 14:30:00

-- TO_DAYS, FROM_DAYS : Conversion en jours depuis an 0
SELECT
    TO_DAYS('2025-12-12') AS jours_depuis_an_0,
    FROM_DAYS(739564) AS date_depuis_jours;
```

---

## Exemples pratiques

### Exemple 1 : Syst√®me de r√©servations

```sql
-- Table de r√©servations d'h√¥tel
CREATE TABLE reservations_hotel (
    reservation_id INT PRIMARY KEY AUTO_INCREMENT,
    client_id INT NOT NULL,
    chambre_numero VARCHAR(10),

    -- DATE pour dates de s√©jour (pas besoin d'heure)
    date_arrivee DATE NOT NULL,
    date_depart DATE NOT NULL,

    -- DATETIME pour r√©servation planifi√©e
    date_reservation DATETIME DEFAULT CURRENT_TIMESTAMP,

    -- TIMESTAMP pour audit (avec fuseau horaire)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    CHECK (date_depart > date_arrivee),
    INDEX idx_dates (date_arrivee, date_depart)
);

-- Insertion
INSERT INTO reservations_hotel (client_id, chambre_numero, date_arrivee, date_depart) VALUES
    (1001, '201', '2025-12-20', '2025-12-25'),
    (1002, '305', '2025-12-22', '2025-12-27');

-- Requ√™tes utiles
-- Dur√©e de s√©jour
SELECT
    reservation_id,
    date_arrivee,
    date_depart,
    DATEDIFF(date_depart, date_arrivee) AS nombre_nuits
FROM reservations_hotel;

-- R√©servations pour aujourd'hui (check-in)
SELECT * FROM reservations_hotel
WHERE date_arrivee = CURRENT_DATE;

-- Chambres occup√©es pour une p√©riode donn√©e
SELECT chambre_numero
FROM reservations_hotel
WHERE date_arrivee <= '2025-12-25'
  AND date_depart >= '2025-12-20';
```

### Exemple 2 : Logs d'application

```sql
-- Logs avec pr√©cision microseconde
CREATE TABLE logs_application (
    log_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    niveau ENUM('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'),
    message TEXT,

    -- TIMESTAMP pour logs (UTC important pour debugging)
    timestamp_log TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6),

    utilisateur_id INT,
    adresse_ip VARCHAR(45),

    INDEX idx_timestamp (timestamp_log),
    INDEX idx_niveau (niveau)
);

-- Insertion de logs
INSERT INTO logs_application (niveau, message, utilisateur_id, adresse_ip) VALUES
    ('INFO', 'Connexion r√©ussie', 1001, '192.168.1.100'),
    ('ERROR', '√âchec connexion base de donn√©es', NULL, '192.168.1.50'),
    ('WARNING', 'Tentative connexion suspecte', NULL, '10.0.0.1');

-- Statistiques par heure
SELECT
    DATE_FORMAT(timestamp_log, '%Y-%m-%d %H:00:00') AS heure,
    niveau,
    COUNT(*) AS nombre_logs
FROM logs_application
GROUP BY heure, niveau
ORDER BY heure DESC, niveau;

-- Logs des derni√®res 24 heures
SELECT * FROM logs_application
WHERE timestamp_log >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
ORDER BY timestamp_log DESC;

-- Temps moyen entre erreurs
SELECT
    AVG(TIMESTAMPDIFF(SECOND,
        LAG(timestamp_log) OVER (ORDER BY timestamp_log),
        timestamp_log
    )) AS secondes_moyennes_entre_erreurs
FROM logs_application
WHERE niveau = 'ERROR';
```

### Exemple 3 : Gestion d'abonnements

```sql
-- Abonnements avec dates de validit√©
CREATE TABLE abonnements (
    abonnement_id INT PRIMARY KEY AUTO_INCREMENT,
    utilisateur_id INT NOT NULL,
    type_abonnement ENUM('mensuel', 'annuel', 'premium'),

    -- DATE pour d√©but/fin d'abonnement
    date_debut DATE NOT NULL,
    date_fin DATE NOT NULL,

    -- TIMESTAMP pour tracking
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- Indicateur actif calcul√©
    actif AS (CURRENT_DATE BETWEEN date_debut AND date_fin) STORED,

    INDEX idx_dates (date_debut, date_fin),
    INDEX idx_utilisateur (utilisateur_id)
);

-- Insertion
INSERT INTO abonnements (utilisateur_id, type_abonnement, date_debut, date_fin) VALUES
    (1001, 'mensuel', '2025-12-01', '2025-12-31'),
    (1002, 'annuel', '2025-01-01', '2025-12-31'),
    (1003, 'premium', '2025-11-01', '2026-10-31');

-- Abonnements actifs
SELECT * FROM abonnements WHERE actif = 1;

-- Abonnements expirant dans 7 jours
SELECT
    utilisateur_id,
    type_abonnement,
    date_fin,
    DATEDIFF(date_fin, CURRENT_DATE) AS jours_restants
FROM abonnements
WHERE date_fin BETWEEN CURRENT_DATE AND DATE_ADD(CURRENT_DATE, INTERVAL 7 DAY);

-- Renouvellement automatique
UPDATE abonnements
SET date_fin = DATE_ADD(date_fin, INTERVAL 1 MONTH)
WHERE type_abonnement = 'mensuel'
  AND date_fin = CURRENT_DATE;
```

---

## Pi√®ges courants √† √©viter

### 1. Confusion entre DATETIME et TIMESTAMP avec fuseaux horaires

```sql
-- ‚ùå PROBL√àME : DATETIME ne g√®re pas les fuseaux horaires
CREATE TABLE meetings_erreur (
    meeting_datetime DATETIME  -- Quelle heure ? Paris ? UTC ? New York ?
);

-- ‚úÖ SOLUTION : Utiliser TIMESTAMP pour multi-timezone
CREATE TABLE meetings_correct (
    meeting_timestamp TIMESTAMP  -- Stock√© en UTC, converti automatiquement
);
```

### 2. Format de date invalide

```sql
-- ‚ùå ERREUR : Format am√©ricain non reconnu
INSERT INTO evenements (date_debut) VALUES ('12/31/2025');  -- MM/DD/YYYY
-- ERROR ou date incorrecte

-- ‚úÖ CORRECT : Toujours utiliser YYYY-MM-DD
INSERT INTO evenements (date_debut) VALUES ('2025-12-31');
```

### 3. Calculs de dates incorrects

```sql
-- ‚ùå MAUVAIS : Addition simple ne fonctionne pas
SELECT date_debut + 1 FROM evenements;  -- Ajoute 1 √† la valeur num√©rique !

-- ‚úÖ BON : Utiliser DATE_ADD ou INTERVAL
SELECT DATE_ADD(date_debut, INTERVAL 1 DAY) FROM evenements;
SELECT date_debut + INTERVAL 1 DAY FROM evenements;  -- Syntaxe alternative
```

### 4. Oubli de la pr√©cision microseconde

```sql
-- ‚ùå PROBL√àME : Perte de pr√©cision
CREATE TABLE mesures (
    temps TIME  -- Pr√©cision seulement √† la seconde
);

-- ‚úÖ SOLUTION : Sp√©cifier la pr√©cision
CREATE TABLE mesures_precises (
    temps TIME(6)  -- Pr√©cision √† la microseconde
);
```

### 5. Comparaison DATETIME avec strings

```sql
-- ‚ö†Ô∏è ATTENTION : Fonctionne mais pas optimal
SELECT * FROM publications
WHERE date_creation > '2025-12-01';  -- Conversion implicite

-- ‚úÖ MEILLEUR : Utiliser des fonctions de date
SELECT * FROM publications
WHERE date_creation > DATE('2025-12-01');

-- ‚úÖ OPTIMAL : Utiliser des colonnes index√©es directement
SELECT * FROM publications
WHERE DATE(date_creation) = '2025-12-01';  -- N'utilise PAS l'index !

SELECT * FROM publications
WHERE date_creation >= '2025-12-01 00:00:00'
  AND date_creation < '2025-12-02 00:00:00';  -- Utilise l'index
```

### 6. Probl√®me Y2038 (r√©solu en 11.8)

```sql
-- ‚ùå Avant MariaDB 11.8 : Limitation 2038
-- Cette insertion aurait √©chou√©
INSERT INTO evenements_futurs (date_evenement) VALUES
    ('2040-01-01 00:00:00');  -- ERROR avec ancien TIMESTAMP

-- ‚úÖ MariaDB 11.8 : Extension jusqu'en 2106
-- Maintenant possible sans probl√®me
INSERT INTO evenements_futurs (date_evenement) VALUES
    ('2040-01-01 00:00:00');  -- OK
```

---

## ‚úÖ Points cl√©s √† retenir

- **DATE** : Dates seules (YYYY-MM-DD), 1000 √† 9999, 3 octets
- **TIME** : Heures ou dur√©es (HH:MM:SS), -838h √† 838h, peut √™tre n√©gatif
- **YEAR** : Ann√©es uniquement (YYYY), 1901 √† 2155, 1 octet
- **DATETIME** : Date + heure sans fuseau horaire, 1000 √† 9999, 5-8 octets
- **TIMESTAMP** : Date + heure avec fuseau horaire (UTC), 1970 √† **2106** üÜï, 4-7 octets
- üÜï **Extension 2106** : MariaDB 11.8 r√©sout le probl√®me Y2038
- **Fuseau horaire** : TIMESTAMP les g√®re, DATETIME non
- **Auto-update** : TIMESTAMP avec ON UPDATE CURRENT_TIMESTAMP
- **Pr√©cision** : (N) pour microsecondes, ex: DATETIME(6)
- Toujours utiliser format **YYYY-MM-DD** pour les dates
- Utiliser **DATE_ADD/DATE_SUB** pour calculs de dates

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB
- [üìñ Date and Time Data Types](https://mariadb.com/kb/en/date-and-time-data-types/)
- [üìñ DATE](https://mariadb.com/kb/en/date/)
- [üìñ TIME](https://mariadb.com/kb/en/time/)
- [üìñ DATETIME](https://mariadb.com/kb/en/datetime/)
- [üìñ TIMESTAMP](https://mariadb.com/kb/en/timestamp/)
- [üìñ TIMESTAMP Extension (Y2038 fix)](https://mariadb.com/kb/en/timestamp-data-type/)
- [üìñ Date and Time Functions](https://mariadb.com/kb/en/date-time-functions/)
- [üìñ Time Zones](https://mariadb.com/kb/en/time-zones/)

### Lectures compl√©mentaires
- [Year 2038 Problem](https://en.wikipedia.org/wiki/Year_2038_problem)
- [ISO 8601 Date Format](https://en.wikipedia.org/wiki/ISO_8601)

---

## ‚û°Ô∏è Section suivante

**[2.2.4 Types binaires (BLOB, BINARY, VARBINARY)](/02-bases-du-sql/02.4-types-binaires.md)**

D√©couvrez comment stocker des donn√©es binaires dans MariaDB : images, fichiers, documents. Comprenez les diff√©rences entre BLOB, BINARY et VARBINARY, et apprenez les bonnes pratiques pour g√©rer des fichiers en base de donn√©es.

---


‚è≠Ô∏è [Binaires (BLOB, BINARY, VARBINARY)](/02-bases-du-sql/02.4-types-binaires.md)
