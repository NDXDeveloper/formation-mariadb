üîù Retour au [Sommaire](/SOMMAIRE.md)

# 2.2.1 Types de donn√©es num√©riques

> **Niveau** : D√©butant
> **Dur√©e estim√©e** : 1 heure
> **Pr√©requis** : Section 2.1 (Introduction au langage SQL)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Identifier les diff√©rents types num√©riques disponibles dans MariaDB
- Choisir le type appropri√© selon vos besoins (entiers vs d√©cimaux)
- Comprendre les attributs UNSIGNED, ZEROFILL et AUTO_INCREMENT
- Conna√Ætre les plages de valeurs et limitations de chaque type
- √âviter les pi√®ges courants li√©s aux types num√©riques

---

## Introduction

Les **types num√©riques** permettent de stocker des valeurs num√©riques dans MariaDB. Ils se divisent en deux grandes cat√©gories :

1. **Entiers** (INT, BIGINT, TINYINT, etc.) : Pour des nombres sans d√©cimale
2. **D√©cimaux/Flottants** (DECIMAL, FLOAT, DOUBLE) : Pour des nombres avec d√©cimale

Le choix du bon type num√©rique a un impact direct sur :
- üíæ **L'espace disque** : Un TINYINT utilise 1 octet, un BIGINT 8 octets
- ‚ö° **Les performances** : Les entiers sont plus rapides que les flottants
- üéØ **La pr√©cision** : DECIMAL est exact, FLOAT/DOUBLE sont approximatifs

üí° **Conseil** : Toujours choisir le type le plus petit qui peut contenir vos valeurs. Cela optimise le stockage et les performances.

---

## Types entiers (Integer Types)

Les types entiers stockent des nombres sans partie d√©cimale. MariaDB propose 5 types d'entiers de tailles diff√©rentes.

### Vue d'ensemble des types entiers

| Type | Taille | SIGNED (min) | SIGNED (max) | UNSIGNED (min) | UNSIGNED (max) |
|------|--------|--------------|--------------|----------------|----------------|
| **TINYINT** | 1 octet | -128 | 127 | 0 | 255 |
| **SMALLINT** | 2 octets | -32,768 | 32,767 | 0 | 65,535 |
| **MEDIUMINT** | 3 octets | -8,388,608 | 8,388,607 | 0 | 16,777,215 |
| **INT** | 4 octets | -2,147,483,648 | 2,147,483,647 | 0 | 4,294,967,295 |
| **BIGINT** | 8 octets | -9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 | 0 | 18,446,744,073,709,551,615 |

---

### TINYINT - Le plus petit entier

**Utilisation** : Id√©al pour les petites valeurs comme les √¢ges, les pourcentages, les statuts.

**Taille** : 1 octet (8 bits)

```sql
-- Cr√©ation d'une table avec TINYINT
CREATE TABLE utilisateurs (
    utilisateur_id INT PRIMARY KEY AUTO_INCREMENT,
    age TINYINT UNSIGNED,              -- √Çge entre 0 et 255
    statut TINYINT DEFAULT 1,          -- Statut actif/inactif (-128 √† 127)
    niveau TINYINT UNSIGNED NOT NULL   -- Niveau de 0 √† 255
);

-- Insertion de donn√©es
INSERT INTO utilisateurs (age, statut, niveau) VALUES
    (25, 1, 5),      -- Utilisateur actif, niveau 5
    (42, 1, 12),     -- Utilisateur actif, niveau 12
    (18, 0, 1);      -- Utilisateur inactif, niveau 1

-- Consultation
SELECT * FROM utilisateurs WHERE age > 20;
```

üí° **Cas d'usage** :
- √Çge d'une personne (0-255 avec UNSIGNED)
- Jours du mois (1-31)
- Pourcentage de compl√©tion (0-100)
- Statut bool√©en am√©lior√© (0=inactif, 1=actif, 2=suspendu)

‚ö†Ô∏è **Attention** : TINYINT(1) est souvent utilis√© pour les bool√©ens, mais peut stocker 0-255 si UNSIGNED.

---

### SMALLINT - Entier court

**Utilisation** : Pour des valeurs interm√©diaires comme les quantit√©s, les ann√©es.

**Taille** : 2 octets (16 bits)

```sql
-- Exemple : Table de produits
CREATE TABLE produits (
    produit_id INT PRIMARY KEY AUTO_INCREMENT,
    nom VARCHAR(100) NOT NULL,
    stock SMALLINT UNSIGNED DEFAULT 0,        -- Stock de 0 √† 65,535
    annee_fabrication SMALLINT,               -- Ann√©e (ex: 2024)
    temperature_stockage SMALLINT             -- -32,768 √† 32,767 (peut √™tre n√©gatif)
);

-- Insertion
INSERT INTO produits (nom, stock, annee_fabrication, temperature_stockage) VALUES
    ('R√©frig√©rateur', 150, 2024, -5),
    ('Four', 85, 2023, 200),
    ('Lave-vaisselle', 42, 2024, 65);

-- Requ√™te : Produits avec peu de stock
SELECT nom, stock
FROM produits
WHERE stock < 100
ORDER BY stock ASC;
```

üí° **Cas d'usage** :
- Ann√©es (1000-9999)
- Quantit√©s en stock (0-65,535 avec UNSIGNED)
- Temp√©ratures en Celsius (-32,768 √† 32,767)
- Num√©ros de port r√©seau (0-65,535)

---

### MEDIUMINT - Entier moyen

**Utilisation** : Compromis entre INT et SMALLINT quand l'espace compte.

**Taille** : 3 octets (24 bits)

```sql
-- Exemple : Table de compteurs
CREATE TABLE compteurs_visites (
    page_id INT PRIMARY KEY AUTO_INCREMENT,
    url VARCHAR(255) UNIQUE,
    nombre_visites MEDIUMINT UNSIGNED DEFAULT 0    -- Jusqu'√† 16 millions
);

-- Insertion
INSERT INTO compteurs_visites (url, nombre_visites) VALUES
    ('/accueil', 1500000),
    ('/produits', 875000),
    ('/contact', 125000);

-- Incr√©menter un compteur
UPDATE compteurs_visites
SET nombre_visites = nombre_visites + 1
WHERE url = '/accueil';
```

üí° **Cas d'usage** :
- Compteurs de visites (jusqu'√† 16M)
- Populations de villes (0-16M)
- Identifiants dans des tables de taille moyenne

‚ö†Ô∏è **Note** : MEDIUMINT est moins courant car INT n'utilise qu'1 octet de plus et est plus performant sur les processeurs 32/64 bits.

---

### INT (ou INTEGER) - Le type entier standard

**Utilisation** : Le type entier le plus utilis√©. Bon compromis taille/performance.

**Taille** : 4 octets (32 bits)

```sql
-- Exemple : Table principale d'une application
CREATE TABLE commandes (
    commande_id INT PRIMARY KEY AUTO_INCREMENT,     -- Cl√© primaire classique
    client_id INT NOT NULL,                         -- R√©f√©rence √† un client
    montant_centimes INT UNSIGNED,                  -- Montant en centimes (√©vite DECIMAL)
    nombre_articles INT UNSIGNED DEFAULT 1,
    timestamp_creation INT UNSIGNED,                -- Unix timestamp
    INDEX idx_client (client_id)
);

-- Insertion
INSERT INTO commandes (client_id, montant_centimes, nombre_articles, timestamp_creation) VALUES
    (1001, 15990, 3, UNIX_TIMESTAMP()),    -- 159.90‚Ç¨ = 15990 centimes
    (1002, 4599, 1, UNIX_TIMESTAMP()),     -- 45.99‚Ç¨
    (1001, 29900, 5, UNIX_TIMESTAMP());    -- 299.00‚Ç¨

-- Requ√™te : Total des commandes d'un client
SELECT
    client_id,
    COUNT(*) AS nombre_commandes,
    SUM(montant_centimes) / 100 AS total_euros
FROM commandes
WHERE client_id = 1001
GROUP BY client_id;
```

üí° **Cas d'usage** :
- **Cl√©s primaires** (avec AUTO_INCREMENT)
- **Cl√©s √©trang√®res**
- Montants en centimes (√©vite les probl√®mes de pr√©cision)
- Unix timestamps (jusqu'en 2038 avec UNSIGNED, voir BIGINT apr√®s)
- Identifiants d'utilisateurs, produits, etc.

‚ö†Ô∏è **Probl√®me Y2038** : INT UNSIGNED pour les timestamps Unix atteint sa limite le 19 janvier 2038. Utilisez BIGINT ou TIMESTAMP pour √©viter ce probl√®me.

---

### BIGINT - Le grand entier

**Utilisation** : Pour les tr√®s grandes valeurs (identifiants distribu√©s, compteurs importants).

**Taille** : 8 octets (64 bits)

```sql
-- Exemple : Table avec tr√®s grandes valeurs
CREATE TABLE transactions_financieres (
    transaction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    compte_source BIGINT NOT NULL,
    compte_destination BIGINT NOT NULL,
    montant_centimes BIGINT UNSIGNED,           -- Peut g√©rer des milliards
    timestamp_ms BIGINT UNSIGNED,               -- Timestamp en millisecondes
    hash_transaction BIGINT UNSIGNED            -- Hash 64-bit
);

-- Insertion avec grandes valeurs
INSERT INTO transactions_financieres
    (compte_source, compte_destination, montant_centimes, timestamp_ms, hash_transaction)
VALUES
    (1000000000001, 1000000000002, 50000000, 1702345678901, 9223372036854775807),
    (1000000000002, 1000000000003, 125000000, 1702345679123, 8765432109876543210);

-- Requ√™te avec grandes valeurs
SELECT
    transaction_id,
    montant_centimes / 100 AS montant_euros,
    FROM_UNIXTIME(timestamp_ms / 1000) AS date_transaction
FROM transactions_financieres
WHERE montant_centimes > 1000000;  -- Plus de 10,000 euros
```

üí° **Cas d'usage** :
- Identifiants Twitter/Facebook (Snowflake IDs)
- Timestamps en millisecondes/microsecondes
- Compteurs tr√®s √©lev√©s (vues YouTube, likes)
- Montants financiers en centimes (grands comptes)
- Cl√©s distribu√©es (UUID num√©riques)

üÜï **MariaDB 11.8** : Meilleure gestion des BIGINT dans les calculs et agr√©gations.

---

## Attributs des types entiers

### UNSIGNED - Entiers non sign√©s

L'attribut **UNSIGNED** double la plage positive en √©liminant les valeurs n√©gatives.

```sql
-- Comparaison SIGNED vs UNSIGNED
CREATE TABLE demo_unsigned (
    -- SIGNED (par d√©faut) : -128 √† 127
    age_signed TINYINT,

    -- UNSIGNED : 0 √† 255
    age_unsigned TINYINT UNSIGNED,

    -- INT SIGNED : -2.1B √† 2.1B
    compteur_signed INT,

    -- INT UNSIGNED : 0 √† 4.3B
    compteur_unsigned INT UNSIGNED
);

-- ‚úÖ Valeurs valides
INSERT INTO demo_unsigned VALUES (50, 200, -1000, 3000000000);

-- ‚ùå Erreurs avec UNSIGNED
INSERT INTO demo_unsigned VALUES (-10, -10, 0, 0);
-- ERROR: Out of range value for column 'age_unsigned'

-- ‚ùå Attention au d√©bordement
UPDATE demo_unsigned SET age_unsigned = age_unsigned - 10 WHERE age_unsigned = 5;
-- R√©sultat : 4294967291 (underflow !) au lieu de -5
```

üí° **Quand utiliser UNSIGNED** :
- ‚úÖ Valeurs toujours positives (√¢ge, quantit√©, prix)
- ‚úÖ Cl√©s primaires et AUTO_INCREMENT
- ‚úÖ Compteurs (visites, likes, vues)

‚ö†Ô∏è **Attention** : Les op√©rations arithm√©tiques avec UNSIGNED peuvent causer des d√©bordements inattendus.

---

### ZEROFILL - Remplissage par des z√©ros

L'attribut **ZEROFILL** remplit les nombres avec des z√©ros √† gauche pour atteindre la largeur d'affichage.

```sql
-- ZEROFILL implique automatiquement UNSIGNED
CREATE TABLE demo_zerofill (
    code_produit INT(6) ZEROFILL,        -- Affiche sur 6 chiffres
    numero_commande INT(8) ZEROFILL,     -- Affiche sur 8 chiffres
    montant INT                          -- Affichage normal
);

-- Insertion
INSERT INTO demo_zerofill VALUES (42, 1234, 1000);

-- R√©sultat de SELECT :
-- code_produit | numero_commande | montant
-- 000042       | 00001234        | 1000
```

üí° **Utilisation** :
- Codes produits : SKU000123
- Num√©ros de facture : FAC00001234
- Identifiants format√©s

‚ö†Ô∏è **Important** :
- ZEROFILL est un attribut d'**affichage** uniquement
- La valeur stock√©e reste 42, seul l'affichage change
- Implique automatiquement UNSIGNED
- Peu utilis√© en production moderne (formatage c√¥t√© application pr√©f√©r√©)

---

### AUTO_INCREMENT - Incr√©mentation automatique

L'attribut **AUTO_INCREMENT** g√©n√®re automatiquement des valeurs uniques croissantes.

```sql
-- Utilisation classique pour les cl√©s primaires
CREATE TABLE clients (
    client_id INT PRIMARY KEY AUTO_INCREMENT,    -- Commence √† 1
    nom VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE
);

-- Insertion sans sp√©cifier l'ID
INSERT INTO clients (nom, email) VALUES
    ('Alice Dupont', 'alice@example.com'),      -- client_id = 1
    ('Bob Martin', 'bob@example.com'),          -- client_id = 2
    ('Charlie Durand', 'charlie@example.com');  -- client_id = 3

-- Obtenir le dernier ID ins√©r√©
SELECT LAST_INSERT_ID();  -- Retourne 3

-- Insertion avec ID explicite (d√©conseill√©)
INSERT INTO clients (client_id, nom, email)
VALUES (100, 'David', 'david@example.com');

-- Le prochain AUTO_INCREMENT sera 101
INSERT INTO clients (nom, email)
VALUES ('Eve', 'eve@example.com');  -- client_id = 101
```

üí° **R√®gles AUTO_INCREMENT** :
- Fonctionne avec : TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT
- Doit √™tre index√© (g√©n√©ralement PRIMARY KEY ou UNIQUE)
- Toujours UNSIGNED en pratique
- Commence √† 1 par d√©faut

```sql
-- Modifier la valeur de d√©part
CREATE TABLE demo_auto (
    id INT PRIMARY KEY AUTO_INCREMENT
) AUTO_INCREMENT = 1000;  -- Commence √† 1000

-- R√©initialiser le compteur
ALTER TABLE clients AUTO_INCREMENT = 1;

-- Voir la valeur actuelle
SHOW CREATE TABLE clients;
```

‚ö†Ô∏è **Pi√®ges courants** :
- Ne jamais ins√©rer manuellement des valeurs AUTO_INCREMENT en production
- Les ID supprim√©s ne sont pas r√©utilis√©s (sauf TRUNCATE)
- Avec InnoDB, les ID sont persistants m√™me apr√®s red√©marrage

---

## Types d√©cimaux et flottants

Pour stocker des nombres avec partie d√©cimale, MariaDB offre trois types principaux.

### Comparaison DECIMAL vs FLOAT vs DOUBLE

| Crit√®re | DECIMAL | FLOAT | DOUBLE |
|---------|---------|-------|--------|
| **Pr√©cision** | ‚úÖ Exacte | ‚ö†Ô∏è Approximative | ‚ö†Ô∏è Approximative |
| **Taille** | Variable (1-9 octets) | 4 octets | 8 octets |
| **Vitesse** | Lent | Rapide | Rapide |
| **Usage** | Finances, prix | Scientifique | Scientifique |
| **Plage** | Configurable | ¬±3.4E+38 | ¬±1.8E+308 |

---

### DECIMAL - Nombres d√©cimaux exacts

**Syntaxe** : `DECIMAL(M, D)` ou `NUMERIC(M, D)`
- **M** : Nombre total de chiffres (pr√©cision) - max 65
- **D** : Nombre de chiffres apr√®s la virgule (√©chelle) - max 30

**Utilisation** : **TOUJOURS** pour l'argent et les valeurs n√©cessitant une pr√©cision exacte.

```sql
-- Exemple : Table de produits avec prix
CREATE TABLE produits_boutique (
    produit_id INT PRIMARY KEY AUTO_INCREMENT,
    nom VARCHAR(100) NOT NULL,
    prix_unitaire DECIMAL(10, 2) NOT NULL,      -- 99999999.99 max
    taux_tva DECIMAL(5, 4) DEFAULT 0.2000,      -- 0.2000 = 20%
    remise DECIMAL(5, 2) DEFAULT 0.00,          -- Pourcentage de remise
    poids_kg DECIMAL(8, 3)                       -- Poids en kilogrammes
);

-- Insertion de produits
INSERT INTO produits_boutique (nom, prix_unitaire, taux_tva, remise, poids_kg) VALUES
    ('Ordinateur portable', 899.99, 0.2000, 10.00, 2.450),
    ('Souris sans fil', 24.90, 0.2000, 0.00, 0.085),
    ('Clavier m√©canique', 159.99, 0.2000, 5.00, 1.120);

-- Calculs pr√©cis avec DECIMAL
SELECT
    nom,
    prix_unitaire,
    prix_unitaire * (1 + taux_tva) AS prix_ttc,
    prix_unitaire * (1 - remise/100) AS prix_avec_remise,
    ROUND(prix_unitaire * (1 + taux_tva) * (1 - remise/100), 2) AS prix_final
FROM produits_boutique;
```

**R√©sultat** :
```
+---------------------+---------------+----------+-------------------+------------+
| nom                 | prix_unitaire | prix_ttc | prix_avec_remise  | prix_final |
+---------------------+---------------+----------+-------------------+------------+
| Ordinateur portable | 899.99        | 1079.99  | 809.99            | 971.99     |
| Souris sans fil     | 24.90         | 29.88    | 24.90             | 29.88      |
| Clavier m√©canique   | 159.99        | 191.99   | 151.99            | 182.39     |
+---------------------+---------------+----------+-------------------+------------+
```

üí° **Cas d'usage DECIMAL** :
- ‚úÖ Prix, montants financiers
- ‚úÖ Taux (TVA, int√©r√™ts, commissions)
- ‚úÖ Pourcentages pr√©cis
- ‚úÖ Mesures scientifiques n√©cessitant pr√©cision

‚ö†Ô∏è **Important** : DECIMAL(10,2) stocke exactement 2 d√©cimales. 10.999 sera arrondi √† 11.00.

```sql
-- D√©monstration de la pr√©cision
CREATE TABLE test_precision (
    montant DECIMAL(10, 2)
);

INSERT INTO test_precision VALUES (10.126);  -- Stocke 10.13 (arrondi)
INSERT INTO test_precision VALUES (10.124);  -- Stocke 10.12 (arrondi)

SELECT * FROM test_precision;
-- R√©sultat : 10.13 et 10.12 (pas 10.126 ni 10.124)
```

---

### FLOAT - Nombre flottant simple pr√©cision

**Taille** : 4 octets (32 bits)
**Pr√©cision** : ~7 chiffres significatifs

**Utilisation** : Valeurs scientifiques o√π une approximation est acceptable.

```sql
-- Exemple : Mesures scientifiques
CREATE TABLE mesures_laboratoire (
    mesure_id INT PRIMARY KEY AUTO_INCREMENT,
    temperature_celsius FLOAT,              -- Temp√©rature
    pression_bar FLOAT,                     -- Pression
    concentration_mol FLOAT,                -- Concentration molaire
    distance_km FLOAT                       -- Distance
);

-- Insertion de valeurs flottantes
INSERT INTO mesures_laboratoire (temperature_celsius, pression_bar, concentration_mol, distance_km) VALUES
    (23.456789, 1.01325, 0.000123, 1234567.89),
    (-15.234, 0.98, 0.5, 999.999),
    (100.1, 2.5, 1.23456789, 0.001);

-- Consultation
SELECT * FROM mesures_laboratoire;
```

‚ö†Ô∏è **Probl√®me de pr√©cision avec FLOAT** :

```sql
-- D√©monstration du probl√®me
CREATE TABLE test_float (
    valeur FLOAT
);

INSERT INTO test_float VALUES (0.1 + 0.2);  -- Math√©matiquement = 0.3

SELECT * FROM test_float;
-- R√©sultat : 0.300000011920929 (approximation !)

-- Comparaison probl√©matique
SELECT * FROM test_float WHERE valeur = 0.3;
-- Peut ne rien retourner √† cause de l'impr√©cision !
```

üí° **Quand utiliser FLOAT** :
- ‚úÖ Calculs scientifiques avec grande plage de valeurs
- ‚úÖ Coordonn√©es GPS (latitude/longitude)
- ‚úÖ Mesures physiques (temp√©rature, pression)
- ‚ùå **JAMAIS pour l'argent**

---

### DOUBLE - Nombre flottant double pr√©cision

**Taille** : 8 octets (64 bits)
**Pr√©cision** : ~15-16 chiffres significatifs

**Utilisation** : Comme FLOAT mais avec plus de pr√©cision.

```sql
-- Exemple : Calculs astronomiques
CREATE TABLE corps_celestes (
    nom VARCHAR(50) PRIMARY KEY,
    distance_terre_km DOUBLE,              -- Distance en km
    masse_kg DOUBLE,                       -- Masse en kg
    rayon_km DOUBLE,                       -- Rayon en km
    temperature_kelvin DOUBLE              -- Temp√©rature
);

-- Insertion de valeurs astronomiques (tr√®s grandes et tr√®s petites)
INSERT INTO corps_celestes VALUES
    ('Soleil', 149597870.7, 1.989e30, 696000, 5778),
    ('Lune', 384400, 7.342e22, 1737.4, 220),
    ('Mars', 225000000, 6.4171e23, 3389.5, 210);

-- Calculs avec DOUBLE
SELECT
    nom,
    distance_terre_km,
    distance_terre_km / 299792.458 AS temps_lumiere_secondes,
    masse_kg / 5.972e24 AS masse_relative_terre
FROM corps_celestes;
```

üí° **Diff√©rence FLOAT vs DOUBLE** :

```sql
-- Comparaison de pr√©cision
CREATE TABLE test_precision_float (
    valeur_float FLOAT,
    valeur_double DOUBLE
);

INSERT INTO test_precision_float VALUES
    (1.123456789012345, 1.123456789012345);

SELECT * FROM test_precision_float;
-- valeur_float  : 1.12346 (7 chiffres)
-- valeur_double : 1.123456789012345 (15 chiffres)
```

---

## Choix du type num√©rique appropri√©

### Arbre de d√©cision

```
Votre nombre a-t-il des d√©cimales ?
‚îÇ
‚îú‚îÄ NON ‚Üí Utiliser un type ENTIER
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ Valeur entre 0-255 ‚Üí TINYINT UNSIGNED
‚îÇ   ‚îú‚îÄ Valeur entre 0-65K ‚Üí SMALLINT UNSIGNED
‚îÇ   ‚îú‚îÄ Valeur entre 0-4B ‚Üí INT UNSIGNED (d√©faut recommand√©)
‚îÇ   ‚îî‚îÄ Valeur > 4B ‚Üí BIGINT UNSIGNED
‚îÇ
‚îî‚îÄ OUI ‚Üí Avez-vous besoin de pr√©cision exacte ?
    ‚îÇ
    ‚îú‚îÄ OUI (argent, finance) ‚Üí DECIMAL(M,D)
    ‚îÇ   ‚îî‚îÄ Exemple : DECIMAL(10,2) pour des prix
    ‚îÇ
    ‚îî‚îÄ NON (scientifique) ‚Üí FLOAT ou DOUBLE
        ‚îú‚îÄ Plage normale ‚Üí FLOAT
        ‚îî‚îÄ Tr√®s grande plage ‚Üí DOUBLE
```

---

### Exemples par cas d'usage

```sql
-- ‚úÖ Recommandations par type de donn√©es

CREATE TABLE guide_types_numeriques (
    -- IDENTIFIANTS
    id INT PRIMARY KEY AUTO_INCREMENT,           -- Cl√© primaire standard
    user_id BIGINT UNSIGNED,                     -- ID utilisateur (distribu√©)

    -- √ÇGE ET PETITES VALEURS
    age TINYINT UNSIGNED,                        -- 0-255
    note_sur_10 TINYINT UNSIGNED,                -- 0-10

    -- QUANTIT√âS
    stock INT UNSIGNED DEFAULT 0,                -- Quantit√© en stock
    nombre_vues BIGINT UNSIGNED DEFAULT 0,       -- Compteur de vues

    -- PRIX ET ARGENT (TOUJOURS DECIMAL)
    prix_euros DECIMAL(10,2),                    -- Prix en euros
    prix_centimes INT UNSIGNED,                  -- Alternative : stocker en centimes

    -- POURCENTAGES ET TAUX
    taux_tva DECIMAL(5,4),                       -- 0.2000 = 20.00%
    taux_interet DECIMAL(6,4),                   -- 0.0325 = 3.25%

    -- MESURES SCIENTIFIQUES
    temperature FLOAT,                           -- Temp√©rature en ¬∞C
    coordonnee_gps_lat DOUBLE,                   -- Latitude GPS
    coordonnee_gps_lng DOUBLE,                   -- Longitude GPS

    -- POIDS ET MESURES PR√âCISES
    poids_grammes INT UNSIGNED,                  -- Poids en grammes (entier)
    poids_kg DECIMAL(8,3),                       -- Poids en kg (3 d√©cimales)

    -- TIMESTAMPS
    timestamp_creation INT UNSIGNED,             -- Unix timestamp (jusqu'√† 2038)
    timestamp_ms BIGINT UNSIGNED                 -- Timestamp en millisecondes
);
```

---

## Pi√®ges courants √† √©viter

### 1. Utiliser FLOAT/DOUBLE pour l'argent

```sql
-- ‚ùå MAUVAIS : Perte de pr√©cision
CREATE TABLE mauvais_exemple (
    prix FLOAT  -- ERREUR !
);

INSERT INTO mauvais_exemple VALUES (10.1);
SELECT prix * 3 FROM mauvais_exemple;  -- R√©sultat : 30.299999... au lieu de 30.3

-- ‚úÖ BON : Pr√©cision garantie
CREATE TABLE bon_exemple (
    prix DECIMAL(10,2)  -- Toujours DECIMAL pour l'argent
);

INSERT INTO bon_exemple VALUES (10.10);
SELECT prix * 3 FROM bon_exemple;  -- R√©sultat exact : 30.30
```

---

### 2. D√©bordement avec UNSIGNED

```sql
-- ‚ùå Attention au d√©bordement
CREATE TABLE compteur (
    visites INT UNSIGNED DEFAULT 0
);

INSERT INTO compteur VALUES (0);

-- Tentative de d√©cr√©mentation
UPDATE compteur SET visites = visites - 1;
-- R√©sultat : 4294967295 (d√©bordement !) au lieu de -1
```

---

### 3. Mauvaise estimation de la plage

```sql
-- ‚ùå Type trop petit
CREATE TABLE produits_erreur (
    prix TINYINT  -- Max 127 ou 255 avec UNSIGNED
);

INSERT INTO produits_erreur VALUES (299);
-- ERROR: Out of range value

-- ‚úÖ Type adapt√©
CREATE TABLE produits_correct (
    prix DECIMAL(10,2)  -- Jusqu'√† 99999999.99
);
```

---

### 4. Oublier UNSIGNED pour les valeurs positives

```sql
-- ‚ùå Gaspillage d'espace
CREATE TABLE exemple_signed (
    quantite INT  -- Accepte -2B √† +2B, mais quantit√© toujours positive
);

-- ‚úÖ Optimis√©
CREATE TABLE exemple_unsigned (
    quantite INT UNSIGNED  -- 0 √† 4B, plus adapt√©
);
```

---

## Conversions et castings

### Conversion implicite

```sql
-- MariaDB convertit automatiquement les types si n√©cessaire
SELECT
    10 + 5.5 AS resultat,          -- INT + DECIMAL = DECIMAL : 15.5
    10 / 3 AS division_entiere,    -- 3.3333
    10 DIV 3 AS division_euclidienne,  -- 3 (division enti√®re)
    10 % 3 AS modulo;              -- 1 (reste de la division)
```

### Conversion explicite avec CAST

```sql
-- Convertir explicitement les types
SELECT
    CAST(123.456 AS SIGNED) AS entier,              -- 123
    CAST(123.456 AS DECIMAL(10,2)) AS deux_decimales,  -- 123.46
    CAST('123' AS SIGNED) AS chaine_vers_entier,    -- 123
    CAST(123 AS CHAR) AS entier_vers_chaine;        -- '123'

-- Utilisation dans des calculs
SELECT
    prix,
    CAST(prix AS SIGNED) AS prix_arrondi,
    FLOOR(prix) AS prix_inferieur,
    CEILING(prix) AS prix_superieur
FROM produits_boutique;
```

---

## Performances et optimisations

### Impact sur l'index

```sql
-- Les entiers sont plus performants pour les index
CREATE TABLE comparaison_index (
    id_int INT PRIMARY KEY,
    id_bigint BIGINT,
    prix DECIMAL(10,2),
    mesure DOUBLE
);

-- Index sur INT : Tr√®s rapide
CREATE INDEX idx_int ON comparaison_index(id_int);

-- Index sur DECIMAL : Plus lent que INT
CREATE INDEX idx_prix ON comparaison_index(prix);
```

üí° **Recommandation** : Utilisez INT ou BIGINT pour les cl√©s primaires et √©trang√®res, jamais DECIMAL ou FLOAT.

---

## ‚úÖ Points cl√©s √† retenir

- **Entiers** : TINYINT < SMALLINT < MEDIUMINT < INT < BIGINT
- **UNSIGNED** double la plage positive (0 √† 2√ómax au lieu de -max √† +max)
- **AUTO_INCREMENT** : Toujours avec INT ou BIGINT pour les cl√©s primaires
- **DECIMAL** : **OBLIGATOIRE** pour l'argent et les valeurs n√©cessitant pr√©cision exacte
- **FLOAT/DOUBLE** : Uniquement pour calculs scientifiques, jamais pour l'argent
- Choisir le **type le plus petit** qui convient (optimisation m√©moire)
- **INT** est le choix par d√©faut pour les entiers (bon compromis)
- **DECIMAL(10,2)** est le standard pour les prix en euros/dollars

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB
- [üìñ Numeric Data Types](https://mariadb.com/kb/en/numeric-data-types/)
- [üìñ INT, BIGINT, TINYINT](https://mariadb.com/kb/en/int/)
- [üìñ DECIMAL](https://mariadb.com/kb/en/decimal/)
- [üìñ FLOAT](https://mariadb.com/kb/en/float/)
- [üìñ DOUBLE](https://mariadb.com/kb/en/double/)
- [üìñ AUTO_INCREMENT](https://mariadb.com/kb/en/auto_increment/)

### Lectures compl√©mentaires
- [What Every Programmer Should Know About Floating-Point](https://floating-point-gui.de/)
- [IEEE 754 Floating Point Standard](https://en.wikipedia.org/wiki/IEEE_754)

---

## ‚û°Ô∏è Section suivante

**[2.2.2 Types de texte (VARCHAR, TEXT, CHAR, ENUM, SET)](/02-bases-du-sql/02.2-types-texte.md)**

D√©couvrez les types de donn√©es pour stocker du texte : VARCHAR vs TEXT, quand utiliser CHAR, les types ENUM et SET, et les consid√©rations importantes sur les charsets et collations avec le nouveau d√©faut utf8mb4 de MariaDB 11.8 üÜï.

---


‚è≠Ô∏è [Texte (VARCHAR, TEXT, CHAR, ENUM, SET)](/02-bases-du-sql/02.2-types-texte.md)
