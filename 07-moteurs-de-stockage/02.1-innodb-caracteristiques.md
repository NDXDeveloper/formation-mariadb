ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 7.2.1 CaractÃ©ristiques d'InnoDB : ACID, Foreign Keys et Row-level Locking

> **Niveau** : AvancÃ©
> **DurÃ©e estimÃ©e** : 2 heures

> **PrÃ©requis** :
> - ComprÃ©hension des concepts de bases de donnÃ©es relationnelles
> - Notions de transactions et concurrence (Section 6)
> - Architecture gÃ©nÃ©rale d'un SGBD (Section 1.4)

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre en profondeur les propriÃ©tÃ©s ACID d'InnoDB et leur mise en Å“uvre technique
- MaÃ®triser le mÃ©canisme des Foreign Keys et leur impact sur la performance
- Exploiter le Row-level locking pour optimiser la concurrence
- Configurer InnoDB pour diffÃ©rents profils de charge (OLTP, mixed workload)
- Diagnostiquer et rÃ©soudre les problÃ¨mes de verrouillage et d'intÃ©gritÃ© rÃ©fÃ©rentielle

---

## Introduction

**InnoDB** est le moteur de stockage par dÃ©faut de MariaDB depuis la version 10.2 et reste le choix privilÃ©giÃ© pour la majoritÃ© des applications en production. ConÃ§u dÃ¨s l'origine pour les charges transactionnelles (OLTP), InnoDB se distingue par trois caractÃ©ristiques fondamentales qui en font un moteur robuste et fiable :

1. **ConformitÃ© ACID complÃ¨te** : Garantie d'intÃ©gritÃ© des transactions
2. **Support natif des Foreign Keys** : IntÃ©gritÃ© rÃ©fÃ©rentielle au niveau moteur
3. **Row-level locking** : Concurrence optimale pour les environnements multi-utilisateurs

Ces caractÃ©ristiques font d'InnoDB le moteur de rÃ©fÃ©rence pour les applications critiques nÃ©cessitant cohÃ©rence des donnÃ©es, intÃ©gritÃ© rÃ©fÃ©rentielle et haute concurrence. Contrairement aux moteurs legacy comme MyISAM (table-level locking, pas de transactions), InnoDB offre un Ã©quilibre optimal entre performance et fiabilitÃ©.

ğŸ’¡ **Note importante** : Dans MariaDB 11.8 LTS, InnoDB bÃ©nÃ©ficie d'optimisations significatives, notamment pour les SSD (cost-based optimizer amÃ©liorÃ©) et la construction d'index (`innodb_alter_copy_bulk`).

---

## Les PropriÃ©tÃ©s ACID d'InnoDB

### Comprendre ACID

ACID est l'acronyme de quatre propriÃ©tÃ©s fondamentales garantissant la fiabilitÃ© des transactions dans un systÃ¨me de bases de donnÃ©es :

#### **A - Atomicity (AtomicitÃ©)**

Une transaction est **atomique** : elle s'exÃ©cute entiÃ¨rement ou pas du tout. Il n'existe pas d'Ã©tat intermÃ©diaire.

**ImplÃ©mentation dans InnoDB** :
- Utilisation de l'**Undo Log** pour stocker les versions antÃ©rieures des lignes modifiÃ©es
- En cas de `ROLLBACK` ou de crash, InnoDB utilise l'Undo Log pour restaurer l'Ã©tat initial
- Les modifications ne deviennent visibles qu'aprÃ¨s un `COMMIT` rÃ©ussi

```sql
-- Exemple d'atomicitÃ©
START TRANSACTION;

-- Ces deux opÃ©rations forment une unitÃ© atomique
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

-- Si une erreur survient (ex: violation de contrainte),
-- ROLLBACK annule TOUTES les modifications
COMMIT; -- Les deux modifications deviennent visibles simultanÃ©ment
```

ğŸ’¡ **En production** : L'atomicitÃ© garantit qu'un transfert d'argent entre comptes ne peut pas laisser le systÃ¨me dans un Ã©tat incohÃ©rent (argent dÃ©bitÃ© mais non crÃ©ditÃ©).

#### **C - Consistency (CohÃ©rence)**

Une transaction fait passer la base de donnÃ©es d'un **Ã©tat cohÃ©rent Ã  un autre Ã©tat cohÃ©rent**, en respectant toutes les contraintes dÃ©finies.

**MÃ©canismes de cohÃ©rence dans InnoDB** :
- **Contraintes d'intÃ©gritÃ©** : PRIMARY KEY, UNIQUE, NOT NULL, CHECK
- **Foreign Keys** : IntÃ©gritÃ© rÃ©fÃ©rentielle appliquÃ©e par le moteur
- **Triggers** : Logique mÃ©tier garantissant la cohÃ©rence

```sql
-- Exemple de cohÃ©rence avec Foreign Keys
CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT NOT NULL,
    order_date DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
        ON DELETE RESTRICT  -- EmpÃªche la suppression incohÃ©rente
        ON UPDATE CASCADE   -- Propage les modifications
) ENGINE=InnoDB;

-- Tentative de violation de cohÃ©rence
INSERT INTO orders (customer_id) VALUES (9999);
-- ERROR 1452: Cannot add or update a child row:
-- a foreign key constraint fails
```

âš ï¸ **Attention** : La cohÃ©rence n'est garantie que si toutes les contraintes sont correctement dÃ©finies. InnoDB applique les contraintes, mais c'est au concepteur de les dÃ©finir judicieusement.

#### **I - Isolation**

Les transactions concurrentes sont **isolÃ©es** les unes des autres, selon le niveau d'isolation configurÃ©.

**ImplÃ©mentation avec MVCC** :
InnoDB utilise le **Multi-Version Concurrency Control (MVCC)** pour fournir l'isolation sans blocage excessif :

```sql
-- Session 1 : Transaction de lecture longue
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;

SELECT SUM(amount) FROM transactions WHERE account_id = 1;
-- RÃ©sultat : 10000

-- Session 2 (en parallÃ¨le) : Insertion d'une nouvelle transaction
INSERT INTO transactions (account_id, amount) VALUES (1, 500);
COMMIT;

-- Session 1 : Re-lecture
SELECT SUM(amount) FROM transactions WHERE account_id = 1;
-- RÃ©sultat : toujours 10000 (vue cohÃ©rente grÃ¢ce Ã  MVCC)
-- La session 1 ne voit pas l'insertion de la session 2

COMMIT;

-- AprÃ¨s commit, nouvelle transaction verra 10500
SELECT SUM(amount) FROM transactions WHERE account_id = 1;
-- RÃ©sultat : 10500
```

**Niveaux d'isolation disponibles** (dÃ©taillÃ©s en Section 6.3) :
1. `READ UNCOMMITTED` : Dirty reads possibles
2. `READ COMMITTED` : Pas de dirty reads
3. `REPEATABLE READ` : **DÃ©faut InnoDB**, pas de non-repeatable reads
4. `SERIALIZABLE` : Isolation maximale

ğŸ’¡ **Best practice** : `REPEATABLE READ` offre le meilleur compromis pour la plupart des applications OLTP.

#### **D - Durability (DurabilitÃ©)**

Une fois une transaction **validÃ©e** (`COMMIT`), ses modifications sont **permanentes**, mÃªme en cas de crash systÃ¨me.

**MÃ©canismes de durabilitÃ©** :
- **Redo Log** (InnoDB log files) : Enregistre toutes les modifications
- **Double Write Buffer** : Protection contre les partial page writes
- **Fsync** : Synchronisation disque garantie

```sql
-- Configuration de la durabilitÃ© (my.cnf)
[mysqld]
# DurabilitÃ© maximale (dÃ©faut)
innodb_flush_log_at_trx_commit = 1

# Options pour performance vs durabilitÃ©
# 0 : Flush tous les 1s (meilleure perf, risque perte 1s donnÃ©es)
# 1 : Flush Ã  chaque commit (durabilitÃ© maximale, dÃ©faut)
# 2 : Flush vers OS cache, Ã©criture disque 1s (compromis)
```

**Comportement en cas de crash** :
```sql
-- ScÃ©nario de crash
START TRANSACTION;
INSERT INTO orders VALUES (1, 100, NOW());
COMMIT; -- Transaction validÃ©e

-- [CRASH SYSTÃˆME ICI]

-- Au redÃ©marrage de MariaDB :
-- InnoDB lit le Redo Log et rejoue les transactions commitÃ©es
-- La ligne INSERT est garantie prÃ©sente dans la table orders
```

âš ï¸ **Trade-off performance/durabilitÃ©** :
- `innodb_flush_log_at_trx_commit=1` : SÃ©curitÃ© maximale, ~50-70% de rÃ©duction des IOPS
- `innodb_flush_log_at_trx_commit=2` : Bon compromis, perte potentielle de 1s de donnÃ©es si crash OS
- Sur SSD avec write cache protÃ©gÃ© par batterie, l'impact est nÃ©gligeable

---

## Support des Foreign Keys

### IntÃ©gritÃ© RÃ©fÃ©rentielle Native

InnoDB est le **seul moteur MariaDB natif** supportant pleinement les contraintes de Foreign Keys (clÃ©s Ã©trangÃ¨res). Cette fonctionnalitÃ© critique garantit l'intÃ©gritÃ© rÃ©fÃ©rentielle au niveau du moteur de stockage.

### Syntaxe et CrÃ©ation

```sql
-- CrÃ©ation de tables avec Foreign Keys
CREATE TABLE customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;

CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT NOT NULL,
    order_date DATETIME DEFAULT CURRENT_TIMESTAMP,
    total_amount DECIMAL(10,2) NOT NULL,

    -- DÃ©finition de la Foreign Key
    CONSTRAINT fk_customer
        FOREIGN KEY (customer_id)
        REFERENCES customers(customer_id)
        ON DELETE RESTRICT      -- Action sur suppression parent
        ON UPDATE CASCADE,      -- Action sur mise Ã  jour parent

    INDEX idx_customer (customer_id)  -- Index requis sur FK
) ENGINE=InnoDB;

-- Ajout de FK sur table existante
ALTER TABLE order_items
    ADD CONSTRAINT fk_order
    FOREIGN KEY (order_id)
    REFERENCES orders(order_id)
    ON DELETE CASCADE;
```

ğŸ’¡ **RÃ¨gle importante** : La colonne rÃ©fÃ©rencÃ©e (parent) doit avoir un index (PRIMARY KEY ou UNIQUE). La colonne rÃ©fÃ©rente (child) doit aussi avoir un index.

### Actions RÃ©fÃ©rentielles

InnoDB supporte quatre actions rÃ©fÃ©rentielles pour `ON DELETE` et `ON UPDATE` :

#### **1. RESTRICT (dÃ©faut)**
EmpÃªche la modification/suppression si des lignes enfants existent.

```sql
-- Configuration
ON DELETE RESTRICT

-- Tentative de suppression
DELETE FROM customers WHERE customer_id = 1;
-- ERROR 1451: Cannot delete or update a parent row:
-- a foreign key constraint fails
```

#### **2. CASCADE**
Propage la modification/suppression aux lignes enfants.

```sql
-- Configuration
ON DELETE CASCADE

-- Suppression du client
DELETE FROM customers WHERE customer_id = 1;
-- RÃ©sultat : toutes les commandes du client sont aussi supprimÃ©es

-- Mise Ã  jour de l'ID
UPDATE customers SET customer_id = 999 WHERE customer_id = 1;
-- RÃ©sultat : toutes les FK dans orders sont mises Ã  jour vers 999
```

âš ï¸ **Attention CASCADE** : Peut entraÃ®ner des suppressions en cascade importantes. Ã€ utiliser avec prÃ©caution.

#### **3. SET NULL**
Met la colonne FK Ã  NULL lors de la suppression/modification du parent.

```sql
-- La colonne FK doit autoriser NULL
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT NULL,  -- Doit accepter NULL
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
        ON DELETE SET NULL
) ENGINE=InnoDB;

-- Suppression du client
DELETE FROM customers WHERE customer_id = 1;
-- RÃ©sultat : orders.customer_id devient NULL pour toutes les commandes
```

#### **4. NO ACTION**
Identique Ã  `RESTRICT` dans InnoDB (vÃ©rifie la contrainte Ã  la fin de la transaction).

### Impact sur les Performances

Les Foreign Keys ont un **coÃ»t de performance** non nÃ©gligeable :

**CoÃ»ts d'exÃ©cution** :
- âœ… **INSERT** : VÃ©rification de l'existence du parent (1 requÃªte supplÃ©mentaire)
- âœ… **UPDATE** : VÃ©rification + propagation si CASCADE
- âœ… **DELETE** : VÃ©rification des enfants + propagation si CASCADE

```sql
-- Mesure de l'impact
-- Sans FK (10000 insertions)
-- Time: 0.8s

-- Avec FK (10000 insertions)
-- Time: 1.2s (+50%)

-- L'impact est proportionnel au nombre de FK sur la table
```

ğŸ’¡ **Optimisations** :
```sql
-- 1. Toujours indexer les colonnes FK
CREATE INDEX idx_customer_id ON orders(customer_id);

-- 2. VÃ©rifier l'utilisation des index
EXPLAIN SELECT * FROM orders WHERE customer_id = 1;

-- 3. Utiliser des transactions pour les opÃ©rations en masse
START TRANSACTION;
-- Insertions multiples
COMMIT;

-- 4. DÃ©sactiver temporairement les vÃ©rifications (USE WITH CAUTION)
SET FOREIGN_KEY_CHECKS = 0;
-- OpÃ©rations de chargement massif
SET FOREIGN_KEY_CHECKS = 1;
```

âš ï¸ **Mise en garde** : Ne dÃ©sactivez `FOREIGN_KEY_CHECKS` qu'en environnement contrÃ´lÃ© (migration, import initial). Toujours rÃ©activer ensuite.

### Visualisation des Foreign Keys

```sql
-- Lister toutes les FK d'une base
SELECT
    CONSTRAINT_NAME,
    TABLE_NAME,
    COLUMN_NAME,
    REFERENCED_TABLE_NAME,
    REFERENCED_COLUMN_NAME,
    UPDATE_RULE,
    DELETE_RULE
FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
WHERE REFERENCED_TABLE_SCHEMA = 'my_database'
    AND REFERENCED_TABLE_NAME IS NOT NULL;

-- DÃ©tails sur une FK spÃ©cifique
SHOW CREATE TABLE orders\G
```

### Cas d'Usage : Quand Utiliser les Foreign Keys

âœ… **Ã€ privilÃ©gier quand** :
- IntÃ©gritÃ© des donnÃ©es critique (finance, santÃ©, lÃ©gal)
- ModÃ¨le relationnel complexe avec nombreuses rÃ©fÃ©rences
- Ã‰quipe de dÃ©veloppement nÃ©cessitant des garde-fous
- Application mature avec schÃ©ma stable

âŒ **Ã€ Ã©viter quand** :
- Performance critique avec trÃ¨s haut dÃ©bit d'Ã©critures (>10k TPS)
- Architecture microservices avec bases sÃ©parÃ©es
- SchÃ©ma Ã©volutif nÃ©cessitant flexibilitÃ©
- Sharding/partitionnement horizontal prÃ©vu

ğŸ”„ **Alternatives** :
```sql
-- VÃ©rifications applicatives (dans le code)
-- + FlexibilitÃ©
-- - IntÃ©gritÃ© non garantie au niveau BDD

-- Triggers personnalisÃ©s
DELIMITER //
CREATE TRIGGER check_customer_exists
BEFORE INSERT ON orders
FOR EACH ROW
BEGIN
    IF NOT EXISTS (SELECT 1 FROM customers WHERE customer_id = NEW.customer_id) THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Customer does not exist';
    END IF;
END//
DELIMITER ;
```

---

## Row-level Locking : Concurrence Optimale

### Principe du Verrouillage par Ligne

InnoDB implÃ©mente le **Row-level locking** : seules les lignes effectivement accÃ©dÃ©es sont verrouillÃ©es, permettant une concurrence maximale.

**Comparaison avec Table-level locking (MyISAM)** :

```sql
-- MyISAM (table-level)
Session 1: UPDATE users SET status = 'active' WHERE user_id = 1;
-- Verrouille TOUTE la table users

Session 2: UPDATE users SET status = 'active' WHERE user_id = 2;
-- BLOQUÃ‰E, attend la fin de Session 1

-- InnoDB (row-level)
Session 1: UPDATE users SET status = 'active' WHERE user_id = 1;
-- Verrouille SEULEMENT la ligne user_id=1

Session 2: UPDATE users SET status = 'active' WHERE user_id = 2;
-- S'exÃ©cute IMMÃ‰DIATEMENT (ligne diffÃ©rente)
```

### Types de Verrous InnoDB

InnoDB utilise deux types principaux de verrous :

#### **1. Shared Locks (S) - Verrous PartagÃ©s**

Permet la lecture, empÃªche l'Ã©criture.

```sql
-- Acquisition explicite avec SELECT ... FOR SHARE (ou LOCK IN SHARE MODE)
START TRANSACTION;

SELECT * FROM products
WHERE product_id = 100
FOR SHARE;  -- Verrou partagÃ©

-- Autre session peut aussi lire
-- Autre session BLOQUÃ‰E si UPDATE/DELETE
```

**Cas d'usage** : Lecture avec garantie que les donnÃ©es ne changeront pas durant la transaction.

#### **2. Exclusive Locks (X) - Verrous Exclusifs**

EmpÃªche toute autre lecture ou Ã©criture.

```sql
-- Acquisition automatique avec UPDATE, DELETE
-- Acquisition explicite avec SELECT ... FOR UPDATE
START TRANSACTION;

SELECT * FROM products
WHERE product_id = 100
FOR UPDATE;  -- Verrou exclusif

-- Autre session BLOQUÃ‰E pour tout accÃ¨s (lecture/Ã©criture)

-- Modification garantie sans concurrence
UPDATE products SET stock = stock - 1 WHERE product_id = 100;
COMMIT;
```

**Cas d'usage** : Modification avec garantie d'exclusivitÃ© (dÃ©crÃ©mentation de stock, rÃ©servations).

### GranularitÃ© des Verrous

InnoDB utilise une hiÃ©rarchie de verrous :

```
Database
 â””â”€â”€ Table
      â”œâ”€â”€ Index (tree structure)
      â”‚    â””â”€â”€ Index record locks
      â””â”€â”€ Rows
           â””â”€â”€ Record locks
```

**Types de verrous par granularitÃ©** :

1. **Record Lock** : Verrou sur une ligne spÃ©cifique
2. **Gap Lock** : Verrou sur un "espace" entre deux index (prÃ©vient les phantom reads)
3. **Next-Key Lock** : Combinaison Record + Gap (dÃ©faut en REPEATABLE READ)

```sql
-- Exemple de Next-Key Lock
-- Table products avec index sur price

START TRANSACTION;
-- Recherche avec condition range
SELECT * FROM products WHERE price BETWEEN 10 AND 20 FOR UPDATE;

-- InnoDB verrouille :
-- 1. Toutes les lignes avec price dans [10, 20]
-- 2. Les "gaps" autour (prÃ©vient l'insertion de nouvelles lignes dans ce range)

-- Autre session : cette insertion est BLOQUÃ‰E
INSERT INTO products (name, price) VALUES ('New Product', 15);
-- Attend la fin de la transaction 1
```

ğŸ’¡ **Optimisation** : Les Gap Locks peuvent Ãªtre dÃ©sactivÃ©s en `READ COMMITTED`, au prix d'une isolation moindre :

```sql
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
-- Les gap locks sont dÃ©sactivÃ©s (sauf pour FK et duplicate-key checking)
```

### Monitoring des Verrous

```sql
-- Voir les transactions actives
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX\G

-- Voir les verrous en cours
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS\G

-- Voir les attentes de verrous
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS\G

-- Performance Schema (MariaDB 11.8)
SELECT
    OBJECT_SCHEMA,
    OBJECT_NAME,
    LOCK_TYPE,
    LOCK_MODE,
    LOCK_STATUS,
    LOCK_DATA
FROM performance_schema.data_locks
ORDER BY LOCK_DATA;
```

### StratÃ©gies pour Minimiser les Conflits

#### **1. RequÃªtes Courtes et Rapides**

```sql
-- âŒ Mauvais : Transaction longue
START TRANSACTION;
SELECT * FROM orders WHERE customer_id = 1;  -- Verrous acquis
-- [Traitement applicatif long - 5 secondes]
UPDATE orders SET status = 'processed';
COMMIT;

-- âœ… Bon : SÃ©parer lecture et Ã©criture
SELECT * FROM orders WHERE customer_id = 1;
-- [Traitement applicatif]
START TRANSACTION;
UPDATE orders SET status = 'processed' WHERE order_id = 123;
COMMIT;
```

#### **2. Ordre CohÃ©rent des AccÃ¨s**

```sql
-- âŒ Risque de deadlock
-- Session 1
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

-- Session 2 (ordre inverse)
UPDATE accounts SET balance = balance - 50 WHERE account_id = 2;
UPDATE accounts SET balance = balance + 50 WHERE account_id = 1;
-- DEADLOCK POSSIBLE

-- âœ… Ordre cohÃ©rent (par account_id croissant)
-- Les deux sessions accÃ¨dent dans le mÃªme ordre -> pas de deadlock
```

#### **3. Index AppropriÃ©s**

```sql
-- Sans index : InnoDB doit scanner toute la table = nombreux verrous
UPDATE users SET status = 'active' WHERE email = 'user@example.com';
-- Peut verrouiller des milliers de lignes si scan complet

-- Avec index sur email : verrouillage prÃ©cis
CREATE INDEX idx_email ON users(email);
UPDATE users SET status = 'active' WHERE email = 'user@example.com';
-- Verrouille uniquement la ligne concernÃ©e
```

#### **4. Batch Updates avec Limite**

```sql
-- âŒ Mise Ã  jour massive en une transaction
UPDATE orders SET status = 'archived' WHERE order_date < '2023-01-01';
-- Peut verrouiller des millions de lignes

-- âœ… Batch processing
DELIMITER //
CREATE PROCEDURE archive_old_orders()
BEGIN
    DECLARE rows_affected INT DEFAULT 1;

    WHILE rows_affected > 0 DO
        UPDATE orders
        SET status = 'archived'
        WHERE order_date < '2023-01-01'
          AND status != 'archived'
        LIMIT 1000;

        SET rows_affected = ROW_COUNT();
        -- Petit dÃ©lai entre chaque batch
        DO SLEEP(0.1);
    END WHILE;
END//
DELIMITER ;
```

### Deadlocks : DÃ©tection et RÃ©solution

InnoDB dÃ©tecte automatiquement les deadlocks et annule l'une des transactions.

```sql
-- Session 1
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
-- [Attend]
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

-- Session 2
START TRANSACTION;
UPDATE accounts SET balance = balance - 50 WHERE account_id = 2;
-- [Attend]
UPDATE accounts SET balance = balance + 50 WHERE account_id = 1;

-- InnoDB dÃ©tecte le deadlock et rollback une transaction
-- ERROR 1213 (40001): Deadlock found when trying to get lock;
-- try restarting transaction
```

**Visualiser les deadlocks** :

```sql
-- Dernier deadlock dÃ©tectÃ©
SHOW ENGINE INNODB STATUS\G

-- Section "LATEST DETECTED DEADLOCK"
-- Affiche les transactions impliquÃ©es et les verrous
```

ğŸ’¡ **Best practice** : ImplÃ©menter une logique de retry automatique dans l'application pour les erreurs de deadlock (code 1213).

---

## Configuration AvancÃ©e pour InnoDB

### Variables SystÃ¨me Essentielles

```sql
-- Buffer Pool (mÃ©moire cache)
innodb_buffer_pool_size = 8G          -- 70-80% RAM disponible
innodb_buffer_pool_instances = 8      -- 1 instance par Go (max 64)

-- Logs de transaction (durabilitÃ©)
innodb_log_file_size = 512M           -- Taille de chaque fichier redo log
innodb_log_buffer_size = 16M          -- Buffer mÃ©moire pour redo log
innodb_flush_log_at_trx_commit = 1    -- DurabilitÃ© maximale

-- I/O et performance
innodb_io_capacity = 2000             -- IOPS disponibles (SSD)
innodb_io_capacity_max = 4000         -- Burst IOPS
innodb_flush_method = O_DIRECT        -- Bypass OS cache (Linux)
innodb_read_io_threads = 8            -- Threads de lecture
innodb_write_io_threads = 8           -- Threads d'Ã©criture

-- Concurrence et verrous
innodb_lock_wait_timeout = 50         -- Timeout d'attente de verrou (secondes)
innodb_deadlock_detect = ON           -- DÃ©tection de deadlocks
innodb_thread_concurrency = 0         -- 0 = illimitÃ© (recommandÃ©)

-- Compression (Ã©conomie d'espace)
innodb_file_per_table = ON            -- Fichier .ibd par table
innodb_page_size = 16384              -- 16KB (dÃ©faut)
```

### Profils de Configuration

#### **OLTP (High Concurrency, Low Latency)**

```ini
[mysqld]
# OptimisÃ© pour nombreuses petites transactions
innodb_buffer_pool_size = 12G
innodb_buffer_pool_instances = 12
innodb_log_file_size = 256M
innodb_flush_log_at_trx_commit = 1
innodb_flush_method = O_DIRECT

# SSD moderne
innodb_io_capacity = 3000
innodb_io_capacity_max = 6000

# Concurrence Ã©levÃ©e
innodb_thread_concurrency = 0
innodb_read_io_threads = 16
innodb_write_io_threads = 16

# Adaptive Hash Index (accÃ©lÃ©ration lectures)
innodb_adaptive_hash_index = ON
```

#### **OLAP/Analytics (Large Scans)**

```ini
[mysqld]
# OptimisÃ© pour grandes lectures sÃ©quentielles
innodb_buffer_pool_size = 16G
innodb_buffer_pool_instances = 8
innodb_log_file_size = 1G
innodb_flush_log_at_trx_commit = 2    # Compromis durabilitÃ©

# I/O sÃ©quentiel optimisÃ©
innodb_read_ahead_threshold = 56      # Prefetch agressif
innodb_io_capacity = 2000
innodb_io_capacity_max = 4000

# Moins de concurrence, mais requÃªtes longues
innodb_lock_wait_timeout = 300        # 5 minutes
```

#### **Mixed Workload**

```ini
[mysqld]
# Ã‰quilibre OLTP/OLAP
innodb_buffer_pool_size = 10G
innodb_buffer_pool_instances = 10
innodb_log_file_size = 512M
innodb_flush_log_at_trx_commit = 1

# Configuration Ã©quilibrÃ©e
innodb_io_capacity = 2000
innodb_io_capacity_max = 4000
innodb_thread_concurrency = 0
```

ğŸ†• **NouveautÃ©s MariaDB 11.8** :

```ini
# Construction d'index efficace (11.8+)
innodb_alter_copy_bulk = ON

# Optimizer conscient des SSD
innodb_use_native_aio = ON
innodb_flush_neighbors = 0           # DÃ©sactiver sur SSD
```

### Monitoring et Tuning

```sql
-- Statistiques Buffer Pool
SHOW ENGINE INNODB STATUS\G

-- Section "BUFFER POOL AND MEMORY"
-- Buffer pool hit rate : doit Ãªtre > 99%
-- Pages read / Pages created / Pages written

-- Calcul du hit ratio
SELECT
    (1 - (Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests)) * 100
    AS buffer_pool_hit_ratio
FROM
    (SELECT
        VARIABLE_VALUE AS Innodb_buffer_pool_reads
     FROM INFORMATION_SCHEMA.GLOBAL_STATUS
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') AS reads,
    (SELECT
        VARIABLE_VALUE AS Innodb_buffer_pool_read_requests
     FROM INFORMATION_SCHEMA.GLOBAL_STATUS
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests') AS requests;

-- Statistiques de verrous
SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS
WHERE NAME LIKE '%lock%';

-- Performance Schema - Attentes
SELECT
    EVENT_NAME,
    COUNT_STAR,
    SUM_TIMER_WAIT/1000000000000 AS total_wait_sec
FROM performance_schema.events_waits_summary_global_by_event_name
WHERE EVENT_NAME LIKE 'wait/synch/mutex/innodb%'
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 10;
```

---

## âœ… Points clÃ©s Ã  retenir

- **InnoDB garantit ACID** : AtomicitÃ© via Undo Log, CohÃ©rence via contraintes, Isolation via MVCC, DurabilitÃ© via Redo Log
- **Foreign Keys natives** : IntÃ©gritÃ© rÃ©fÃ©rentielle au niveau moteur avec actions CASCADE, RESTRICT, SET NULL, NO ACTION
- **Row-level locking** : Concurrence optimale avec verrouillage granulaire (record, gap, next-key locks)
- **Configuration critique** : `innodb_buffer_pool_size` (70-80% RAM), `innodb_flush_log_at_trx_commit` (durabilitÃ©), `innodb_io_capacity` (SSD)
- **Trade-offs** : DurabilitÃ© vs Performance, Isolation vs Concurrence, IntÃ©gritÃ© rÃ©fÃ©rentielle vs FlexibilitÃ©
- **Monitoring essentiel** : Buffer pool hit ratio (>99%), deadlocks, lock waits, I/O statistics
- **MariaDB 11.8** : Optimisations SSD (cost optimizer), construction index efficace (`innodb_alter_copy_bulk`)

---

## ğŸ”— Ressources et rÃ©fÃ©rences

- [ğŸ“– Documentation officielle InnoDB](https://mariadb.com/kb/en/innodb/)
- [ğŸ“– InnoDB Storage Engine](https://mariadb.com/kb/en/xtradbinnodb-storage-engine/)
- [ğŸ“– InnoDB System Variables](https://mariadb.com/kb/en/innodb-system-variables/)
- [ğŸ“– Foreign Keys](https://mariadb.com/kb/en/foreign-keys/)
- [ğŸ“– InnoDB Locking](https://mariadb.com/kb/en/innodb-lock-modes/)
- [ğŸ“– ACID Compliance](https://mariadb.com/kb/en/acid-compliance/)
- [ğŸ†• MariaDB 11.8 Release Notes](https://mariadb.com/kb/en/changes-improvements-in-mariadb-118/)

**Livres recommandÃ©s** :
- "High Performance MySQL" (Baron Schwartz et al.)
- "MySQL InnoDB Cluster Tutorial" (MySQL Documentation)

**Outils d'analyse** :
- `pt-query-digest` (Percona Toolkit)
- `innotop` - Monitoring InnoDB en temps rÃ©el
- PMM (Percona Monitoring and Management)

---

## â¡ï¸ Section suivante

**[7.2.2 Buffer Pool et gestion mÃ©moire](/07-moteurs-de-stockage/02.2-innodb-buffer-pool.md)** : PlongÃ©e approfondie dans le composant mÃ©moire le plus critique d'InnoDB, optimisations et dimensionnement pour diffÃ©rentes charges de travail.

â­ï¸ [Buffer Pool et gestion mÃ©moire](/07-moteurs-de-stockage/02.2-innodb-buffer-pool.md)
