ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 7.2.3 Redo Log et Undo Log : DurabilitÃ© et RÃ©cupÃ©ration

> **Niveau** : AvancÃ©
> **DurÃ©e estimÃ©e** : 3 heures

> **PrÃ©requis** :
> - Section 7.2.1 (CaractÃ©ristiques InnoDB - ACID)
> - Section 7.2.2 (Buffer Pool et gestion mÃ©moire)
> - ComprÃ©hension des transactions et de la concurrence
> - Notions de systÃ¨mes de fichiers et I/O

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre les mÃ©canismes de durabilitÃ© et de rÃ©cupÃ©ration d'InnoDB
- MaÃ®triser le rÃ´le distinct des Redo Logs et Undo Logs
- Configurer optimalement les logs de transactions pour diffÃ©rents profils de charge
- Diagnostiquer et rÃ©soudre les problÃ¨mes liÃ©s aux logs (redo log full, undo log bloat)
- Optimiser les performances d'Ã©criture via la configuration des logs
- ImplÃ©menter les best practices de crash recovery
- Exploiter les amÃ©liorations MariaDB 11.8 en matiÃ¨re de logging

---

## Introduction

Les **Redo Logs** et **Undo Logs** sont deux systÃ¨mes de journalisation complÃ©mentaires au cÅ“ur de la garantie ACID d'InnoDB :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     TRANSACTION                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                            â”‚
â”‚   REDO LOG (WAL)              UNDO LOG (MVCC)              â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€           â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€               â”‚
â”‚   "REDO = Rejouer"            "UNDO = Annuler"             â”‚
â”‚                                                            â”‚
â”‚   â€¢ DurabilitÃ© (D)            â€¢ AtomicitÃ© (A)              â”‚
â”‚   â€¢ Crash recovery            â€¢ Rollback                   â”‚
â”‚   â€¢ Write-Ahead Logging       â€¢ MVCC (Isolation)           â”‚
â”‚                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Distinction fondamentale** :
- **Redo Log** : Enregistre ce qui **doit Ãªtre refait** (changes physiques)
- **Undo Log** : Enregistre ce qui **doit Ãªtre dÃ©fait** (changes logiques inversÃ©s)

Ces deux mÃ©canismes travaillent ensemble pour garantir que les transactions validÃ©es survivent aux crashes (durabilitÃ©) tout en permettant l'annulation des transactions non validÃ©es (atomicitÃ©) et la lecture cohÃ©rente (isolation via MVCC).

ğŸ’¡ **Analogie** :
- Redo Log = Journal de construction : "Voici ce qui a Ã©tÃ© fait et doit Ãªtre refait aprÃ¨s interruption"
- Undo Log = Plan des travaux avant modification : "Voici comment revenir en arriÃ¨re si nÃ©cessaire"

---

## Redo Log : Write-Ahead Logging et DurabilitÃ©

### Architecture du Redo Log

Le Redo Log utilise le principe du **Write-Ahead Logging (WAL)** : les modifications sont d'abord Ã©crites dans le log, puis asynchronÃ©ment dans les data files.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TRANSACTION FLOW                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. BEGIN TRANSACTION
   â†“
2. UPDATE table SET col = val WHERE id = 1
   â†“
3. Modification en mÃ©moire (Buffer Pool)
   â†“
4. Ã‰criture dans REDO LOG BUFFER (mÃ©moire)
   â†“
5. Ã‰criture dans REDO LOG FILES (disque) â† WAL
   â†“
6. COMMIT (transaction validÃ©e)
   â†“
7. [Plus tard] Ã‰criture dans DATA FILES (disque)
   â””â”€â”€â†’ Checkpoint
```

**Avantage du WAL** : Les Ã©critures sÃ©quentielles dans le Redo Log sont beaucoup plus rapides que les Ã©critures alÃ©atoires dans les data files.

```
Redo Log (sÃ©quentiel) : 1000-5000 IOPS sur HDD, 50000+ IOPS sur SSD
Data Files (alÃ©atoire) : 100-200 IOPS sur HDD, 10000+ IOPS sur SSD
â†’ Gain de performance : 5-10x
```

### Structure des Redo Log Files

InnoDB utilise des **fichiers circulaires** de taille fixe :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           REDO LOG FILES (Circular Buffer)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  ib_logfile0 (512 MB)     ib_logfile1 (512 MB)           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ [====Write====>] â”‚ â”€â”€â†’ â”‚                  â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚         â†‘                         â†“                      â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€[Wrap]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                                                          â”‚
â”‚  Checkpoint LSN â”€â”€â”                                      â”‚
â”‚  Write Pos â”€â”€â”€â”€â”€â”€â”€â”¤ â† Active Range                       â”‚
â”‚  Flush Pos â”€â”€â”€â”€â”€â”€â”€â”˜                                      â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Fichiers par dÃ©faut** :
- `ib_logfile0` et `ib_logfile1` dans le datadir
- Taille configurable via `innodb_log_file_size`
- Nombre de fichiers : `innodb_log_files_in_group` (dÃ©faut : 2)

**LSN (Log Sequence Number)** : NumÃ©ro sÃ©quentiel identifiant chaque entrÃ©e du log.

```sql
-- Visualiser les LSN
SHOW ENGINE INNODB STATUS\G

-- Section "LOG"
-- Log sequence number 123456789012
-- Log flushed up to   123456789000
-- Pages flushed up to 123456788000
-- Last checkpoint at  123456787000
```

### Redo Log Buffer

Avant d'Ãªtre Ã©crit sur disque, le Redo Log transite par un **buffer en mÃ©moire** :

```sql
-- Taille du buffer (dÃ©faut : 16 MB)
innodb_log_buffer_size = 16M

-- Dimensionnement :
-- - OLTP lÃ©ger : 8-16 MB
-- - OLTP intensif : 32-64 MB
-- - Batch processing : 128-256 MB
```

**Flush du buffer vers le disque** :

```sql
-- ContrÃ´le de la durabilitÃ©
innodb_flush_log_at_trx_commit = 1

-- Options :
-- 0 : Flush toutes les 1 seconde (risque perte 1s de donnÃ©es)
-- 1 : Flush Ã  chaque COMMIT (durabilitÃ© maximale, dÃ©faut)
-- 2 : Flush vers OS cache, sync OS toutes les 1s (compromis)
```

**Comparaison des modes** :

| Mode | DurabilitÃ© | Performance | Risque Crash OS | Risque Crash MariaDB |
|------|------------|-------------|-----------------|---------------------|
| 0    | Faible     | Maximum     | Perte 1s donnÃ©es | Perte 1s donnÃ©es   |
| 1    | Maximum    | Faible      | Aucune perte    | Aucune perte       |
| 2    | Moyenne    | Ã‰levÃ©e      | Perte 1s donnÃ©es | Aucune perte       |

ğŸ’¡ **Best practice** :
- **Production critique** : Mode 1 (dÃ©faut) + SSD avec write cache protÃ©gÃ© par batterie
- **RÃ©plicas/Reporting** : Mode 2 pour meilleures performances
- **DÃ©veloppement** : Mode 0 acceptable

### Processus de Checkpoint

Le **checkpoint** synchronise l'Ã©tat des pages modifiÃ©es en mÃ©moire (Buffer Pool) avec les data files sur disque.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  CHECKPOINT PROCESS                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                        â”‚
â”‚  1. InnoDB identifie les dirty pages Ã  Ã©crire          â”‚
â”‚     (Flush List du Buffer Pool)                        â”‚
â”‚                                                        â”‚
â”‚  2. Page Cleaner Threads Ã©crivent les pages            â”‚
â”‚     Buffer Pool â†’ Data Files                           â”‚
â”‚                                                        â”‚
â”‚  3. Checkpoint LSN avance dans le Redo Log             â”‚
â”‚     Les entrÃ©es avant ce LSN peuvent Ãªtre recyclÃ©es    â”‚
â”‚                                                        â”‚
â”‚  4. Espace libÃ©rÃ© dans les Redo Log files              â”‚
â”‚                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Types de checkpoint** :

#### **1. Sharp Checkpoint**
Bloque toutes les opÃ©rations pour flush complet (shutdown propre).

```sql
-- Au shutdown
SHUTDOWN;

-- InnoDB effectue un sharp checkpoint :
-- - Flush toutes les dirty pages
-- - Ã‰crit dernier checkpoint LSN
-- - Fermeture propre
```

#### **2. Fuzzy Checkpoint**
Checkpoints progressifs en arriÃ¨re-plan (opÃ©ration normale).

```sql
-- Configuration du flushing
innodb_adaptive_flushing = ON          -- Ajuste dynamiquement
innodb_max_dirty_pages_pct = 90        -- Max 90% dirty pages
innodb_max_dirty_pages_pct_lwm = 10    -- DÃ©clenchement flushing agressif

-- Threads de nettoyage
innodb_page_cleaners = 4               -- 1 par Buffer Pool instance (max 64)
```

**ProblÃ¨me : Redo Log Full**

Si les checkpoints ne suivent pas le rythme des Ã©critures :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   REDO LOG FULL SCENARIO                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                  â”‚
â”‚  Write Pos rattrape Checkpoint LSN               â”‚
â”‚  â†’ Redo Log circulaire saturÃ©                    â”‚
â”‚  â†’ InnoDB BLOQUE les transactions                â”‚
â”‚  â†’ "Waiting for checkpoint to complete"          â”‚
â”‚  â†’ Chute brutale des performances                â”‚
â”‚                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**SymptÃ´mes** :

```sql
-- Log des erreurs
[Warning] InnoDB: The age of the last checkpoint is 999999999,
which exceeds the log group capacity 999999900.

-- Monitoring
SHOW ENGINE INNODB STATUS\G
-- "Pending checkpoint_writes"
```

**Solutions** :

```sql
-- 1. Augmenter la taille des Redo Logs
innodb_log_file_size = 1G              -- Au lieu de 512M

-- 2. Augmenter la capacitÃ© I/O
innodb_io_capacity = 5000
innodb_io_capacity_max = 10000

-- 3. Plus de threads de nettoyage
innodb_page_cleaners = 8

-- 4. Flushing plus agressif
innodb_max_dirty_pages_pct = 75
innodb_adaptive_flushing_lwm = 10
```

### Configuration Optimale du Redo Log

#### **Dimensionnement**

```sql
-- Calcul thÃ©orique :
-- Redo Log Size = Volume Ã©criture par heure / 2

-- Exemple :
-- Charge : 100 GB Ã©crits/heure
-- Redo Log Size = 50 GB total
innodb_log_file_size = 25G              -- 2 fichiers Ã— 25 GB
innodb_log_files_in_group = 2
```

**RÃ¨gles de dimensionnement** :

```
Workload             Redo Log Total Size
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
OLTP lÃ©ger          512 MB - 1 GB
OLTP moyen          1 GB - 4 GB
OLTP intensif       4 GB - 16 GB
Batch/ETL           16 GB - 64 GB
Data Warehouse      32 GB - 128 GB
```

ğŸ’¡ **Indicateur clÃ©** : Le Redo Log doit pouvoir contenir 30-60 minutes de modifications en pÃ©riode de pointe.

```sql
-- VÃ©rifier le taux de gÃ©nÃ©ration
SHOW ENGINE INNODB STATUS\G

-- Section "LOG"
-- Log sequence number 123456789012
-- [Attendre 1 minute]
SHOW ENGINE INNODB STATUS\G
-- Log sequence number 123556789012
-- GÃ©nÃ©ration = 100 MB/min = 6 GB/heure
-- â†’ Redo Log recommandÃ© : 3-6 GB
```

#### **Configuration Haute Performance**

```ini
[mysqld]
# Redo Log sizing (OLTP intensif)
innodb_log_file_size = 4G
innodb_log_files_in_group = 2
innodb_log_buffer_size = 64M

# DurabilitÃ© vs Performance
innodb_flush_log_at_trx_commit = 1    # Production
# innodb_flush_log_at_trx_commit = 2  # RÃ©plicas (acceptable)

# MÃ©thode de flush (Linux)
innodb_flush_method = O_DIRECT        # Bypass OS cache

# Flushing adaptatif
innodb_adaptive_flushing = ON
innodb_adaptive_flushing_lwm = 10
innodb_max_dirty_pages_pct = 80

# I/O capacity (SSD moderne)
innodb_io_capacity = 5000
innodb_io_capacity_max = 10000
innodb_page_cleaners = 8
```

### Crash Recovery avec le Redo Log

**ScÃ©nario de crash** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          CRASH RECOVERY PROCESS                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                â”‚
â”‚  1. MariaDB dÃ©marre aprÃ¨s crash                â”‚
â”‚                                                â”‚
â”‚  2. InnoDB lit le dernier checkpoint LSN       â”‚
â”‚     depuis les Redo Log files                  â”‚
â”‚                                                â”‚
â”‚  3. Roll-forward : Rejoue toutes les           â”‚
â”‚     transactions du Redo Log depuis            â”‚
â”‚     checkpoint jusqu'Ã  la fin                  â”‚
â”‚     â†’ Restaure les transactions COMMITÃ©es      â”‚
â”‚                                                â”‚
â”‚  4. Roll-back : Utilise l'Undo Log pour        â”‚
â”‚     annuler les transactions non COMMITÃ©es     â”‚
â”‚                                                â”‚
â”‚  5. Base de donnÃ©es en Ã©tat cohÃ©rent           â”‚
â”‚                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Exemple concret** :

```sql
-- ScÃ©nario
-- T0 : Checkpoint (LSN = 1000)
START TRANSACTION;
INSERT INTO orders VALUES (1, 100);    -- LSN = 1100
COMMIT;                                -- Transaction A validÃ©e

START TRANSACTION;
INSERT INTO orders VALUES (2, 200);    -- LSN = 1200
-- [CRASH ICI - pas de COMMIT]

-- Recovery au redÃ©marrage :
-- 1. Roll-forward depuis LSN 1000 :
--    - Rejoue INSERT (1, 100) â†’ PrÃ©sent
--    - Rejoue INSERT (2, 200) â†’ PrÃ©sent temporairement
--
-- 2. Roll-back des transactions non commitÃ©es :
--    - Utilise Undo Log pour annuler INSERT (2, 200)
--
-- 3. Ã‰tat final :
--    - orders(1, 100) : PRÃ‰SENT âœ“
--    - orders(2, 200) : ABSENT âœ“
```

**Monitoring du recovery** :

```bash
# Log de dÃ©marrage
tail -f /var/log/mysql/error.log

# Messages attendus :
# InnoDB: Starting crash recovery from checkpoint LSN=123456789
# InnoDB: Applying log records from LSN 123456789 to 123556789
# InnoDB: Apply batch completed
# InnoDB: Rollback of non-prepared transactions completed
# InnoDB: Recovery completed
```

**DurÃ©e du recovery** :

```
Temps recovery â‰ˆ Taille Redo Log / Vitesse I/O sÃ©quentiel

Exemple :
- Redo Log : 8 GB
- SSD : 500 MB/s read
- Temps : ~16 secondes

+ Temps de rollback (dÃ©pend des transactions actives)
â†’ Total typique : 30-60 secondes
```

ğŸ’¡ **Best practice** : Tester rÃ©guliÃ¨rement le crash recovery en environnement de staging.

---

## Undo Log : AtomicitÃ© et MVCC

### RÃ´le de l'Undo Log

L'Undo Log sert trois objectifs distincts :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             UNDO LOG PURPOSES                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                â”‚
â”‚  1. ROLLBACK (AtomicitÃ©)                       â”‚
â”‚     Annuler les modifications d'une            â”‚
â”‚     transaction en cours                       â”‚
â”‚                                                â”‚
â”‚  2. MVCC (Isolation)                           â”‚
â”‚     Fournir des versions cohÃ©rentes            â”‚
â”‚     pour les lectures concurrentes             â”‚
â”‚                                                â”‚
â”‚  3. CRASH RECOVERY                             â”‚
â”‚     Annuler les transactions non commitÃ©es     â”‚
â”‚     aprÃ¨s un crash                             â”‚
â”‚                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Structure de l'Undo Log

L'Undo Log est stockÃ© dans des **Undo Tablespaces** :

```sql
-- Localisation (MariaDB 10.3+)
SHOW VARIABLES LIKE 'innodb_undo_directory';
-- /var/lib/mysql/undo

-- Nombre de tablespaces
innodb_undo_tablespaces = 2            -- DÃ©faut (2-127 possible)

-- Fichiers crÃ©Ã©s :
-- undo001, undo002, ...
```

**Architecture** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         UNDO TABLESPACES                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  undo001 (1 GB)         undo002 (1 GB)          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ Rollback     â”‚       â”‚ Rollback     â”‚        â”‚
â”‚  â”‚ Segments     â”‚       â”‚ Segments     â”‚        â”‚
â”‚  â”‚              â”‚       â”‚              â”‚        â”‚
â”‚  â”‚ [=====]      â”‚       â”‚ [===]        â”‚        â”‚
â”‚  â”‚              â”‚       â”‚              â”‚        â”‚
â”‚  â”‚ (Active)     â”‚       â”‚ (Active)     â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚         â†“                       â†“               â”‚
â”‚    UNDO RECORDS            UNDO RECORDS         â”‚
â”‚    (old versions)          (old versions)       â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Chaque tablespace contient des **Rollback Segments** qui contiennent les **Undo Records** (anciennes versions des lignes).

### Undo Records et MVCC

**Principe MVCC** : Chaque transaction voit une version cohÃ©rente des donnÃ©es.

```sql
-- Ã‰tat initial : account balance = 1000

-- Transaction 1 (lecture longue)
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT balance FROM accounts WHERE id = 1;
-- RÃ©sultat : 1000
-- Transaction lit la version actuelle + stocke le read view

-- Transaction 2 (modification)
START TRANSACTION;
UPDATE accounts SET balance = 1500 WHERE id = 1;
-- InnoDB :
-- 1. Copie l'ancienne valeur (1000) dans l'Undo Log
-- 2. Ã‰crit la nouvelle valeur (1500) dans la page
-- 3. Ajoute pointeur vers Undo Record
COMMIT;

-- Transaction 1 (re-lecture)
SELECT balance FROM accounts WHERE id = 1;
-- RÃ©sultat : 1000 (via Undo Log, pas 1500)
-- MVCC fournit la version cohÃ©rente avec le read view

COMMIT;

-- Nouvelle transaction
SELECT balance FROM accounts WHERE id = 1;
-- RÃ©sultat : 1500 (version actuelle)
```

**Structure d'une ligne avec MVCC** :

```
Row in Data Page :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  id | balance | TRX_ID | ROLL_PTR  | ...         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1  |  1500   | 12345  | â†’Undo Log | ...         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
                     Undo Record:
                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                     â”‚ balance = 1000     â”‚
                     â”‚ TRX_ID = 12340     â”‚
                     â”‚ ROLL_PTR = â†’Older  â”‚
                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â†“
                          (chaÃ®ne de versions)
```

- **TRX_ID** : ID de la transaction qui a modifiÃ© la ligne
- **ROLL_PTR** : Pointeur vers l'Undo Record (version prÃ©cÃ©dente)

### Purge des Undo Records

Les anciennes versions doivent Ãªtre **purgÃ©es** lorsqu'elles ne sont plus nÃ©cessaires.

**Conditions de purge** :

```
Un Undo Record peut Ãªtre purgÃ© si :
1. La transaction qui l'a crÃ©Ã© est commitÃ©e
2. Aucune transaction active n'a besoin de cette version
   (plus ancienne que le plus vieux read view actif)
```

**Purge Thread** :

```sql
-- Configuration du purge
innodb_purge_threads = 4               -- Nombre de threads (1-32)
innodb_purge_batch_size = 300          -- Records purgÃ©s par batch
innodb_max_purge_lag = 0               -- Limite du lag (0 = illimitÃ©)
innodb_max_purge_lag_delay = 0         -- DÃ©lai si lag dÃ©passÃ© (ms)
```

**Monitoring du purge** :

```sql
SHOW ENGINE INNODB STATUS\G

-- Section "TRANSACTIONS"
-- History list length 1234           â† Undo records en attente de purge
-- (Valeur normale : < 10000)

-- Purge done for trx's n:o < 123456 undo n:o < 654321
```

âš ï¸ **ProblÃ¨me : Undo Log Bloat**

Si le purge ne suit pas, l'Undo Log grossit indÃ©finiment :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         UNDO LOG BLOAT SCENARIO                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                â”‚
â”‚  1. Transaction de lecture trÃ¨s longue         â”‚
â”‚     (plusieurs heures/jours)                   â”‚
â”‚                                                â”‚
â”‚  2. EmpÃªche le purge de toutes les versions    â”‚
â”‚     postÃ©rieures Ã  son read view               â”‚
â”‚                                                â”‚
â”‚  3. Undo Log grandit continuellement           â”‚
â”‚     (plusieurs dizaines/centaines de GB)       â”‚
â”‚                                                â”‚
â”‚  4. Performance dÃ©gradÃ©e (MVCC lent)           â”‚
â”‚     + Disque saturÃ©                            â”‚
â”‚                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**SymptÃ´mes** :

```sql
-- History list length trÃ¨s Ã©levÃ©e
SHOW ENGINE INNODB STATUS\G
-- History list length 5000000        â† Alerte !

-- Taille des Undo Tablespaces
SELECT
    FILE_NAME,
    TABLESPACE_NAME,
    FILE_SIZE / 1024 / 1024 / 1024 AS size_gb
FROM INFORMATION_SCHEMA.FILES
WHERE FILE_NAME LIKE '%undo%';
-- undo001 : 50 GB                    â† Anormal
```

**Solutions** :

```sql
-- 1. Identifier les transactions longues
SELECT
    trx_id,
    trx_state,
    trx_started,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS duration_sec,
    trx_query
FROM INFORMATION_SCHEMA.INNODB_TRX
WHERE trx_started < DATE_SUB(NOW(), INTERVAL 1 HOUR);

-- 2. Tuer les transactions problÃ©matiques
KILL <connection_id>;

-- 3. Attendre le purge automatique
-- (monitoring : history list length diminue)

-- 4. Configurer une limite de purge lag
SET GLOBAL innodb_max_purge_lag = 100000;
-- Ralentit les Ã©critures si lag > 100000
```

ğŸ’¡ **Best practice** : Ã‰viter les transactions de lecture ultra-longues. PrivilÃ©gier les snapshots (mysqldump, Mariabackup) pour les exports longs.

### Truncate Undo Tablespaces

ğŸ†• **Depuis MariaDB 10.5** : PossibilitÃ© de tronquer automatiquement les Undo Tablespaces.

```sql
-- Activer le truncate automatique
innodb_undo_log_truncate = ON

-- Seuil de taille pour le truncate (dÃ©faut : 1 GB)
innodb_max_undo_log_size = 1G

-- Processus :
-- 1. Undo Tablespace dÃ©passe innodb_max_undo_log_size
-- 2. InnoDB marque le tablespace pour truncate
-- 3. Nouveaux undo records vont dans un autre tablespace
-- 4. Purge complÃ¨te du tablespace marquÃ©
-- 5. Tablespace tronquÃ© Ã  sa taille initiale (10 MB)
```

**Monitoring du truncate** :

```sql
-- Statut
SELECT
    TABLESPACE_NAME,
    FILE_NAME,
    TOTAL_EXTENTS,
    EXTENT_SIZE
FROM INFORMATION_SCHEMA.FILES
WHERE FILE_NAME LIKE '%undo%';

-- Log de truncate
-- [Note] InnoDB: Truncating undo tablespace 'undo002'
-- [Note] InnoDB: Finished truncating undo tablespace 'undo002'
```

---

## Double Write Buffer : Protection Contre les Partial Page Writes

### ProblÃ¨me des Ã‰critures Partielles

Les pages InnoDB (16 KB) ne sont pas Ã©crites atomiquement sur disque. Un crash pendant l'Ã©criture peut corrompre une page.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         PARTIAL PAGE WRITE SCENARIO            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                â”‚
â”‚  Page Size : 16 KB (4 blocs de 4 KB)           â”‚
â”‚                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”                         â”‚
â”‚  â”‚ B1 â”‚ B2 â”‚ B3 â”‚ B4 â”‚                         â”‚
â”‚  â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜                         â”‚
â”‚     âœ“    âœ“    âœ—    âœ—   â† CRASH ici
â”‚                                                â”‚
â”‚  RÃ©sultat : Page partiellement Ã©crite          â”‚
â”‚  â†’ Corruption des donnÃ©es                      â”‚
â”‚                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Solution : Double Write Buffer

InnoDB Ã©crit d'abord les pages dans un **buffer d'Ã©criture sÃ©quentiel** avant les data files.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           DOUBLE WRITE PROCESS                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  1. Pages modifiÃ©es dans Buffer Pool                â”‚
â”‚     â†“                                               â”‚
â”‚  2. Ã‰criture dans DOUBLE WRITE BUFFER               â”‚
â”‚     (zone sÃ©quentielle dans ibdata1)                â”‚
â”‚     â†“                                               â”‚
â”‚  3. Fsync du Double Write Buffer                    â”‚
â”‚     â†“                                               â”‚
â”‚  4. Ã‰criture dans DATA FILES (.ibd)                 â”‚
â”‚     â†“                                               â”‚
â”‚  5. En cas de crash pendant (4) :                   â”‚
â”‚     â†’ Recovery utilise la copie du Double Write     â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Configuration** :

```sql
-- Activer/DÃ©sactiver (dÃ©faut : ON)
innodb_doublewrite = ON

-- Depuis MariaDB 10.6 : Support de fichiers sÃ©parÃ©s
innodb_doublewrite_file = ''           -- DÃ©faut : dans ibdata1

-- Threads de doublewrite (parallÃ©lisme)
innodb_doublewrite_pages = 128         -- Pages par batch
innodb_doublewrite_batch_size = 128
```

**Trade-off Performance** :

```
Avec Double Write :
- SÃ©curitÃ© maximale contre corruption
- Overhead : ~10-15% sur les Ã©critures

Sans Double Write :
- +10-15% performance Ã©criture
- Risque de corruption en cas de crash
- UNIQUEMENT sur filesystems garantissant atomicitÃ© (ZFS, etc.)
```

ğŸ’¡ **Recommandation** :
- **Production** : Toujours activÃ© (dÃ©faut)
- **Filesystems spÃ©ciaux** (ZFS, Btrfs) : Peut Ãªtre dÃ©sactivÃ© si atomicitÃ© garantie
- **RÃ©plicas/Dev** : DÃ©sactivation acceptable pour performance

---

## Configuration AvancÃ©e et Tuning

### Profil OLTP Haute Performance

```ini
[mysqld]
# â”€â”€â”€ REDO LOG (Haute frÃ©quence de commits) â”€â”€â”€
innodb_log_file_size = 2G
innodb_log_files_in_group = 2
innodb_log_buffer_size = 32M
innodb_flush_log_at_trx_commit = 1     # DurabilitÃ© max

# â”€â”€â”€ UNDO LOG (Transactions courtes) â”€â”€â”€
innodb_undo_tablespaces = 4            # RÃ©partition charge
innodb_undo_log_truncate = ON
innodb_max_undo_log_size = 2G
innodb_purge_threads = 8               # Purge agressif
innodb_purge_batch_size = 300

# â”€â”€â”€ DOUBLE WRITE â”€â”€â”€
innodb_doublewrite = ON                # SÃ©curitÃ©

# â”€â”€â”€ I/O CONFIGURATION â”€â”€â”€
innodb_flush_method = O_DIRECT
innodb_io_capacity = 5000
innodb_io_capacity_max = 10000
innodb_page_cleaners = 8

# â”€â”€â”€ CHECKPOINT TUNING â”€â”€â”€
innodb_adaptive_flushing = ON
innodb_max_dirty_pages_pct = 80
innodb_max_dirty_pages_pct_lwm = 10
```

### Profil ETL / Batch Processing

```ini
[mysqld]
# â”€â”€â”€ REDO LOG (Grosses Ã©critures en batch) â”€â”€â”€
innodb_log_file_size = 16G             # TrÃ¨s large
innodb_log_files_in_group = 4
innodb_log_buffer_size = 256M          # Buffer large
innodb_flush_log_at_trx_commit = 2     # Compromis acceptable

# â”€â”€â”€ UNDO LOG (Grosses transactions) â”€â”€â”€
innodb_undo_tablespaces = 2
innodb_undo_log_truncate = ON
innodb_max_undo_log_size = 10G         # Seuil Ã©levÃ©
innodb_purge_threads = 4
innodb_max_purge_lag = 0               # Pas de limite

# â”€â”€â”€ DOUBLE WRITE (Peut Ãªtre dÃ©sactivÃ© si contrÃ´lÃ©) â”€â”€â”€
innodb_doublewrite = OFF               # Gain performance

# â”€â”€â”€ I/O CONFIGURATION â”€â”€â”€
innodb_flush_method = O_DIRECT
innodb_io_capacity = 2000
innodb_io_capacity_max = 4000
innodb_adaptive_flushing = ON
```

### Profil Read-Heavy (RÃ©plicas, Reporting)

```ini
[mysqld]
# â”€â”€â”€ REDO LOG (Peu d'Ã©critures) â”€â”€â”€
innodb_log_file_size = 512M            # Peut Ãªtre rÃ©duit
innodb_log_files_in_group = 2
innodb_log_buffer_size = 16M
innodb_flush_log_at_trx_commit = 2     # Acceptable sur replica

# â”€â”€â”€ UNDO LOG (Peu de purge nÃ©cessaire) â”€â”€â”€
innodb_undo_tablespaces = 2
innodb_purge_threads = 2               # Suffisant
innodb_max_purge_lag = 1000000         # Pas critique

# â”€â”€â”€ FOCUS BUFFER POOL â”€â”€â”€
innodb_buffer_pool_size = 48G          # 80% RAM (lectures)

# â”€â”€â”€ I/O CONFIGURATION (Lectures optimisÃ©es) â”€â”€â”€
innodb_read_io_threads = 16            # Plus de threads lecture
innodb_write_io_threads = 4
innodb_io_capacity = 1000
```

### Profil SSD Haute Performance

```ini
[mysqld]
# â”€â”€â”€ REDO LOG (SSD rapide) â”€â”€â”€
innodb_log_file_size = 4G
innodb_log_files_in_group = 2
innodb_log_buffer_size = 64M
innodb_flush_log_at_trx_commit = 1

# â”€â”€â”€ I/O OPTIMIZATIONS (SSD) â”€â”€â”€
innodb_flush_method = O_DIRECT
innodb_use_native_aio = ON             # AIO natif
innodb_io_capacity = 10000             # SSD rapide
innodb_io_capacity_max = 20000
innodb_flush_neighbors = 0             # Inutile sur SSD

# â”€â”€â”€ CHECKPOINT (Flushing agressif possible) â”€â”€â”€
innodb_adaptive_flushing = ON
innodb_max_dirty_pages_pct = 90
innodb_page_cleaners = 16              # ParallÃ©lisme Ã©levÃ©

# â”€â”€â”€ DOUBLEWRITE (SSD atomic writes) â”€â”€â”€
# Si SSD supporte atomic writes (rare)
# innodb_doublewrite = OFF
```

---

## Monitoring et Troubleshooting

### MÃ©triques Essentielles

#### **1. Redo Log Metrics**

```sql
-- Utilisation du Redo Log
SHOW ENGINE INNODB STATUS\G

-- Section "LOG"
-- ================================
-- Log sequence number 123456789012
-- Log flushed up to   123456789000  â† 12 bytes de retard (OK)
-- Pages flushed up to 123456788000  â† Checkpoint lag
-- Last checkpoint at  123456787000

-- Calcul de l'utilisation :
-- Used = (Log seq number - Last checkpoint) / (log_file_size Ã— n_files)
```

**Alertes** :

```
Checkpoint Age > 80% : Risque de stall
Flushed lag > 100 MB : Flushing en retard
```

#### **2. Undo Log Metrics**

```sql
-- History list length (undo records en attente)
SHOW ENGINE INNODB STATUS\G
-- History list length 5234

-- Transactions actives
SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_TRX;

-- Taille des Undo Tablespaces
SELECT
    FILE_NAME,
    FILE_SIZE / 1024 / 1024 / 1024 AS size_gb,
    AUTOEXTEND_SIZE
FROM INFORMATION_SCHEMA.FILES
WHERE FILE_NAME LIKE '%undo%';
```

**Alertes** :

```
History list > 100000 : Purge en retard
Undo Tablespace > 10 GB : Bloat possible
Transaction active > 1 heure : Investigation requise
```

#### **3. Double Write Metrics**

```sql
-- Nombre d'Ã©critures via doublewrite
SHOW GLOBAL STATUS LIKE 'Innodb_dblwr%';

-- Innodb_dblwr_pages_written : Pages Ã©crites dans doublewrite
-- Innodb_dblwr_writes : Nombre de syncs doublewrite

-- Ratio (doit Ãªtre > 10:1)
SELECT
    VARIABLE_VALUE AS pages_written
FROM INFORMATION_SCHEMA.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'Innodb_dblwr_pages_written';

SELECT
    VARIABLE_VALUE AS writes
FROM INFORMATION_SCHEMA.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'Innodb_dblwr_writes';

-- Ratio = pages_written / writes
-- Optimal : > 30
-- Si < 10 : Trop de syncs (impact performance)
```

### Scripts de Monitoring

#### **Health Check Complet**

```sql
-- Script de monitoring logs InnoDB
SELECT
    'Redo Log Status' AS metric,
    CONCAT(
        'LSN: ',
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_lsn_current'),
        ' | Checkpoint Age: ',
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_checkpoint_age')
    ) AS value
UNION ALL
SELECT
    'History List Length',
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_history_list_length')
UNION ALL
SELECT
    'Active Transactions',
    COUNT(*)
FROM INFORMATION_SCHEMA.INNODB_TRX
UNION ALL
SELECT
    'Pending Checkpoint Writes',
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_checkpoint_pending_writes')
UNION ALL
SELECT
    'Log Writes per Second',
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_os_log_written') /
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Uptime')
UNION ALL
SELECT
    'Undo Tablespaces Size (GB)',
    CONCAT(
        ROUND(SUM(FILE_SIZE) / 1024 / 1024 / 1024, 2),
        ' GB'
    )
FROM INFORMATION_SCHEMA.FILES
WHERE FILE_NAME LIKE '%undo%';
```

### Troubleshooting Guide

#### **ProblÃ¨me : Stalls pendant les Checkpoints**

**SymptÃ´mes** :

```
-- Logs
[Warning] InnoDB: Difficult to find free blocks in the buffer pool

-- MÃ©triques
-- Checkpoint age > 90%
-- Pending checkpoint writes Ã©levÃ©
```

**Solutions** :

```sql
-- 1. Augmenter Redo Log
SET GLOBAL innodb_log_file_size = 4G;  -- NÃ©cessite redÃ©marrage

-- 2. Augmenter I/O capacity
SET GLOBAL innodb_io_capacity = 5000;
SET GLOBAL innodb_io_capacity_max = 10000;

-- 3. Plus de page cleaners
SET GLOBAL innodb_page_cleaners = 8;

-- 4. RÃ©duire dirty pages max
SET GLOBAL innodb_max_dirty_pages_pct = 75;
```

#### **ProblÃ¨me : Undo Log Bloat**

**SymptÃ´mes** :

```sql
-- History list trÃ¨s Ã©levÃ©e
-- History list length 5000000

-- Undo Tablespaces volumineux
-- undo001 : 50 GB
```

**Solutions** :

```sql
-- 1. Identifier et tuer les transactions longues
SELECT
    trx_id,
    trx_state,
    TIMESTAMPDIFF(MINUTE, trx_started, NOW()) AS duration_min,
    trx_mysql_thread_id
FROM INFORMATION_SCHEMA.INNODB_TRX
ORDER BY trx_started;

KILL <thread_id>;

-- 2. Forcer le purge (attendre)
-- Monitoring :
SHOW ENGINE INNODB STATUS\G
-- History list length dÃ©croÃ®t progressivement

-- 3. Configurer truncate automatique
SET GLOBAL innodb_undo_log_truncate = ON;
SET GLOBAL innodb_max_undo_log_size = 2G;

-- 4. Augmenter threads purge
SET GLOBAL innodb_purge_threads = 8;
```

#### **ProblÃ¨me : Performances d'Ã‰criture DÃ©gradÃ©es**

**Diagnostic** :

```sql
-- VÃ©rifier le flushing
SHOW ENGINE INNODB STATUS\G
-- Modified db pages / Database pages > 80%

-- VÃ©rifier l'I/O
-- Pending writes Ã©levÃ©
```

**Solutions** :

```sql
-- 1. Optimiser I/O
SET GLOBAL innodb_io_capacity = 5000;
SET GLOBAL innodb_adaptive_flushing = ON;

-- 2. ConsidÃ©rer flush_log_at_trx_commit = 2 (si acceptable)
SET GLOBAL innodb_flush_log_at_trx_commit = 2;

-- 3. DÃ©sactiver doublewrite (avec prudence)
-- SET GLOBAL innodb_doublewrite = OFF;  -- NÃ©cessite redÃ©marrage

-- 4. Augmenter log buffer
SET GLOBAL innodb_log_buffer_size = 64M;
```

---

## ğŸ†• NouveautÃ©s MariaDB 11.8

### Optimisations du Redo Log

ğŸ†• **AmÃ©liorations du write-ahead logging** :

```ini
[mysqld]
# Compression du Redo Log (expÃ©rimental)
# RÃ©duit la taille et amÃ©liore le throughput
innodb_log_compressed_pages = ON

# Redo Log avec support des SSD ultra-rapides
innodb_log_write_ahead_size = 16384    # AlignÃ© sur SSD page size
```

### Support AmÃ©liore des Undo Tablespaces

ğŸ†• **Gestion dynamique** :

```sql
-- CrÃ©er un nouveau Undo Tablespace Ã  chaud
CREATE UNDO TABLESPACE undo003 ADD DATAFILE 'undo003.ibu';

-- Supprimer un Undo Tablespace (aprÃ¨s purge)
DROP UNDO TABLESPACE undo003;

-- Monitoring amÃ©liorÃ©
SELECT
    NAME,
    STATE,
    SPACE_TYPE
FROM INFORMATION_SCHEMA.INNODB_TABLESPACES
WHERE SPACE_TYPE = 'Undo';
```

### Optimisations Performance Schema

```sql
-- Instrumentation dÃ©taillÃ©e des logs
UPDATE performance_schema.setup_instruments
SET ENABLED = 'YES'
WHERE NAME LIKE 'wait/io/file/innodb/innodb_log%';

-- Statistiques I/O des logs
SELECT
    EVENT_NAME,
    COUNT_READ,
    COUNT_WRITE,
    SUM_TIMER_WAIT / 1000000000000 AS total_wait_sec
FROM performance_schema.file_summary_by_event_name
WHERE EVENT_NAME LIKE '%innodb_log%';
```

---

## âœ… Points clÃ©s Ã  retenir

- **Redo Log (WAL)** : Garantit la durabilitÃ© via write-ahead logging, permet crash recovery rapide
- **Undo Log** : Permet rollback, MVCC (isolation), et rÃ©cupÃ©ration aprÃ¨s crash des transactions non commitÃ©es
- **Double Write Buffer** : Protection contre partial page writes, overhead 10-15% mais critique en production
- **Dimensionnement Redo Log** : 30-60 minutes de modifications en pÃ©riode de pointe (formule : Ã©criture/heure Ã· 2)
- **Checkpoint** : Synchronisation Buffer Pool â†’ Data Files, monitoring crucial pour Ã©viter les stalls
- **Purge Undo Log** : Transactions longues bloquent le purge â†’ bloat, monitoring history list length
- **Configuration critique** : `innodb_flush_log_at_trx_commit` (durabilitÃ© vs performance), `innodb_io_capacity` (SSD)
- **MariaDB 11.8** : Support dynamique Undo Tablespaces, compression Redo Log, optimisations SSD
- **Trade-offs** : DurabilitÃ© (mode 1) vs Performance (mode 2), Double Write (sÃ©curitÃ© vs 15% perf)

---

## ğŸ”— Ressources et rÃ©fÃ©rences

- [ğŸ“– InnoDB Redo Log](https://mariadb.com/kb/en/innodb-redo-log/)
- [ğŸ“– InnoDB Undo Log](https://mariadb.com/kb/en/innodb-undo-log/)
- [ğŸ“– InnoDB Recovery](https://mariadb.com/kb/en/innodb-recovery-modes/)
- [ğŸ“– InnoDB Doublewrite Buffer](https://mariadb.com/kb/en/innodb-doublewrite-buffer/)
- [ğŸ“– InnoDB System Variables - Logs](https://mariadb.com/kb/en/innodb-system-variables/#innodb_log_file_size)
- [ğŸ“– SHOW ENGINE INNODB STATUS](https://mariadb.com/kb/en/show-engine-innodb-status/)
- [ğŸ†• MariaDB 11.8 - Undo Tablespaces Improvements](https://mariadb.com/kb/en/changes-improvements-in-mariadb-118/)

**Articles techniques recommandÃ©s** :
- "Understanding the InnoDB Recovery Process" - Percona Blog
- "InnoDB Undo Tablespaces: The Complete Guide" - MariaDB Corporation
- "Optimizing InnoDB Log Settings" - MySQL Performance Blog
- "InnoDB Crash Recovery Internals" - Jeremy Cole Blog

**Outils de diagnostic** :
- `innodb_ruby` - Analyse des structures internes InnoDB
- `pt-ioprofile` - Profiling I/O (Percona Toolkit)
- PMM - Dashboards Redo/Undo Logs

---

## â¡ï¸ Section suivante

**[7.2.4 Configuration avancÃ©e InnoDB](/07-moteurs-de-stockage/02.4-innodb-configuration.md)** : SynthÃ¨se des paramÃ¨tres critiques, profils de configuration pour diffÃ©rents workloads, tuning methodology et best practices pour architectes.

â­ï¸ [Configuration avancÃ©e](/07-moteurs-de-stockage/02.4-innodb-configuration.md)
