ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 7.2.2 Buffer Pool et Gestion MÃ©moire InnoDB

> **Niveau** : AvancÃ©
> **DurÃ©e estimÃ©e** : 2.5 heures

> **PrÃ©requis** :
> - Section 7.2.1 (CaractÃ©ristiques InnoDB)
> - ComprÃ©hension de l'architecture systÃ¨me Linux
> - Notions de gestion mÃ©moire OS

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre l'architecture interne du Buffer Pool et son fonctionnement
- Dimensionner optimalement le Buffer Pool selon votre workload
- Configurer les Buffer Pool instances pour la concurrence
- Monitorer et analyser l'efficacitÃ© du cache mÃ©moire
- Diagnostiquer et rÃ©soudre les problÃ¨mes de performance mÃ©moire
- Appliquer les optimisations spÃ©cifiques MariaDB 11.8 pour SSD

---

## Introduction

Le **Buffer Pool** est le composant mÃ©moire le plus critique d'InnoDB. C'est une zone de cache RAM qui stocke les pages de donnÃ©es et d'index, rÃ©duisant drastiquement les accÃ¨s disque. Une configuration optimale du Buffer Pool peut amÃ©liorer les performances d'un facteur 10 Ã  100 comparÃ© aux lectures disque.

**Principe fondamental** :
```
Lecture RAM (Buffer Pool) : ~100 nanosecondes
Lecture SSD            : ~100 microsecondes (1000x plus lent)
Lecture HDD            : ~10 millisecondes (100 000x plus lent)
```

ğŸ’¡ **RÃ¨gle d'or** : Le Buffer Pool doit contenir votre "working set" (donnÃ©es frÃ©quemment accÃ©dÃ©es). Un hit ratio > 99% est l'objectif en production.

Dans MariaDB 11.8 LTS, le Buffer Pool bÃ©nÃ©ficie d'optimisations pour les architectures modernes (SSD, mÃ©moire persistante) et une meilleure intÃ©gration avec le cost-based optimizer.

---

## Architecture du Buffer Pool

### Structure Globale

Le Buffer Pool est organisÃ© en **pages** de taille fixe (par dÃ©faut 16 KB) :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BUFFER POOL                         â”‚
â”‚  (innodb_buffer_pool_size = 8 GB)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚  DATA PAGES    â”‚  â”‚  INDEX PAGES   â”‚                â”‚
â”‚  â”‚  (70-75%)      â”‚  â”‚  (20-25%)      â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚  UNDO PAGES    â”‚  â”‚  INSERT BUFFER â”‚                â”‚
â”‚  â”‚  (3-5%)        â”‚  â”‚  (3-5%)        â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  FREE LIST - Pages disponibles              â”‚       â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”‚
â”‚  â”‚  LRU LIST - Pages utilisÃ©es (algorithme LRU)â”‚       â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”‚
â”‚  â”‚  FLUSH LIST - Pages modifiÃ©es (dirty pages) â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Les Trois Listes du Buffer Pool

#### **1. Free List - Pages Libres**

Liste des pages disponibles pour accueillir de nouvelles donnÃ©es.

```sql
-- Visualiser la Free List
SHOW ENGINE INNODB STATUS\G

-- Section "BUFFER POOL AND MEMORY"
-- Free buffers : nombre de pages disponibles
```

**Comportement** :
- Au dÃ©marrage, toutes les pages sont dans la Free List
- Lorsqu'une donnÃ©e est lue depuis le disque, une page libre est utilisÃ©e
- Si Free List vide â†’ Ã©viction depuis LRU List

#### **2. LRU List - Least Recently Used**

Liste des pages en cache, ordonnÃ©es par frÃ©quence d'utilisation. InnoDB utilise un **algorithme LRU modifiÃ©** pour Ã©viter que les scans de tables ne chassent les donnÃ©es chaudes.

**LRU Classique vs InnoDB LRU** :

```
LRU Classique (problÃ©matique) :
[Most Recent] â† [Scan Table] â† [Old Data]
ProblÃ¨me : Un scan chasse toutes les donnÃ©es chaudes

InnoDB LRU ModifiÃ© (midpoint insertion) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          NEW SUBLIST (5/8)              â”‚  â† DonnÃ©es chaudes
â”‚  (young pages - frequently accessed)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          OLD SUBLIST (3/8)              â”‚  â† Nouvelles entrÃ©es
â”‚  (pages from disk, scans)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†‘
    Midpoint (37%)
```

**Configuration du midpoint** :

```sql
-- Position du midpoint (% de la LRU list)
-- DÃ©faut : 37 (optimal pour la plupart des workloads)
SET GLOBAL innodb_old_blocks_pct = 37;

-- Temps avant promotion de old â†’ young
-- DÃ©faut : 1000ms (1 seconde)
SET GLOBAL innodb_old_blocks_time = 1000;
```

ğŸ’¡ **Explication** : Une page nouvellement lue est insÃ©rÃ©e au midpoint (old sublist). Elle ne remonte vers la young sublist que si elle est rÃ©-accÃ©dÃ©e aprÃ¨s `innodb_old_blocks_time` ms. Cela protÃ¨ge les donnÃ©es chaudes des scans de tables.

**Exemple concret** :

```sql
-- ScÃ©nario 1 : Table scan ponctuel
SELECT COUNT(*) FROM huge_table;  -- Scan de 100 GB

-- Pages huge_table insÃ©rÃ©es dans old sublist
-- AprÃ¨s 1 seconde sans rÃ©-accÃ¨s : Ã©ligibles Ã  Ã©viction
-- â†’ Les donnÃ©es chaudes restent dans young sublist

-- ScÃ©nario 2 : DonnÃ©es frÃ©quemment accÃ©dÃ©es
SELECT * FROM hot_products WHERE category = 'electronics';
-- ExÃ©cutÃ© 100x par seconde

-- Pages hot_products :
-- 1. Insertion dans old sublist
-- 2. RÃ©-accÃ¨s < 1s â†’ promotion vers young sublist
-- 3. Restent en mÃ©moire (haute frÃ©quence)
```

#### **3. Flush List - Pages ModifiÃ©es**

Liste des **dirty pages** (pages modifiÃ©es non encore Ã©crites sur disque).

```sql
-- Visualiser les dirty pages
SELECT
    pool_id,
    pool_size,
    free_buffers,
    database_pages,
    old_database_pages,
    modified_database_pages,  -- DIRTY PAGES
    pending_reads,
    pending_writes
FROM INFORMATION_SCHEMA.INNODB_BUFFER_POOL_STATS;
```

**Processus de flush** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Transaction modifie une page                           â”‚
â”‚  â†“                                                      â”‚
â”‚  Page marquÃ©e "dirty" + ajoutÃ©e Ã  Flush List            â”‚
â”‚  â†“                                                      â”‚
â”‚  Page Cleaner Thread Ã©crit pÃ©riodiquement sur disque    â”‚
â”‚  â†“                                                      â”‚
â”‚  Page retirÃ©e de Flush List (reste dans LRU)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Configuration du flushing** :

```sql
-- CapacitÃ© I/O du systÃ¨me (IOPS)
innodb_io_capacity = 2000            -- SSD standard
innodb_io_capacity_max = 4000        -- Burst capacity

-- ContrÃ´le du ratio de dirty pages
innodb_max_dirty_pages_pct = 90      -- Max 90% de dirty pages
innodb_max_dirty_pages_pct_lwm = 10  -- Low water mark : flushing agressif

-- Adaptive flushing (ajuste selon charge)
innodb_adaptive_flushing = ON
innodb_adaptive_flushing_lwm = 10

-- Threads dÃ©diÃ©s au flushing
innodb_page_cleaners = 4             -- Nombre de threads (â‰¤ buffer pool instances)
```

âš ï¸ **Attention** : Trop de dirty pages (>90%) peut causer des stalls lors des checkpoints. Un flushing trop agressif impacte les performances d'Ã©criture.

---

## Buffer Pool Instances : ParallÃ©lisation

### ProblÃ¨me de Concurrence

Avec un seul Buffer Pool, toutes les opÃ©rations se disputent le mÃªme verrou (mutex), crÃ©ant un **goulot d'Ã©tranglement** sur les serveurs multi-cÅ“urs.

**Solution** : Diviser le Buffer Pool en **plusieurs instances indÃ©pendantes**.

```
Single Buffer Pool (8 GB)         Multiple Instances (8 GB = 8 x 1 GB)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚                          â”‚      â”‚ 0 â”‚ 1 â”‚ 2 â”‚ 3 â”‚ 4 â”‚ 5 â”‚ 6 â”‚ 7 â”‚
â”‚    ONE MUTEX LOCK        â”‚      â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
â”‚    (contention)          â”‚        â†“   â†“   â†“   â†“   â†“   â†“   â†“   â†“
â”‚                          â”‚      8 MUTEX LOCKS (parallÃ©lisme)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Configuration Optimale

```sql
-- RÃ¨gle : 1 instance par GB de Buffer Pool (maximum 64 instances)
innodb_buffer_pool_size = 16G
innodb_buffer_pool_instances = 16

-- Exemples selon la taille :
-- 1-2 GB   : instances = 1
-- 4 GB     : instances = 4
-- 8 GB     : instances = 8
-- 16 GB    : instances = 16
-- 32 GB    : instances = 32
-- 64+ GB   : instances = 64 (maximum)
```

ğŸ’¡ **RÃ¨gles de dimensionnement** :
- Minimum : 1 GB par instance (`innodb_buffer_pool_chunk_size` * `innodb_buffer_pool_instances`)
- IdÃ©al : 1 instance par GB (ou par cÅ“ur CPU disponible)
- Maximum : 64 instances

**VÃ©rification de la configuration** :

```sql
-- Voir la configuration actuelle
SHOW VARIABLES LIKE 'innodb_buffer_pool%';

-- Statistiques par instance
SELECT
    pool_id,
    pool_size,
    free_buffers,
    database_pages,
    modified_database_pages
FROM INFORMATION_SCHEMA.INNODB_BUFFER_POOL_STATS
ORDER BY pool_id;
```

### Chunks : Redimensionnement Dynamique

ğŸ†• **Depuis MariaDB 10.2** : Le Buffer Pool peut Ãªtre redimensionnÃ© **sans redÃ©marrage**.

```sql
-- Structure en chunks
innodb_buffer_pool_chunk_size = 128M  -- Taille de chaque chunk

-- Buffer Pool Size =
--   innodb_buffer_pool_instances Ã—
--   innodb_buffer_pool_chunk_size Ã—
--   nombre de chunks

-- Exemple : 8 GB avec 8 instances
-- 8 GB = 8 instances Ã— 128 MB Ã— 8 chunks
```

**Redimensionnement Ã  chaud** :

```sql
-- Augmenter le Buffer Pool (online)
SET GLOBAL innodb_buffer_pool_size = 12G;

-- MariaDB effectue le redimensionnement progressivement
-- Monitoring du processus :
SHOW STATUS LIKE 'Innodb_buffer_pool_resize_status';

-- RÃ©sultat possible :
-- "Resizing also other hash tables."
-- "Completed resizing buffer pool at 2025-12-12 10:30:00."
```

âš ï¸ **Limitations** :
- La taille doit Ãªtre un multiple de `chunk_size Ã— instances`
- Le redimensionnement peut prendre plusieurs minutes sur de grandes tailles
- Impact lÃ©ger sur les performances durant le processus

---

## Dimensionnement du Buffer Pool

### MÃ©thode de Calcul

**RÃ¨gle gÃ©nÃ©rale** : Allouer **70-80% de la RAM disponible** au Buffer Pool.

```
RAM Serveur : 32 GB
OS + SystÃ¨me : 4-6 GB
Connexions : 2 GB (400 connexions Ã— 5 MB)
Autres buffers : 1-2 GB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Buffer Pool : 23-24 GB (70-75%)
```

**Formule de dimensionnement** :

```bash
# Calcul thÃ©orique
RAM_total = 32 GB
RAM_os = 4 GB
RAM_connections = nb_connections Ã— (
    read_buffer_size +
    sort_buffer_size +
    join_buffer_size +
    thread_stack
) / 1024 / 1024

buffer_pool_size = RAM_total - RAM_os - RAM_connections - 2 GB (marge)
```

### Dimensionnement par Type de Workload

#### **OLTP (High Concurrency)**

```ini
[mysqld]
# Serveur : 64 GB RAM
innodb_buffer_pool_size = 48G      # 75% RAM
innodb_buffer_pool_instances = 48

# Working set : donnÃ©es chaudes frÃ©quemment accÃ©dÃ©es
# Objectif : Tout le working set en RAM
```

**Validation** :

```sql
-- Taille de la base de donnÃ©es
SELECT
    table_schema,
    SUM(data_length + index_length) / 1024 / 1024 / 1024 AS size_gb
FROM information_schema.tables
GROUP BY table_schema;

-- Si database = 80 GB, mais working set = 40 GB
-- â†’ Buffer Pool 48 GB est optimal
```

#### **OLAP/Analytics**

```ini
[mysqld]
# Serveur : 128 GB RAM
innodb_buffer_pool_size = 96G      # 75% RAM
innodb_buffer_pool_instances = 64  # Maximum

# Working set : large scans, moins de donnÃ©es chaudes
# Utilisation de temp tables, filesort
```

#### **Mixed Workload**

```ini
[mysqld]
# Serveur : 32 GB RAM
innodb_buffer_pool_size = 24G      # 75% RAM
innodb_buffer_pool_instances = 24

# Ã‰quilibre entre OLTP et reporting
```

### Cas Particuliers

#### **Serveur DÃ©diÃ© (MariaDB seul)**

```ini
[mysqld]
# 80% de la RAM au Buffer Pool
innodb_buffer_pool_size = 50G     # Pour 64 GB RAM
```

#### **Serveur MutualisÃ© (MariaDB + Application)**

```ini
[mysqld]
# 50-60% de la RAM au Buffer Pool
innodb_buffer_pool_size = 32G     # Pour 64 GB RAM
```

#### **Conteneur Docker / Kubernetes**

```yaml
# Limite mÃ©moire : 8 GB
resources:
  limits:
    memory: 8Gi
  requests:
    memory: 6Gi
```

```ini
[mysqld]
# 60-70% de la limite du conteneur
innodb_buffer_pool_size = 5G
innodb_buffer_pool_instances = 5
```

ğŸ’¡ **Best practice conteneurs** : Toujours dÃ©finir `memory.limit` dans le conteneur pour Ã©viter l'OOM killer Linux.

---

## Monitoring et Optimisation

### MÃ©triques Essentielles

#### **1. Buffer Pool Hit Ratio**

Pourcentage de lectures satisfaites par le cache (objectif : >99%).

```sql
-- Calcul du hit ratio
SELECT
    CONCAT(
        ROUND(
            (1 - (
                SELECT VARIABLE_VALUE
                FROM INFORMATION_SCHEMA.GLOBAL_STATUS
                WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads'
            ) / (
                SELECT VARIABLE_VALUE
                FROM INFORMATION_SCHEMA.GLOBAL_STATUS
                WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests'
            )) * 100,
            2
        ),
        '%'
    ) AS buffer_pool_hit_ratio;

-- RÃ©sultat idÃ©al : > 99.00%
-- < 95% : Buffer Pool trop petit ou working set > RAM disponible
```

**InterprÃ©tation** :

```
Hit Ratio    Diagnostic
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
> 99.5%      Excellent - Buffer Pool bien dimensionnÃ©
95-99%       Acceptable - Envisager augmentation
90-95%       ProblÃ©matique - Trop de disk reads
< 90%        Critique - Augmenter Buffer Pool immÃ©diatement
```

#### **2. Pages Read vs Read Requests**

```sql
-- DÃ©tail des lectures
SELECT
    VARIABLE_NAME,
    VARIABLE_VALUE
FROM INFORMATION_SCHEMA.GLOBAL_STATUS
WHERE VARIABLE_NAME IN (
    'Innodb_buffer_pool_read_requests',  -- Lectures demandÃ©es
    'Innodb_buffer_pool_reads',          -- Lectures disque
    'Innodb_pages_read',                 -- Pages lues disque
    'Innodb_pages_written'               -- Pages Ã©crites disque
);
```

#### **3. Dirty Pages Ratio**

```sql
-- Ratio de pages modifiÃ©es
SELECT
    pool_id,
    CONCAT(
        ROUND(
            (modified_database_pages / database_pages) * 100,
            2
        ),
        '%'
    ) AS dirty_pages_ratio
FROM INFORMATION_SCHEMA.INNODB_BUFFER_POOL_STATS;

-- Alerte si > 90% : risque de stall au checkpoint
```

#### **4. Free Pages**

```sql
-- Pages disponibles
SELECT
    pool_id,
    free_buffers,
    CONCAT(
        ROUND((free_buffers / pool_size) * 100, 2),
        '%'
    ) AS free_ratio
FROM INFORMATION_SCHEMA.INNODB_BUFFER_POOL_STATS;

-- Free ratio < 5% : Buffer Pool saturÃ© (normal en production)
-- Free ratio > 20% : Buffer Pool sur-dimensionnÃ©
```

### Commandes de Monitoring AvancÃ©es

#### **SHOW ENGINE INNODB STATUS**

```sql
SHOW ENGINE INNODB STATUS\G

-- Section "BUFFER POOL AND MEMORY"
-- ====================================
-- Total large memory allocated 8589934592
-- Dictionary memory allocated 1234567
-- Buffer pool size   524288         -- Pages totales (Ã—16KB = 8 GB)
-- Free buffers       1024           -- Pages libres
-- Database pages     523000         -- Pages utilisÃ©es
-- Old database pages 193000         -- Pages dans old sublist
-- Modified db pages  50000          -- Dirty pages
-- Pending reads      0
-- Pending writes: LRU 0, flush list 0, single page 0
-- Pages made young   1000000        -- Promotions oldâ†’young
-- Pages made not young 500000       -- Pages restÃ©es dans old
-- Pages read 5000000, created 100000, written 200000
-- 10.50 reads/s, 0.20 creates/s, 0.50 writes/s
-- Buffer pool hit rate 999 / 1000   -- HIT RATIO : 99.9%
```

ğŸ’¡ **Indicateurs clÃ©s Ã  surveiller** :
- `Buffer pool hit rate` : > 999/1000 (99.9%)
- `Modified db pages` : < 90% de `Database pages`
- `Pages made young` : Taux de promotion raisonnable
- `Pending reads/writes` : Doit Ãªtre proche de 0

#### **Performance Schema Instrumentation**

```sql
-- Activer l'instrumentation mÃ©moire
UPDATE performance_schema.setup_instruments
SET ENABLED = 'YES'
WHERE NAME LIKE 'memory/innodb/buf_buf_pool';

-- Consommation mÃ©moire dÃ©taillÃ©e
SELECT
    EVENT_NAME,
    CURRENT_COUNT_USED,
    CURRENT_NUMBER_OF_BYTES_USED / 1024 / 1024 / 1024 AS memory_gb,
    HIGH_COUNT_USED,
    HIGH_NUMBER_OF_BYTES_USED / 1024 / 1024 / 1024 AS high_memory_gb
FROM performance_schema.memory_summary_global_by_event_name
WHERE EVENT_NAME LIKE 'memory/innodb/buf%'
ORDER BY CURRENT_NUMBER_OF_BYTES_USED DESC;
```

#### **Sys Schema Helper Views**

```sql
-- Vue simplifiÃ©e du Buffer Pool (MariaDB 10.5+)
SELECT * FROM sys.innodb_buffer_stats_by_schema
ORDER BY allocated DESC;

-- Vue par table
SELECT * FROM sys.innodb_buffer_stats_by_table
ORDER BY allocated DESC
LIMIT 20;
```

### Diagnostic de Performance

#### **ProblÃ¨me : Hit Ratio Faible (<95%)**

**Causes possibles** :

1. **Buffer Pool trop petit**

```sql
-- VÃ©rifier la taille des donnÃ©es
SELECT
    SUM(data_length + index_length) / 1024 / 1024 / 1024 AS total_size_gb
FROM information_schema.tables
WHERE engine = 'InnoDB';

-- Comparer avec Buffer Pool size
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';

-- Solution : Augmenter
SET GLOBAL innodb_buffer_pool_size = 16G;
```

2. **Scans de tables frÃ©quents**

```sql
-- Identifier les full table scans
SELECT
    SCHEMA_NAME,
    SUM(ROWS_EXAMINED - ROWS_SENT) AS rows_scanned
FROM performance_schema.events_statements_summary_by_digest
GROUP BY SCHEMA_NAME
ORDER BY rows_scanned DESC;

-- Solution : Ajouter des index appropriÃ©s
```

3. **Working set > RAM disponible**

```sql
-- Analyser les tables les plus accÃ©dÃ©es
SELECT
    object_schema,
    object_name,
    COUNT_READ,
    COUNT_WRITE,
    COUNT_FETCH,
    COUNT_INSERT
FROM performance_schema.table_io_waits_summary_by_table
ORDER BY COUNT_READ + COUNT_FETCH DESC
LIMIT 20;

-- Solution : Partitionnement, archivage, scaling vertical
```

#### **ProblÃ¨me : Trop de Dirty Pages (>90%)**

**Causes** :
- Charge d'Ã©criture trÃ¨s Ã©levÃ©e
- Flushing insuffisant

```sql
-- VÃ©rifier la configuration I/O
SHOW VARIABLES LIKE 'innodb_io_capacity%';

-- Augmenter la capacitÃ© I/O (SSD moderne)
SET GLOBAL innodb_io_capacity = 5000;
SET GLOBAL innodb_io_capacity_max = 10000;

-- Activer adaptive flushing
SET GLOBAL innodb_adaptive_flushing = ON;

-- RÃ©duire le seuil de dirty pages
SET GLOBAL innodb_max_dirty_pages_pct = 75;
```

#### **ProblÃ¨me : Pages Made Young Ã‰levÃ©**

Trop de promotions oldâ†’young indique un workload conflictuel entre donnÃ©es chaudes et scans.

```sql
-- Augmenter le temps avant promotion
SET GLOBAL innodb_old_blocks_time = 2000;  -- 2 secondes

-- Augmenter la taille de la old sublist
SET GLOBAL innodb_old_blocks_pct = 50;  -- 50% au lieu de 37%
```

---

## PrÃ©chargement et Warm-up du Buffer Pool

### Sauvegarder l'Ã‰tat du Buffer Pool

ğŸ†• **FonctionnalitÃ© native** : InnoDB peut sauvegarder et restaurer l'Ã©tat du Buffer Pool lors d'un redÃ©marrage, Ã©vitant une pÃ©riode de "warm-up" longue.

```sql
-- Activer la sauvegarde automatique
innodb_buffer_pool_dump_at_shutdown = ON   -- Sauver au shutdown
innodb_buffer_pool_load_at_startup = ON    -- Charger au dÃ©marrage

-- Sauvegarde manuelle (sans redÃ©marrage)
SET GLOBAL innodb_buffer_pool_dump_now = ON;

-- Restauration manuelle
SET GLOBAL innodb_buffer_pool_load_now = ON;

-- Annuler une restauration en cours
SET GLOBAL innodb_buffer_pool_load_abort = ON;
```

**Fichier de dump** :

```bash
# Emplacement du fichier (datadir)
/var/lib/mysql/ib_buffer_pool

# Contenu : liste des (space_id, page_id) des pages en cache
# Taille : ~10-50 MB pour un Buffer Pool de 32 GB
```

**Monitoring du processus** :

```sql
-- Statut du dump/load
SHOW STATUS LIKE 'Innodb_buffer_pool_dump%';
SHOW STATUS LIKE 'Innodb_buffer_pool_load%';

-- Exemple de rÃ©sultat :
-- Innodb_buffer_pool_dump_status: Dumping buffer pool(s) completed at 2025-12-12 10:00:00
-- Innodb_buffer_pool_load_status: Buffer pool(s) load completed at 2025-12-12 10:05:00
```

ğŸ’¡ **Best practice** : Toujours activer ces options en production pour minimiser le temps de warm-up aprÃ¨s un redÃ©marrage.

### PrÃ©chargement de Tables Critiques

```sql
-- Forcer le chargement d'une table en mÃ©moire
SELECT COUNT(*) FROM hot_products;

-- Ou avec index hint pour charger l'index
SELECT COUNT(*) FROM hot_products FORCE INDEX (PRIMARY);

-- Script de warm-up (aprÃ¨s redÃ©marrage)
DELIMITER //
CREATE PROCEDURE warmup_buffer_pool()
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE tbl_name VARCHAR(255);

    DECLARE cur CURSOR FOR
        SELECT table_name
        FROM information_schema.tables
        WHERE table_schema = 'myapp'
          AND table_name IN ('orders', 'customers', 'products');

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    OPEN cur;

    read_loop: LOOP
        FETCH cur INTO tbl_name;
        IF done THEN
            LEAVE read_loop;
        END IF;

        SET @sql = CONCAT('SELECT COUNT(*) FROM ', tbl_name);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END LOOP;

    CLOSE cur;
END//
DELIMITER ;

-- ExÃ©cution au dÃ©marrage
CALL warmup_buffer_pool();
```

---

## Optimisations AvancÃ©es et MariaDB 11.8

### Optimisations SSD

ğŸ†• **MariaDB 11.8** : Le cost-based optimizer prend dÃ©sormais en compte les caractÃ©ristiques des SSD.

```ini
[mysqld]
# DÃ©sactiver le flushing de pages adjacentes (inutile sur SSD)
innodb_flush_neighbors = 0

# Utiliser native AIO (asynchronous I/O)
innodb_use_native_aio = ON

# I/O capacity adaptÃ©e aux SSD modernes
innodb_io_capacity = 5000
innodb_io_capacity_max = 10000

# Read-ahead optimisÃ© pour SSD
innodb_random_read_ahead = OFF      # DÃ©sactiver pour SSD (accÃ¨s random rapide)
innodb_read_ahead_threshold = 56    # Ou 0 pour dÃ©sactiver complÃ¨tement
```

### Adaptive Hash Index

InnoDB maintient un index hash en mÃ©moire pour accÃ©lÃ©rer les lookups frÃ©quents.

```sql
-- Activer (dÃ©faut)
innodb_adaptive_hash_index = ON

-- Partitionner l'AHI (rÃ©duire la contention)
innodb_adaptive_hash_index_parts = 8

-- Monitoring
SHOW ENGINE INNODB STATUS\G
-- Section "INSERT BUFFER AND ADAPTIVE HASH INDEX"
-- hash searches/s, non-hash searches/s
-- Hash table size: X (buckets)
```

ğŸ’¡ **Quand l'activer** :
- âœ… Workload OLTP avec lookups rÃ©pÃ©titifs sur clÃ©s primaires
- âœ… Peu de variation dans les requÃªtes (patterns prÃ©visibles)

**Quand le dÃ©sactiver** :
- âŒ Workload OLAP avec scans complets
- âŒ Charge trÃ¨s variable (hash index thrashing)

### Transparent Page Compression

ğŸ†• **Compression Ã  la volÃ©e** : RÃ©duire l'empreinte disque et I/O.

```sql
-- Activer sur table existante
ALTER TABLE large_logs
    COMPRESSION='zlib'
    PAGE_COMPRESSED=1;

-- Nouvelle table avec compression
CREATE TABLE archive_data (
    id INT PRIMARY KEY,
    data LONGTEXT
) ENGINE=InnoDB
  ROW_FORMAT=COMPRESSED
  KEY_BLOCK_SIZE=8
  PAGE_COMPRESSED=1
  COMPRESSION='zlib';
```

**Algorithmes disponibles** :
- `zlib` : Bon ratio, CPU modÃ©rÃ©
- `lz4` : Moins de compression, trÃ¨s rapide (ğŸ†• recommandÃ©)
- `lzma` : Maximum compression, CPU Ã©levÃ©
- `snappy` : Compromis
- `bzip2` : Legacy

âš ï¸ **Trade-off** : Compression rÃ©duit I/O mais augmente CPU. Ã€ utiliser sur donnÃ©es froides ou archives.

---

## Configuration de RÃ©fÃ©rence par Profil

### Production OLTP (64 GB RAM, SSD)

```ini
[mysqld]
# Buffer Pool
innodb_buffer_pool_size = 48G
innodb_buffer_pool_instances = 48
innodb_buffer_pool_chunk_size = 128M

# Sauvegarde/Restauration Buffer Pool
innodb_buffer_pool_dump_at_shutdown = ON
innodb_buffer_pool_load_at_startup = ON
innodb_buffer_pool_dump_pct = 50

# LRU tuning
innodb_old_blocks_pct = 37
innodb_old_blocks_time = 1000

# I/O Configuration (SSD)
innodb_io_capacity = 5000
innodb_io_capacity_max = 10000
innodb_flush_neighbors = 0
innodb_use_native_aio = ON

# Flushing
innodb_adaptive_flushing = ON
innodb_adaptive_flushing_lwm = 10
innodb_max_dirty_pages_pct = 80
innodb_max_dirty_pages_pct_lwm = 10
innodb_page_cleaners = 8

# Adaptive Hash Index
innodb_adaptive_hash_index = ON
innodb_adaptive_hash_index_parts = 8

# Read-ahead (dÃ©sactivÃ© pour SSD)
innodb_random_read_ahead = OFF
innodb_read_ahead_threshold = 0
```

### Data Warehouse / OLAP (128 GB RAM)

```ini
[mysqld]
# Buffer Pool large pour analytique
innodb_buffer_pool_size = 96G
innodb_buffer_pool_instances = 64

# LRU adaptÃ© aux scans
innodb_old_blocks_pct = 25          # Old sublist plus petite
innodb_old_blocks_time = 100        # Promotion rapide

# I/O sÃ©quentiel optimisÃ©
innodb_io_capacity = 2000
innodb_io_capacity_max = 4000
innodb_read_ahead_threshold = 56    # Prefetch agressif

# Moins de flushing (moins d'Ã©critures)
innodb_max_dirty_pages_pct = 90
innodb_adaptive_flushing = ON

# Adaptive Hash moins utile (scans)
innodb_adaptive_hash_index = OFF
```

### DÃ©veloppement Local (8 GB RAM)

```ini
[mysqld]
# Configuration minimale
innodb_buffer_pool_size = 4G
innodb_buffer_pool_instances = 4

# DurabilitÃ© relaxÃ©e (dev uniquement)
innodb_flush_log_at_trx_commit = 2
innodb_doublewrite = OFF

# I/O rÃ©duit
innodb_io_capacity = 200
innodb_io_capacity_max = 400

# Monitoring simplifiÃ©
innodb_buffer_pool_dump_at_shutdown = OFF
```

### Conteneur / Kubernetes (16 GB Pod)

```ini
[mysqld]
# 60% de la limite mÃ©moire du pod
innodb_buffer_pool_size = 10G
innodb_buffer_pool_instances = 10

# Configuration stable
innodb_buffer_pool_dump_at_shutdown = ON
innodb_buffer_pool_load_at_startup = ON

# I/O adaptÃ© au stockage cloud
innodb_io_capacity = 1000
innodb_io_capacity_max = 2000
innodb_flush_method = O_DIRECT

# Ã‰viter l'OOM killer
performance_schema = OFF            # Ã‰conomiser 400 MB
```

---

## âœ… Points clÃ©s Ã  retenir

- **Buffer Pool = Cache RAM critique** : Doit contenir le working set (donnÃ©es chaudes) pour atteindre >99% hit ratio
- **Architecture en 3 listes** : Free List (disponibles), LRU List (algorithme modifiÃ© midpoint), Flush List (dirty pages)
- **Dimensionnement** : 70-80% RAM disponible, 1 instance par GB (max 64), redimensionnement dynamique possible
- **Monitoring essentiel** : Hit ratio (>99%), dirty pages (<90%), free buffers, pages read vs requests
- **Optimisations SSD** : `innodb_flush_neighbors=0`, `innodb_io_capacity` Ã©levÃ©, read-ahead dÃ©sactivÃ©
- **Dump/Load automatique** : Active en production pour warm-up rapide aprÃ¨s redÃ©marrage
- **MariaDB 11.8** : Cost optimizer conscient des SSD, `innodb_alter_copy_bulk` pour construction index efficace
- **Trade-offs** : MÃ©moire vs Concurrence (instances), DurabilitÃ© vs Performance (flushing), Compression vs CPU

---

## ğŸ”— Ressources et rÃ©fÃ©rences

- [ğŸ“– InnoDB Buffer Pool](https://mariadb.com/kb/en/innodb-buffer-pool/)
- [ğŸ“– InnoDB Buffer Pool Configuration](https://mariadb.com/kb/en/innodb-system-variables/#innodb_buffer_pool_size)
- [ğŸ“– InnoDB Startup Configuration](https://mariadb.com/kb/en/innodb-system-variables/#innodb_buffer_pool_load_at_startup)
- [ğŸ“– Optimizing InnoDB Disk I/O](https://mariadb.com/kb/en/optimizing-innodb-disk-io/)
- [ğŸ“– INFORMATION_SCHEMA INNODB_BUFFER_POOL_STATS](https://mariadb.com/kb/en/information-schema-innodb_buffer_pool_stats-table/)
- [ğŸ†• MariaDB 11.8 Performance Improvements](https://mariadb.com/kb/en/changes-improvements-in-mariadb-118/)

**Outils recommandÃ©s** :
- `innotop` - Monitoring InnoDB temps rÃ©el
- PMM (Percona Monitoring Management) - Dashboards Buffer Pool
- `pt-query-digest` - Analyse des requÃªtes pour optimisation

**Articles techniques** :
- "Understanding the InnoDB Buffer Pool" - Percona Blog
- "InnoDB Performance Optimization Basics" - MariaDB Foundation
- "InnoDB Buffer Pool Sizing" - MySQL Server Team Blog

---

## â¡ï¸ Section suivante

**[7.2.3 Redo Log et Undo Log](/07-moteurs-de-stockage/02.3-innodb-redo-undo-log.md)** : MÃ©canismes de durabilitÃ© et de rÃ©cupÃ©ration aprÃ¨s crash, configuration des logs de transactions, optimisations pour haute performance.

â­ï¸ [Redo Log et Undo Log](/07-moteurs-de-stockage/02.3-innodb-redo-undo-log.md)
