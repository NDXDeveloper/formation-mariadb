üîù Retour au [Sommaire](/SOMMAIRE.md)

# 7.10.1 Memory : Tables en RAM

> **Niveau** : Avanc√©
> **Dur√©e estim√©e** : 2 heures

> **Pr√©requis** :
> - Compr√©hension des moteurs de stockage MariaDB
> - Notions de gestion m√©moire
> - Architecture InnoDB (Section 7.2)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre l'architecture et le fonctionnement du moteur Memory
- Identifier les cas d'usage appropri√©s pour les tables Memory
- Ma√Ætriser les limitations et contraintes du moteur
- Configurer et optimiser les tables Memory
- Comparer Memory avec les alternatives (temp tables, Redis, InnoDB)
- Impl√©menter des patterns de cache efficaces avec Memory
- Choisir entre Memory et autres solutions selon le contexte

---

## Introduction

Le moteur **Memory** (anciennement appel√© **HEAP**) est un moteur de stockage sp√©cialis√© qui stocke **toutes les donn√©es en RAM**. Il offre des performances extr√™mes pour les acc√®s en lecture/√©criture au prix d'importantes limitations.

**Caract√©ristiques principales** :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              MOTEUR MEMORY                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                       ‚îÇ
‚îÇ  ‚úì Stockage 100% RAM (volatile)                       ‚îÇ
‚îÇ  ‚úì Performance ultra-rapide (pas d'I/O)               ‚îÇ
‚îÇ  ‚úì Table-level locking                                ‚îÇ
‚îÇ  ‚úó Donn√©es perdues au red√©marrage                     ‚îÇ
‚îÇ  ‚úó Types de donn√©es limit√©s                           ‚îÇ
‚îÇ  ‚úó Pas de support BLOB/TEXT                           ‚îÇ
‚îÇ  ‚úó Taille limit√©e par max_heap_table_size             ‚îÇ
‚îÇ                                                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

üí° **Principe fondamental** : Memory est con√ßu pour des donn√©es **temporaires**, **petites** et **fr√©quemment acc√©d√©es** o√π la persistance n'est pas requise.

### Quand Utiliser Memory ?

**Cas d'usage appropri√©s** :
- Tables de lookup/r√©f√©rence charg√©es au d√©marrage
- Caches applicatifs simples
- Tables de session utilisateur
- R√©sultats interm√©diaires de calculs
- Donn√©es de monitoring temps r√©el

**Quand NE PAS utiliser Memory** :
- Donn√©es critiques n√©cessitant persistance
- Tables volumineuses (>quelques GB)
- Donn√©es n√©cessitant BLOB/TEXT
- Applications n√©cessitant transactions ACID
- Environnements avec RAM limit√©e

---

## Architecture du Moteur Memory

### Stockage en M√©moire

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               ARCHITECTURE MEMORY ENGINE               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                        ‚îÇ
‚îÇ   RAM (Heap Memory)                                    ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ   ‚îÇ                                              ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  TABLE memory_table                          ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚îú‚îÄ Metadata (structure)                     ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚îú‚îÄ Row Data (array of fixed-size records)   ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ  ‚îî‚îÄ Indexes                                  ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ     ‚îú‚îÄ HASH indexes (default)                ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ     ‚îî‚îÄ BTREE indexes (optional)              ‚îÇ     ‚îÇ
‚îÇ   ‚îÇ                                              ‚îÇ     ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                                                        ‚îÇ
‚îÇ   Disk (ONLY metadata - .frm file)                     ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ   ‚îÇ  memory_table.frm (structure definition)     ‚îÇ     ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                                                        ‚îÇ
‚îÇ   Au red√©marrage : table vide (donn√©es perdues)        ‚îÇ
‚îÇ                                                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Points cl√©s** :
- Les donn√©es r√©sident uniquement en RAM (jamais √©crites sur disque)
- Seule la d√©finition de la table (.frm) est persist√©e
- Au red√©marrage du serveur, les tables sont recr√©√©es vides
- Pas de journalisation (redo/undo logs)

### Types d'Index

Le moteur Memory supporte **deux types d'index** :

#### **1. HASH Index (Par D√©faut)**

```sql
-- Cr√©ation avec index HASH par d√©faut
CREATE TABLE cache_users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    last_login DATETIME,
    KEY idx_username (username)  -- HASH par d√©faut
) ENGINE=MEMORY;
```

**Caract√©ristiques HASH** :
- ‚úÖ Recherche par √©galit√© ultra-rapide : O(1)
- ‚úÖ Parfait pour lookups exacts
- ‚ùå Pas de range queries (WHERE col > value)
- ‚ùå Pas de ORDER BY optimis√©
- ‚ùå Pas de prefix matching (LIKE 'prefix%')

```sql
-- Requ√™tes optimis√©es avec HASH
SELECT * FROM cache_users WHERE user_id = 12345;        -- Optimal
SELECT * FROM cache_users WHERE username = 'alice';     -- Optimal

-- Requ√™tes NON optimis√©es avec HASH
SELECT * FROM cache_users WHERE user_id > 10000;        -- Full scan
SELECT * FROM cache_users WHERE username LIKE 'ali%';   -- Full scan
SELECT * FROM cache_users ORDER BY username;            -- Full scan + sort
```

#### **2. BTREE Index (Optionnel)**

```sql
-- Cr√©ation avec index BTREE explicite
CREATE TABLE session_data (
    session_id CHAR(32) PRIMARY KEY,
    user_id INT NOT NULL,
    created_at TIMESTAMP,
    data VARCHAR(1000),
    INDEX idx_user_btree (user_id) USING BTREE,
    INDEX idx_created_btree (created_at) USING BTREE
) ENGINE=MEMORY;
```

**Caract√©ristiques BTREE** :
- ‚úÖ Range queries efficaces
- ‚úÖ ORDER BY optimis√©
- ‚úÖ Prefix matching
- ‚ùå L√©g√®rement plus lent que HASH pour √©galit√© stricte

```sql
-- Requ√™tes optimis√©es avec BTREE
SELECT * FROM session_data WHERE user_id > 1000;                -- Range scan
SELECT * FROM session_data WHERE created_at BETWEEN '2025-01-01' AND '2025-12-31';
SELECT * FROM session_data ORDER BY created_at DESC LIMIT 10;   -- Index scan
```

**Comparaison Performance** :

| Op√©ration | HASH | BTREE |
|-----------|------|-------|
| √âgalit√© (=) | ‚ö°‚ö°‚ö° Tr√®s rapide | ‚ö°‚ö° Rapide |
| Range (<, >) | ‚ùå Full scan | ‚ö°‚ö° Range scan |
| ORDER BY | ‚ùå Full scan + sort | ‚ö° Index scan |
| LIKE 'prefix%' | ‚ùå Full scan | ‚ö°‚ö° Prefix scan |
| IN (...) | ‚ö°‚ö°‚ö° Multiple lookups | ‚ö°‚ö° Multiple lookups |

üí° **Recommandation** :
- HASH pour colonnes de lookup/cl√©s (user_id, session_id, code)
- BTREE pour colonnes de tri/range (dates, montants, scores)

---

## Caract√©ristiques et Limitations

### Support des Types de Donn√©es

**Types support√©s** :

```sql
CREATE TABLE memory_types_demo (
    -- Types num√©riques : OK
    id INT PRIMARY KEY,
    bigint_col BIGINT,
    decimal_col DECIMAL(10,2),
    float_col FLOAT,
    double_col DOUBLE,

    -- Types cha√Æne : OK (longueur fixe recommand√©e)
    char_col CHAR(10),          -- Optimal
    varchar_col VARCHAR(255),   -- Support√©

    -- Types temporels : OK
    date_col DATE,
    datetime_col DATETIME,
    timestamp_col TIMESTAMP,
    time_col TIME,

    -- Types binaires : Limit√©s
    binary_col BINARY(16),      -- OK
    varbinary_col VARBINARY(100), -- OK

    -- Types NON support√©s
    -- text_col TEXT,            ‚ùå ERROR
    -- blob_col BLOB,            ‚ùå ERROR
    -- json_col JSON,            ‚ùå ERROR (utiliser VARCHAR)
    -- spatial_col GEOMETRY      ‚ùå ERROR

    -- √ânum√©rations : OK
    enum_col ENUM('A', 'B', 'C'),
    set_col SET('opt1', 'opt2', 'opt3')
) ENGINE=MEMORY;
```

‚ö†Ô∏è **Limitations critiques** :
- **Pas de BLOB/TEXT** : Pour stocker du texte long, utiliser VARCHAR(max)
- **Pas de JSON natif** : Stocker en VARCHAR et parser en application
- **VARCHAR stock√© comme CHAR** : Padding avec espaces (consommation m√©moire)

### Limitations Fonctionnelles

```sql
-- ‚ùå Pas de support transactions
START TRANSACTION;
INSERT INTO memory_table VALUES (1, 'test');
ROLLBACK;  -- N'annule PAS l'insertion

-- ‚ùå Pas de Foreign Keys
CREATE TABLE memory_parent (id INT PRIMARY KEY) ENGINE=MEMORY;
CREATE TABLE memory_child (
    id INT PRIMARY KEY,
    parent_id INT,
    FOREIGN KEY (parent_id) REFERENCES memory_parent(id)  -- ERROR
) ENGINE=MEMORY;

-- ‚ùå Pas d'AUTO_INCREMENT persistant
CREATE TABLE memory_auto (
    id INT AUTO_INCREMENT PRIMARY KEY,
    data VARCHAR(100)
) ENGINE=MEMORY;

INSERT INTO memory_auto (data) VALUES ('row1'), ('row2');  -- id: 1, 2
-- [Red√©marrage serveur]
INSERT INTO memory_auto (data) VALUES ('row3');  -- id: 1 (restart √† 1)

-- ‚ùå Table-level locking uniquement
-- Session 1
UPDATE memory_table SET col = 'value' WHERE id = 1;  -- Verrouille TOUTE la table

-- Session 2
UPDATE memory_table SET col = 'value' WHERE id = 2;  -- BLOQU√âE
```

### Limitations de Taille

```sql
-- Configuration de la taille maximale
SHOW VARIABLES LIKE 'max_heap_table_size';
-- +---------------------+-----------+
-- | Variable_name       | Value     |
-- +---------------------+-----------+
-- | max_heap_table_size | 16777216  |  -- 16 MB (d√©faut)
-- +---------------------+-----------+

-- Taille par session (peut √™tre plus restrictive)
SHOW VARIABLES LIKE 'tmp_table_size';

-- Augmenter la limite (session)
SET max_heap_table_size = 1073741824;  -- 1 GB

-- Augmenter globalement (my.cnf)
[mysqld]
max_heap_table_size = 1G
```

**Calcul de la consommation m√©moire** :

```sql
-- Formule approximative
Taille = (taille_ligne_fixe √ó nombre_lignes) + overhead_index

-- Exemple
CREATE TABLE memory_example (
    id INT,              -- 4 bytes
    code CHAR(10),       -- 10 bytes
    value DECIMAL(10,2), -- 5 bytes
    timestamp INT,       -- 4 bytes
    PRIMARY KEY (id)     -- HASH index: ~16 bytes/row overhead
) ENGINE=MEMORY;

-- Taille par ligne ‚âà 4 + 10 + 5 + 4 + 16 = 39 bytes
-- Pour 1 million de lignes ‚âà 39 MB
-- + Overhead structure ‚âà 5%
-- Total ‚âà 41 MB
```

üí° **Best practice** : Pr√©voir 20-30% de marge pour overhead et croissance.

---

## Configuration et Optimisation

### Variables Syst√®me

```ini
[mysqld]
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# MEMORY ENGINE CONFIGURATION
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# Taille maximale d'une table Memory (par table)
max_heap_table_size = 1G                    # D√©faut: 16M

# Taille maximale des tables temporaires internes
# (limite inf√©rieure pour Memory)
tmp_table_size = 512M                       # D√©faut: 16M

# Monitoring : Nombre de tables Memory cr√©√©es
# SHOW GLOBAL STATUS LIKE 'Created_tmp_tables';
# SHOW GLOBAL STATUS LIKE 'Created_tmp_disk_tables';
```

**Relation entre les variables** :

```
Table Memory Limit = MIN(max_heap_table_size, tmp_table_size)

Exemple :
max_heap_table_size = 1G
tmp_table_size = 512M
‚Üí Limite effective = 512M
```

### Optimisation des Structures

#### **1. Utiliser des Types Fixes**

```sql
-- ‚ùå Sous-optimal (VARCHAR = stockage variable)
CREATE TABLE cache_suboptimal (
    id INT PRIMARY KEY,
    code VARCHAR(20),
    name VARCHAR(100)
) ENGINE=MEMORY;

-- ‚úÖ Optimal (CHAR = stockage fixe)
CREATE TABLE cache_optimal (
    id INT PRIMARY KEY,
    code CHAR(20),        -- Taille fixe
    name CHAR(100)        -- Taille fixe
) ENGINE=MEMORY;

-- Gains :
-- - Calcul offset plus rapide (acc√®s direct)
-- - Pas de fragmentation m√©moire
-- - Meilleure localit√© cache CPU
```

#### **2. Minimiser la Taille des Colonnes**

```sql
-- ‚ùå Gaspillage m√©moire
CREATE TABLE session_waste (
    session_id CHAR(255) PRIMARY KEY,  -- Trop grand
    user_id BIGINT,                    -- INT suffisant
    status VARCHAR(255),               -- ENUM ou TINYINT
    counter DECIMAL(20,0)              -- INT suffisant
) ENGINE=MEMORY;

-- ‚úÖ Optimis√©
CREATE TABLE session_optimized (
    session_id CHAR(32) PRIMARY KEY,   -- MD5/UUID size
    user_id INT,                       -- 4 bytes vs 8
    status ENUM('active', 'expired'),  -- 1 byte
    counter INT                        -- 4 bytes
) ENGINE=MEMORY;

-- √âconomie : ~50% de m√©moire pour m√™me donn√©es
```

#### **3. Index Strat√©giques**

```sql
-- Table de cache avec patterns d'acc√®s mixtes
CREATE TABLE product_cache (
    product_id INT PRIMARY KEY,              -- HASH (lookup)
    category_id INT,
    price DECIMAL(10,2),
    created_at DATETIME,
    name VARCHAR(100),

    INDEX idx_category (category_id),       -- HASH (lookup)
    INDEX idx_price (price) USING BTREE,    -- BTREE (range)
    INDEX idx_created (created_at) USING BTREE  -- BTREE (ORDER BY)
) ENGINE=MEMORY;

-- Requ√™tes optimis√©es
SELECT * FROM product_cache WHERE product_id = 123;         -- HASH O(1)
SELECT * FROM product_cache WHERE category_id = 5;          -- HASH O(1)
SELECT * FROM product_cache WHERE price BETWEEN 10 AND 50;  -- BTREE range
SELECT * FROM product_cache ORDER BY created_at DESC LIMIT 10;  -- BTREE scan
```

---

## Cas d'Usage et Patterns

### 1. Table de Lookup (R√©f√©rence)

**Sc√©nario** : Codes pays, devises, param√®tres configuration

```sql
-- Cr√©ation au d√©marrage
CREATE TABLE IF NOT EXISTS config_lookup (
    config_key VARCHAR(50) PRIMARY KEY,
    config_value VARCHAR(200),
    updated_at TIMESTAMP
) ENGINE=MEMORY;

-- Chargement initial (dans script de d√©marrage)
DELIMITER //
CREATE PROCEDURE load_config_cache()
BEGIN
    -- Nettoyer
    DELETE FROM config_lookup;

    -- Charger depuis table persistante
    INSERT INTO config_lookup
    SELECT config_key, config_value, updated_at
    FROM config_persistent
    WHERE active = 1;
END//
DELIMITER ;

-- Au d√©marrage du serveur
CALL load_config_cache();

-- Application : lookup ultra-rapide
SELECT config_value FROM config_lookup WHERE config_key = 'max_upload_size';
-- Temps : <0.1ms
```

### 2. Cache de Session Utilisateur

**Sc√©nario** : Sessions web, tokens d'authentification

```sql
-- Table de session
CREATE TABLE user_sessions (
    session_id CHAR(32) PRIMARY KEY,
    user_id INT NOT NULL,
    ip_address VARCHAR(45),
    user_agent VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_activity TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    data VARCHAR(2000),  -- JSON serialized data

    INDEX idx_user (user_id),
    INDEX idx_activity (last_activity) USING BTREE
) ENGINE=MEMORY;

-- Insertion session (login)
INSERT INTO user_sessions (session_id, user_id, ip_address, user_agent, data)
VALUES (MD5(CONCAT(UNIX_TIMESTAMP(), RAND())), 12345, '192.168.1.100', 'Mozilla/5.0...', '{"cart_id":789}');

-- Validation session (chaque requ√™te)
SELECT user_id, data
FROM user_sessions
WHERE session_id = ?
  AND last_activity > DATE_SUB(NOW(), INTERVAL 30 MINUTE);

-- Nettoyage sessions expir√©es (scheduled job)
DELETE FROM user_sessions
WHERE last_activity < DATE_SUB(NOW(), INTERVAL 30 MINUTE);
```

### 3. Compteurs et Statistiques Temps R√©el

**Sc√©nario** : M√©triques applicatives, rate limiting

```sql
-- Table de compteurs
CREATE TABLE realtime_counters (
    metric_key VARCHAR(100) PRIMARY KEY,
    counter_value BIGINT DEFAULT 0,
    window_start TIMESTAMP,

    INDEX idx_window (window_start) USING BTREE
) ENGINE=MEMORY;

-- Incr√©menter compteur
INSERT INTO realtime_counters (metric_key, counter_value, window_start)
VALUES ('api_calls_user_123', 1, NOW())
ON DUPLICATE KEY UPDATE
    counter_value = counter_value + 1,
    window_start = IF(window_start < DATE_SUB(NOW(), INTERVAL 1 MINUTE), NOW(), window_start);

-- V√©rifier rate limit
SELECT counter_value
FROM realtime_counters
WHERE metric_key = 'api_calls_user_123'
  AND window_start >= DATE_SUB(NOW(), INTERVAL 1 MINUTE);

-- R√©initialisation p√©riodique (chaque minute)
DELETE FROM realtime_counters
WHERE window_start < DATE_SUB(NOW(), INTERVAL 1 MINUTE);
```

### 4. R√©sultats Interm√©diaires (ETL)

**Sc√©nario** : Calculs complexes multi-√©tapes

```sql
-- √âtape 1 : Agr√©gation initiale (table persistante ‚Üí Memory)
CREATE TABLE temp_sales_summary (
    product_id INT PRIMARY KEY,
    total_qty INT,
    total_amount DECIMAL(15,2),
    avg_price DECIMAL(10,2)
) ENGINE=MEMORY;

INSERT INTO temp_sales_summary
SELECT
    product_id,
    SUM(quantity) AS total_qty,
    SUM(amount) AS total_amount,
    AVG(price) AS avg_price
FROM sales_fact
WHERE sale_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
GROUP BY product_id;

-- √âtape 2 : Enrichissement (jointure rapide en m√©moire)
CREATE TABLE temp_product_analysis (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(100),
    category VARCHAR(50),
    total_qty INT,
    total_amount DECIMAL(15,2),
    margin_pct DECIMAL(5,2)
) ENGINE=MEMORY;

INSERT INTO temp_product_analysis
SELECT
    s.product_id,
    p.name,
    p.category,
    s.total_qty,
    s.total_amount,
    ((s.total_amount - (s.total_qty * p.cost)) / s.total_amount) * 100 AS margin_pct
FROM temp_sales_summary s
JOIN products p ON s.product_id = p.id;

-- √âtape 3 : R√©sultat final vers table persistante
INSERT INTO product_performance_report
SELECT * FROM temp_product_analysis;

-- Nettoyage
DROP TABLE temp_sales_summary;
DROP TABLE temp_product_analysis;
```

### 5. Queue/Buffer Temporaire

**Sc√©nario** : File d'attente pour traitement asynchrone

```sql
-- Queue en m√©moire
CREATE TABLE job_queue (
    job_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    job_type VARCHAR(50),
    payload VARCHAR(2000),
    priority TINYINT DEFAULT 5,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_priority (priority, created_at) USING BTREE
) ENGINE=MEMORY;

-- Enqueue job
INSERT INTO job_queue (job_type, payload, priority)
VALUES ('send_email', '{"to":"user@example.com","subject":"..."}', 3);

-- Dequeue job (worker)
SELECT job_id, job_type, payload
FROM job_queue
ORDER BY priority ASC, created_at ASC
LIMIT 1
FOR UPDATE;  -- Lock pour √©viter double traitement

-- Apr√®s traitement
DELETE FROM job_queue WHERE job_id = ?;

-- Failover : Persister si queue trop grande
INSERT INTO job_queue_persistent
SELECT * FROM job_queue
WHERE created_at < DATE_SUB(NOW(), INTERVAL 5 MINUTE);

DELETE FROM job_queue
WHERE created_at < DATE_SUB(NOW(), INTERVAL 5 MINUTE);
```

---

## Comparaison avec Alternatives

### Memory vs InnoDB (Buffer Pool)

```sql
-- Test : 1 million lookups
-- Configuration : InnoDB Buffer Pool 8GB, table 100MB

-- Option 1 : InnoDB
CREATE TABLE lookup_innodb (
    id INT PRIMARY KEY,
    code CHAR(10),
    value INT
) ENGINE=InnoDB;

-- Option 2 : Memory
CREATE TABLE lookup_memory (
    id INT PRIMARY KEY,
    code CHAR(10),
    value INT
) ENGINE=MEMORY;
```

**Benchmark r√©sultats** :

| M√©trique | InnoDB (in Buffer Pool) | Memory |
|----------|------------------------|---------|
| SELECT par cl√© | 0.05 ms | 0.02 ms |
| SELECT 1000 rows | 5 ms | 2 ms |
| INSERT 1 row | 0.1 ms | 0.03 ms |
| UPDATE 1 row | 0.15 ms | 0.04 ms |
| Persistance | ‚úÖ Oui | ‚ùå Non |
| ACID | ‚úÖ Complet | ‚ùå Non |
| Overhead m√©moire | +30% (index, MVCC) | +10% (minimal) |

**Conclusion** :
- Memory 2-3√ó plus rapide qu'InnoDB en Buffer Pool
- InnoDB recommand√© si :
  - Persistance requise
  - Transactions n√©cessaires
  - Table > 1-2 GB
- Memory recommand√© si :
  - Donn√©es purement temporaires
  - Performance critique
  - Table < 500 MB

### Memory vs Temporary Tables

```sql
-- Temporary table (cr√©√©e automatiquement par MySQL)
CREATE TEMPORARY TABLE temp_calc (
    id INT,
    value DECIMAL(10,2)
);  -- ENGINE selon configuration (peut √™tre Memory ou InnoDB)

-- vs

-- Explicit Memory table
CREATE TABLE explicit_memory (
    id INT,
    value DECIMAL(10,2)
) ENGINE=MEMORY;
```

**Diff√©rences** :

| Aspect | TEMPORARY TABLE | Explicit MEMORY |
|--------|----------------|-----------------|
| Scope | Session uniquement | Global (toutes sessions) |
| Dur√©e de vie | Jusqu'√† fermeture connexion | Jusqu'√† red√©marrage serveur |
| Moteur | Memory OU InnoDB (auto) | Toujours Memory |
| Visibilit√© | Une seule session | Toutes sessions |
| Nommage | Peut conflits √©vit√©s | Risque conflits nommage |

üí° **Recommandation** :
- **TEMPORARY** pour calculs dans une session
- **MEMORY** pour cache partag√© entre sessions

### Memory vs Redis

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              MEMORY TABLE vs REDIS                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                          ‚îÇ
‚îÇ  Memory Table                Redis                       ‚îÇ
‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                      ‚îÇ
‚îÇ  ‚Ä¢ SQL natif                  ‚Ä¢ Key-Value store          ‚îÇ
‚îÇ  ‚Ä¢ Transactions locales       ‚Ä¢ Transactions distribu√©es ‚îÇ
‚îÇ  ‚Ä¢ Pas de persistance         ‚Ä¢ Persistance optionnelle  ‚îÇ
‚îÇ  ‚Ä¢ Requ√™tes complexes         ‚Ä¢ Commandes simples        ‚îÇ
‚îÇ  ‚Ä¢ Limit√© √† MariaDB           ‚Ä¢ Ind√©pendant DB           ‚îÇ
‚îÇ  ‚Ä¢ Pas de clustering          ‚Ä¢ Clustering natif         ‚îÇ
‚îÇ                                                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Quand choisir Memory** :
- D√©j√† utilise MariaDB
- Requ√™tes SQL complexes n√©cessaires
- Pas besoin de clustering
- Int√©gration simple (m√™me connexion DB)

**Quand choisir Redis** :
- Architecture microservices
- Besoin de persistance configurable
- Clustering/haute disponibilit√©
- Types de donn√©es avanc√©s (lists, sets, sorted sets)
- Pub/Sub messaging

---

## Patterns Avanc√©s

### 1. Two-Tier Cache Pattern

**Architecture** : Memory table + InnoDB table

```sql
-- Tier 1 : Hot cache (Memory)
CREATE TABLE cache_hot (
    cache_key VARCHAR(100) PRIMARY KEY,
    cache_value VARCHAR(2000),
    created_at TIMESTAMP,
    access_count INT DEFAULT 1
) ENGINE=MEMORY;

-- Tier 2 : Cold cache (InnoDB persistant)
CREATE TABLE cache_cold (
    cache_key VARCHAR(100) PRIMARY KEY,
    cache_value VARCHAR(2000),
    created_at TIMESTAMP,
    access_count INT
) ENGINE=InnoDB;

-- Proc√©dure de lookup avec promotion
DELIMITER //
CREATE PROCEDURE cache_get(IN p_key VARCHAR(100))
BEGIN
    DECLARE v_value VARCHAR(2000);

    -- Tentative tier 1 (hot)
    SELECT cache_value INTO v_value
    FROM cache_hot
    WHERE cache_key = p_key;

    IF v_value IS NULL THEN
        -- Chercher dans tier 2 (cold)
        SELECT cache_value INTO v_value
        FROM cache_cold
        WHERE cache_key = p_key;

        IF v_value IS NOT NULL THEN
            -- Promouvoir vers hot cache
            INSERT INTO cache_hot (cache_key, cache_value, created_at)
            VALUES (p_key, v_value, NOW())
            ON DUPLICATE KEY UPDATE
                access_count = access_count + 1;
        END IF;
    ELSE
        -- Incr√©menter compteur hot
        UPDATE cache_hot
        SET access_count = access_count + 1
        WHERE cache_key = p_key;
    END IF;

    SELECT v_value AS result;
END//
DELIMITER ;

-- √âviction LRU du hot cache (scheduled)
DELETE FROM cache_hot
ORDER BY access_count ASC, created_at ASC
LIMIT 1000;
```

### 2. Write-Through Cache

```sql
-- Cache Memory
CREATE TABLE user_profile_cache (
    user_id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100),
    last_login TIMESTAMP,
    settings VARCHAR(1000)
) ENGINE=MEMORY;

-- Source persistante
CREATE TABLE user_profiles (
    user_id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100),
    last_login TIMESTAMP,
    settings TEXT
) ENGINE=InnoDB;

-- Proc√©dure write-through
DELIMITER //
CREATE PROCEDURE update_user_profile(
    IN p_user_id INT,
    IN p_settings VARCHAR(1000)
)
BEGIN
    -- √âcrire dans source (persistant)
    UPDATE user_profiles
    SET settings = p_settings
    WHERE user_id = p_user_id;

    -- Invalider cache
    DELETE FROM user_profile_cache
    WHERE user_id = p_user_id;

    -- Ou mettre √† jour cache (write-through)
    INSERT INTO user_profile_cache
    SELECT user_id, username, email, last_login, LEFT(settings, 1000)
    FROM user_profiles
    WHERE user_id = p_user_id
    ON DUPLICATE KEY UPDATE
        settings = VALUES(settings),
        last_login = VALUES(last_login);
END//
DELIMITER ;
```

### 3. Lazy Loading avec TTL

```sql
CREATE TABLE cache_with_ttl (
    cache_key VARCHAR(100) PRIMARY KEY,
    cache_value VARCHAR(2000),
    expires_at TIMESTAMP,

    INDEX idx_expires (expires_at) USING BTREE
) ENGINE=MEMORY;

-- Fonction de r√©cup√©ration avec lazy load
DELIMITER //
CREATE FUNCTION cache_get_or_load(
    p_key VARCHAR(100),
    p_ttl_seconds INT
) RETURNS VARCHAR(2000)
READS SQL DATA
BEGIN
    DECLARE v_value VARCHAR(2000);
    DECLARE v_expires TIMESTAMP;

    -- Chercher dans cache
    SELECT cache_value, expires_at INTO v_value, v_expires
    FROM cache_with_ttl
    WHERE cache_key = p_key;

    -- Si trouv√© et non expir√©
    IF v_value IS NOT NULL AND v_expires > NOW() THEN
        RETURN v_value;
    END IF;

    -- Sinon, charger depuis source
    -- (Exemple simplifi√© - adapter selon logique m√©tier)
    SELECT computed_value INTO v_value
    FROM expensive_computation(p_key);

    -- Mettre en cache
    INSERT INTO cache_with_ttl (cache_key, cache_value, expires_at)
    VALUES (p_key, v_value, DATE_ADD(NOW(), INTERVAL p_ttl_seconds SECOND))
    ON DUPLICATE KEY UPDATE
        cache_value = VALUES(cache_value),
        expires_at = VALUES(expires_at);

    RETURN v_value;
END//
DELIMITER ;

-- Nettoyage automatique (event scheduler)
CREATE EVENT IF NOT EXISTS cleanup_expired_cache
ON SCHEDULE EVERY 5 MINUTE
DO
    DELETE FROM cache_with_ttl
    WHERE expires_at < NOW();
```

---

## Migration et Conversion

### Conversion InnoDB ‚Üí Memory

```sql
-- Table source InnoDB
CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    category VARCHAR(50),
    price DECIMAL(10,2),
    description TEXT,  -- Probl√®me !
    created_at TIMESTAMP
) ENGINE=InnoDB;

-- Conversion vers Memory (avec adaptations)
CREATE TABLE products_memory (
    product_id INT PRIMARY KEY,  -- Pas d'AUTO_INCREMENT sur Memory
    name CHAR(100),               -- CHAR pour performance
    category CHAR(50),
    price DECIMAL(10,2),
    description VARCHAR(1000),    -- TEXT ‚Üí VARCHAR
    created_at TIMESTAMP
) ENGINE=MEMORY;

-- Copie des donn√©es
INSERT INTO products_memory
SELECT
    product_id,
    name,
    category,
    price,
    LEFT(description, 1000),  -- Tronquer TEXT
    created_at
FROM products;

-- V√©rification
SELECT COUNT(*) FROM products;        -- Original
SELECT COUNT(*) FROM products_memory;  -- Cache
```

### Conversion Memory ‚Üí InnoDB

```sql
-- Convertir une table Memory en InnoDB (persister)
CREATE TABLE sessions_persistent LIKE user_sessions;
ALTER TABLE sessions_persistent ENGINE=InnoDB;

-- Copier les donn√©es
INSERT INTO sessions_persistent
SELECT * FROM user_sessions;

-- Optionnel : renommer
RENAME TABLE
    user_sessions TO user_sessions_old,
    sessions_persistent TO user_sessions;
```

### Script de Synchronisation

```bash
#!/bin/bash
# sync_memory_cache.sh - Recharger cache Memory apr√®s red√©marrage

MYSQL="mysql -u root -p${MYSQL_PASSWORD}"

echo "Rechargement des caches Memory..."

# 1. Config lookup
${MYSQL} -e "
USE myapp;
DELETE FROM config_lookup;
INSERT INTO config_lookup
SELECT config_key, config_value, updated_at
FROM config_persistent
WHERE active = 1;
"

# 2. Product cache
${MYSQL} -e "
USE myapp;
DELETE FROM product_cache;
INSERT INTO product_cache
SELECT product_id, category_id, price, created_at, name
FROM products
WHERE active = 1
ORDER BY created_at DESC
LIMIT 10000;
"

echo "Caches recharg√©s avec succ√®s."

# 3. V√©rification
${MYSQL} -e "
USE myapp;
SELECT
    'config_lookup' AS table_name,
    COUNT(*) AS row_count
FROM config_lookup
UNION ALL
SELECT
    'product_cache',
    COUNT(*)
FROM product_cache;
"
```

---

## Monitoring et Maintenance

### M√©triques Essentielles

```sql
-- Taille des tables Memory
SELECT
    TABLE_NAME,
    ENGINE,
    TABLE_ROWS,
    DATA_LENGTH / 1024 / 1024 AS data_mb,
    INDEX_LENGTH / 1024 / 1024 AS index_mb,
    (DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024 AS total_mb,
    MAX_DATA_LENGTH / 1024 / 1024 / 1024 AS max_size_gb
FROM INFORMATION_SCHEMA.TABLES
WHERE ENGINE = 'MEMORY'
  AND TABLE_SCHEMA = 'myapp'
ORDER BY (DATA_LENGTH + INDEX_LENGTH) DESC;

-- Limite de m√©moire globale
SELECT
    @@max_heap_table_size / 1024 / 1024 AS max_heap_mb,
    @@tmp_table_size / 1024 / 1024 AS tmp_table_mb,
    SUM(DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024 AS used_mb,
    (@@max_heap_table_size / 1024 / 1024) -
    SUM(DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024 AS available_mb
FROM INFORMATION_SCHEMA.TABLES
WHERE ENGINE = 'MEMORY';

-- D√©passement de limite (conversion vers disque)
SHOW GLOBAL STATUS LIKE 'Created_tmp_disk_tables';
SHOW GLOBAL STATUS LIKE 'Created_tmp_tables';

-- Ratio (doit √™tre faible)
SELECT
    (
        SELECT VARIABLE_VALUE
        FROM INFORMATION_SCHEMA.GLOBAL_STATUS
        WHERE VARIABLE_NAME = 'Created_tmp_disk_tables'
    ) / (
        SELECT VARIABLE_VALUE
        FROM INFORMATION_SCHEMA.GLOBAL_STATUS
        WHERE VARIABLE_NAME = 'Created_tmp_tables'
    ) * 100 AS disk_tmp_ratio_pct;
-- Objectif : < 5%
```

### Maintenance Automatique

```sql
-- Event : Nettoyage p√©riodique
CREATE EVENT IF NOT EXISTS cleanup_memory_tables
ON SCHEDULE EVERY 10 MINUTE
DO
BEGIN
    -- Nettoyer sessions expir√©es
    DELETE FROM user_sessions
    WHERE last_activity < DATE_SUB(NOW(), INTERVAL 30 MINUTE);

    -- Nettoyer compteurs anciens
    DELETE FROM realtime_counters
    WHERE window_start < DATE_SUB(NOW(), INTERVAL 5 MINUTE);

    -- Nettoyer cache expir√©
    DELETE FROM cache_with_ttl
    WHERE expires_at < NOW();

    -- Log de maintenance
    INSERT INTO maintenance_log (action, affected_rows)
    VALUES ('cleanup_memory_tables', ROW_COUNT());
END;

-- Activer event scheduler
SET GLOBAL event_scheduler = ON;
```

---

## Best Practices

### ‚úÖ √Ä Faire

1. **Limiter la taille des tables** : < 500 MB recommand√©
2. **Utiliser des types fixes** : CHAR, INT, DECIMAL (pas VARCHAR)
3. **Index appropri√©s** : HASH pour √©galit√©, BTREE pour range
4. **Reload apr√®s red√©marrage** : Script automatique
5. **Monitoring r√©gulier** : Taille, hit ratio, d√©passements
6. **TTL pour caches** : Expiration automatique
7. **Fallback vers disque** : Plan B si table d√©borde

```sql
-- Exemple de bonne pratique compl√®te
CREATE TABLE IF NOT EXISTS rate_limits (
    user_id INT PRIMARY KEY,
    request_count INT DEFAULT 0,
    window_start TIMESTAMP,

    INDEX idx_window (window_start) USING BTREE
) ENGINE=MEMORY
  MAX_ROWS=1000000  -- Hint pour optimisation
  AVG_ROW_LENGTH=20;  -- Hint taille moyenne

-- Configuration appropri√©e
SET max_heap_table_size = 104857600;  -- 100 MB
```

### ‚ùå √Ä √âviter

1. **Stocker donn√©es critiques** : Risque de perte
2. **Tables > 1-2 GB** : Performance d√©grad√©e
3. **Utiliser BLOB/TEXT** : Non support√©
4. **N√©gliger le reload** : Tables vides apr√®s restart
5. **Pas de limite de taille** : Risque OOM
6. **AUTO_INCREMENT comme cl√© m√©tier** : Reset √† 1 apr√®s restart
7. **Attendre ACID** : Memory n'offre pas de transactions

```sql
-- ‚ùå Anti-pattern : donn√©es critiques
CREATE TABLE orders (  -- NE PAS FAIRE
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT,
    amount DECIMAL(10,2)
) ENGINE=MEMORY;  -- Donn√©es perdues au restart !

-- ‚úÖ Bon usage
CREATE TABLE order_draft_cache (  -- OK pour cache temporaire
    draft_id VARCHAR(36) PRIMARY KEY,
    user_id INT,
    items VARCHAR(2000),
    created_at TIMESTAMP
) ENGINE=MEMORY;
```

---

## ‚úÖ Points cl√©s √† retenir

- **Memory = RAM uniquement** : Donn√©es volatiles, perdues au red√©marrage serveur
- **Performance extr√™me** : 2-3√ó plus rapide qu'InnoDB en Buffer Pool, mais sans persistance
- **Limitations critiques** : Pas de BLOB/TEXT, pas d'ACID, table-level locking, taille limit√©e
- **Index HASH vs BTREE** : HASH pour √©galit√© (d√©faut), BTREE pour range/ORDER BY
- **Taille limit√©e** : max_heap_table_size (d√©faut 16MB), tmp_table_size
- **Types fixes recommand√©s** : CHAR > VARCHAR, pas de VARCHAR padding
- **Cas d'usage** : Lookups, sessions, compteurs temps r√©el, r√©sultats interm√©diaires ETL
- **Alternatives** : InnoDB (Buffer Pool) pour persistance, Redis pour clustering
- **Reload obligatoire** : Script automatique apr√®s red√©marrage pour recharger donn√©es
- **Monitoring** : Surveiller taille, disk tmp tables ratio (<5%), d√©passements limite

---

## üîó Ressources et r√©f√©rences

- [üìñ MEMORY Storage Engine](https://mariadb.com/kb/en/memory-storage-engine/)
- [üìñ MEMORY System Variables](https://mariadb.com/kb/en/server-system-variables/#max_heap_table_size)
- [üìñ CREATE TABLE - ENGINE Options](https://mariadb.com/kb/en/create-table/#storage-engines)
- [üìñ Internal Temporary Tables](https://mariadb.com/kb/en/internal-temporary-tables/)
- [üìñ HASH vs BTREE Indexes](https://mariadb.com/kb/en/storage-engine-index-types/)

**Articles techniques** :
- "When to Use MEMORY Tables" - MariaDB Blog
- "MEMORY Storage Engine Best Practices" - Percona Blog
- "Optimizing Temporary Tables in MySQL/MariaDB" - Planet MySQL

**Comparaisons** :
- Memory vs Redis: Use Cases and Trade-offs
- In-Memory Storage Options in MariaDB

---

## ‚û°Ô∏è Section suivante

**[7.10.2 Archive : Compression maximale](/07-moteurs-de-stockage/10.2-archive.md)** : Moteur sp√©cialis√© pour l'archivage de donn√©es rarement acc√©d√©es avec compression maximale, cas d'usage (logs, historiques), et strat√©gies de tiering des donn√©es.

‚è≠Ô∏è [Archive : Compression maximale](/07-moteurs-de-stockage/10.2-archive.md)
