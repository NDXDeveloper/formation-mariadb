ðŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 7.2.4 Configuration AvancÃ©e InnoDB

> **Niveau** : AvancÃ©
> **DurÃ©e estimÃ©e** : 3.5 heures

> **PrÃ©requis** :
> - Section 7.2.1 (CaractÃ©ristiques InnoDB)
> - Section 7.2.2 (Buffer Pool)
> - Section 7.2.3 (Redo/Undo Log)
> - ExpÃ©rience en administration systÃ¨me et performance tuning

## ðŸŽ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- MaÃ®triser l'ensemble des paramÃ¨tres de configuration InnoDB et leurs interactions
- Appliquer une mÃ©thodologie rigoureuse de tuning performance
- Configurer InnoDB pour diffÃ©rents profils de charge (OLTP, OLAP, Mixed, Cloud)
- Prendre des dÃ©cisions architecturales Ã©clairÃ©es sur les trade-offs performance/fiabilitÃ©
- Diagnostiquer et rÃ©soudre les problÃ¨mes de configuration
- ImplÃ©menter les best practices de production pour haute disponibilitÃ©
- Exploiter les nouvelles fonctionnalitÃ©s de MariaDB 11.8 pour optimiser les performances

---

## Introduction

La configuration d'InnoDB est un exercice d'**Ã©quilibrage** entre multiples contraintes :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           CONFIGURATION TRADE-OFFS                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                        â”‚
â”‚  Performance â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ DurabilitÃ©                   â”‚
â”‚  MÃ©moire     â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Concurrence                  â”‚
â”‚  I/O         â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ CPU                          â”‚
â”‚  Latence     â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Throughput                   â”‚
â”‚  SimplicitÃ©  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Optimisation                 â”‚
â”‚                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Principe fondamental** : Il n'existe pas de configuration universelle. Chaque environnement nÃ©cessite un tuning spÃ©cifique basÃ© sur :
- Type de workload (OLTP, OLAP, Mixed)
- Infrastructure (RAM, CPU, stockage)
- Contraintes mÃ©tier (SLA, durabilitÃ©, coÃ»t)
- Patterns d'accÃ¨s (lectures/Ã©critures, concurrence)

ðŸ’¡ **RÃ¨gle d'or** : Toujours mesurer avant et aprÃ¨s chaque modification. Le tuning aveugle est contre-productif.

---

## MÃ©thodologie de Tuning InnoDB

### Approche StructurÃ©e

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         MÃ‰THODOLOGIE DE TUNING (5 PHASES)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  1. BASELINE & MESURE                                   â”‚
â”‚     â””â”€â†’ Ã‰tablir mÃ©triques de rÃ©fÃ©rence                  â”‚
â”‚                                                         â”‚
â”‚  2. IDENTIFICATION                                      â”‚
â”‚     â””â”€â†’ Identifier les goulots d'Ã©tranglement           â”‚
â”‚                                                         â”‚
â”‚  3. HYPOTHÃˆSE                                           â”‚
â”‚     â””â”€â†’ Formuler hypothÃ¨se d'amÃ©lioration               â”‚
â”‚                                                         â”‚
â”‚  4. CHANGEMENT CONTRÃ”LÃ‰                                 â”‚
â”‚     â””â”€â†’ Modifier UN paramÃ¨tre Ã  la fois                 â”‚
â”‚                                                         â”‚
â”‚  5. VALIDATION                                          â”‚
â”‚     â””â”€â†’ Mesurer l'impact, itÃ©rer ou rollback            â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Phase 1 : Ã‰tablir la Baseline

```sql
-- Capturer les mÃ©triques de base
CREATE TABLE performance_baseline AS
SELECT
    NOW() AS measured_at,
    'Baseline' AS phase,
    -- Buffer Pool
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests') AS bp_read_requests,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS
     WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') AS bp_disk_reads,
    -- Transactions
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS
     WHERE VARIABLE_NAME = 'Com_commit') AS commits,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS
     WHERE VARIABLE_NAME = 'Com_rollback') AS rollbacks,
    -- I/O
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS
     WHERE VARIABLE_NAME = 'Innodb_data_read') AS data_read,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS
     WHERE VARIABLE_NAME = 'Innodb_data_written') AS data_written,
    -- Rows
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS
     WHERE VARIABLE_NAME = 'Innodb_rows_read') AS rows_read,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS
     WHERE VARIABLE_NAME = 'Innodb_rows_inserted') AS rows_inserted,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS
     WHERE VARIABLE_NAME = 'Innodb_rows_updated') AS rows_updated,
    (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS
     WHERE VARIABLE_NAME = 'Innodb_rows_deleted') AS rows_deleted;

-- Benchmarking avec sysbench
sysbench oltp_read_write \
    --mysql-host=localhost \
    --mysql-user=root \
    --mysql-password=secret \
    --mysql-db=testdb \
    --tables=10 \
    --table-size=1000000 \
    --threads=16 \
    --time=300 \
    --report-interval=10 \
    run
```

### Phase 2 : Identification des Bottlenecks

**Checklist de diagnostic** :

```sql
-- 1. Buffer Pool Hit Ratio (objectif : >99%)
SELECT
    CONCAT(
        ROUND(
            (1 - (
                SELECT VARIABLE_VALUE
                FROM INFORMATION_SCHEMA.GLOBAL_STATUS
                WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads'
            ) / NULLIF((
                SELECT VARIABLE_VALUE
                FROM INFORMATION_SCHEMA.GLOBAL_STATUS
                WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests'
            ), 0)) * 100,
            2
        ),
        '%'
    ) AS hit_ratio;

-- 2. Dirty Pages Ratio (objectif : <80%)
SELECT
    pool_id,
    ROUND((modified_database_pages / database_pages) * 100, 2) AS dirty_pct
FROM INFORMATION_SCHEMA.INNODB_BUFFER_POOL_STATS;

-- 3. Checkpoint Age (objectif : <80% capacity)
SHOW ENGINE INNODB STATUS\G
-- Log sequence number vs Last checkpoint

-- 4. Lock Waits (objectif : minimal)
SELECT
    COUNT(*) AS lock_waits,
    SUM(LOCK_TIME) / 1000000000 AS total_wait_sec
FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;

-- 5. I/O Pending Operations (objectif : proche de 0)
SHOW ENGINE INNODB STATUS\G
-- Pending reads/writes

-- 6. History List Length (objectif : <10000)
-- Section TRANSACTIONS de SHOW ENGINE INNODB STATUS
```

### Phase 3-5 : ItÃ©ration ContrÃ´lÃ©e

```bash
#!/bin/bash
# Script de tuning itÃ©ratif

# 1. Sauvegarder configuration actuelle
mysqldump --no-data --all-databases > schema_backup.sql
cp /etc/mysql/my.cnf /etc/mysql/my.cnf.backup

# 2. Appliquer changement (exemple : Buffer Pool)
mysql -e "SET GLOBAL innodb_buffer_pool_size = 16G;"

# 3. Warmup (charger donnÃ©es en cache)
mysql -e "SELECT COUNT(*) FROM important_table1;"
mysql -e "SELECT COUNT(*) FROM important_table2;"

# 4. Benchmark
sysbench oltp_read_write --time=300 run > after_change.txt

# 5. Comparer rÃ©sultats
diff baseline.txt after_change.txt

# 6. DÃ©cision : Keep ou Rollback
# Si amÃ©lioration : conserver et documenter
# Si dÃ©gradation : rollback
```

---

## CatÃ©gories de ParamÃ¨tres InnoDB

### 1. Configuration MÃ©moire

#### **Buffer Pool - Le Plus Critique**

```ini
[mysqld]
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BUFFER POOL CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Taille totale (70-80% RAM disponible)
innodb_buffer_pool_size = 32G

# Instances (1 par GB, max 64)
innodb_buffer_pool_instances = 32

# Chunk size (pour redimensionnement dynamique)
innodb_buffer_pool_chunk_size = 128M

# Dump/Load au shutdown/startup
innodb_buffer_pool_dump_at_shutdown = ON
innodb_buffer_pool_load_at_startup = ON
innodb_buffer_pool_dump_pct = 50              # % Ã  sauvegarder

# LRU tuning (protection contre scans)
innodb_old_blocks_pct = 37                    # DÃ©faut, rarement modifiÃ©
innodb_old_blocks_time = 1000                 # 1 seconde
```

**Calcul du Buffer Pool Size** :

```python
# Formule de dimensionnement
def calculate_buffer_pool_size(total_ram_gb, workload_type):
    """
    total_ram_gb: RAM totale du serveur
    workload_type: 'oltp', 'olap', 'mixed', 'container'
    """
    ratios = {
        'oltp': 0.75,        # 75% RAM (serveur dÃ©diÃ©)
        'olap': 0.75,        # 75% RAM (gros scans)
        'mixed': 0.70,       # 70% RAM (Ã©quilibrÃ©)
        'container': 0.60    # 60% RAM (overhead K8s)
    }

    # RÃ©server pour OS, connexions, autres buffers
    os_overhead = 4  # GB
    connections_overhead = 2  # GB (pour 400 connexions)

    available_ram = total_ram_gb - os_overhead - connections_overhead
    buffer_pool = available_ram * ratios.get(workload_type, 0.70)

    return round(buffer_pool)

# Exemples
print(f"OLTP 64GB: {calculate_buffer_pool_size(64, 'oltp')}G")  # ~44G
print(f"OLAP 128GB: {calculate_buffer_pool_size(128, 'olap')}G")  # ~92G
print(f"Container 16GB: {calculate_buffer_pool_size(16, 'container')}G")  # ~6G
```

#### **Autres Buffers MÃ©moire**

```ini
# Additional Memory Buffers
innodb_additional_mem_pool_size = 20M         # DÃ©prÃ©ciÃ© (automatique depuis 5.7)

# Log buffer (pour transactions)
innodb_log_buffer_size = 64M                  # OLTP intensif : 32-128M
                                               # Batch : 128-256M

# Sort buffer (per-connection)
sort_buffer_size = 2M                         # DÃ©faut : 2M, max 4M
read_buffer_size = 2M                         # Scans sÃ©quentiels
read_rnd_buffer_size = 4M                     # Sorts avec ORDER BY
join_buffer_size = 2M                         # Joins sans index

# Key buffer (MyISAM/Aria only)
key_buffer_size = 16M                         # Minimal si InnoDB only
```

ðŸ’¡ **Important** : Les buffers per-connection sont allouÃ©s par thread. Avec 1000 connexions :
```
Memory = 1000 Ã— (sort_buffer + read_buffer + join_buffer + thread_stack)
       = 1000 Ã— (2M + 2M + 2M + 256K) â‰ˆ 6.3 GB
```

âš ï¸ **Attention** : Ne pas sur-allouer les buffers per-connection, risque d'OOM.

### 2. Configuration I/O et Disque

```ini
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# I/O CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# CapacitÃ© I/O du systÃ¨me (IOPS disponibles)
# HDD: 200-500, SSD SATA: 2000-5000, NVMe: 10000-50000
innodb_io_capacity = 5000
innodb_io_capacity_max = 10000                # Burst capacity (2x normal)

# Threads I/O (parallÃ©lisme)
innodb_read_io_threads = 16                   # Lectures asynchrones
innodb_write_io_threads = 16                  # Ã‰critures asynchrones

# MÃ©thode de flush (Linux)
innodb_flush_method = O_DIRECT                # Bypass OS cache (recommandÃ©)
# Alternatives :
#   O_DSYNC   : Sync data only (Windows)
#   fsync     : Default (double buffering)
#   littlesync: MariaDB specific
#   nosync    : Pas de sync (dev uniquement)

# Flush des pages adjacentes (dÃ©sactiver sur SSD)
innodb_flush_neighbors = 0                    # 0: dÃ©sactivÃ© (SSD)
                                               # 1: adjacent dans extent
                                               # 2: adjacent dans extent + contiguous

# AIO natif (asynchronous I/O)
innodb_use_native_aio = ON                    # Linux : toujours ON

# Read-ahead (prefetching)
innodb_random_read_ahead = OFF                # OFF sur SSD (accÃ¨s random rapide)
innodb_read_ahead_threshold = 0               # 0-64, 0=dÃ©sactivÃ© (SSD)
                                               # 56=agressif (HDD sÃ©quentiel)
```

**Tuning selon le stockage** :

| Type Stockage | io_capacity | io_capacity_max | flush_neighbors | read_ahead |
|---------------|-------------|-----------------|-----------------|------------|
| HDD 7200rpm   | 200         | 400             | 1               | 56         |
| HDD RAID-10   | 800         | 1600            | 1               | 56         |
| SSD SATA      | 3000        | 6000            | 0               | 0          |
| SSD NVMe      | 10000       | 20000           | 0               | 0          |
| Cloud (AWS EBS gp3) | 5000  | 10000           | 0               | 0          |

### 3. Configuration Logs

```ini
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# REDO LOG CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Taille des fichiers redo log
innodb_log_file_size = 4G                     # OLTP: 2-8G, Batch: 16-64G

# Nombre de fichiers (gÃ©nÃ©ralement 2)
innodb_log_files_in_group = 2

# Buffer des logs en mÃ©moire
innodb_log_buffer_size = 64M                  # OLTP: 32-128M, Batch: 256M

# DurabilitÃ© vs Performance
innodb_flush_log_at_trx_commit = 1            # 1: durabilitÃ© max (dÃ©faut)
                                               # 0: flush chaque seconde
                                               # 2: flush vers OS cache

# Compression des logs (expÃ©rimental 11.8+)
innodb_log_compressed_pages = ON              # RÃ©duit taille redo log

# Write-ahead size (alignement SSD)
innodb_log_write_ahead_size = 16384           # 16KB (page size SSD)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# UNDO LOG CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Nombre d'undo tablespaces
innodb_undo_tablespaces = 4                   # 2-127, plus = meilleure rÃ©partition

# RÃ©pertoire des undo logs
innodb_undo_directory = /var/lib/mysql/undo

# Truncate automatique
innodb_undo_log_truncate = ON
innodb_max_undo_log_size = 2G                 # Seuil de truncate

# Threads de purge
innodb_purge_threads = 8                      # 1-32, plus = purge rapide
innodb_purge_batch_size = 300                 # Records par batch

# Limite du purge lag
innodb_max_purge_lag = 0                      # 0: illimitÃ© (dÃ©faut)
innodb_max_purge_lag_delay = 0                # DÃ©lai si lag > max (ms)
```

**Dimensionnement Redo Log** :

```python
def calculate_redo_log_size(write_gb_per_hour, workload):
    """
    Calcul basÃ© sur le volume d'Ã©criture
    Objectif : Contenir 30-60 minutes de modifications
    """
    if workload == 'oltp':
        # 50% du volume horaire
        redo_size = write_gb_per_hour * 0.5
    elif workload == 'batch':
        # 100% du volume horaire
        redo_size = write_gb_per_hour * 1.0
    else:  # mixed
        redo_size = write_gb_per_hour * 0.75

    # Arrondir et limiter
    redo_size = max(1, min(redo_size, 128))  # Entre 1GB et 128GB

    return f"{int(redo_size)}G"

# Exemples
print(calculate_redo_log_size(10, 'oltp'))    # 5G
print(calculate_redo_log_size(50, 'batch'))   # 50G
print(calculate_redo_log_size(20, 'mixed'))   # 15G
```

### 4. Configuration Concurrence et Verrous

```ini
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONCURRENCY & LOCKING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Thread concurrency (0 = illimitÃ©, recommandÃ©)
innodb_thread_concurrency = 0                 # 0: auto-scaling
# Si besoin limiter : ncpu * 2 (disk-bound), ncpu * 1.5 (CPU-bound)

# Spin wait delay (pour mutexes)
innodb_sync_spin_loops = 30                   # Tentatives avant sleep
innodb_spin_wait_delay = 6                    # DÃ©lai entre spins

# Lock wait timeout
innodb_lock_wait_timeout = 50                 # 50 secondes (dÃ©faut)
                                               # OLTP: 10-30s
                                               # Batch: 120-300s

# Deadlock detection
innodb_deadlock_detect = ON                   # Toujours ON (recommandÃ©)

# Nombre de mutex latches pour AHI
innodb_adaptive_hash_index_parts = 8          # 1-512, dÃ©faut 8

# Rollback segments
innodb_rollback_segments = 128                # 1-128, dÃ©faut 128 (max)
```

**Thread Concurrency - Quand Limiter** :

```sql
-- Diagnostic : trop de threads actifs
SHOW ENGINE INNODB STATUS\G
-- Threads active > CPU cores Ã— 2 â†’ contention

-- Solution : limiter
SET GLOBAL innodb_thread_concurrency = 32;   -- Pour 16 cores

-- Monitoring
SELECT
    VARIABLE_VALUE AS threads_active
FROM INFORMATION_SCHEMA.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'Threads_running';
```

### 5. Configuration Flushing et Checkpointing

```ini
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FLUSHING & CHECKPOINTING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Flushing adaptatif
innodb_adaptive_flushing = ON                 # Ajuste selon charge
innodb_adaptive_flushing_lwm = 10             # Low water mark (%)

# Limites de dirty pages
innodb_max_dirty_pages_pct = 90               # Max 90% dirty pages
innodb_max_dirty_pages_pct_lwm = 10           # Flushing agressif si >10%

# Threads de nettoyage
innodb_page_cleaners = 8                      # 1-64, idÃ©al = buffer_pool_instances

# ContrÃ´le du flushing
innodb_flushing_avg_loops = 30                # Lissage de la charge I/O

# Checkpoint interval
innodb_log_checkpoint_now = OFF               # Force checkpoint (debug only)
```

**Tuning Flushing** :

```
SymptÃ´me : Stalls pendant checkpoints
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Diagnostic :
- Modified db pages > 80%
- Checkpoint age > 80% capacity

Solution :
1. Augmenter innodb_io_capacity
2. Plus de page_cleaners
3. RÃ©duire max_dirty_pages_pct
4. Augmenter redo log size
```

### 6. Configuration Tables et Index

```ini
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TABLES & INDEXES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# File per table
innodb_file_per_table = ON                    # Toujours ON (dÃ©faut depuis 5.6)

# Format de page (dÃ©faut : 16KB)
innodb_page_size = 16384                      # 4K, 8K, 16K, 32K, 64K
                                               # 16K optimal (dÃ©faut)

# Compression
innodb_compression_level = 6                  # 1-9 (zlib), dÃ©faut 6
innodb_compression_failure_threshold_pct = 5
innodb_compression_pad_pct_max = 50

# Adaptive Hash Index
innodb_adaptive_hash_index = ON               # ON pour OLTP, OFF pour OLAP
innodb_adaptive_hash_index_parts = 8

# Statistics
innodb_stats_on_metadata = OFF                # OFF (recommandÃ©)
innodb_stats_persistent = ON                  # Persistent stats (dÃ©faut)
innodb_stats_auto_recalc = ON
innodb_stats_sample_pages = 20                # Pages Ã©chantillonnÃ©es

# Online DDL (11.8+)
innodb_alter_copy_bulk = ON                   # Construction index efficace
innodb_online_alter_log_max_size = 134217728  # 128M (log tampon ALTER)

# Autoinc lock mode
innodb_autoinc_lock_mode = 2                  # 2: interleaved (rÃ©plication GTID)
                                               # 1: consecutive (rÃ©plication traditionnelle)
                                               # 0: traditional (legacy)
```

### 7. Configuration Monitoring et Debug

```ini
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MONITORING & DIAGNOSTICS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# InnoDB Monitor
innodb_status_output = OFF                    # Periodically print STATUS
innodb_status_output_locks = OFF              # Include locks info

# Print all deadlocks
innodb_print_all_deadlocks = ON               # Log tous les deadlocks

# Lock monitor
innodb_lock_monitor_timeout = 60              # Timeout lock wait details

# Strict mode (validation)
innodb_strict_mode = ON                       # Validation stricte DDL

# Metrics
innodb_monitor_enable = '%'                   # Activer toutes les mÃ©triques
# Ou spÃ©cifique :
# innodb_monitor_enable = 'log_lsn_current'
# innodb_monitor_enable = 'buffer_pool_size'
```

---

## Profils de Configuration par Workload

### 1. Production OLTP (Haute Concurrence)

**Infrastructure** : 64 GB RAM, 16 cores CPU, SSD NVMe

```ini
[mysqld]
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PROFIL : PRODUCTION OLTP - HAUTE CONCURRENCE
# Infrastructure : 64 GB RAM, 16 cores, NVMe SSD
# Workload : 10k-50k TPS, 90% reads, 10% writes
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# â”€â”€â”€ BUFFER POOL (MÃ©moire) â”€â”€â”€
innodb_buffer_pool_size = 48G                 # 75% RAM
innodb_buffer_pool_instances = 48
innodb_buffer_pool_chunk_size = 128M
innodb_buffer_pool_dump_at_shutdown = ON
innodb_buffer_pool_load_at_startup = ON
innodb_old_blocks_pct = 37
innodb_old_blocks_time = 1000

# â”€â”€â”€ LOGS (Transactions courtes frÃ©quentes) â”€â”€â”€
innodb_log_file_size = 4G                     # 8G total (2Ã—4G)
innodb_log_files_in_group = 2
innodb_log_buffer_size = 64M
innodb_flush_log_at_trx_commit = 1            # DurabilitÃ© maximale
innodb_flush_method = O_DIRECT

# â”€â”€â”€ UNDO (Transactions courtes) â”€â”€â”€
innodb_undo_tablespaces = 4
innodb_undo_log_truncate = ON
innodb_max_undo_log_size = 2G
innodb_purge_threads = 8
innodb_purge_batch_size = 300

# â”€â”€â”€ I/O (SSD NVMe) â”€â”€â”€
innodb_io_capacity = 10000
innodb_io_capacity_max = 20000
innodb_read_io_threads = 16
innodb_write_io_threads = 16
innodb_flush_neighbors = 0                    # SSD : dÃ©sactivÃ©
innodb_use_native_aio = ON
innodb_random_read_ahead = OFF
innodb_read_ahead_threshold = 0

# â”€â”€â”€ FLUSHING & CHECKPOINTING â”€â”€â”€
innodb_adaptive_flushing = ON
innodb_adaptive_flushing_lwm = 10
innodb_max_dirty_pages_pct = 80
innodb_max_dirty_pages_pct_lwm = 10
innodb_page_cleaners = 16

# â”€â”€â”€ CONCURRENCY (Haute concurrence) â”€â”€â”€
innodb_thread_concurrency = 0                 # IllimitÃ©
innodb_lock_wait_timeout = 20                 # 20s (OLTP)
innodb_deadlock_detect = ON

# â”€â”€â”€ TABLES & INDEX â”€â”€â”€
innodb_file_per_table = ON
innodb_adaptive_hash_index = ON               # Crucial pour OLTP
innodb_adaptive_hash_index_parts = 8
innodb_autoinc_lock_mode = 2                  # Interleaved

# â”€â”€â”€ STATISTICS â”€â”€â”€
innodb_stats_persistent = ON
innodb_stats_on_metadata = OFF
innodb_stats_auto_recalc = ON

# â”€â”€â”€ DOUBLEWRITE â”€â”€â”€
innodb_doublewrite = ON                       # Production : toujours ON

# â”€â”€â”€ PER-CONNECTION BUFFERS â”€â”€â”€
sort_buffer_size = 2M
read_buffer_size = 2M
read_rnd_buffer_size = 2M
join_buffer_size = 2M

# â”€â”€â”€ MONITORING â”€â”€â”€
innodb_print_all_deadlocks = ON
innodb_monitor_enable = 'all'
```

**MÃ©triques attendues** :
- Buffer Pool Hit Ratio : >99.5%
- Transactions/sec : 10k-50k
- Latence p95 : <10ms
- Checkpoint age : <70%

### 2. Data Warehouse / OLAP

**Infrastructure** : 256 GB RAM, 32 cores CPU, SSD SATA

```ini
[mysqld]
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PROFIL : DATA WAREHOUSE / OLAP
# Infrastructure : 256 GB RAM, 32 cores, SSD SATA
# Workload : RequÃªtes analytiques longues, batch loads
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# â”€â”€â”€ BUFFER POOL (Maximum pour cache) â”€â”€â”€
innodb_buffer_pool_size = 192G                # 75% RAM
innodb_buffer_pool_instances = 64             # Maximum
innodb_buffer_pool_chunk_size = 128M
innodb_buffer_pool_dump_at_shutdown = ON
innodb_buffer_pool_load_at_startup = ON
innodb_old_blocks_pct = 25                    # Old sublist rÃ©duite (scans)
innodb_old_blocks_time = 100                  # Promotion rapide

# â”€â”€â”€ LOGS (Grosses transactions) â”€â”€â”€
innodb_log_file_size = 32G                    # TrÃ¨s large (64G total)
innodb_log_files_in_group = 2
innodb_log_buffer_size = 256M                 # Buffer large
innodb_flush_log_at_trx_commit = 2            # Compromis acceptable
innodb_flush_method = O_DIRECT

# â”€â”€â”€ UNDO (Transactions longues) â”€â”€â”€
innodb_undo_tablespaces = 2
innodb_max_undo_log_size = 16G                # Seuil Ã©levÃ©
innodb_purge_threads = 4
innodb_max_purge_lag = 1000000                # Lag Ã©levÃ© tolÃ©rÃ©

# â”€â”€â”€ I/O (SÃ©quentiel optimisÃ©) â”€â”€â”€
innodb_io_capacity = 2000
innodb_io_capacity_max = 4000
innodb_read_io_threads = 32                   # Beaucoup de lectures
innodb_write_io_threads = 8
innodb_flush_neighbors = 0
innodb_use_native_aio = ON
innodb_random_read_ahead = OFF
innodb_read_ahead_threshold = 56              # Prefetch agressif

# â”€â”€â”€ FLUSHING (Moins critique) â”€â”€â”€
innodb_adaptive_flushing = ON
innodb_max_dirty_pages_pct = 90
innodb_page_cleaners = 8

# â”€â”€â”€ CONCURRENCY (Moins de concurrence) â”€â”€â”€
innodb_thread_concurrency = 64                # Limiter (32 cores Ã— 2)
innodb_lock_wait_timeout = 300                # 5 minutes (requÃªtes longues)

# â”€â”€â”€ TABLES & INDEX â”€â”€â”€
innodb_file_per_table = ON
innodb_adaptive_hash_index = OFF              # Moins utile (scans)
innodb_autoinc_lock_mode = 2

# â”€â”€â”€ STATISTICS (PrÃ©cision importante) â”€â”€â”€
innodb_stats_persistent = ON
innodb_stats_sample_pages = 50                # Plus d'Ã©chantillons

# â”€â”€â”€ PER-CONNECTION BUFFERS (Larges) â”€â”€â”€
sort_buffer_size = 8M                         # Sorts frÃ©quents
read_buffer_size = 8M
read_rnd_buffer_size = 8M
join_buffer_size = 8M
tmp_table_size = 512M
max_heap_table_size = 512M
```

### 3. Mixed Workload (Hybride OLTP/OLAP)

**Infrastructure** : 128 GB RAM, 24 cores CPU, SSD NVMe

```ini
[mysqld]
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PROFIL : MIXED WORKLOAD (OLTP + REPORTING)
# Infrastructure : 128 GB RAM, 24 cores, NVMe SSD
# Workload : 70% OLTP, 30% reporting/analytics
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# â”€â”€â”€ BUFFER POOL (Ã‰quilibrÃ©) â”€â”€â”€
innodb_buffer_pool_size = 96G                 # 75% RAM
innodb_buffer_pool_instances = 64
innodb_old_blocks_pct = 37                    # DÃ©faut (Ã©quilibrÃ©)
innodb_old_blocks_time = 1000

# â”€â”€â”€ LOGS (Compromis) â”€â”€â”€
innodb_log_file_size = 8G                     # 16G total
innodb_log_files_in_group = 2
innodb_log_buffer_size = 128M
innodb_flush_log_at_trx_commit = 1            # PrÃ©fÃ©rer durabilitÃ©

# â”€â”€â”€ UNDO â”€â”€â”€
innodb_undo_tablespaces = 4
innodb_max_undo_log_size = 4G
innodb_purge_threads = 8

# â”€â”€â”€ I/O (NVMe performant) â”€â”€â”€
innodb_io_capacity = 8000
innodb_io_capacity_max = 16000
innodb_read_io_threads = 20
innodb_write_io_threads = 12
innodb_flush_neighbors = 0
innodb_read_ahead_threshold = 0               # SSD : dÃ©sactivÃ©

# â”€â”€â”€ FLUSHING â”€â”€â”€
innodb_adaptive_flushing = ON
innodb_max_dirty_pages_pct = 85
innodb_page_cleaners = 16

# â”€â”€â”€ CONCURRENCY â”€â”€â”€
innodb_thread_concurrency = 0
innodb_lock_wait_timeout = 60

# â”€â”€â”€ TABLES & INDEX â”€â”€â”€
innodb_adaptive_hash_index = ON               # BÃ©nÃ©fique pour partie OLTP

# â”€â”€â”€ PER-CONNECTION BUFFERS (ModÃ©rÃ©s) â”€â”€â”€
sort_buffer_size = 4M
read_buffer_size = 4M
read_rnd_buffer_size = 4M
join_buffer_size = 4M
```

### 4. Cloud / Kubernetes (Ressources LimitÃ©es)

**Infrastructure** : Pod 32 GB RAM limit, 8 cores, EBS gp3

```ini
[mysqld]
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PROFIL : CLOUD / KUBERNETES
# Infrastructure : Pod 32 GB limit, 8 vCPU, AWS EBS gp3
# Workload : OLTP avec contraintes ressources
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# â”€â”€â”€ BUFFER POOL (60% pod limit) â”€â”€â”€
innodb_buffer_pool_size = 20G                 # 60% des 32G
innodb_buffer_pool_instances = 20
innodb_buffer_pool_dump_at_shutdown = ON
innodb_buffer_pool_load_at_startup = ON

# â”€â”€â”€ LOGS (ModÃ©rÃ©s) â”€â”€â”€
innodb_log_file_size = 2G
innodb_log_files_in_group = 2
innodb_log_buffer_size = 32M
innodb_flush_log_at_trx_commit = 1
innodb_flush_method = O_DIRECT

# â”€â”€â”€ UNDO â”€â”€â”€
innodb_undo_tablespaces = 2
innodb_max_undo_log_size = 1G
innodb_purge_threads = 4

# â”€â”€â”€ I/O (EBS gp3: 3000 IOPS baseline) â”€â”€â”€
innodb_io_capacity = 3000
innodb_io_capacity_max = 6000
innodb_read_io_threads = 8
innodb_write_io_threads = 8
innodb_flush_neighbors = 0

# â”€â”€â”€ FLUSHING â”€â”€â”€
innodb_adaptive_flushing = ON
innodb_max_dirty_pages_pct = 75
innodb_page_cleaners = 4

# â”€â”€â”€ CONCURRENCY â”€â”€â”€
innodb_thread_concurrency = 0
innodb_lock_wait_timeout = 30

# â”€â”€â”€ MONITORING (Performance Schema dÃ©sactivÃ© pour Ã©conomiser RAM) â”€â”€â”€
performance_schema = OFF                      # Ã‰conomise ~400MB

# â”€â”€â”€ PER-CONNECTION BUFFERS (RÃ©duits) â”€â”€â”€
sort_buffer_size = 1M
read_buffer_size = 1M
read_rnd_buffer_size = 1M
join_buffer_size = 1M
max_connections = 200                         # Limiter connexions

# â”€â”€â”€ RESOURCE LIMITS â”€â”€â”€
max_allowed_packet = 64M
max_heap_table_size = 64M
tmp_table_size = 64M
```

ðŸ’¡ **Best practice Kubernetes** :

```yaml
# DÃ©finir les resource limits
resources:
  requests:
    memory: "28Gi"
    cpu: "6"
  limits:
    memory: "32Gi"
    cpu: "8"

# Monitoring de l'OOM
livenessProbe:
  exec:
    command:
    - mysqladmin
    - ping
  initialDelaySeconds: 30
  periodSeconds: 10
```

### 5. RÃ©plica Read-Only (Reporting)

```ini
[mysqld]
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PROFIL : REPLICA READ-ONLY (REPORTING)
# Infrastructure : 64 GB RAM, 16 cores, SSD
# Workload : 100% reads, reporting, analytics
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# â”€â”€â”€ BUFFER POOL (Maximum) â”€â”€â”€
innodb_buffer_pool_size = 52G                 # 80% RAM (plus pour reads)
innodb_buffer_pool_instances = 52

# â”€â”€â”€ LOGS (Minimal - peu d'Ã©critures) â”€â”€â”€
innodb_log_file_size = 512M                   # Peut Ãªtre rÃ©duit
innodb_log_files_in_group = 2
innodb_log_buffer_size = 16M
innodb_flush_log_at_trx_commit = 2            # Acceptable sur replica

# â”€â”€â”€ UNDO (Minimal) â”€â”€â”€
innodb_undo_tablespaces = 2
innodb_purge_threads = 2

# â”€â”€â”€ I/O (Lectures optimisÃ©es) â”€â”€â”€
innodb_io_capacity = 2000
innodb_io_capacity_max = 4000
innodb_read_io_threads = 24                   # Beaucoup de reads
innodb_write_io_threads = 4                   # Peu de writes
innodb_flush_neighbors = 0

# â”€â”€â”€ TABLES & INDEX â”€â”€â”€
innodb_adaptive_hash_index = ON               # Utile pour reads rÃ©pÃ©titifs

# â”€â”€â”€ DOUBLEWRITE (Peut Ãªtre dÃ©sactivÃ© si snapshot rÃ©guliers) â”€â”€â”€
innodb_doublewrite = OFF                      # Gain 10-15% performance

# â”€â”€â”€ READ-ONLY MODE â”€â”€â”€
read_only = ON                                # EmpÃªcher Ã©critures accidentelles
super_read_only = ON                          # MÃªme SUPER user
```

---

## Tuning AvancÃ© et Optimisations

### 1. Optimisation pour Ã‰critures Intensives

**ScÃ©nario** : Batch inserts, ETL, data ingestion

```sql
-- â”€â”€â”€ SESSION LEVEL â”€â”€â”€
-- DÃ©sactiver temporairement les contraintes
SET FOREIGN_KEY_CHECKS = 0;
SET UNIQUE_CHECKS = 0;
SET AUTOCOMMIT = 0;

-- Gros batch
START TRANSACTION;
-- Insertions multiples (10k-100k rows)
LOAD DATA INFILE '/data/file.csv' INTO TABLE target;
COMMIT;

-- RÃ©activer
SET FOREIGN_KEY_CHECKS = 1;
SET UNIQUE_CHECKS = 1;
SET AUTOCOMMIT = 1;

-- Reconstruire index aprÃ¨s batch
OPTIMIZE TABLE target;
ANALYZE TABLE target;
```

**Configuration globale** :

```ini
# Augmenter buffers pour batch
innodb_log_buffer_size = 256M
innodb_log_file_size = 16G

# DÃ©sactiver doublewrite temporairement (avec prudence)
innodb_doublewrite = OFF

# Flush log mode relaxÃ© (batch uniquement)
innodb_flush_log_at_trx_commit = 2

# Bulk load optimization (11.8+)
innodb_alter_copy_bulk = ON
```

### 2. Optimisation pour Lectures Intensives

```ini
# Maximum Buffer Pool
innodb_buffer_pool_size = 80% RAM

# Adaptive Hash Index crucial
innodb_adaptive_hash_index = ON
innodb_adaptive_hash_index_parts = 16

# Plus de read threads
innodb_read_io_threads = 32

# Query cache (si nombreuses requÃªtes identiques)
# Note : DÃ©prÃ©ciÃ©, utiliser ProxySQL Ã  la place
```

### 3. Optimisation Latence (Low Latency OLTP)

```ini
# Petits logs pour flushes rapides
innodb_log_file_size = 1G
innodb_flush_log_at_trx_commit = 1

# I/O capacity Ã©levÃ©e
innodb_io_capacity = 20000
innodb_io_capacity_max = 40000

# Flushing agressif
innodb_max_dirty_pages_pct = 50
innodb_adaptive_flushing = ON

# NVMe avec atomic writes
innodb_doublewrite = OFF                      # Si supportÃ©

# Thread pool (si available)
thread_handling = pool-of-threads
thread_pool_size = 16
```

### 4. Optimisation MÃ©moire (Memory-Constrained)

```ini
# Buffer Pool rÃ©duit
innodb_buffer_pool_size = 4G
innodb_buffer_pool_instances = 4

# Per-connection buffers minimaux
sort_buffer_size = 256K
read_buffer_size = 256K
read_rnd_buffer_size = 256K
join_buffer_size = 256K

# DÃ©sactiver Performance Schema
performance_schema = OFF

# Limiter connexions
max_connections = 100

# DÃ©sactiver AHI si peu de RAM
innodb_adaptive_hash_index = OFF
```

---

## ðŸ†• NouveautÃ©s MariaDB 11.8 pour InnoDB

### 1. Construction d'Index Efficace

```sql
-- Nouveau paramÃ¨tre (11.8+)
SET GLOBAL innodb_alter_copy_bulk = ON;

-- Impact sur ALTER TABLE
ALTER TABLE large_table ADD INDEX idx_column (column);

-- AmÃ©lioration :
-- - Bulk load des donnÃ©es triÃ©es
-- - RÃ©duction du temps de construction
-- - Moins de fragmentation
```

**Benchmark** :

```
Table : 100 millions de lignes
Index : Non-unique sur INT column

Avant (innodb_alter_copy_bulk = OFF) :
- Temps : 45 minutes
- I/O : 1.2 TB writes

AprÃ¨s (innodb_alter_copy_bulk = ON) :
- Temps : 28 minutes (-38%)
- I/O : 800 GB writes (-33%)
```

### 2. Cost Optimizer Conscient des SSD

```sql
-- Configuration automatique (11.8)
-- L'optimizer ajuste les coÃ»ts I/O selon le type de stockage dÃ©tectÃ©

-- VÃ©rifier la dÃ©tection
SHOW VARIABLES LIKE '%ssd%';

-- Impact sur l'optimiseur
EXPLAIN SELECT * FROM large_table WHERE indexed_col = 123;

-- Avant : PrÃ©fÃ©rait index scan (sÃ©quentiel)
-- AprÃ¨s : PrÃ©fÃ¨re random access (SSD rapide)
```

### 3. Gestion Dynamique Undo Tablespaces

```sql
-- CrÃ©er Ã  chaud (11.8+)
CREATE UNDO TABLESPACE undo005 ADD DATAFILE 'undo005.ibu';

-- Lister
SELECT NAME, STATE FROM INFORMATION_SCHEMA.INNODB_TABLESPACES
WHERE SPACE_TYPE = 'Undo';

-- Marquer pour suppression (aprÃ¨s purge automatique)
DROP UNDO TABLESPACE undo005;

-- Monitoring
SELECT
    NAME,
    STATE,
    SPACE_TYPE,
    FILE_SIZE / 1024 / 1024 / 1024 AS size_gb
FROM INFORMATION_SCHEMA.INNODB_TABLESPACES
WHERE SPACE_TYPE = 'Undo';
```

### 4. Compression Redo Log

```sql
-- Activer compression (expÃ©rimental)
SET GLOBAL innodb_log_compressed_pages = ON;

-- Monitoring de l'impact
SHOW GLOBAL STATUS LIKE 'Innodb_log%';

-- RÃ©duction typique : 20-40% selon workload
```

### 5. Optimisations Performance Schema

```sql
-- Instrumentation granulaire (11.8)
UPDATE performance_schema.setup_instruments
SET ENABLED = 'YES', TIMED = 'YES'
WHERE NAME LIKE 'wait/io/file/innodb/%';

-- Nouvelles mÃ©triques
SELECT
    EVENT_NAME,
    COUNT_STAR,
    SUM_TIMER_WAIT / 1000000000000 AS total_wait_sec
FROM performance_schema.file_summary_by_event_name
WHERE EVENT_NAME LIKE '%innodb%'
ORDER BY SUM_TIMER_WAIT DESC;
```

---

## Validation et Monitoring Post-Configuration

### Checklist de Validation

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- VALIDATION CONFIGURATION INNODB
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- 1. Buffer Pool Hit Ratio (>99%)
SELECT
    CONCAT(
        ROUND((1 - (
            (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
            (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
        )) * 100, 2), '%'
    ) AS hit_ratio;
-- Objectif : > 99.00%

-- 2. Dirty Pages Ratio (<80%)
SELECT
    ROUND(AVG(modified_database_pages / database_pages) * 100, 2) AS avg_dirty_pct,
    MAX(modified_database_pages / database_pages) * 100 AS max_dirty_pct
FROM INFORMATION_SCHEMA.INNODB_BUFFER_POOL_STATS;
-- Objectif : < 80%

-- 3. Checkpoint Age (<80% capacity)
-- Via SHOW ENGINE INNODB STATUS
-- Log sequence number - Last checkpoint < 80% log capacity

-- 4. History List Length (<10000)
SELECT VARIABLE_VALUE AS history_list_length
FROM INFORMATION_SCHEMA.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'Innodb_history_list_length';
-- Objectif : < 10000

-- 5. Lock Waits (minimal)
SELECT COUNT(*) AS active_lock_waits
FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
-- Objectif : 0 ou trÃ¨s faible

-- 6. Pending Operations (0)
-- Via SHOW ENGINE INNODB STATUS
-- Pending reads/writes doivent Ãªtre proche de 0

-- 7. Log Writes Rate
SELECT
    VARIABLE_VALUE / (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Uptime')
    AS log_writes_per_sec
FROM INFORMATION_SCHEMA.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'Innodb_os_log_written';

-- 8. Configuration Memory Check
SELECT
    @@innodb_buffer_pool_size / 1024 / 1024 / 1024 AS buffer_pool_gb,
    @@innodb_log_file_size / 1024 / 1024 / 1024 AS log_file_gb,
    @@innodb_buffer_pool_instances AS instances;
```

### Script de Health Check Complet

```bash
#!/bin/bash
# innodb_health_check.sh

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "InnoDB HEALTH CHECK - $(date)"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Configuration
MYSQL_USER="root"
MYSQL_PASS="password"
MYSQL_CMD="mysql -u${MYSQL_USER} -p${MYSQL_PASS} -N -s"

# 1. Buffer Pool
echo ""
echo "â”€â”€â”€ BUFFER POOL â”€â”€â”€"
HIT_RATIO=$(${MYSQL_CMD} -e "
    SELECT ROUND((1 - (
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
        (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
    )) * 100, 2)
")
echo "Hit Ratio: ${HIT_RATIO}% (Target: >99%)"

# 2. Dirty Pages
DIRTY_PCT=$(${MYSQL_CMD} -e "
    SELECT ROUND(AVG(modified_database_pages / database_pages) * 100, 2)
    FROM INFORMATION_SCHEMA.INNODB_BUFFER_POOL_STATS
")
echo "Dirty Pages: ${DIRTY_PCT}% (Target: <80%)"

# 3. History List
HISTORY=$(${MYSQL_CMD} -e "
    SELECT VARIABLE_VALUE
    FROM INFORMATION_SCHEMA.GLOBAL_STATUS
    WHERE VARIABLE_NAME = 'Innodb_history_list_length'
")
echo "History List Length: ${HISTORY} (Target: <10000)"

# 4. Active Transactions
TRX_COUNT=$(${MYSQL_CMD} -e "
    SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_TRX
")
echo "Active Transactions: ${TRX_COUNT}"

# 5. Lock Waits
LOCK_WAITS=$(${MYSQL_CMD} -e "
    SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS
")
echo "Lock Waits: ${LOCK_WAITS} (Target: 0)"

# 6. Undo Tablespaces Size
echo ""
echo "â”€â”€â”€ UNDO TABLESPACES â”€â”€â”€"
${MYSQL_CMD} -e "
    SELECT
        FILE_NAME,
        ROUND(FILE_SIZE / 1024 / 1024 / 1024, 2) AS size_gb
    FROM INFORMATION_SCHEMA.FILES
    WHERE FILE_NAME LIKE '%undo%'
"

# 7. Configuration Summary
echo ""
echo "â”€â”€â”€ CONFIGURATION â”€â”€â”€"
${MYSQL_CMD} -e "
    SELECT
        CONCAT(@@innodb_buffer_pool_size / 1024 / 1024 / 1024, ' GB') AS buffer_pool,
        @@innodb_buffer_pool_instances AS bp_instances,
        CONCAT(@@innodb_log_file_size / 1024 / 1024 / 1024, ' GB') AS log_file_size,
        @@innodb_flush_log_at_trx_commit AS flush_log_commit,
        @@innodb_io_capacity AS io_capacity
"

# 8. Alertes
echo ""
echo "â”€â”€â”€ ALERTES â”€â”€â”€"
if (( $(echo "$HIT_RATIO < 99" | bc -l) )); then
    echo "âš ï¸  ALERTE: Buffer Pool Hit Ratio < 99%"
fi
if (( $(echo "$DIRTY_PCT > 80" | bc -l) )); then
    echo "âš ï¸  ALERTE: Dirty Pages > 80%"
fi
if [ "$HISTORY" -gt 10000 ]; then
    echo "âš ï¸  ALERTE: History List Length > 10000"
fi
if [ "$LOCK_WAITS" -gt 0 ]; then
    echo "âš ï¸  ALERTE: Lock Waits actifs"
fi

echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
```

### Monitoring Continu avec Performance Schema

```sql
-- CrÃ©er une vue de monitoring
CREATE OR REPLACE VIEW innodb_health AS
SELECT
    'Buffer Pool Hit Ratio' AS metric,
    CONCAT(
        ROUND((1 - (
            (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
            NULLIF((SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests'), 0)
        )) * 100, 2), '%'
    ) AS value,
    CASE
        WHEN (1 - (
            (SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
            NULLIF((SELECT VARIABLE_VALUE FROM INFORMATION_SCHEMA.GLOBAL_STATUS WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests'), 0)
        )) * 100 > 99 THEN 'OK'
        ELSE 'WARNING'
    END AS status

UNION ALL

SELECT
    'Dirty Pages Ratio',
    CONCAT(ROUND(AVG(modified_database_pages / database_pages) * 100, 2), '%'),
    CASE
        WHEN AVG(modified_database_pages / database_pages) * 100 < 80 THEN 'OK'
        ELSE 'WARNING'
    END
FROM INFORMATION_SCHEMA.INNODB_BUFFER_POOL_STATS

UNION ALL

SELECT
    'History List Length',
    VARIABLE_VALUE,
    CASE
        WHEN CAST(VARIABLE_VALUE AS UNSIGNED) < 10000 THEN 'OK'
        ELSE 'WARNING'
    END
FROM INFORMATION_SCHEMA.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'Innodb_history_list_length';

-- Utilisation
SELECT * FROM innodb_health;
```

---

## Best Practices pour Architectes

### 1. Principes de Configuration

âœ… **DO - Ã€ Faire** :
- Toujours benchmarker avant/aprÃ¨s chaque changement
- Commencer avec les defaults, optimiser progressivement
- Documenter chaque modification et sa justification
- Utiliser des profils de configuration par environnement
- Monitorer les mÃ©triques critiques en continu
- Tester en staging avant production
- Dimensionner pour les pics de charge, pas la moyenne

âŒ **DON'T - Ã€ Ã‰viter** :
- Copier-coller des configurations sans comprendre
- Modifier plusieurs paramÃ¨tres simultanÃ©ment
- Sur-optimiser prÃ©maturÃ©ment (YAGNI)
- Ignorer les warnings dans les logs
- NÃ©gliger la durabilitÃ© pour la performance
- Oublier les ressources per-connection
- Configurer sans monitoring

### 2. HiÃ©rarchie de Tuning

```
PrioritÃ© 1 (Impact Maximum)
  â””â”€â†’ Buffer Pool Size
  â””â”€â†’ Redo Log Size
  â””â”€â†’ I/O Capacity (si SSD)
  â””â”€â†’ flush_log_at_trx_commit

PrioritÃ© 2 (Impact Important)
  â””â”€â†’ Buffer Pool Instances
  â””â”€â†’ Page Cleaners
  â””â”€â†’ Read/Write IO Threads
  â””â”€â†’ Undo Configuration

PrioritÃ© 3 (Fine-tuning)
  â””â”€â†’ Adaptive Hash Index
  â””â”€â†’ Old Blocks Settings
  â””â”€â†’ Statistics Settings
  â””â”€â†’ Doublewrite (selon cas)

PrioritÃ© 4 (Edge Cases)
  â””â”€â†’ Thread Concurrency
  â””â”€â†’ Spin Wait Parameters
  â””â”€â†’ Compression Settings
```

### 3. Trade-offs Majeurs

**DurabilitÃ© vs Performance** :

```
innodb_flush_log_at_trx_commit = 1
  âœ“ DurabilitÃ© maximale (aucune perte)
  âœ— Performance rÃ©duite (50-70% TPS)

innodb_flush_log_at_trx_commit = 2
  âœ“ Performance excellente
  âœ— Risque perte 1s (crash OS)

innodb_flush_log_at_trx_commit = 0
  âœ“ Performance maximale
  âœ— Risque perte 1s (crash MariaDB ou OS)

Recommandation :
- Primary : Mode 1
- Replica : Mode 2
- Dev/Test : Mode 0
```

**MÃ©moire vs Concurrence** :

```
Buffer Pool Large (80% RAM)
  âœ“ Cache maximum
  âœ“ Moins de disk I/O
  âœ— Moins de RAM pour OS/connexions
  âœ— Checkpoints plus longs

Buffer Pool ModÃ©rÃ© (60-70% RAM)
  âœ“ RAM disponible pour connexions
  âœ“ Checkpoints rapides
  âœ— Hit ratio potentiellement plus faible
```

### 4. Checklist de Production

```markdown
# CHECKLIST CONFIGURATION INNODB PRODUCTION

## MÃ©moire
- [ ] Buffer Pool = 70-80% RAM disponible
- [ ] Buffer Pool Instances = Size en GB (max 64)
- [ ] Per-connection buffers raisonnables (<4M each)
- [ ] Dump/Load Buffer Pool activÃ©

## Logs
- [ ] Redo Log = 30-60 min de modifications en pointe
- [ ] flush_log_at_trx_commit = 1 (primary)
- [ ] Undo tablespaces >= 2
- [ ] Truncate automatique activÃ©

## I/O
- [ ] io_capacity ajustÃ© au stockage (SSD: 3000-10000)
- [ ] flush_neighbors = 0 (SSD)
- [ ] flush_method = O_DIRECT
- [ ] native_aio = ON

## Concurrence
- [ ] thread_concurrency = 0 (illimitÃ©)
- [ ] lock_wait_timeout appropriÃ© au workload
- [ ] deadlock_detect = ON

## Monitoring
- [ ] print_all_deadlocks = ON
- [ ] Performance Schema activÃ© (si RAM suffisante)
- [ ] MÃ©triques exportÃ©es vers Prometheus/Grafana

## SÃ©curitÃ©
- [ ] doublewrite = ON (sauf cas spÃ©ciaux)
- [ ] file_per_table = ON
- [ ] strict_mode = ON

## Backup
- [ ] Backup automatisÃ© quotidien
- [ ] PITR possible (binary logs activÃ©s)
- [ ] Test de restore mensuel
```

### 5. Documentation et Versioning

```ini
# /etc/mysql/conf.d/innodb.cnf
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INNODB CONFIGURATION - PRODUCTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# Version: 2.1
# Date: 2025-12-12
# Auteur: DBA Team
# Environnement: Production OLTP
# Infrastructure: 64 GB RAM, 16 cores, NVMe SSD
#
# Changelog:
# 2025-12-12 v2.1: Augmentation Buffer Pool 32Gâ†’48G (ticket #1234)
# 2025-11-15 v2.0: Migration MariaDB 11.8 (nouveaux params)
# 2025-10-01 v1.5: Tuning I/O capacity pour NVMe
#
# Metrics Baseline (avant v2.1):
# - TPS: 15000
# - Buffer Pool Hit Ratio: 98.5%
# - P95 Latency: 12ms
#
# Metrics Target (aprÃ¨s v2.1):
# - TPS: 20000+
# - Buffer Pool Hit Ratio: >99.5%
# - P95 Latency: <10ms
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[mysqld]
# Configuration suivant...
```

---

## âœ… Points clÃ©s Ã  retenir

- **MÃ©thodologie** : Baseline â†’ Identification â†’ HypothÃ¨se â†’ Changement â†’ Validation (une modification Ã  la fois)
- **PrioritÃ©s de tuning** : Buffer Pool > Redo Log > I/O Capacity > flush_log_at_trx_commit
- **Buffer Pool sizing** : 70-80% RAM serveur dÃ©diÃ©, 60% conteneur, 1 instance par GB
- **Redo Log sizing** : 30-60 minutes de modifications en pointe (formule : Ã©criture/heure Ã· 2)
- **Trade-off critique** : flush_log_at_trx_commit (1=durabilitÃ© max, 2=compromis, 0=performance max)
- **SSD optimizations** : flush_neighbors=0, io_capacity Ã©levÃ©, read_ahead dÃ©sactivÃ©
- **MariaDB 11.8** : innodb_alter_copy_bulk, compression redo log, undo tablespaces dynamiques
- **Profils distincts** : OLTP (transactions courtes), OLAP (scans), Mixed, Cloud, Replica
- **Monitoring continu** : Hit ratio >99%, dirty pages <80%, history list <10k, checkpoint age <80%
- **Documentation** : Versionner les configurations, maintenir changelog, documenter rationale

---

## ðŸ”— Ressources et rÃ©fÃ©rences

- [ðŸ“– InnoDB System Variables](https://mariadb.com/kb/en/innodb-system-variables/)
- [ðŸ“– InnoDB Server Status Variables](https://mariadb.com/kb/en/innodb-status-variables/)
- [ðŸ“– Optimizing InnoDB Configuration](https://mariadb.com/kb/en/optimizing-innodb-configuration/)
- [ðŸ“– InnoDB Performance](https://mariadb.com/kb/en/innodb-performance/)
- [ðŸ†• MariaDB 11.8 - InnoDB Improvements](https://mariadb.com/kb/en/changes-improvements-in-mariadb-118/)
- [ðŸ“– SHOW ENGINE INNODB STATUS](https://mariadb.com/kb/en/show-engine-innodb-status/)

**Outils recommandÃ©s** :
- `mysqltuner.pl` - Analyse automatique de configuration
- `pt-mysql-summary` (Percona Toolkit) - RÃ©sumÃ© configuration
- `innotop` - Monitoring InnoDB temps rÃ©el
- PMM (Percona Monitoring Management) - Dashboards complets
- `sysbench` - Benchmarking performance

**Livres et guides** :
- "High Performance MySQL" (Baron Schwartz et al.) - Chapitre InnoDB
- "MySQL Troubleshooting" (Sveta Smirnova) - Configuration troubleshooting
- "Effective MySQL: Optimizing SQL Statements" (Ronald Bradford)

**Blogs techniques** :
- Percona Database Performance Blog
- MariaDB Corporation Blog
- MySQL Server Team Blog
- Planet MySQL

---

## âž¡ï¸ Section suivante

**[7.3 MyISAM : Moteur Legacy](/07-moteurs-de-stockage/03-myisam.md)** : PrÃ©sentation du moteur historique, cas d'usage rÃ©siduels, migration vers InnoDB/Aria, et pourquoi InnoDB est prÃ©fÃ©rable pour les nouvelles applications.

â­ï¸ [MyISAM : Moteur legacy](/07-moteurs-de-stockage/03-myisam.md)
