üîù Retour au [Sommaire](/SOMMAIRE.md)

# 9.7.2 PERFORMANCE_SCHEMA

> **Niveau** : Interm√©diaire √† Avanc√©
> **Dur√©e estim√©e** : 2.5-3 heures
> **Pr√©requis** : Sections 9.7 et 9.7.1, compr√©hension des concepts de performance

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :

- Configurer et activer PERFORMANCE_SCHEMA efficacement
- Comprendre l'architecture et l'organisation de PERFORMANCE_SCHEMA
- Utiliser les tables de statements pour identifier les requ√™tes lentes
- Analyser les I/O et identifier les tables probl√©matiques
- Diagnostiquer les verrous et les contentions
- Surveiller les connexions et threads actifs
- Optimiser la configuration de PERFORMANCE_SCHEMA pour minimiser l'impact
- Cr√©er des requ√™tes de monitoring pour la production
- Interpr√©ter les m√©triques de performance pour l'optimisation

---

## Introduction

### Qu'est-ce que PERFORMANCE_SCHEMA ?

**PERFORMANCE_SCHEMA** est un moteur de stockage sp√©cialis√© qui collecte des **m√©triques de performance d√©taill√©es** en temps r√©el sur le serveur MariaDB. Introduit dans MySQL 5.5 et repris par MariaDB, il fournit une instrumentation bas niveau pour :

- **Statements** : Toutes les requ√™tes SQL ex√©cut√©es
- **Waits** : Temps d'attente (I/O, verrous, mutex)
- **Stages** : √âtapes d'ex√©cution des requ√™tes
- **Transactions** : M√©triques transactionnelles
- **Connections** : Informations sur les connexions
- **Memory** : Utilisation de la m√©moire

```sql
-- PERFORMANCE_SCHEMA est une base de donn√©es √† part
USE performance_schema;

-- Plus de 100 tables instrument√©es
SHOW TABLES;
-- events_statements_summary_by_digest
-- events_waits_summary_global_by_event_name
-- table_io_waits_summary_by_table
-- ...
```

### Diff√©rences avec INFORMATION_SCHEMA

| Aspect | INFORMATION_SCHEMA | PERFORMANCE_SCHEMA |
|--------|-------------------|-------------------|
| **Type** | M√©tadonn√©es structurelles | M√©triques de performance |
| **Donn√©es** | Tables, colonnes, index, privil√®ges | Requ√™tes, I/O, verrous, latence |
| **Mise √† jour** | Lors des modifications DDL | En temps r√©el (continu) |
| **Objectif** | Administration, structure | Monitoring, optimisation |
| **Impact** | N√©gligeable | L√©ger (< 5% typiquement) |
| **Historique** | Pas d'historique | Historique configurable |

üí° **Compl√©mentarit√©** : INFORMATION_SCHEMA r√©pond √† "quelle est la structure ?" et PERFORMANCE_SCHEMA r√©pond √† "comment √ßa performe ?".

---

## Configuration et activation

### V√©rifier si PERFORMANCE_SCHEMA est activ√©

```sql
-- Variable principale
SHOW VARIABLES LIKE 'performance_schema';
-- +--------------------+-------+
-- | Variable_name      | Value |
-- +--------------------+-------+
-- | performance_schema | ON    |  ‚Üê Doit √™tre ON
-- +--------------------+-------+

-- V√©rifier les instruments actifs
SELECT COUNT(*) AS instruments_actifs
FROM performance_schema.setup_instruments
WHERE ENABLED = 'YES';
```

### Activer PERFORMANCE_SCHEMA

Si PERFORMANCE_SCHEMA est d√©sactiv√© :

```ini
# Dans my.cnf ou my.ini
[mysqld]
performance_schema = ON

# Taille des buffers (optionnel, ajuster selon vos besoins)
performance_schema_max_table_instances = 12500
performance_schema_max_table_handles = 4000
performance_schema_events_statements_history_size = 10
performance_schema_events_statements_history_long_size = 10000
```

Puis red√©marrer MariaDB :

```bash
sudo systemctl restart mariadb
```

‚ö†Ô∏è **Important** : PERFORMANCE_SCHEMA ne peut pas √™tre activ√© dynamiquement. Un red√©marrage est n√©cessaire.

### Configuration des instruments

PERFORMANCE_SCHEMA utilise des **instruments** (compteurs) pour collecter les m√©triques. On peut activer/d√©sactiver des instruments pour contr√¥ler l'overhead.

```sql
-- Voir tous les instruments disponibles
SELECT
    NAME,
    ENABLED,
    TIMED
FROM performance_schema.setup_instruments
ORDER BY NAME
LIMIT 20;

-- Cat√©gories d'instruments
SELECT
    SUBSTRING_INDEX(NAME, '/', 1) AS categorie,
    COUNT(*) AS nb_instruments,
    SUM(ENABLED = 'YES') AS actifs
FROM performance_schema.setup_instruments
GROUP BY categorie
ORDER BY categorie;
```

**Activer/d√©sactiver des instruments** :

```sql
-- D√©sactiver tous les instruments wait/io/file
UPDATE performance_schema.setup_instruments
SET ENABLED = 'NO', TIMED = 'NO'
WHERE NAME LIKE 'wait/io/file%';

-- Activer uniquement les statements
UPDATE performance_schema.setup_instruments
SET ENABLED = 'YES', TIMED = 'YES'
WHERE NAME LIKE 'statement/%';

-- V√©rifier les changements
SELECT NAME, ENABLED, TIMED
FROM performance_schema.setup_instruments
WHERE NAME LIKE 'statement/%'
LIMIT 10;
```

üí° **Conseil** : Pour minimiser l'overhead, d√©sactivez les instruments que vous n'utilisez pas (ex: wait/io/file si vous ne surveillez pas les I/O fichiers).

---

## Architecture de PERFORMANCE_SCHEMA

### Organisation des tables

PERFORMANCE_SCHEMA contient plus de 100 tables organis√©es en cat√©gories :

#### 1. Setup tables (configuration)

```sql
-- setup_instruments : Instruments disponibles
-- setup_consumers : O√π stocker les √©v√©nements
-- setup_actors : Threads √† surveiller
-- setup_objects : Objets (tables, bases) √† surveiller
-- setup_timers : Configuration des timers

-- Exemple : Activer la collecte des statements
UPDATE performance_schema.setup_consumers
SET ENABLED = 'YES'
WHERE NAME LIKE '%statements%';

-- V√©rifier les consumers actifs
SELECT NAME, ENABLED
FROM performance_schema.setup_consumers
ORDER BY NAME;
```

#### 2. Instance tables (objets instrument√©s)

```sql
-- file_instances : Fichiers ouverts
-- mutex_instances : Mutex en m√©moire
-- rwlock_instances : Read-write locks
-- socket_instances : Connexions r√©seau
-- cond_instances : Variables conditionnelles

-- Exemple : Fichiers ouverts
SELECT
    FILE_NAME,
    EVENT_NAME,
    OPEN_COUNT
FROM performance_schema.file_instances
WHERE OPEN_COUNT > 0
LIMIT 20;
```

#### 3. Events tables (√©v√©nements historiques)

```sql
-- events_statements_current : Requ√™tes en cours
-- events_statements_history : Historique par thread (derni√®res 10)
-- events_statements_history_long : Historique global (derni√®res 10000)

-- Requ√™tes en cours d'ex√©cution
SELECT
    THREAD_ID,
    EVENT_NAME,
    SQL_TEXT,
    TIMER_WAIT / 1000000000000 AS duration_sec
FROM performance_schema.events_statements_current
WHERE SQL_TEXT IS NOT NULL
ORDER BY TIMER_WAIT DESC;
```

#### 4. Summary tables (agr√©gations)

C'est la partie la plus utile pour le monitoring :

```sql
-- events_statements_summary_by_digest : Requ√™tes agr√©g√©es par pattern
-- table_io_waits_summary_by_table : I/O par table
-- table_lock_waits_summary_by_table : Verrous par table
-- events_waits_summary_by_instance : Attentes par objet
-- memory_summary_global_by_event_name : Utilisation m√©moire
```

---

## Analyse des requ√™tes (Statements)

### events_statements_summary_by_digest : La table essentielle

Cette table agr√®ge toutes les requ√™tes par **digest** (pattern SQL normalis√©).

```sql
-- Structure de la table
DESC performance_schema.events_statements_summary_by_digest;

-- Colonnes cl√©s :
-- SCHEMA_NAME : Base de donn√©es
-- DIGEST : Hash du pattern SQL
-- DIGEST_TEXT : Pattern SQL lisible (constantes remplac√©es par ?)
-- COUNT_STAR : Nombre d'ex√©cutions
-- SUM_TIMER_WAIT : Temps total cumul√© (picosecondes)
-- MIN_TIMER_WAIT, MAX_TIMER_WAIT, AVG_TIMER_WAIT : Stats de temps
-- SUM_LOCK_TIME : Temps total en verrous
-- SUM_ROWS_AFFECTED, SUM_ROWS_SENT, SUM_ROWS_EXAMINED : Stats de lignes
-- SUM_CREATED_TMP_TABLES, SUM_CREATED_TMP_DISK_TABLES : Tables temporaires
-- SUM_SORT_ROWS, SUM_SORT_MERGE_PASSES : Tris
-- FIRST_SEEN, LAST_SEEN : Premi√®re et derni√®re ex√©cution
```

**Requ√™te 1 : Top 20 requ√™tes les plus lentes (temps cumul√©)**

```sql
SELECT
    SCHEMA_NAME AS base,
    DIGEST_TEXT AS requete,
    COUNT_STAR AS nb_exec,
    ROUND(SUM_TIMER_WAIT / 1000000000000, 3) AS temps_total_sec,
    ROUND(AVG_TIMER_WAIT / 1000000000000, 3) AS temps_moyen_sec,
    ROUND(MAX_TIMER_WAIT / 1000000000000, 3) AS temps_max_sec,
    ROUND(SUM_LOCK_TIME / 1000000000000, 3) AS lock_time_sec,
    SUM_ROWS_EXAMINED AS lignes_examinees,
    SUM_ROWS_SENT AS lignes_retournees,
    SUM_CREATED_TMP_TABLES AS tmp_tables,
    SUM_CREATED_TMP_DISK_TABLES AS tmp_disk_tables,
    FIRST_SEEN,
    LAST_SEEN
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME IS NOT NULL
  AND SCHEMA_NAME NOT IN ('performance_schema', 'information_schema', 'mysql')
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 20;

-- Identifie les requ√™tes qui consomment le plus de temps total
```

**Requ√™te 2 : Requ√™tes avec temps moyen le plus √©lev√©**

```sql
SELECT
    SCHEMA_NAME,
    LEFT(DIGEST_TEXT, 100) AS requete_tronquee,
    COUNT_STAR AS nb_exec,
    ROUND(AVG_TIMER_WAIT / 1000000000000, 3) AS temps_moyen_sec,
    ROUND(MAX_TIMER_WAIT / 1000000000000, 3) AS temps_max_sec,
    ROUND(SUM_ROWS_EXAMINED / COUNT_STAR, 0) AS lignes_moy_examinees
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = 'production_db'
  AND COUNT_STAR > 10  -- Au moins 10 ex√©cutions
ORDER BY AVG_TIMER_WAIT DESC
LIMIT 20;

-- Requ√™tes individuellement lentes (m√™me si peu fr√©quentes)
```

**Requ√™te 3 : Requ√™tes avec le plus de full table scans**

```sql
SELECT
    SCHEMA_NAME,
    LEFT(DIGEST_TEXT, 80) AS requete,
    COUNT_STAR AS nb_exec,
    SUM_NO_INDEX_USED AS sans_index,
    SUM_NO_GOOD_INDEX_USED AS mauvais_index,
    ROUND(SUM_NO_INDEX_USED / COUNT_STAR * 100, 1) AS pct_sans_index,
    SUM_ROWS_EXAMINED AS lignes_examinees,
    ROUND(AVG_TIMER_WAIT / 1000000000000, 3) AS temps_moyen_sec
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = 'production_db'
  AND SUM_NO_INDEX_USED > 0
ORDER BY SUM_NO_INDEX_USED DESC
LIMIT 20;

-- Requ√™tes qui n'utilisent pas d'index (probl√®me majeur)
```

**Requ√™te 4 : Requ√™tes cr√©ant beaucoup de tables temporaires**

```sql
SELECT
    SCHEMA_NAME,
    LEFT(DIGEST_TEXT, 80) AS requete,
    COUNT_STAR AS nb_exec,
    SUM_CREATED_TMP_TABLES AS tmp_tables,
    SUM_CREATED_TMP_DISK_TABLES AS tmp_disk_tables,
    ROUND(SUM_CREATED_TMP_DISK_TABLES / SUM_CREATED_TMP_TABLES * 100, 1) AS pct_disk,
    ROUND(AVG_TIMER_WAIT / 1000000000000, 3) AS temps_moyen_sec
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = 'production_db'
  AND SUM_CREATED_TMP_TABLES > 0
ORDER BY SUM_CREATED_TMP_DISK_TABLES DESC
LIMIT 20;

-- Tables temporaires sur disque = tr√®s lent
```

**Requ√™te 5 : Requ√™tes avec beaucoup de tris**

```sql
SELECT
    SCHEMA_NAME,
    LEFT(DIGEST_TEXT, 80) AS requete,
    COUNT_STAR AS nb_exec,
    SUM_SORT_ROWS AS lignes_triees,
    SUM_SORT_MERGE_PASSES AS merge_passes,
    ROUND(SUM_SORT_MERGE_PASSES / COUNT_STAR, 1) AS merge_moy,
    ROUND(AVG_TIMER_WAIT / 1000000000000, 3) AS temps_moyen_sec
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = 'production_db'
  AND SUM_SORT_ROWS > 0
ORDER BY SUM_SORT_MERGE_PASSES DESC
LIMIT 20;

-- Merge passes > 0 = tri trop volumineux pour tenir en m√©moire
```

### R√©initialiser les statistiques

```sql
-- R√©initialiser toutes les statistiques statements
TRUNCATE TABLE performance_schema.events_statements_summary_by_digest;
TRUNCATE TABLE performance_schema.events_statements_history;
TRUNCATE TABLE performance_schema.events_statements_history_long;

-- Les compteurs repartent √† z√©ro
-- Utile apr√®s optimisation pour mesurer l'am√©lioration
```

---

## Analyse des I/O sur les tables

### table_io_waits_summary_by_table : Activit√© par table

```sql
-- Top 20 tables avec le plus d'I/O (temps total)
SELECT
    OBJECT_SCHEMA AS base,
    OBJECT_NAME AS table_name,
    COUNT_STAR AS nb_operations,
    COUNT_READ AS nb_lectures,
    COUNT_WRITE AS nb_ecritures,
    ROUND(SUM_TIMER_WAIT / 1000000000000, 3) AS temps_total_sec,
    ROUND(SUM_TIMER_READ / 1000000000000, 3) AS temps_lecture_sec,
    ROUND(SUM_TIMER_WRITE / 1000000000000, 3) AS temps_ecriture_sec,
    ROUND((SUM_TIMER_READ / 1000000000000) / GREATEST(COUNT_READ, 1), 6) AS temps_moy_lecture,
    ROUND((SUM_TIMER_WRITE / 1000000000000) / GREATEST(COUNT_WRITE, 1), 6) AS temps_moy_ecriture
FROM performance_schema.table_io_waits_summary_by_table
WHERE OBJECT_SCHEMA NOT IN ('mysql', 'performance_schema', 'information_schema')
  AND COUNT_STAR > 0
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 20;

-- Tables avec le plus d'activit√© I/O = candidates √† l'optimisation
```

### Identifier les tables avec des lectures lentes

```sql
SELECT
    OBJECT_SCHEMA,
    OBJECT_NAME,
    COUNT_READ,
    ROUND(SUM_TIMER_READ / 1000000000000, 3) AS temps_lecture_total_sec,
    ROUND((SUM_TIMER_READ / 1000000000000) / COUNT_READ, 6) AS temps_moy_lecture_sec,
    ROUND(SUM_NUMBER_OF_BYTES_READ / 1024 / 1024, 2) AS mb_lus
FROM performance_schema.table_io_waits_summary_by_table
WHERE OBJECT_SCHEMA = 'production_db'
  AND COUNT_READ > 0
ORDER BY (SUM_TIMER_READ / COUNT_READ) DESC
LIMIT 20;

-- Lectures lentes en moyenne = manque d'index ou fragmentation
```

### Combiner avec INFORMATION_SCHEMA pour analyse compl√®te

```sql
-- Tables avec le plus d'I/O + leur taille
SELECT
    tio.OBJECT_NAME AS table_name,
    t.TABLE_ROWS AS nb_lignes,
    ROUND((t.DATA_LENGTH + t.INDEX_LENGTH) / 1024 / 1024, 2) AS taille_mb,
    tio.COUNT_READ AS nb_lectures,
    tio.COUNT_WRITE AS nb_ecritures,
    ROUND(tio.SUM_TIMER_WAIT / 1000000000000, 3) AS temps_io_sec,
    ROUND(tio.SUM_TIMER_WAIT / 1000000000000 / (t.DATA_LENGTH + t.INDEX_LENGTH) * 1024 * 1024, 6) AS sec_par_mb
FROM performance_schema.table_io_waits_summary_by_table tio
INNER JOIN information_schema.TABLES t
    ON tio.OBJECT_SCHEMA = t.TABLE_SCHEMA
    AND tio.OBJECT_NAME = t.TABLE_NAME
WHERE tio.OBJECT_SCHEMA = 'production_db'
  AND tio.COUNT_STAR > 0
ORDER BY tio.SUM_TIMER_WAIT DESC
LIMIT 20;
```

---

## Analyse des verrous (Locks)

### table_lock_waits_summary_by_table : Attente de verrous

```sql
SELECT
    OBJECT_SCHEMA,
    OBJECT_NAME,
    COUNT_STAR AS nb_operations,
    COUNT_READ AS nb_read_locks,
    COUNT_WRITE AS nb_write_locks,
    COUNT_READ_NORMAL AS nb_read_normal,
    COUNT_READ_WITH_SHARED_LOCKS AS nb_read_shared,
    COUNT_READ_HIGH_PRIORITY AS nb_read_high_priority,
    COUNT_WRITE_ALLOW_WRITE AS nb_write_concurrent,
    COUNT_WRITE_NORMAL AS nb_write_exclusive,
    ROUND(SUM_TIMER_WAIT / 1000000000000, 3) AS temps_attente_total_sec,
    ROUND((SUM_TIMER_WAIT / 1000000000000) / COUNT_STAR, 6) AS temps_moy_attente
FROM performance_schema.table_lock_waits_summary_by_table
WHERE OBJECT_SCHEMA = 'production_db'
  AND COUNT_STAR > 0
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 20;

-- Tables avec le plus d'attente de verrous = contentions
```

### metadata_locks : Verrous actifs en ce moment

```sql
-- Verrous de m√©tadonn√©es actuels
SELECT
    OBJECT_TYPE,
    OBJECT_SCHEMA,
    OBJECT_NAME,
    LOCK_TYPE,
    LOCK_DURATION,
    LOCK_STATUS,
    OWNER_THREAD_ID,
    OWNER_EVENT_ID
FROM performance_schema.metadata_locks
WHERE OBJECT_SCHEMA = 'production_db'
ORDER BY OBJECT_TYPE, OBJECT_NAME;

-- Si des verrous sont bloquants, identifier les threads responsables
```

### data_locks et data_lock_waits (MariaDB 10.5+)

```sql
-- Verrous de lignes actifs (InnoDB)
SELECT
    ENGINE,
    ENGINE_LOCK_ID,
    ENGINE_TRANSACTION_ID,
    OBJECT_SCHEMA,
    OBJECT_NAME,
    PARTITION_NAME,
    INDEX_NAME,
    LOCK_TYPE,
    LOCK_MODE,
    LOCK_STATUS,
    LOCK_DATA
FROM performance_schema.data_locks
WHERE OBJECT_SCHEMA = 'production_db'
LIMIT 50;

-- Verrous en attente (deadlocks potentiels)
SELECT
    dl.ENGINE,
    dl.REQUESTING_ENGINE_LOCK_ID,
    dl.BLOCKING_ENGINE_LOCK_ID,
    dl.REQUESTING_ENGINE_TRANSACTION_ID,
    dl.BLOCKING_ENGINE_TRANSACTION_ID,
    dl.OBJECT_SCHEMA,
    dl.OBJECT_NAME
FROM performance_schema.data_lock_waits dl
WHERE dl.OBJECT_SCHEMA = 'production_db';
```

---

## Analyse des threads et connexions

### threads : Tous les threads actifs

```sql
SELECT
    THREAD_ID,
    NAME,
    TYPE,              -- FOREGROUND (utilisateur) ou BACKGROUND
    PROCESSLIST_ID,
    PROCESSLIST_USER,
    PROCESSLIST_HOST,
    PROCESSLIST_DB,
    PROCESSLIST_COMMAND,  -- Query, Sleep, Connect, etc.
    PROCESSLIST_TIME,     -- Dur√©e en secondes
    PROCESSLIST_STATE,
    LEFT(PROCESSLIST_INFO, 100) AS query_preview,
    INSTRUMENTED          -- YES ou NO
FROM performance_schema.threads
WHERE TYPE = 'FOREGROUND'
  AND PROCESSLIST_COMMAND != 'Sleep'
ORDER BY PROCESSLIST_TIME DESC;

-- Threads utilisateurs actifs avec leur requ√™te en cours
```

### Connexions avec requ√™tes longues

```sql
-- Requ√™tes qui durent depuis plus de 30 secondes
SELECT
    t.PROCESSLIST_ID,
    t.PROCESSLIST_USER AS user,
    t.PROCESSLIST_HOST AS host,
    t.PROCESSLIST_DB AS database,
    t.PROCESSLIST_TIME AS duration_sec,
    t.PROCESSLIST_STATE AS state,
    esc.SQL_TEXT AS current_query,
    ROUND(esc.TIMER_WAIT / 1000000000000, 3) AS query_time_sec
FROM performance_schema.threads t
LEFT JOIN performance_schema.events_statements_current esc
    ON t.THREAD_ID = esc.THREAD_ID
WHERE t.TYPE = 'FOREGROUND'
  AND t.PROCESSLIST_COMMAND = 'Query'
  AND t.PROCESSLIST_TIME > 30
ORDER BY t.PROCESSLIST_TIME DESC;

-- Identifier les requ√™tes probl√©matiques √† tuer si n√©cessaire
```

### Historique de connexions

```sql
-- R√©sum√© des connexions par utilisateur
SELECT
    USER,
    HOST,
    CURRENT_CONNECTIONS AS connexions_actuelles,
    TOTAL_CONNECTIONS AS connexions_totales
FROM performance_schema.accounts
ORDER BY TOTAL_CONNECTIONS DESC;

-- Voir l'activit√© par utilisateur/host
```

---

## Utilisation de la m√©moire

### memory_summary_global_by_event_name : M√©moire par instrument

```sql
SELECT
    EVENT_NAME,
    COUNT_ALLOC AS nb_allocations,
    COUNT_FREE AS nb_liberations,
    CURRENT_COUNT_USED AS allocations_actuelles,
    ROUND(CURRENT_NUMBER_OF_BYTES_USED / 1024 / 1024, 2) AS memoire_utilisee_mb,
    ROUND(HIGH_NUMBER_OF_BYTES_USED / 1024 / 1024, 2) AS pic_memoire_mb,
    ROUND(LOW_NUMBER_OF_BYTES_USED / 1024 / 1024, 2) AS memoire_min_mb
FROM performance_schema.memory_summary_global_by_event_name
WHERE CURRENT_NUMBER_OF_BYTES_USED > 0
ORDER BY CURRENT_NUMBER_OF_BYTES_USED DESC
LIMIT 30;

-- Instruments qui consomment le plus de m√©moire
```

### M√©moire par thread

```sql
SELECT
    t.THREAD_ID,
    t.PROCESSLIST_USER,
    t.PROCESSLIST_HOST,
    t.PROCESSLIST_DB,
    ROUND(SUM(mst.CURRENT_NUMBER_OF_BYTES_USED) / 1024 / 1024, 2) AS memoire_thread_mb
FROM performance_schema.memory_summary_by_thread_by_event_name mst
INNER JOIN performance_schema.threads t
    ON mst.THREAD_ID = t.THREAD_ID
WHERE t.TYPE = 'FOREGROUND'
GROUP BY t.THREAD_ID, t.PROCESSLIST_USER, t.PROCESSLIST_HOST, t.PROCESSLIST_DB
HAVING memoire_thread_mb > 10  -- Plus de 10 MB
ORDER BY memoire_thread_mb DESC
LIMIT 20;

-- Threads qui consomment beaucoup de m√©moire
```

---

## Monitoring en production : Requ√™tes essentielles

### Dashboard de monitoring temps r√©el

```sql
-- Vue d'ensemble du serveur
SELECT
    (SELECT COUNT(*) FROM performance_schema.threads WHERE TYPE = 'FOREGROUND') AS connexions_actives,
    (SELECT COUNT(*) FROM performance_schema.threads WHERE TYPE = 'FOREGROUND' AND PROCESSLIST_COMMAND = 'Query') AS requetes_actives,
    (SELECT COUNT(*) FROM performance_schema.threads WHERE TYPE = 'FOREGROUND' AND PROCESSLIST_TIME > 10) AS requetes_lentes_10s,
    (SELECT COUNT(*) FROM performance_schema.threads WHERE TYPE = 'FOREGROUND' AND PROCESSLIST_TIME > 60) AS requetes_lentes_60s,
    (SELECT ROUND(SUM(CURRENT_NUMBER_OF_BYTES_USED) / 1024 / 1024 / 1024, 2)
     FROM performance_schema.memory_summary_global_by_event_name) AS memoire_totale_gb,
    (SELECT COUNT(*) FROM performance_schema.metadata_locks) AS verrous_metadata,
    (SELECT COUNT(*) FROM performance_schema.data_locks) AS verrous_lignes;
```

### Top 10 requ√™tes √† optimiser (score composite)

```sql
-- Score bas√© sur temps total + fr√©quence + impact
SELECT
    SCHEMA_NAME,
    LEFT(DIGEST_TEXT, 100) AS requete,
    COUNT_STAR AS nb_exec,
    ROUND(SUM_TIMER_WAIT / 1000000000000, 2) AS temps_total_sec,
    ROUND(AVG_TIMER_WAIT / 1000000000000, 3) AS temps_moy_sec,
    SUM_ROWS_EXAMINED AS lignes_examinees,
    SUM_NO_INDEX_USED AS sans_index,
    SUM_CREATED_TMP_DISK_TABLES AS tmp_disk,
    -- Score composite (plus √©lev√© = plus prioritaire)
    ROUND(
        (SUM_TIMER_WAIT / 1000000000000) *
        LOG(COUNT_STAR + 1) *
        (1 + SUM_NO_INDEX_USED * 10) *
        (1 + SUM_CREATED_TMP_DISK_TABLES * 5)
    , 2) AS score_priorite
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = 'production_db'
  AND COUNT_STAR > 10
ORDER BY score_priorite DESC
LIMIT 10;

-- Requ√™tes avec le plus d'impact global √† optimiser en priorit√©
```

### Alertes automatiques

```sql
-- Cr√©er une vue pour les alertes
CREATE OR REPLACE VIEW v_alertes_performance AS
SELECT
    'REQUETE_TRES_LENTE' AS type_alerte,
    t.PROCESSLIST_ID AS process_id,
    t.PROCESSLIST_USER AS user,
    t.PROCESSLIST_TIME AS duration_sec,
    LEFT(esc.SQL_TEXT, 200) AS query_text,
    'CRITICAL' AS severite
FROM performance_schema.threads t
INNER JOIN performance_schema.events_statements_current esc
    ON t.THREAD_ID = esc.THREAD_ID
WHERE t.TYPE = 'FOREGROUND'
  AND t.PROCESSLIST_COMMAND = 'Query'
  AND t.PROCESSLIST_TIME > 300  -- Plus de 5 minutes

UNION ALL

SELECT
    'TROP_CONNEXIONS' AS type_alerte,
    NULL AS process_id,
    USER AS user,
    CURRENT_CONNECTIONS AS duration_sec,
    CONCAT('User has ', CURRENT_CONNECTIONS, ' connections') AS query_text,
    'WARNING' AS severite
FROM performance_schema.accounts
WHERE CURRENT_CONNECTIONS > 50  -- Plus de 50 connexions par user

UNION ALL

SELECT
    'MEMOIRE_ELEVEE' AS type_alerte,
    t.THREAD_ID AS process_id,
    t.PROCESSLIST_USER AS user,
    ROUND(SUM(mst.CURRENT_NUMBER_OF_BYTES_USED) / 1024 / 1024, 0) AS duration_sec,
    CONCAT('Thread uses ', ROUND(SUM(mst.CURRENT_NUMBER_OF_BYTES_USED) / 1024 / 1024, 0), ' MB') AS query_text,
    'WARNING' AS severite
FROM performance_schema.memory_summary_by_thread_by_event_name mst
INNER JOIN performance_schema.threads t ON mst.THREAD_ID = t.THREAD_ID
WHERE t.TYPE = 'FOREGROUND'
GROUP BY t.THREAD_ID, t.PROCESSLIST_USER
HAVING SUM(mst.CURRENT_NUMBER_OF_BYTES_USED) > 100 * 1024 * 1024;  -- Plus de 100 MB

-- Interroger cette vue r√©guli√®rement (cron, monitoring tool)
SELECT * FROM v_alertes_performance;
```

---

## Optimisation de PERFORMANCE_SCHEMA

### Minimiser l'impact sur les performances

#### 1. D√©sactiver les instruments inutilis√©s

```sql
-- D√©sactiver tous les wait/io/file (I/O fichiers)
UPDATE performance_schema.setup_instruments
SET ENABLED = 'NO', TIMED = 'NO'
WHERE NAME LIKE 'wait/io/file%';

-- D√©sactiver les stages (√©tapes de requ√™tes)
UPDATE performance_schema.setup_instruments
SET ENABLED = 'NO', TIMED = 'NO'
WHERE NAME LIKE 'stage/%';

-- Garder uniquement statements et table I/O
UPDATE performance_schema.setup_instruments
SET ENABLED = 'YES', TIMED = 'YES'
WHERE NAME LIKE 'statement/%' OR NAME LIKE 'wait/io/table/%';
```

#### 2. R√©duire la taille des historiques

```ini
# Dans my.cnf
[mysqld]
# R√©duire l'historique des statements
performance_schema_events_statements_history_size = 5
performance_schema_events_statements_history_long_size = 5000

# R√©duire l'historique des waits
performance_schema_events_waits_history_size = 5
performance_schema_events_waits_history_long_size = 5000
```

#### 3. D√©sactiver les consumers inutilis√©s

```sql
-- D√©sactiver l'historique d√©taill√© si non utilis√©
UPDATE performance_schema.setup_consumers
SET ENABLED = 'NO'
WHERE NAME LIKE '%history%' AND NAME != '%history_long';

-- Garder uniquement les summaries et history_long
SELECT NAME, ENABLED
FROM performance_schema.setup_consumers
ORDER BY NAME;
```

#### 4. Filtrer les objets surveill√©s

```sql
-- Ne surveiller que certaines bases
UPDATE performance_schema.setup_objects
SET ENABLED = 'NO'
WHERE OBJECT_SCHEMA = 'test_db';

-- Surveiller uniquement production_db
UPDATE performance_schema.setup_objects
SET ENABLED = 'YES'
WHERE OBJECT_SCHEMA = 'production_db';

-- V√©rifier
SELECT OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, ENABLED
FROM performance_schema.setup_objects;
```

### Mesurer l'overhead de PERFORMANCE_SCHEMA

```sql
-- Comparer les performances avec/sans PERFORMANCE_SCHEMA
-- (n√©cessite des tests avec PERFORMANCE_SCHEMA ON puis OFF)

-- Overhead typique : 1-5% selon la configuration
-- Avec uniquement statements : ~1-2%
-- Avec tous les instruments : ~5-10%
```

---

## Cas d'usage pratiques

### Cas 1 : Identifier une requ√™te lente sp√©cifique

```sql
-- 1. Trouver la requ√™te dans l'historique actuel
SELECT
    THREAD_ID,
    SQL_TEXT,
    ROUND(TIMER_WAIT / 1000000000000, 3) AS duration_sec,
    LOCK_TIME / 1000000000000 AS lock_time_sec,
    ROWS_EXAMINED,
    ROWS_SENT,
    CREATED_TMP_TABLES,
    NO_INDEX_USED,
    NO_GOOD_INDEX_USED
FROM performance_schema.events_statements_history_long
WHERE SQL_TEXT LIKE '%FROM commandes%'
  AND TIMER_WAIT > 1000000000000  -- Plus de 1 seconde
ORDER BY TIMER_WAIT DESC
LIMIT 10;

-- 2. Trouver le digest pour voir l'historique complet
SELECT
    SCHEMA_NAME,
    DIGEST_TEXT,
    COUNT_STAR,
    ROUND(AVG_TIMER_WAIT / 1000000000000, 3) AS avg_sec,
    ROUND(MAX_TIMER_WAIT / 1000000000000, 3) AS max_sec
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE '%FROM `commandes`%'
LIMIT 5;

-- 3. Analyser avec EXPLAIN
-- Copier le DIGEST_TEXT et le faire passer dans EXPLAIN
```

### Cas 2 : Diagnostiquer un probl√®me de verrous

```sql
-- 1. Identifier les tables avec contention
SELECT
    OBJECT_SCHEMA,
    OBJECT_NAME,
    COUNT_STAR,
    ROUND(SUM_TIMER_WAIT / 1000000000000, 3) AS wait_time_sec
FROM performance_schema.table_lock_waits_summary_by_table
WHERE OBJECT_SCHEMA = 'production_db'
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 10;

-- 2. Voir les verrous actifs maintenant
SELECT
    ml.OBJECT_SCHEMA,
    ml.OBJECT_NAME,
    ml.LOCK_TYPE,
    ml.LOCK_STATUS,
    ml.OWNER_THREAD_ID,
    t.PROCESSLIST_ID,
    t.PROCESSLIST_USER,
    LEFT(esc.SQL_TEXT, 100) AS query_holding_lock
FROM performance_schema.metadata_locks ml
INNER JOIN performance_schema.threads t
    ON ml.OWNER_THREAD_ID = t.THREAD_ID
LEFT JOIN performance_schema.events_statements_current esc
    ON t.THREAD_ID = esc.THREAD_ID
WHERE ml.OBJECT_SCHEMA = 'production_db'
  AND ml.LOCK_STATUS = 'GRANTED'
ORDER BY ml.OBJECT_NAME;

-- 3. Si besoin, tuer la connexion qui d√©tient le verrou
-- KILL <PROCESSLIST_ID>;
```

### Cas 3 : Audit de performance apr√®s d√©ploiement

```sql
-- 1. R√©initialiser les stats avant d√©ploiement
TRUNCATE TABLE performance_schema.events_statements_summary_by_digest;

-- 2. Laisser tourner pendant 1 heure

-- 3. Comparer avec les stats d'avant (si sauvegard√©es)
SELECT
    'NEW' AS version,
    SCHEMA_NAME,
    LEFT(DIGEST_TEXT, 80) AS requete,
    COUNT_STAR AS nb_exec,
    ROUND(AVG_TIMER_WAIT / 1000000000000, 3) AS avg_sec
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = 'production_db'
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 20;

-- Comparer les temps moyens : am√©lioration ou r√©gression ?
```

---

## ‚úÖ Points cl√©s √† retenir

- **PERFORMANCE_SCHEMA** collecte des m√©triques de performance en temps r√©el
- Impact typique : **1-5%** sur les performances (configurable)
- **events_statements_summary_by_digest** : La table la plus importante pour l'analyse des requ√™tes
- **table_io_waits_summary_by_table** : Identifier les tables avec le plus d'I/O
- **table_lock_waits_summary_by_table** : D√©tecter les contentions de verrous
- **threads** : Surveiller les connexions actives et requ√™tes en cours
- **Optimisation** : D√©sactiver les instruments inutilis√©s pour r√©duire l'overhead
- **R√©initialisation** : TRUNCATE sur les tables summary pour repartir √† z√©ro
- Toujours filtrer par **SCHEMA_NAME** pour am√©liorer les performances des requ√™tes
- Combiner avec **INFORMATION_SCHEMA** pour des analyses compl√®tes
- Cr√©er des **vues de monitoring** pour simplifier la surveillance quotidienne

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB
- [üìñ PERFORMANCE_SCHEMA](https://mariadb.com/kb/en/performance-schema/) - Documentation compl√®te
- [üìñ Performance Schema Tables](https://mariadb.com/kb/en/performance-schema-tables/) - Liste des tables
- [üìñ Performance Schema Configuration](https://mariadb.com/kb/en/performance-schema-system-variables/) - Variables de configuration

### Outils et scripts
- **pt-query-digest** (Percona Toolkit) - Analyse PERFORMANCE_SCHEMA
- **PMM (Percona Monitoring and Management)** - Dashboard bas√© sur PERFORMANCE_SCHEMA
- **sys schema** (MySQL 5.7+) - Vues simplifi√©es sur PERFORMANCE_SCHEMA

---

## ‚û°Ô∏è Section suivante

**[9.7.3 mysql (system tables)](./07.3-mysql-system-tables.md)** : Exploration des tables syst√®me mysql pour la gestion des utilisateurs, privil√®ges, configuration des plugins, et administration syst√®me avanc√©e.

---


‚è≠Ô∏è [mysql system tables](/09-vues-et-donnees-virtuelles/07.3-mysql-system-tables.md)
