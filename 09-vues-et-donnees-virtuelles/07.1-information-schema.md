üîù Retour au [Sommaire](/SOMMAIRE.md)

# 9.7.1 INFORMATION_SCHEMA

> **Niveau** : Interm√©diaire
> **Dur√©e estim√©e** : 2 heures
> **Pr√©requis** : Section 9.7 (Introduction aux vues syst√®me), compr√©hension des m√©tadonn√©es

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :

- Naviguer efficacement dans les vues INFORMATION_SCHEMA
- Extraire des m√©tadonn√©es sur les bases de donn√©es, tables, colonnes et index
- Auditer les privil√®ges et la s√©curit√© via INFORMATION_SCHEMA
- Analyser la structure du sch√©ma pour l'optimisation
- √âcrire des requ√™tes d'administration complexes sur les m√©tadonn√©es
- Automatiser des t√¢ches d'administration bas√©es sur INFORMATION_SCHEMA
- Optimiser les requ√™tes sur INFORMATION_SCHEMA pour minimiser l'impact
- G√©n√©rer des rapports et scripts √† partir des m√©tadonn√©es

---

## Introduction

### Qu'est-ce qu'INFORMATION_SCHEMA ?

**INFORMATION_SCHEMA** est une base de donn√©es virtuelle standardis√©e (norme SQL:2003) qui fournit un acc√®s en lecture seule aux **m√©tadonn√©es** de toutes les bases de donn√©es du serveur MariaDB. Elle contient plus de 60 vues qui exposent les informations sur :

- Les bases de donn√©es (SCHEMATA)
- Les tables et colonnes (TABLES, COLUMNS)
- Les index et statistiques (STATISTICS)
- Les contraintes (KEY_COLUMN_USAGE, TABLE_CONSTRAINTS)
- Les privil√®ges (USER_PRIVILEGES, TABLE_PRIVILEGES, etc.)
- Les vues, proc√©dures, fonctions, triggers (VIEWS, ROUTINES, TRIGGERS)
- Et bien plus...

```sql
-- INFORMATION_SCHEMA est une base comme les autres
USE INFORMATION_SCHEMA;

-- Mais c'est une base virtuelle : pas de fichiers sur disque
-- Les donn√©es sont g√©n√©r√©es dynamiquement √† la demande

-- Lister toutes les vues disponibles
SHOW TABLES;
-- Plus de 60 vues !
```

### Pourquoi utiliser INFORMATION_SCHEMA ?

**Au lieu de** :
- M√©moriser toutes les tables et colonnes
- Ex√©cuter SHOW TABLES, DESCRIBE, SHOW CREATE TABLE manuellement
- V√©rifier les privil√®ges un par un

**Utilisez INFORMATION_SCHEMA pour** :
- Interroger les m√©tadonn√©es avec SQL standard
- Automatiser les audits et rapports
- G√©n√©rer des scripts de migration
- Surveiller l'√©volution du sch√©ma
- D√©tecter les probl√®mes de structure

---

## Organisation d'INFORMATION_SCHEMA

### Cat√©gories de vues

Les vues INFORMATION_SCHEMA sont organis√©es par th√©matique :

| Cat√©gorie | Vues principales | Usage |
|-----------|-----------------|-------|
| **Bases et tables** | SCHEMATA, TABLES, TABLESPACES | Structure g√©n√©rale |
| **Colonnes** | COLUMNS | D√©finition des colonnes |
| **Index** | STATISTICS | Informations sur les index |
| **Contraintes** | KEY_COLUMN_USAGE, TABLE_CONSTRAINTS, REFERENTIAL_CONSTRAINTS | Cl√©s et relations |
| **Privil√®ges** | USER_PRIVILEGES, SCHEMA_PRIVILEGES, TABLE_PRIVILEGES, COLUMN_PRIVILEGES | S√©curit√© |
| **Objets programmables** | VIEWS, ROUTINES, TRIGGERS, EVENTS | Code SQL stock√© |
| **Partitions** | PARTITIONS | Tables partitionn√©es |
| **Divers** | PROCESSLIST, CHARACTER_SETS, COLLATIONS, ENGINES | Configuration et √©tat |

---

## M√©tadonn√©es de bases et tables

### SCHEMATA : Liste des bases de donn√©es

```sql
-- Structure de SCHEMATA
DESC INFORMATION_SCHEMA.SCHEMATA;
-- +----------------------------+
-- | Field                      |
-- +----------------------------+
-- | CATALOG_NAME               |
-- | SCHEMA_NAME                | ‚Üê Nom de la base
-- | DEFAULT_CHARACTER_SET_NAME | ‚Üê Charset par d√©faut
-- | DEFAULT_COLLATION_NAME     | ‚Üê Collation par d√©faut
-- | SQL_PATH                   |
-- | DEFAULT_ENCRYPTION         |
-- +----------------------------+

-- Exemple : Lister toutes les bases utilisateurs
SELECT
    SCHEMA_NAME AS base,
    DEFAULT_CHARACTER_SET_NAME AS charset,
    DEFAULT_COLLATION_NAME AS collation
FROM INFORMATION_SCHEMA.SCHEMATA
WHERE SCHEMA_NAME NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')
ORDER BY SCHEMA_NAME;
```

### TABLES : Informations sur les tables

```sql
-- Colonnes importantes de TABLES
SELECT
    TABLE_SCHEMA,          -- Base de donn√©es
    TABLE_NAME,            -- Nom de la table
    TABLE_TYPE,            -- 'BASE TABLE' ou 'VIEW'
    ENGINE,                -- InnoDB, MyISAM, Aria, etc.
    VERSION,               -- Version de la structure
    ROW_FORMAT,            -- Dynamic, Compact, Compressed, etc.
    TABLE_ROWS,            -- Nombre de lignes (estimation)
    AVG_ROW_LENGTH,        -- Longueur moyenne d'une ligne
    DATA_LENGTH,           -- Taille des donn√©es en octets
    MAX_DATA_LENGTH,       -- Taille max th√©orique
    INDEX_LENGTH,          -- Taille des index en octets
    DATA_FREE,             -- Espace libre (fragmentation)
    AUTO_INCREMENT,        -- Prochaine valeur AUTO_INCREMENT
    CREATE_TIME,           -- Date de cr√©ation
    UPDATE_TIME,           -- Derni√®re modification
    CHECK_TIME,            -- Dernier CHECK TABLE
    TABLE_COLLATION,       -- Collation de la table
    CHECKSUM,              -- Checksum si activ√©
    CREATE_OPTIONS,        -- Options CREATE TABLE
    TABLE_COMMENT          -- Commentaire
FROM INFORMATION_SCHEMA.TABLES
LIMIT 1\G
```

**Requ√™te pratique 1 : Tables les plus volumineuses**

```sql
SELECT
    TABLE_NAME,
    TABLE_ROWS AS nb_lignes,
    ROUND(DATA_LENGTH / 1024 / 1024, 2) AS data_mb,
    ROUND(INDEX_LENGTH / 1024 / 1024, 2) AS index_mb,
    ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) AS total_mb,
    ROUND(DATA_FREE / 1024 / 1024, 2) AS fragmentation_mb,
    ENGINE
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'production_db'
  AND TABLE_TYPE = 'BASE TABLE'
ORDER BY (DATA_LENGTH + INDEX_LENGTH) DESC
LIMIT 20;
```

**Requ√™te pratique 2 : Espace disque par moteur de stockage**

```sql
SELECT
    ENGINE,
    COUNT(*) AS nb_tables,
    SUM(TABLE_ROWS) AS total_rows,
    ROUND(SUM(DATA_LENGTH) / 1024 / 1024, 2) AS total_data_mb,
    ROUND(SUM(INDEX_LENGTH) / 1024 / 1024, 2) AS total_index_mb,
    ROUND(SUM(DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) AS total_mb
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'production_db'
  AND TABLE_TYPE = 'BASE TABLE'
  AND ENGINE IS NOT NULL
GROUP BY ENGINE
ORDER BY total_mb DESC;
```

**Requ√™te pratique 3 : Tables non utilis√©es r√©cemment**

```sql
SELECT
    TABLE_NAME,
    CREATE_TIME,
    UPDATE_TIME,
    DATEDIFF(NOW(), UPDATE_TIME) AS jours_depuis_update,
    ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) AS total_mb
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'production_db'
  AND TABLE_TYPE = 'BASE TABLE'
  AND UPDATE_TIME < DATE_SUB(NOW(), INTERVAL 6 MONTH)
ORDER BY UPDATE_TIME ASC;

-- Tables potentiellement archivables
```

---

## Colonnes et types de donn√©es

### COLUMNS : D√©tails des colonnes

```sql
-- Colonnes importantes de COLUMNS
SELECT
    TABLE_SCHEMA,
    TABLE_NAME,
    COLUMN_NAME,           -- Nom de la colonne
    ORDINAL_POSITION,      -- Position dans la table (1, 2, 3...)
    COLUMN_DEFAULT,        -- Valeur par d√©faut
    IS_NULLABLE,           -- 'YES' ou 'NO'
    DATA_TYPE,             -- int, varchar, text, etc.
    CHARACTER_MAXIMUM_LENGTH,  -- Longueur max pour CHAR/VARCHAR
    CHARACTER_OCTET_LENGTH,    -- Longueur en octets
    NUMERIC_PRECISION,     -- Pr√©cision pour types num√©riques
    NUMERIC_SCALE,         -- √âchelle pour DECIMAL
    DATETIME_PRECISION,    -- Pr√©cision pour DATETIME
    CHARACTER_SET_NAME,    -- Charset de la colonne
    COLLATION_NAME,        -- Collation de la colonne
    COLUMN_TYPE,           -- Type complet : varchar(255), int(11), etc.
    COLUMN_KEY,            -- 'PRI', 'UNI', 'MUL' ou ''
    EXTRA,                 -- 'auto_increment', 'on update CURRENT_TIMESTAMP', etc.
    PRIVILEGES,            -- Privil√®ges sur cette colonne
    COLUMN_COMMENT         -- Commentaire
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_SCHEMA = 'production_db'
  AND TABLE_NAME = 'clients'
ORDER BY ORDINAL_POSITION;
```

**Requ√™te pratique 1 : Trouver toutes les colonnes d'un type sp√©cifique**

```sql
-- Exemple : Toutes les colonnes TEXT dans la base
SELECT
    TABLE_NAME,
    COLUMN_NAME,
    COLUMN_TYPE,
    IS_NULLABLE,
    CHARACTER_MAXIMUM_LENGTH
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_SCHEMA = 'production_db'
  AND DATA_TYPE IN ('text', 'mediumtext', 'longtext')
ORDER BY TABLE_NAME, ORDINAL_POSITION;
```

**Requ√™te pratique 2 : Colonnes avec AUTO_INCREMENT**

```sql
SELECT
    TABLE_NAME,
    COLUMN_NAME,
    DATA_TYPE,
    COLUMN_TYPE
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_SCHEMA = 'production_db'
  AND EXTRA LIKE '%auto_increment%'
ORDER BY TABLE_NAME;
```

**Requ√™te pratique 3 : Colonnes nullable qui devraient √™tre NOT NULL**

```sql
-- Colonnes terminant par _id qui sont nullable (potentiel probl√®me)
SELECT
    TABLE_NAME,
    COLUMN_NAME,
    DATA_TYPE,
    IS_NULLABLE,
    COLUMN_DEFAULT
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_SCHEMA = 'production_db'
  AND COLUMN_NAME LIKE '%_id'
  AND IS_NULLABLE = 'YES'
  AND COLUMN_DEFAULT IS NULL
ORDER BY TABLE_NAME, COLUMN_NAME;

-- Ces colonnes sont probablement des foreign keys qui devraient √™tre NOT NULL
```

**Requ√™te pratique 4 : Diff√©rences de charset/collation entre colonnes**

```sql
-- Trouver les colonnes avec des charsets diff√©rents du d√©faut
SELECT
    t.TABLE_NAME,
    c.COLUMN_NAME,
    c.CHARACTER_SET_NAME AS col_charset,
    c.COLLATION_NAME AS col_collation,
    t.TABLE_COLLATION AS table_collation
FROM INFORMATION_SCHEMA.COLUMNS c
INNER JOIN INFORMATION_SCHEMA.TABLES t
    ON c.TABLE_SCHEMA = t.TABLE_SCHEMA
    AND c.TABLE_NAME = t.TABLE_NAME
WHERE c.TABLE_SCHEMA = 'production_db'
  AND c.CHARACTER_SET_NAME IS NOT NULL
  AND c.COLLATION_NAME != t.TABLE_COLLATION
ORDER BY t.TABLE_NAME, c.ORDINAL_POSITION;

-- Peut causer des probl√®mes de performance sur les jointures
```

---

## Index et statistiques

### STATISTICS : Informations sur les index

```sql
-- Colonnes importantes de STATISTICS
SELECT
    TABLE_SCHEMA,
    TABLE_NAME,
    NON_UNIQUE,            -- 0 = unique, 1 = non-unique
    INDEX_SCHEMA,
    INDEX_NAME,            -- Nom de l'index
    SEQ_IN_INDEX,          -- Position dans l'index composite (1, 2, 3...)
    COLUMN_NAME,           -- Colonne index√©e
    COLLATION,             -- 'A' = ascendant, 'D' = descendant, NULL
    CARDINALITY,           -- Nombre de valeurs uniques (estimation)
    SUB_PART,              -- Longueur de l'index partiel
    PACKED,                -- Si l'index est compress√©
    NULLABLE,              -- Si la colonne peut contenir NULL
    INDEX_TYPE,            -- BTREE, HASH, FULLTEXT, SPATIAL
    COMMENT,
    INDEX_COMMENT
FROM INFORMATION_SCHEMA.STATISTICS
WHERE TABLE_SCHEMA = 'production_db'
  AND TABLE_NAME = 'produits'
ORDER BY INDEX_NAME, SEQ_IN_INDEX;
```

**Requ√™te pratique 1 : Index composites (multi-colonnes)**

```sql
-- Lister les index composites avec leur ordre de colonnes
SELECT
    TABLE_NAME,
    INDEX_NAME,
    GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) AS colonnes_indexees,
    COUNT(*) AS nb_colonnes,
    INDEX_TYPE
FROM INFORMATION_SCHEMA.STATISTICS
WHERE TABLE_SCHEMA = 'production_db'
  AND INDEX_NAME != 'PRIMARY'
GROUP BY TABLE_NAME, INDEX_NAME
HAVING COUNT(*) > 1
ORDER BY TABLE_NAME, INDEX_NAME;
```

**Requ√™te pratique 2 : Index redondants ou dupliqu√©s**

```sql
-- Trouver les index potentiellement redondants
-- (m√™me colonnes, m√™me ordre)
SELECT
    s1.TABLE_NAME,
    s1.INDEX_NAME AS index1,
    s2.INDEX_NAME AS index2,
    GROUP_CONCAT(s1.COLUMN_NAME ORDER BY s1.SEQ_IN_INDEX) AS colonnes
FROM INFORMATION_SCHEMA.STATISTICS s1
INNER JOIN INFORMATION_SCHEMA.STATISTICS s2
    ON s1.TABLE_SCHEMA = s2.TABLE_SCHEMA
    AND s1.TABLE_NAME = s2.TABLE_NAME
    AND s1.INDEX_NAME < s2.INDEX_NAME
    AND s1.COLUMN_NAME = s2.COLUMN_NAME
    AND s1.SEQ_IN_INDEX = s2.SEQ_IN_INDEX
WHERE s1.TABLE_SCHEMA = 'production_db'
GROUP BY s1.TABLE_NAME, s1.INDEX_NAME, s2.INDEX_NAME
HAVING COUNT(*) = (
    SELECT COUNT(*) FROM INFORMATION_SCHEMA.STATISTICS
    WHERE TABLE_SCHEMA = s1.TABLE_SCHEMA
      AND TABLE_NAME = s1.TABLE_NAME
      AND INDEX_NAME = s1.INDEX_NAME
);

-- Index redondants √† supprimer
```

**Requ√™te pratique 3 : Tables sans index (hors PRIMARY)**

```sql
SELECT
    t.TABLE_NAME,
    t.TABLE_ROWS,
    ROUND((t.DATA_LENGTH + t.INDEX_LENGTH) / 1024 / 1024, 2) AS total_mb
FROM INFORMATION_SCHEMA.TABLES t
LEFT JOIN INFORMATION_SCHEMA.STATISTICS s
    ON t.TABLE_SCHEMA = s.TABLE_SCHEMA
    AND t.TABLE_NAME = s.TABLE_NAME
    AND s.INDEX_NAME != 'PRIMARY'
WHERE t.TABLE_SCHEMA = 'production_db'
  AND t.TABLE_TYPE = 'BASE TABLE'
  AND s.INDEX_NAME IS NULL
  AND t.TABLE_ROWS > 1000  -- Tables significatives seulement
ORDER BY t.TABLE_ROWS DESC;

-- Tables qui pourraient b√©n√©ficier d'index suppl√©mentaires
```

**Requ√™te pratique 4 : Cardinalit√© des index (efficacit√©)**

```sql
-- V√©rifier la s√©lectivit√© des index
SELECT
    TABLE_NAME,
    INDEX_NAME,
    COLUMN_NAME,
    CARDINALITY,
    (SELECT TABLE_ROWS FROM INFORMATION_SCHEMA.TABLES
     WHERE TABLE_SCHEMA = s.TABLE_SCHEMA AND TABLE_NAME = s.TABLE_NAME) AS table_rows,
    ROUND(CARDINALITY / (SELECT TABLE_ROWS FROM INFORMATION_SCHEMA.TABLES
                         WHERE TABLE_SCHEMA = s.TABLE_SCHEMA AND TABLE_NAME = s.TABLE_NAME) * 100, 2) AS selectivity_pct
FROM INFORMATION_SCHEMA.STATISTICS s
WHERE TABLE_SCHEMA = 'production_db'
  AND SEQ_IN_INDEX = 1  -- Premi√®re colonne de l'index
  AND INDEX_NAME != 'PRIMARY'
  AND CARDINALITY IS NOT NULL
ORDER BY selectivity_pct ASC;

-- S√©lectivit√© < 1% = index peu efficace
```

---

## Contraintes et relations

### KEY_COLUMN_USAGE : Colonnes dans les contraintes

```sql
-- Colonnes importantes de KEY_COLUMN_USAGE
SELECT
    CONSTRAINT_CATALOG,
    CONSTRAINT_SCHEMA,
    CONSTRAINT_NAME,           -- Nom de la contrainte
    TABLE_SCHEMA,
    TABLE_NAME,
    COLUMN_NAME,               -- Colonne concern√©e
    ORDINAL_POSITION,          -- Position dans la contrainte composite
    POSITION_IN_UNIQUE_CONSTRAINT,
    REFERENCED_TABLE_SCHEMA,   -- Pour les FK : sch√©ma de la table r√©f√©renc√©e
    REFERENCED_TABLE_NAME,     -- Pour les FK : table r√©f√©renc√©e
    REFERENCED_COLUMN_NAME     -- Pour les FK : colonne r√©f√©renc√©e
FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
WHERE TABLE_SCHEMA = 'production_db'
  AND TABLE_NAME = 'commandes'
ORDER BY CONSTRAINT_NAME, ORDINAL_POSITION;
```

**Requ√™te pratique 1 : Toutes les foreign keys d'une base**

```sql
SELECT
    kcu.TABLE_NAME AS table_source,
    kcu.COLUMN_NAME AS colonne_source,
    kcu.CONSTRAINT_NAME AS fk_name,
    kcu.REFERENCED_TABLE_NAME AS table_cible,
    kcu.REFERENCED_COLUMN_NAME AS colonne_cible,
    rc.UPDATE_RULE,
    rc.DELETE_RULE
FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
INNER JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS rc
    ON kcu.CONSTRAINT_SCHEMA = rc.CONSTRAINT_SCHEMA
    AND kcu.CONSTRAINT_NAME = rc.CONSTRAINT_NAME
WHERE kcu.TABLE_SCHEMA = 'production_db'
  AND kcu.REFERENCED_TABLE_NAME IS NOT NULL
ORDER BY kcu.TABLE_NAME, kcu.CONSTRAINT_NAME;
```

**Requ√™te pratique 2 : Foreign keys orphelines (table cible supprim√©e)**

```sql
SELECT
    kcu.TABLE_NAME,
    kcu.COLUMN_NAME,
    kcu.CONSTRAINT_NAME,
    kcu.REFERENCED_TABLE_NAME AS table_cible_manquante
FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
LEFT JOIN INFORMATION_SCHEMA.TABLES t
    ON kcu.REFERENCED_TABLE_SCHEMA = t.TABLE_SCHEMA
    AND kcu.REFERENCED_TABLE_NAME = t.TABLE_NAME
WHERE kcu.TABLE_SCHEMA = 'production_db'
  AND kcu.REFERENCED_TABLE_NAME IS NOT NULL
  AND t.TABLE_NAME IS NULL;

-- Foreign keys qui pointent vers des tables inexistantes
```

**Requ√™te pratique 3 : Relations entre tables (graphe)**

```sql
-- G√©n√©rer un graphe des relations pour documentation
SELECT
    CONCAT(kcu.TABLE_NAME, '.', kcu.COLUMN_NAME) AS source,
    CONCAT(kcu.REFERENCED_TABLE_NAME, '.', kcu.REFERENCED_COLUMN_NAME) AS target,
    kcu.CONSTRAINT_NAME AS relation
FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
WHERE kcu.TABLE_SCHEMA = 'production_db'
  AND kcu.REFERENCED_TABLE_NAME IS NOT NULL
ORDER BY kcu.TABLE_NAME;

-- Peut √™tre export√© vers un outil de visualisation (Graphviz, etc.)
```

### TABLE_CONSTRAINTS : Toutes les contraintes

```sql
-- Types de contraintes
SELECT
    CONSTRAINT_SCHEMA,
    TABLE_NAME,
    CONSTRAINT_NAME,
    CONSTRAINT_TYPE    -- 'PRIMARY KEY', 'FOREIGN KEY', 'UNIQUE', 'CHECK'
FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS
WHERE CONSTRAINT_SCHEMA = 'production_db'
ORDER BY TABLE_NAME, CONSTRAINT_TYPE;
```

**Requ√™te pratique : R√©sum√© des contraintes par table**

```sql
SELECT
    TABLE_NAME,
    SUM(CASE WHEN CONSTRAINT_TYPE = 'PRIMARY KEY' THEN 1 ELSE 0 END) AS nb_pk,
    SUM(CASE WHEN CONSTRAINT_TYPE = 'FOREIGN KEY' THEN 1 ELSE 0 END) AS nb_fk,
    SUM(CASE WHEN CONSTRAINT_TYPE = 'UNIQUE' THEN 1 ELSE 0 END) AS nb_unique,
    SUM(CASE WHEN CONSTRAINT_TYPE = 'CHECK' THEN 1 ELSE 0 END) AS nb_check
FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS
WHERE CONSTRAINT_SCHEMA = 'production_db'
GROUP BY TABLE_NAME
ORDER BY nb_fk DESC, TABLE_NAME;
```

---

## Privil√®ges et s√©curit√©

### USER_PRIVILEGES : Privil√®ges globaux

```sql
SELECT
    GRANTEE,           -- 'user'@'host'
    PRIVILEGE_TYPE,    -- SELECT, INSERT, UPDATE, etc.
    IS_GRANTABLE       -- YES ou NO
FROM INFORMATION_SCHEMA.USER_PRIVILEGES
WHERE GRANTEE LIKE '%app_user%'
ORDER BY PRIVILEGE_TYPE;
```

### SCHEMA_PRIVILEGES : Privil√®ges au niveau base

```sql
SELECT
    GRANTEE,
    TABLE_SCHEMA,
    PRIVILEGE_TYPE,
    IS_GRANTABLE
FROM INFORMATION_SCHEMA.SCHEMA_PRIVILEGES
WHERE TABLE_SCHEMA = 'production_db'
ORDER BY GRANTEE, PRIVILEGE_TYPE;
```

### TABLE_PRIVILEGES : Privil√®ges au niveau table

```sql
SELECT
    GRANTEE,
    TABLE_SCHEMA,
    TABLE_NAME,
    PRIVILEGE_TYPE,
    IS_GRANTABLE
FROM INFORMATION_SCHEMA.TABLE_PRIVILEGES
WHERE TABLE_SCHEMA = 'production_db'
ORDER BY TABLE_NAME, GRANTEE;
```

**Requ√™te pratique : Audit complet des privil√®ges d'un utilisateur**

```sql
-- Privil√®ges globaux
SELECT
    'GLOBAL' AS niveau,
    '*.*' AS objet,
    PRIVILEGE_TYPE AS privilege,
    IS_GRANTABLE AS grantable
FROM INFORMATION_SCHEMA.USER_PRIVILEGES
WHERE GRANTEE = "'app_user'@'%'"

UNION ALL

-- Privil√®ges par base
SELECT
    'DATABASE' AS niveau,
    CONCAT(TABLE_SCHEMA, '.*') AS objet,
    PRIVILEGE_TYPE,
    IS_GRANTABLE
FROM INFORMATION_SCHEMA.SCHEMA_PRIVILEGES
WHERE GRANTEE = "'app_user'@'%'"

UNION ALL

-- Privil√®ges par table
SELECT
    'TABLE' AS niveau,
    CONCAT(TABLE_SCHEMA, '.', TABLE_NAME) AS objet,
    PRIVILEGE_TYPE,
    IS_GRANTABLE
FROM INFORMATION_SCHEMA.TABLE_PRIVILEGES
WHERE GRANTEE = "'app_user'@'%'"

UNION ALL

-- Privil√®ges par colonne
SELECT
    'COLUMN' AS niveau,
    CONCAT(TABLE_SCHEMA, '.', TABLE_NAME, '.', COLUMN_NAME) AS objet,
    PRIVILEGE_TYPE,
    IS_GRANTABLE
FROM INFORMATION_SCHEMA.COLUMN_PRIVILEGES
WHERE GRANTEE = "'app_user'@'%'"

ORDER BY niveau, objet, privilege;
```

---

## Vues et objets programmables

### VIEWS : M√©tadonn√©es des vues

```sql
SELECT
    TABLE_SCHEMA,
    TABLE_NAME,
    VIEW_DEFINITION,       -- Requ√™te SQL de la vue
    CHECK_OPTION,          -- NONE, LOCAL, CASCADED
    IS_UPDATABLE,          -- YES ou NO
    DEFINER,               -- Cr√©ateur de la vue
    SECURITY_TYPE,         -- DEFINER ou INVOKER
    CHARACTER_SET_CLIENT,
    COLLATION_CONNECTION,
    ALGORITHM              -- MERGE, TEMPTABLE, UNDEFINED
FROM INFORMATION_SCHEMA.VIEWS
WHERE TABLE_SCHEMA = 'production_db'
ORDER BY TABLE_NAME;
```

**Requ√™te pratique 1 : Vues qui utilisent TEMPTABLE**

```sql
SELECT
    TABLE_NAME,
    ALGORITHM,
    LENGTH(VIEW_DEFINITION) AS definition_length
FROM INFORMATION_SCHEMA.VIEWS
WHERE TABLE_SCHEMA = 'production_db'
  AND ALGORITHM = 'TEMPTABLE'
ORDER BY TABLE_NAME;

-- Ces vues peuvent avoir des probl√®mes de performance
```

**Requ√™te pratique 2 : Vues updatable**

```sql
SELECT
    TABLE_NAME,
    IS_UPDATABLE,
    CHECK_OPTION,
    SECURITY_TYPE
FROM INFORMATION_SCHEMA.VIEWS
WHERE TABLE_SCHEMA = 'production_db'
  AND IS_UPDATABLE = 'YES'
ORDER BY TABLE_NAME;
```

### ROUTINES : Proc√©dures et fonctions

```sql
SELECT
    ROUTINE_SCHEMA,
    ROUTINE_NAME,
    ROUTINE_TYPE,          -- FUNCTION ou PROCEDURE
    DTD_IDENTIFIER,        -- Type de retour (fonctions)
    ROUTINE_BODY,          -- 'SQL'
    ROUTINE_DEFINITION,    -- Code de la routine (peut √™tre tronqu√©)
    IS_DETERMINISTIC,      -- YES ou NO
    SQL_DATA_ACCESS,       -- CONTAINS SQL, NO SQL, READS SQL DATA, MODIFIES SQL DATA
    SECURITY_TYPE,         -- DEFINER ou INVOKER
    CREATED,
    LAST_ALTERED,
    SQL_MODE,
    ROUTINE_COMMENT,
    DEFINER
FROM INFORMATION_SCHEMA.ROUTINES
WHERE ROUTINE_SCHEMA = 'production_db'
ORDER BY ROUTINE_TYPE, ROUTINE_NAME;
```

**Requ√™te pratique : Proc√©dures modifiant des donn√©es**

```sql
SELECT
    ROUTINE_NAME,
    ROUTINE_TYPE,
    SQL_DATA_ACCESS,
    IS_DETERMINISTIC,
    SECURITY_TYPE
FROM INFORMATION_SCHEMA.ROUTINES
WHERE ROUTINE_SCHEMA = 'production_db'
  AND SQL_DATA_ACCESS = 'MODIFIES SQL DATA'
ORDER BY ROUTINE_NAME;
```

### TRIGGERS : D√©clencheurs

```sql
SELECT
    TRIGGER_SCHEMA,
    TRIGGER_NAME,
    EVENT_MANIPULATION,    -- INSERT, UPDATE, DELETE
    EVENT_OBJECT_SCHEMA,
    EVENT_OBJECT_TABLE,    -- Table sur laquelle le trigger s'applique
    ACTION_STATEMENT,      -- Code du trigger
    ACTION_ORIENTATION,    -- 'ROW'
    ACTION_TIMING,         -- BEFORE ou AFTER
    CREATED,
    SQL_MODE,
    DEFINER,
    CHARACTER_SET_CLIENT,
    COLLATION_CONNECTION
FROM INFORMATION_SCHEMA.TRIGGERS
WHERE TRIGGER_SCHEMA = 'production_db'
ORDER BY EVENT_OBJECT_TABLE, ACTION_TIMING, EVENT_MANIPULATION;
```

**Requ√™te pratique : R√©sum√© des triggers par table**

```sql
SELECT
    EVENT_OBJECT_TABLE AS table_name,
    COUNT(*) AS nb_triggers,
    GROUP_CONCAT(CONCAT(ACTION_TIMING, ' ', EVENT_MANIPULATION) ORDER BY ACTION_TIMING, EVENT_MANIPULATION) AS triggers
FROM INFORMATION_SCHEMA.TRIGGERS
WHERE TRIGGER_SCHEMA = 'production_db'
GROUP BY EVENT_OBJECT_TABLE
ORDER BY nb_triggers DESC, table_name;
```

---

## Partitions

### PARTITIONS : Tables partitionn√©es

```sql
SELECT
    TABLE_SCHEMA,
    TABLE_NAME,
    PARTITION_NAME,
    PARTITION_ORDINAL_POSITION,
    PARTITION_METHOD,          -- RANGE, LIST, HASH, KEY
    PARTITION_EXPRESSION,      -- Expression de partitionnement
    PARTITION_DESCRIPTION,     -- Valeurs pour RANGE/LIST
    TABLE_ROWS,
    AVG_ROW_LENGTH,
    DATA_LENGTH,
    MAX_DATA_LENGTH,
    INDEX_LENGTH,
    DATA_FREE,
    CREATE_TIME,
    UPDATE_TIME,
    CHECK_TIME
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_SCHEMA = 'production_db'
  AND PARTITION_NAME IS NOT NULL
ORDER BY TABLE_NAME, PARTITION_ORDINAL_POSITION;
```

**Requ√™te pratique : Analyser la distribution des donn√©es par partition**

```sql
SELECT
    TABLE_NAME,
    PARTITION_METHOD,
    COUNT(*) AS nb_partitions,
    SUM(TABLE_ROWS) AS total_rows,
    MIN(TABLE_ROWS) AS min_rows_partition,
    MAX(TABLE_ROWS) AS max_rows_partition,
    AVG(TABLE_ROWS) AS avg_rows_partition,
    ROUND(SUM(DATA_LENGTH) / 1024 / 1024, 2) AS total_data_mb
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_SCHEMA = 'production_db'
  AND PARTITION_NAME IS NOT NULL
GROUP BY TABLE_NAME, PARTITION_METHOD
ORDER BY total_rows DESC;

-- V√©rifier l'√©quilibre des partitions
```

---

## Autres vues utiles

### PROCESSLIST : Connexions et requ√™tes actives

```sql
SELECT
    ID,
    USER,
    HOST,
    DB,
    COMMAND,       -- Query, Sleep, Connect, etc.
    TIME,          -- Dur√©e en secondes
    STATE,         -- √âtat de la requ√™te
    INFO           -- Requ√™te SQL (peut √™tre tronqu√©e)
FROM INFORMATION_SCHEMA.PROCESSLIST
WHERE COMMAND != 'Sleep'
  AND TIME > 10  -- Plus de 10 secondes
ORDER BY TIME DESC;
```

### CHARACTER_SETS et COLLATIONS

```sql
-- Character sets disponibles
SELECT
    CHARACTER_SET_NAME,
    DEFAULT_COLLATE_NAME,
    DESCRIPTION,
    MAXLEN
FROM INFORMATION_SCHEMA.CHARACTER_SETS
ORDER BY CHARACTER_SET_NAME;

-- Collations pour un charset sp√©cifique
SELECT
    COLLATION_NAME,
    CHARACTER_SET_NAME,
    IS_DEFAULT,
    IS_COMPILED,
    SORTLEN
FROM INFORMATION_SCHEMA.COLLATIONS
WHERE CHARACTER_SET_NAME = 'utf8mb4'
ORDER BY COLLATION_NAME;
```

### ENGINES : Moteurs de stockage

```sql
SELECT
    ENGINE,
    SUPPORT,       -- YES, NO, DEFAULT, DISABLED
    COMMENT,
    TRANSACTIONS,  -- YES ou NO
    XA,            -- YES ou NO
    SAVEPOINTS     -- YES ou NO
FROM INFORMATION_SCHEMA.ENGINES
ORDER BY ENGINE;
```

---

## Performance et optimisation

### Bonnes pratiques pour interroger INFORMATION_SCHEMA

#### 1. Toujours filtrer par TABLE_SCHEMA

```sql
-- ‚ùå Tr√®s lent : scanne toutes les bases
SELECT * FROM INFORMATION_SCHEMA.TABLES;

-- ‚úÖ Rapide : filtre sur une base sp√©cifique
SELECT * FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'production_db';
```

#### 2. Filtrer √©galement par TABLE_NAME quand possible

```sql
-- ‚úÖ Encore plus rapide
SELECT * FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_SCHEMA = 'production_db'
  AND TABLE_NAME = 'clients';
```

#### 3. S√©lectionner uniquement les colonnes n√©cessaires

```sql
-- ‚ùå Peut √™tre lent
SELECT * FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_SCHEMA = 'production_db';

-- ‚úÖ Plus rapide
SELECT TABLE_NAME, COLUMN_NAME, DATA_TYPE, IS_NULLABLE
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_SCHEMA = 'production_db';
```

#### 4. √âviter les sous-requ√™tes corr√©l√©es sur INFORMATION_SCHEMA

```sql
-- ‚ùå Tr√®s lent (sous-requ√™te corr√©l√©e)
SELECT
    t.TABLE_NAME,
    (SELECT COUNT(*) FROM INFORMATION_SCHEMA.COLUMNS c
     WHERE c.TABLE_SCHEMA = t.TABLE_SCHEMA AND c.TABLE_NAME = t.TABLE_NAME) AS nb_columns
FROM INFORMATION_SCHEMA.TABLES t
WHERE t.TABLE_SCHEMA = 'production_db';

-- ‚úÖ Plus rapide (jointure)
SELECT
    t.TABLE_NAME,
    COUNT(c.COLUMN_NAME) AS nb_columns
FROM INFORMATION_SCHEMA.TABLES t
LEFT JOIN INFORMATION_SCHEMA.COLUMNS c
    ON t.TABLE_SCHEMA = c.TABLE_SCHEMA
    AND t.TABLE_NAME = c.TABLE_NAME
WHERE t.TABLE_SCHEMA = 'production_db'
GROUP BY t.TABLE_NAME;
```

#### 5. Mettre en cache les r√©sultats fr√©quemment utilis√©s

```sql
-- Cr√©er une table de cache pour les m√©tadonn√©es
CREATE TABLE cache_table_info AS
SELECT
    TABLE_NAME,
    TABLE_ROWS,
    DATA_LENGTH,
    INDEX_LENGTH,
    CREATE_TIME,
    UPDATE_TIME
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'production_db';

-- Rafra√Æchir quotidiennement
CREATE EVENT evt_refresh_table_info
ON SCHEDULE EVERY 1 DAY
DO
    REPLACE INTO cache_table_info
    SELECT ... FROM INFORMATION_SCHEMA.TABLES ...;
```

---

## Cas d'usage avanc√©s

### G√©n√©ration de scripts DDL

#### Script pour recr√©er toutes les vues

```sql
SELECT CONCAT(
    'CREATE OR REPLACE VIEW ',
    TABLE_SCHEMA, '.', TABLE_NAME,
    ' AS\n',
    VIEW_DEFINITION,
    ';\n'
) AS ddl_script
FROM INFORMATION_SCHEMA.VIEWS
WHERE TABLE_SCHEMA = 'production_db'
ORDER BY TABLE_NAME;

-- Exporter le r√©sultat pour le rejouer sur une autre base
```

#### Script pour recr√©er tous les index

```sql
SELECT CONCAT(
    'CREATE ',
    IF(NON_UNIQUE = 0, 'UNIQUE ', ''),
    'INDEX ',
    INDEX_NAME,
    ' ON ',
    TABLE_SCHEMA, '.', TABLE_NAME,
    ' (',
    GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX SEPARATOR ', '),
    ');\n'
) AS ddl_script
FROM INFORMATION_SCHEMA.STATISTICS
WHERE TABLE_SCHEMA = 'production_db'
  AND INDEX_NAME != 'PRIMARY'
GROUP BY TABLE_SCHEMA, TABLE_NAME, INDEX_NAME, NON_UNIQUE
ORDER BY TABLE_NAME, INDEX_NAME;
```

### Comparaison de sch√©mas entre environnements

```sql
-- Comparer les colonnes entre deux bases
SELECT
    COALESCE(dev.TABLE_NAME, prod.TABLE_NAME) AS table_name,
    COALESCE(dev.COLUMN_NAME, prod.COLUMN_NAME) AS column_name,
    CASE
        WHEN dev.COLUMN_NAME IS NULL THEN 'Manquant en DEV'
        WHEN prod.COLUMN_NAME IS NULL THEN 'Manquant en PROD'
        WHEN dev.DATA_TYPE != prod.DATA_TYPE THEN 'Type diff√©rent'
        WHEN dev.IS_NULLABLE != prod.IS_NULLABLE THEN 'Nullable diff√©rent'
        ELSE 'OK'
    END AS status,
    dev.DATA_TYPE AS dev_type,
    prod.DATA_TYPE AS prod_type
FROM
    (SELECT * FROM dev_db.INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = 'app_db') dev
FULL OUTER JOIN
    (SELECT * FROM prod_db.INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = 'app_db') prod
    ON dev.TABLE_NAME = prod.TABLE_NAME
    AND dev.COLUMN_NAME = prod.COLUMN_NAME
WHERE status != 'OK'
ORDER BY table_name, column_name;
```

### Documentation automatique du sch√©ma

```sql
-- G√©n√©rer une documentation Markdown
SELECT CONCAT(
    '## Table: ', TABLE_NAME, '\n\n',
    '**Description:** ', IFNULL(TABLE_COMMENT, 'N/A'), '\n',
    '**Lignes:** ', TABLE_ROWS, '\n',
    '**Taille:** ', ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2), ' MB\n',
    '**Moteur:** ', ENGINE, '\n\n',
    '### Colonnes\n\n',
    '| Colonne | Type | NULL | D√©faut | Commentaire |\n',
    '|---------|------|------|--------|-------------|\n',
    (SELECT GROUP_CONCAT(
        CONCAT('| ', COLUMN_NAME, ' | ', COLUMN_TYPE, ' | ', IS_NULLABLE, ' | ',
               IFNULL(COLUMN_DEFAULT, 'NULL'), ' | ', IFNULL(COLUMN_COMMENT, ''), ' |')
        ORDER BY ORDINAL_POSITION
        SEPARATOR '\n'
    )
    FROM INFORMATION_SCHEMA.COLUMNS c
    WHERE c.TABLE_SCHEMA = t.TABLE_SCHEMA
      AND c.TABLE_NAME = t.TABLE_NAME
    ),
    '\n\n'
) AS documentation
FROM INFORMATION_SCHEMA.TABLES t
WHERE TABLE_SCHEMA = 'production_db'
  AND TABLE_TYPE = 'BASE TABLE'
ORDER BY TABLE_NAME;

-- Exporter en fichier .md
```

---

## ‚úÖ Points cl√©s √† retenir

- **INFORMATION_SCHEMA** est une base virtuelle standardis√©e pour les m√©tadonn√©es
- Contient **plus de 60 vues** couvrant tous les aspects du sch√©ma
- **TABLES** et **COLUMNS** : Structure des bases et tables
- **STATISTICS** : Informations sur les index et leur efficacit√©
- **KEY_COLUMN_USAGE** : Contraintes (PK, FK, UNIQUE)
- **USER_PRIVILEGES, TABLE_PRIVILEGES** : Audit de s√©curit√©
- **VIEWS, ROUTINES, TRIGGERS** : Objets programmables
- **Toujours filtrer par TABLE_SCHEMA** pour optimiser les performances
- √âviter **SELECT *** et **sous-requ√™tes corr√©l√©es** sur INFORMATION_SCHEMA
- Mettre en **cache** les r√©sultats fr√©quemment utilis√©s
- Id√©al pour **g√©n√©ration de scripts**, **audits**, **documentation automatique**

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB
- [üìñ INFORMATION_SCHEMA Tables](https://mariadb.com/kb/en/information-schema-tables/) - Liste compl√®te
- [üìñ INFORMATION_SCHEMA.TABLES](https://mariadb.com/kb/en/information-schema-tables-table/) - M√©tadonn√©es des tables
- [üìñ INFORMATION_SCHEMA.COLUMNS](https://mariadb.com/kb/en/information-schema-columns-table/) - M√©tadonn√©es des colonnes
- [üìñ INFORMATION_SCHEMA.STATISTICS](https://mariadb.com/kb/en/information-schema-statistics-table/) - Index

---

## ‚û°Ô∏è Section suivante

**[9.7.2 PERFORMANCE_SCHEMA](./07.2-performance-schema.md)** : Utilisation avanc√©e de PERFORMANCE_SCHEMA pour le monitoring des performances, analyse des requ√™tes lentes, d√©tection des verrous, et optimisation en production.

---


‚è≠Ô∏è [PERFORMANCE_SCHEMA](/09-vues-et-donnees-virtuelles/07.2-performance-schema.md)
