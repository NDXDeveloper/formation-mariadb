üîù Retour au [Sommaire](/SOMMAIRE.md)

# 17.1.4 Node.js : mysql2, mariadb

> **Niveau** : Interm√©diaire √† Avanc√©  
> **Dur√©e estim√©e** : 3-4 heures  
> **Pr√©requis** : Node.js 18+, npm/yarn, JavaScript ES6+, bases async/await, TypeScript (optionnel)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Choisir entre mysql2 et mariadb selon vos besoins
- √âtablir des connexions asynchrones modernes avec async/await
- Utiliser les prepared statements pour s√©curiser vos requ√™tes
- Configurer et optimiser un connection pool
- Ma√Ætriser Sequelize et Prisma pour le d√©veloppement rapide
- Int√©grer MariaDB dans Express.js, Fastify et NestJS
- Appliquer les patterns modernes (Repository, Service)
- G√©rer les transactions et erreurs de mani√®re robuste

---

## Introduction

Node.js, avec son architecture event-driven et non-bloquante, est particuli√®rement adapt√© aux applications web modernes et APIs. L'√©cosyst√®me JavaScript offre plusieurs biblioth√®ques pour interagir avec MariaDB :

### √âcosyst√®me Node.js-MariaDB

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        Application Node.js                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Framework Layer (optionnel)                ‚îÇ
‚îÇ  ‚îú‚îÄ Express.js (minimaliste)                ‚îÇ
‚îÇ  ‚îú‚îÄ Fastify (haute performance)             ‚îÇ
‚îÇ  ‚îú‚îÄ NestJS (enterprise, TypeScript)         ‚îÇ
‚îÇ  ‚îî‚îÄ Koa.js (moderne, minimal)               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ORM/Query Builder                          ‚îÇ
‚îÇ  ‚îú‚îÄ Prisma (moderne, type-safe)             ‚îÇ
‚îÇ  ‚îú‚îÄ Sequelize (mature, feature-rich)        ‚îÇ
‚îÇ  ‚îú‚îÄ TypeORM (TypeScript-first)              ‚îÇ
‚îÇ  ‚îî‚îÄ Knex.js (SQL query builder)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Database Drivers                           ‚îÇ
‚îÇ  ‚îú‚îÄ mysql2 (+ performant, promise support)  ‚îÇ
‚îÇ  ‚îî‚îÄ mariadb (officiel MariaDB)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ          MariaDB Server                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

üí° **Conseil** : Pour les nouveaux projets, utilisez **mysql2** avec **Prisma** ou **Sequelize**. Pour les applications TypeScript enterprise, **NestJS** + **Prisma** + **mysql2** est la stack recommand√©e.

---

## Comparaison des connecteurs Node.js

### Tableau comparatif d√©taill√©

| Crit√®re | mysql2 | mariadb | mysql (legacy) |
|---------|--------|---------|----------------|
| **Performance** | Tr√®s √©lev√©e | Tr√®s √©lev√©e | Moyenne |
| **Promise/Async** | ‚úÖ Natif | ‚úÖ Natif | ‚ùå Callback only |
| **Prepared Statements** | ‚úÖ Serveur & client | ‚úÖ Serveur | ‚ö†Ô∏è Client uniquement |
| **Streaming** | ‚úÖ Support | ‚úÖ Support | ‚úÖ Support |
| **Connection Pool** | ‚úÖ Int√©gr√© | ‚úÖ Int√©gr√© | ‚úÖ Int√©gr√© |
| **TypeScript** | ‚úÖ @types/mysql2 | ‚úÖ Typings inclus | ‚ö†Ô∏è @types/mysql |
| **Compression** | ‚úÖ Support | ‚úÖ Support | ‚úÖ Support |
| **SSL/TLS** | ‚úÖ Support | ‚úÖ Support | ‚úÖ Support |
| **MariaDB sp√©cifique** | ‚ö†Ô∏è Basique | ‚úÖ Optimis√© | ‚ùå Non |
| **Maintenance** | Tr√®s active | Active | Deprecated |
| **Bundle size** | ~500 KB | ~600 KB | ~400 KB |
| **npm downloads/week** | ~6M | ~400K | ~2M (legacy) |

### mysql2 vs mariadb : Le choix

#### mysql2
```bash
npm install mysql2
# ou
yarn add mysql2
```

**Utiliser quand :**
- Compatibilit√© MySQL et MariaDB souhait√©e
- √âcosyst√®me ORM mature (Sequelize, TypeORM)
- Performance maximale
- Communaut√© large et ressources abondantes

**Avantages :**
- ‚úÖ Le plus rapide (benchmarks)
- ‚úÖ Compatible MySQL 5.7+, MariaDB 10.x+
- ‚úÖ Excellente int√©gration avec ORMs
- ‚úÖ Documentation extensive
- ‚úÖ Promise API native

**Inconv√©nients :**
- ‚ö†Ô∏è Moins optimis√© pour MariaDB sp√©cifique

#### mariadb (connector officiel)
```bash
npm install mariadb
```

**Utiliser quand :**
- MariaDB-only (pas besoin compatibilit√© MySQL)
- Features MariaDB sp√©cifiques (RETURNING, JSON, etc.)
- Support officiel prioritaire

**Avantages :**
- ‚úÖ Optimis√© pour MariaDB
- ‚úÖ Support officiel MariaDB Foundation
- ‚úÖ Features MariaDB natives
- ‚úÖ TypeScript typings inclus

**Inconv√©nients :**
- ‚ö†Ô∏è √âcosyst√®me ORM moins mature
- ‚ö†Ô∏è Moins de ressources communautaires

üí° **Recommandation** : Utilisez **mysql2** sauf si vous avez besoin de features MariaDB tr√®s sp√©cifiques. La compatibilit√© avec l'√©cosyst√®me est un avantage majeur.

---

## Installation et configuration

### Package.json moderne

```json
{
  "name": "mariadb-nodejs-app",
  "version": "1.0.0",
  "type": "module",
  "engines": {
    "node": ">=18.0.0"
  },
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "test": "jest"
  },
  "dependencies": {
    "mysql2": "^3.6.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2"
  },
  "devDependencies": {
    "@types/node": "^20.10.6",
    "nodemon": "^3.0.2",
    "jest": "^29.7.0"
  }
}
```

### Configuration avec variables d'environnement

```javascript
// config/database.js
import dotenv from 'dotenv';
dotenv.config();

export const dbConfig = {
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT) || 3306,
  user: process.env.DB_USER || 'app_user',
  password: process.env.DB_PASSWORD || '',
  database: process.env.DB_NAME || 'production_db',
  
  // Connection pool
  connectionLimit: parseInt(process.env.DB_POOL_SIZE) || 10,
  queueLimit: 0,  // Pas de limite de queue
  
  // Timeouts
  connectTimeout: 10000,  // 10 secondes
  acquireTimeout: 10000,
  timeout: 60000,         // Query timeout 60s
  
  // Charset et collation (üÜï utf8mb4 par d√©faut en MariaDB 11.8)
  charset: 'utf8mb4',
  collation: 'utf8mb4_unicode_ci',
  
  // SSL/TLS (üÜï activ√© par d√©faut en MariaDB 11.8)
  ssl: process.env.DB_SSL === 'true' ? {
    rejectUnauthorized: true
  } : false,
  
  // Timezone UTC
  timezone: '+00:00',
  
  // Date strings (garder en Date objects)
  dateStrings: false,
  
  // Multiple statements (‚ö†Ô∏è d√©sactiver pour s√©curit√©)
  multipleStatements: false,
  
  // Debugging (dev only)
  debug: process.env.NODE_ENV === 'development',
  
  // Retry strategy
  enableKeepAlive: true,
  keepAliveInitialDelay: 0
};
```

```env
# .env (ne JAMAIS commiter)
NODE_ENV=production
DB_HOST=localhost
DB_PORT=3306
DB_USER=app_user
DB_PASSWORD=SecureP@ssw0rd!
DB_NAME=production_db
DB_POOL_SIZE=10
DB_SSL=false
```

---

## Connexion avec mysql2

### Connexion Promise-based moderne

```javascript
// db/connection.js
import mysql from 'mysql2/promise';
import { dbConfig } from '../config/database.js';

/**
 * Connexion simple avec mysql2/promise
 * Utilise async/await pour un code moderne et lisible
 */
export async function testConnection() {
  let connection;
  
  try {
    // Cr√©er la connexion
    connection = await mysql.createConnection(dbConfig);
    
    console.log('‚úì Connect√© √† MariaDB');
    
    // Test query
    const [rows] = await connection.execute(
      'SELECT VERSION() as version, DATABASE() as db'
    );
    
    console.log('MariaDB version:', rows[0].version);
    console.log('Current database:', rows[0].db);
    
  } catch (error) {
    console.error('‚úó Erreur de connexion:', error.message);
    throw error;
  } finally {
    // Toujours fermer la connexion
    if (connection) {
      await connection.end();
    }
  }
}

// Ex√©cution
testConnection();
```

### Connection Pool (recommand√© pour production)

```javascript
// db/pool.js
import mysql from 'mysql2/promise';
import { dbConfig } from '../config/database.js';

/**
 * Pool de connexions - R√©utilisation des connexions
 * TOUJOURS utiliser un pool en production
 */
class DatabasePool {
  constructor() {
    this.pool = null;
  }
  
  /**
   * Initialiser le pool
   */
  async initialize() {
    if (!this.pool) {
      this.pool = mysql.createPool(dbConfig);
      
      // Event listeners pour monitoring
      this.pool.on('connection', (connection) => {
        console.log('Nouvelle connexion cr√©√©e:', connection.threadId);
      });
      
      this.pool.on('acquire', (connection) => {
        console.log('Connexion acquise:', connection.threadId);
      });
      
      this.pool.on('release', (connection) => {
        console.log('Connexion rel√¢ch√©e:', connection.threadId);
      });
      
      console.log('‚úì Pool MariaDB initialis√©');
    }
    
    return this.pool;
  }
  
  /**
   * Obtenir une connexion du pool
   */
  async getConnection() {
    if (!this.pool) {
      await this.initialize();
    }
    return this.pool.getConnection();
  }
  
  /**
   * Ex√©cuter une requ√™te directement
   */
  async execute(sql, params = []) {
    if (!this.pool) {
      await this.initialize();
    }
    return this.pool.execute(sql, params);
  }
  
  /**
   * Ex√©cuter une requ√™te (non pr√©par√©e)
   */
  async query(sql, params = []) {
    if (!this.pool) {
      await this.initialize();
    }
    return this.pool.query(sql, params);
  }
  
  /**
   * Fermer le pool (shutdown graceful)
   */
  async close() {
    if (this.pool) {
      await this.pool.end();
      this.pool = null;
      console.log('‚úì Pool ferm√©');
    }
  }
  
  /**
   * Statistiques du pool
   */
  getStats() {
    if (!this.pool) {
      return null;
    }
    
    return {
      totalConnections: this.pool._allConnections.length,
      freeConnections: this.pool._freeConnections.length,
      queuedRequests: this.pool._connectionQueue.length
    };
  }
}

// Export singleton
export const db = new DatabasePool();

// Graceful shutdown
process.on('SIGINT', async () => {
  await db.close();
  process.exit(0);
});
```

### Utilisation du pool

```javascript
// examples/pool-usage.js
import { db } from '../db/pool.js';

/**
 * Exemples d'utilisation du pool
 */

// Exemple 1 : Requ√™te simple avec execute (prepared statement)
async function getUser(userId) {
  try {
    const [rows] = await db.execute(
      'SELECT id, username, email FROM users WHERE id = ?',
      [userId]
    );
    
    return rows[0] || null;
  } catch (error) {
    console.error('Erreur getUser:', error);
    throw error;
  }
}

// Exemple 2 : Obtenir une connexion pour plusieurs requ√™tes
async function getUserWithOrders(userId) {
  const connection = await db.getConnection();
  
  try {
    // Utiliser la m√™me connexion pour plusieurs requ√™tes
    const [userRows] = await connection.execute(
      'SELECT * FROM users WHERE id = ?',
      [userId]
    );
    
    const [orderRows] = await connection.execute(
      'SELECT * FROM orders WHERE user_id = ? ORDER BY created_at DESC',
      [userId]
    );
    
    return {
      user: userRows[0],
      orders: orderRows
    };
    
  } catch (error) {
    console.error('Erreur:', error);
    throw error;
  } finally {
    // IMPORTANT : toujours rel√¢cher la connexion
    connection.release();
  }
}

// Exemple 3 : Afficher les stats du pool
async function showPoolStats() {
  const stats = db.getStats();
  console.log('Pool Stats:', stats);
}

// Tests
(async () => {
  await db.initialize();
  
  const user = await getUser(1);
  console.log('User:', user);
  
  const userWithOrders = await getUserWithOrders(1);
  console.log('User with orders:', userWithOrders);
  
  await showPoolStats();
})();
```

---

## Prepared Statements et s√©curit√©

### Exemples de prepared statements

```javascript
// repositories/user.repository.js
import { db } from '../db/pool.js';

/**
 * Repository pour les op√©rations utilisateur
 * TOUJOURS utiliser des prepared statements
 */
export class UserRepository {
  
  /**
   * CREATE - Cr√©er un utilisateur
   */
  async create(username, email, passwordHash) {
    try {
      const [result] = await db.execute(
        `INSERT INTO users (username, email, password_hash, created_at)
         VALUES (?, ?, ?, NOW())`,
        [username, email, passwordHash]
      );
      
      return {
        id: result.insertId,
        username,
        email
      };
      
    } catch (error) {
      // G√©rer les erreurs de contraintes
      if (error.code === 'ER_DUP_ENTRY') {
        throw new Error('Username ou email d√©j√† utilis√©');
      }
      throw error;
    }
  }
  
  /**
   * READ - Trouver par ID
   */
  async findById(userId) {
    const [rows] = await db.execute(
      `SELECT id, username, email, created_at, last_login
       FROM users WHERE id = ?`,
      [userId]
    );
    
    return rows[0] || null;
  }
  
  /**
   * READ - Trouver par email
   */
  async findByEmail(email) {
    const [rows] = await db.execute(
      'SELECT * FROM users WHERE email = ?',
      [email]
    );
    
    return rows[0] || null;
  }
  
  /**
   * READ - Liste avec pagination
   */
  async findAll(page = 0, pageSize = 20) {
    const offset = page * pageSize;
    
    const [rows] = await db.execute(
      `SELECT id, username, email, created_at
       FROM users
       WHERE is_active = true
       ORDER BY created_at DESC
       LIMIT ? OFFSET ?`,
      [pageSize, offset]
    );
    
    return rows;
  }
  
  /**
   * UPDATE - Mettre √† jour l'email
   */
  async updateEmail(userId, newEmail) {
    const [result] = await db.execute(
      `UPDATE users 
       SET email = ?, updated_at = NOW()
       WHERE id = ?`,
      [newEmail, userId]
    );
    
    return result.affectedRows > 0;
  }
  
  /**
   * DELETE - Soft delete (d√©sactivation)
   */
  async softDelete(userId) {
    const [result] = await db.execute(
      `UPDATE users 
       SET is_active = false, updated_at = NOW()
       WHERE id = ?`,
      [userId]
    );
    
    return result.affectedRows > 0;
  }
  
  /**
   * DELETE - Hard delete
   */
  async delete(userId) {
    const [result] = await db.execute(
      'DELETE FROM users WHERE id = ?',
      [userId]
    );
    
    return result.affectedRows > 0;
  }
  
  /**
   * Recherche avanc√©e
   */
  async search(searchTerm, filters = {}) {
    let sql = `
      SELECT id, username, email, created_at
      FROM users
      WHERE (username LIKE ? OR email LIKE ?)
    `;
    
    const params = [`%${searchTerm}%`, `%${searchTerm}%`];
    
    // Filtres dynamiques
    if (filters.isActive !== undefined) {
      sql += ' AND is_active = ?';
      params.push(filters.isActive);
    }
    
    if (filters.createdAfter) {
      sql += ' AND created_at >= ?';
      params.push(filters.createdAfter);
    }
    
    sql += ' ORDER BY created_at DESC LIMIT ?';
    params.push(filters.limit || 50);
    
    const [rows] = await db.execute(sql, params);
    return rows;
  }
  
  /**
   * Batch INSERT pour performance
   */
  async createBatch(users) {
    if (users.length === 0) return [];
    
    // Construire la requ√™te avec placeholders
    const values = users.map(() => '(?, ?, ?, NOW())').join(',');
    const sql = `
      INSERT INTO users (username, email, password_hash, created_at)
      VALUES ${values}
    `;
    
    // Aplatir le tableau de param√®tres
    const params = users.flatMap(u => [u.username, u.email, u.passwordHash]);
    
    const [result] = await db.execute(sql, params);
    
    return {
      insertedCount: result.affectedRows,
      firstInsertId: result.insertId
    };
  }
  
  /**
   * Compter les utilisateurs
   */
  async count(filters = {}) {
    let sql = 'SELECT COUNT(*) as total FROM users WHERE 1=1';
    const params = [];
    
    if (filters.isActive !== undefined) {
      sql += ' AND is_active = ?';
      params.push(filters.isActive);
    }
    
    const [rows] = await db.execute(sql, params);
    return rows[0].total;
  }
}
```

‚ö†Ô∏è **Attention** : Ne JAMAIS construire des requ√™tes SQL par concat√©nation ou template literals avec des donn√©es utilisateur !

```javascript
// ‚ùå DANGEREUX - Injection SQL possible
async function vulnerableQuery(username) {
  const sql = `SELECT * FROM users WHERE username = '${username}'`;
  // Si username = "admin' OR '1'='1" ‚Üí contournement !
  return db.query(sql);
}

// ‚úÖ S√âCURIS√â - Prepared statement
async function secureQuery(username) {
  return db.execute(
    'SELECT * FROM users WHERE username = ?',
    [username]
  );
}
```

---

## Gestion des transactions

### Transactions avec async/await

```javascript
// services/order.service.js
import { db } from '../db/pool.js';

/**
 * Service de gestion des commandes avec transactions
 */
export class OrderService {
  
  /**
   * Cr√©er une commande (transaction atomique)
   */
  async createOrder(userId, items) {
    const connection = await db.getConnection();
    
    try {
      // D√©marrer la transaction
      await connection.beginTransaction();
      
      // 1. Cr√©er la commande
      const [orderResult] = await connection.execute(
        `INSERT INTO orders (user_id, total_amount, status, created_at)
         VALUES (?, ?, ?, NOW())`,
        [userId, 0, 'pending']
      );
      
      const orderId = orderResult.insertId;
      let totalAmount = 0;
      
      // 2. Ajouter les items et v√©rifier le stock
      for (const item of items) {
        const { productId, quantity } = item;
        
        // R√©cup√©rer le produit avec lock
        const [products] = await connection.execute(
          'SELECT id, price, stock FROM products WHERE id = ? FOR UPDATE',
          [productId]
        );
        
        if (products.length === 0) {
          throw new Error(`Produit ${productId} introuvable`);
        }
        
        const product = products[0];
        
        // V√©rifier le stock
        if (product.stock < quantity) {
          throw new Error(`Stock insuffisant pour le produit ${productId}`);
        }
        
        // Calculer le sous-total
        const subtotal = product.price * quantity;
        totalAmount += subtotal;
        
        // Ins√©rer l'item
        await connection.execute(
          `INSERT INTO order_items (order_id, product_id, quantity, price)
           VALUES (?, ?, ?, ?)`,
          [orderId, productId, quantity, product.price]
        );
        
        // D√©cr√©menter le stock
        await connection.execute(
          'UPDATE products SET stock = stock - ? WHERE id = ?',
          [quantity, productId]
        );
      }
      
      // 3. Mettre √† jour le montant total
      await connection.execute(
        'UPDATE orders SET total_amount = ? WHERE id = ?',
        [totalAmount, orderId]
      );
      
      // Valider la transaction
      await connection.commit();
      
      console.log(`‚úì Commande ${orderId} cr√©√©e avec succ√®s`);
      
      return {
        orderId,
        totalAmount,
        itemCount: items.length
      };
      
    } catch (error) {
      // Annuler la transaction en cas d'erreur
      await connection.rollback();
      console.error('‚úó Transaction annul√©e:', error.message);
      throw error;
      
    } finally {
      // Toujours rel√¢cher la connexion
      connection.release();
    }
  }
  
  /**
   * Annuler une commande (transaction)
   */
  async cancelOrder(orderId) {
    const connection = await db.getConnection();
    
    try {
      await connection.beginTransaction();
      
      // 1. R√©cup√©rer les items de la commande
      const [items] = await connection.execute(
        'SELECT product_id, quantity FROM order_items WHERE order_id = ?',
        [orderId]
      );
      
      // 2. Remettre le stock pour chaque item
      for (const item of items) {
        await connection.execute(
          'UPDATE products SET stock = stock + ? WHERE id = ?',
          [item.quantity, item.product_id]
        );
      }
      
      // 3. Mettre √† jour le statut de la commande
      const [result] = await connection.execute(
        `UPDATE orders 
         SET status = 'cancelled', updated_at = NOW()
         WHERE id = ? AND status IN ('pending', 'confirmed')`,
        [orderId]
      );
      
      if (result.affectedRows === 0) {
        throw new Error('Commande introuvable ou d√©j√† annul√©e');
      }
      
      await connection.commit();
      
      return { success: true, orderId };
      
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }
  
  /**
   * Transaction avec niveaux d'isolation
   */
  async transferWithIsolation(fromAccountId, toAccountId, amount) {
    const connection = await db.getConnection();
    
    try {
      // D√©finir le niveau d'isolation
      await connection.execute(
        'SET TRANSACTION ISOLATION LEVEL REPEATABLE READ'
      );
      
      await connection.beginTransaction();
      
      // Transf√©rer...
      // (code similaire aux exemples pr√©c√©dents)
      
      await connection.commit();
      
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }
}
```

---

## Connexion avec mariadb (connector officiel)

### Configuration et utilisation

```javascript
// db/mariadb-pool.js
import mariadb from 'mariadb';

/**
 * Pool MariaDB officiel
 * Syntaxe l√©g√®rement diff√©rente de mysql2
 */
const pool = mariadb.createPool({
  host: 'localhost',
  port: 3306,
  user: 'app_user',
  password: 'SecureP@ssw0rd!',
  database: 'production_db',
  
  // Pool sizing
  connectionLimit: 10,
  acquireTimeout: 10000,
  
  // Charset
  charset: 'utf8mb4',
  collation: 'utf8mb4_unicode_ci',
  
  // Compression
  compress: true,
  
  // Timeouts
  connectTimeout: 10000,
  socketTimeout: 60000,
  
  // Timezone
  timezone: 'Z',  // UTC
  
  // Metadata
  metaAsArray: false,  // Retourner metadata comme objet
  
  // Logging
  trace: process.env.NODE_ENV === 'development'
});

/**
 * Exemple d'utilisation avec mariadb
 */
export async function mariadbExample() {
  let conn;
  
  try {
    // Obtenir une connexion
    conn = await pool.getConnection();
    
    // Query simple
    const rows = await conn.query('SELECT VERSION() as version');
    console.log('MariaDB version:', rows[0].version);
    
    // Prepared statement
    const users = await conn.query(
      'SELECT * FROM users WHERE id = ?',
      [1]
    );
    console.log('User:', users[0]);
    
    // Batch insert (feature mariadb)
    const batchResult = await conn.batch(
      'INSERT INTO logs (message, created_at) VALUES (?, NOW())',
      [['Log 1'], ['Log 2'], ['Log 3']]
    );
    console.log('Batch inserted:', batchResult.affectedRows);
    
    // Named placeholders (feature mariadb)
    const result = await conn.query(
      'SELECT * FROM users WHERE email = :email AND is_active = :active',
      { email: 'user@example.com', active: true }
    );
    
  } catch (error) {
    console.error('Erreur:', error);
  } finally {
    if (conn) {
      conn.release();
    }
  }
}

// Fermeture du pool
export async function closeMariadbPool() {
  await pool.end();
}
```

üí° **Conseil** : Le connector `mariadb` offre des features int√©ressantes comme les named placeholders et batch operations optimis√©es, mais `mysql2` reste plus populaire dans l'√©cosyst√®me.

---

## ORM : Sequelize

### Installation et configuration

```bash
npm install sequelize mysql2
# CLI pour migrations
npm install --save-dev sequelize-cli
```

```javascript
// config/sequelize.js
import { Sequelize } from 'sequelize';
import dotenv from 'dotenv';

dotenv.config();

/**
 * Configuration Sequelize
 */
export const sequelize = new Sequelize({
  dialect: 'mysql',
  host: process.env.DB_HOST,
  port: process.env.DB_PORT,
  username: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  
  // Charset
  dialectOptions: {
    charset: 'utf8mb4',
    collate: 'utf8mb4_unicode_ci',
    
    // SSL (optionnel)
    // ssl: {
    //   require: true,
    //   rejectUnauthorized: false
    // }
  },
  
  // Pool de connexions
  pool: {
    max: 10,
    min: 2,
    acquire: 30000,
    idle: 10000
  },
  
  // Timezone
  timezone: '+00:00',
  
  // Logging
  logging: process.env.NODE_ENV === 'development' ? console.log : false,
  
  // Performance
  benchmark: true,
  
  // Options de requ√™te par d√©faut
  define: {
    // timestamps automatiques
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    
    // underscored (snake_case)
    underscored: true,
    
    // Pas de delete physique par d√©faut
    paranoid: false,
    
    // Freeze table name (pas de pluriel auto)
    freezeTableName: true
  }
});

// Tester la connexion
export async function testSequelizeConnection() {
  try {
    await sequelize.authenticate();
    console.log('‚úì Sequelize connect√© √† MariaDB');
  } catch (error) {
    console.error('‚úó Erreur Sequelize:', error);
    throw error;
  }
}
```

### D√©finition de mod√®les

```javascript
// models/User.js
import { DataTypes, Model } from 'sequelize';
import { sequelize } from '../config/sequelize.js';
import bcrypt from 'bcrypt';

/**
 * Mod√®le User avec Sequelize
 */
export class User extends Model {
  /**
   * M√©thode d'instance : v√©rifier le mot de passe
   */
  async validatePassword(password) {
    return bcrypt.compare(password, this.password_hash);
  }
  
  /**
   * M√©thode de classe : cr√©er un utilisateur avec hash
   */
  static async createWithPassword(username, email, password) {
    const passwordHash = await bcrypt.hash(password, 12);
    
    return this.create({
      username,
      email,
      password_hash: passwordHash
    });
  }
  
  /**
   * M√©thode de classe : authentifier
   */
  static async authenticate(email, password) {
    const user = await this.findOne({ where: { email } });
    
    if (!user) {
      return null;
    }
    
    const isValid = await user.validatePassword(password);
    return isValid ? user : null;
  }
  
  /**
   * Hook : exclure le password_hash lors de la s√©rialisation
   */
  toJSON() {
    const values = { ...this.get() };
    delete values.password_hash;
    return values;
  }
}

// D√©finir le sch√©ma
User.init({
  id: {
    type: DataTypes.BIGINT.UNSIGNED,
    primaryKey: true,
    autoIncrement: true
  },
  
  username: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: true,
    validate: {
      len: [3, 50],
      isAlphanumeric: true
    }
  },
  
  email: {
    type: DataTypes.STRING(255),
    allowNull: false,
    unique: true,
    validate: {
      isEmail: true
    }
  },
  
  password_hash: {
    type: DataTypes.STRING(255),
    allowNull: false
  },
  
  first_name: {
    type: DataTypes.STRING(100),
    allowNull: true
  },
  
  last_name: {
    type: DataTypes.STRING(100),
    allowNull: true
  },
  
  is_active: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  },
  
  is_admin: {
    type: DataTypes.BOOLEAN,
    defaultValue: false
  },
  
  last_login: {
    type: DataTypes.DATE,
    allowNull: true
  }
}, {
  sequelize,
  modelName: 'User',
  tableName: 'users',
  timestamps: true,
  underscored: true,
  
  // Index
  indexes: [
    { fields: ['email'] },
    { fields: ['username'] },
    { fields: ['is_active', 'created_at'] }
  ],
  
  // Hooks
  hooks: {
    beforeCreate: async (user) => {
      // Normaliser l'email
      user.email = user.email.toLowerCase();
    }
  }
});
```

```javascript
// models/Order.js
import { DataTypes, Model } from 'sequelize';
import { sequelize } from '../config/sequelize.js';

export class Order extends Model {}

Order.init({
  id: {
    type: DataTypes.BIGINT.UNSIGNED,
    primaryKey: true,
    autoIncrement: true
  },
  
  user_id: {
    type: DataTypes.BIGINT.UNSIGNED,
    allowNull: false,
    references: {
      model: 'users',
      key: 'id'
    }
  },
  
  total_amount: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false,
    defaultValue: 0.00
  },
  
  status: {
    type: DataTypes.ENUM('pending', 'confirmed', 'shipped', 'delivered', 'cancelled'),
    defaultValue: 'pending'
  }
}, {
  sequelize,
  modelName: 'Order',
  tableName: 'orders',
  timestamps: true,
  underscored: true
});

// D√©finir les relations
import { User } from './User.js';

User.hasMany(Order, {
  foreignKey: 'user_id',
  as: 'orders'
});

Order.belongsTo(User, {
  foreignKey: 'user_id',
  as: 'user'
});
```

### Utilisation de Sequelize

```javascript
// services/user.service.js
import { User } from '../models/User.js';
import { Order } from '../models/Order.js';
import { Op } from 'sequelize';

/**
 * Service utilisateur avec Sequelize
 */
export class UserService {
  
  /**
   * Cr√©er un utilisateur
   */
  async createUser(username, email, password) {
    try {
      const user = await User.createWithPassword(username, email, password);
      return user.toJSON();  // Exclut password_hash
      
    } catch (error) {
      if (error.name === 'SequelizeUniqueConstraintError') {
        throw new Error('Username ou email d√©j√† utilis√©');
      }
      throw error;
    }
  }
  
  /**
   * Trouver par ID avec eager loading
   */
  async getUserWithOrders(userId) {
    const user = await User.findByPk(userId, {
      include: [
        {
          model: Order,
          as: 'orders',
          order: [['created_at', 'DESC']],
          limit: 10
        }
      ]
    });
    
    return user;
  }
  
  /**
   * Recherche avanc√©e
   */
  async searchUsers(query, options = {}) {
    const {
      page = 0,
      pageSize = 20,
      isActive = true
    } = options;
    
    const result = await User.findAndCountAll({
      where: {
        [Op.and]: [
          {
            [Op.or]: [
              { username: { [Op.like]: `%${query}%` } },
              { email: { [Op.like]: `%${query}%` } }
            ]
          },
          { is_active: isActive }
        ]
      },
      limit: pageSize,
      offset: page * pageSize,
      order: [['created_at', 'DESC']]
    });
    
    return {
      users: result.rows,
      total: result.count,
      page,
      pageSize,
      totalPages: Math.ceil(result.count / pageSize)
    };
  }
  
  /**
   * Mise √† jour
   */
  async updateUser(userId, updates) {
    const user = await User.findByPk(userId);
    
    if (!user) {
      throw new Error('Utilisateur introuvable');
    }
    
    // Filtrer les champs autoris√©s
    const allowedFields = ['first_name', 'last_name', 'email'];
    const filteredUpdates = {};
    
    for (const [key, value] of Object.entries(updates)) {
      if (allowedFields.includes(key)) {
        filteredUpdates[key] = value;
      }
    }
    
    await user.update(filteredUpdates);
    return user.toJSON();
  }
  
  /**
   * Supprimer (soft delete)
   */
  async deactivateUser(userId) {
    const user = await User.findByPk(userId);
    
    if (!user) {
      throw new Error('Utilisateur introuvable');
    }
    
    await user.update({ is_active: false });
    return true;
  }
  
  /**
   * Statistiques avec agr√©gation
   */
  async getUserStats() {
    const [results] = await sequelize.query(`
      SELECT 
        COUNT(*) as total_users,
        SUM(CASE WHEN is_active = 1 THEN 1 ELSE 0 END) as active_users,
        SUM(CASE WHEN is_admin = 1 THEN 1 ELSE 0 END) as admin_users,
        AVG(TIMESTAMPDIFF(DAY, created_at, NOW())) as avg_account_age_days
      FROM users
    `);
    
    return results[0];
  }
}
```

---

## ORM : Prisma (moderne et type-safe)

### Installation et setup

```bash
npm install prisma @prisma/client
npx prisma init
```

### Schema Prisma

```prisma
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id           BigInt    @id @default(autoincrement()) @db.UnsignedBigInt
  username     String    @unique @db.VarChar(50)
  email        String    @unique @db.VarChar(255)
  passwordHash String    @map("password_hash") @db.VarChar(255)
  firstName    String?   @map("first_name") @db.VarChar(100)
  lastName     String?   @map("last_name") @db.VarChar(100)
  isActive     Boolean   @default(true) @map("is_active")
  isAdmin      Boolean   @default(false) @map("is_admin")
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")
  lastLogin    DateTime? @map("last_login")
  
  // Relations
  orders    Order[]
  addresses Address[]
  
  @@index([email])
  @@index([username])
  @@index([isActive, createdAt])
  @@map("users")
}

model Order {
  id          BigInt      @id @default(autoincrement()) @db.UnsignedBigInt
  userId      BigInt      @map("user_id") @db.UnsignedBigInt
  totalAmount Decimal     @default(0.00) @map("total_amount") @db.Decimal(10, 2)
  status      OrderStatus @default(PENDING)
  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")
  
  // Relations
  user  User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  items OrderItem[]
  
  @@index([userId, status])
  @@map("orders")
}

model OrderItem {
  id        BigInt  @id @default(autoincrement()) @db.UnsignedBigInt
  orderId   BigInt  @map("order_id") @db.UnsignedBigInt
  productId BigInt  @map("product_id") @db.UnsignedBigInt
  quantity  Int
  price     Decimal @db.Decimal(10, 2)
  
  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id])
  
  @@unique([orderId, productId])
  @@map("order_items")
}

model Product {
  id          BigInt      @id @default(autoincrement()) @db.UnsignedBigInt
  name        String      @db.VarChar(255)
  description String?     @db.Text
  price       Decimal     @db.Decimal(10, 2)
  stock       Int         @default(0)
  isActive    Boolean     @default(true) @map("is_active")
  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")
  
  orderItems OrderItem[]
  
  @@index([isActive, price])
  @@map("products")
}

model Address {
  id          BigInt   @id @default(autoincrement()) @db.UnsignedBigInt
  userId      BigInt   @map("user_id") @db.UnsignedBigInt
  addressType String   @map("address_type") @db.VarChar(20)
  street      String   @db.VarChar(255)
  city        String   @db.VarChar(100)
  postalCode  String   @map("postal_code") @db.VarChar(20)
  country     String   @db.Char(2)
  createdAt   DateTime @default(now()) @map("created_at")
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, addressType])
  @@map("addresses")
}

enum OrderStatus {
  PENDING
  CONFIRMED
  SHIPPED
  DELIVERED
  CANCELLED
}
```

```env
# .env
DATABASE_URL="mysql://app_user:SecureP@ssw0rd!@localhost:3306/production_db"
```

### G√©n√©ration du client et utilisation

```bash
# G√©n√©rer le client TypeScript
npx prisma generate

# Migrer la base (dev)
npx prisma migrate dev --name init

# Ouvrir Prisma Studio (UI)
npx prisma studio
```

```typescript
// services/prisma.service.ts
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcrypt';

/**
 * Service Prisma - Type-safe et moderne
 */
export class PrismaService {
  private prisma: PrismaClient;
  
  constructor() {
    this.prisma = new PrismaClient({
      log: process.env.NODE_ENV === 'development' 
        ? ['query', 'info', 'warn', 'error']
        : ['error']
    });
  }
  
  /**
   * Cr√©er un utilisateur
   */
  async createUser(username: string, email: string, password: string) {
    const passwordHash = await bcrypt.hash(password, 12);
    
    try {
      const user = await this.prisma.user.create({
        data: {
          username,
          email,
          passwordHash
        },
        select: {
          id: true,
          username: true,
          email: true,
          createdAt: true
        }
      });
      
      return user;
      
    } catch (error: any) {
      if (error.code === 'P2002') {  // Unique constraint
        throw new Error('Username ou email d√©j√† utilis√©');
      }
      throw error;
    }
  }
  
  /**
   * Trouver par email
   */
  async findUserByEmail(email: string) {
    return this.prisma.user.findUnique({
      where: { email },
      include: {
        orders: {
          take: 10,
          orderBy: { createdAt: 'desc' }
        }
      }
    });
  }
  
  /**
   * Recherche avec filtres
   */
  async searchUsers(query: string, page: number = 0, pageSize: number = 20) {
    const skip = page * pageSize;
    
    const [users, total] = await Promise.all([
      this.prisma.user.findMany({
        where: {
          AND: [
            {
              OR: [
                { username: { contains: query } },
                { email: { contains: query } }
              ]
            },
            { isActive: true }
          ]
        },
        select: {
          id: true,
          username: true,
          email: true,
          createdAt: true,
          _count: {
            select: { orders: true }
          }
        },
        skip,
        take: pageSize,
        orderBy: { createdAt: 'desc' }
      }),
      
      this.prisma.user.count({
        where: {
          OR: [
            { username: { contains: query } },
            { email: { contains: query } }
          ],
          isActive: true
        }
      })
    ]);
    
    return {
      users,
      total,
      page,
      pageSize,
      totalPages: Math.ceil(total / pageSize)
    };
  }
  
  /**
   * Cr√©er une commande (transaction)
   */
  async createOrder(userId: bigint, items: Array<{ productId: bigint; quantity: number }>) {
    return this.prisma.$transaction(async (tx) => {
      let totalAmount = 0;
      
      // Cr√©er la commande
      const order = await tx.order.create({
        data: {
          userId,
          totalAmount: 0,
          status: 'PENDING'
        }
      });
      
      // Traiter chaque item
      for (const item of items) {
        // R√©cup√©rer le produit
        const product = await tx.product.findUnique({
          where: { id: item.productId }
        });
        
        if (!product) {
          throw new Error(`Produit ${item.productId} introuvable`);
        }
        
        if (product.stock < item.quantity) {
          throw new Error(`Stock insuffisant pour ${product.name}`);
        }
        
        // Calculer le sous-total
        const subtotal = Number(product.price) * item.quantity;
        totalAmount += subtotal;
        
        // Cr√©er l'item
        await tx.orderItem.create({
          data: {
            orderId: order.id,
            productId: item.productId,
            quantity: item.quantity,
            price: product.price
          }
        });
        
        // D√©cr√©menter le stock
        await tx.product.update({
          where: { id: item.productId },
          data: {
            stock: { decrement: item.quantity }
          }
        });
      }
      
      // Mettre √† jour le total
      return tx.order.update({
        where: { id: order.id },
        data: { totalAmount },
        include: {
          items: {
            include: {
              product: true
            }
          }
        }
      });
    });
  }
  
  /**
   * Statistiques utilisateurs
   */
  async getUserStats() {
    const [totalUsers, activeUsers, adminUsers] = await Promise.all([
      this.prisma.user.count(),
      this.prisma.user.count({ where: { isActive: true } }),
      this.prisma.user.count({ where: { isAdmin: true } })
    ]);
    
    return {
      totalUsers,
      activeUsers,
      adminUsers
    };
  }
  
  /**
   * Fermer la connexion
   */
  async disconnect() {
    await this.prisma.$disconnect();
  }
}
```

üí° **Conseil** : Prisma est excellent pour les projets TypeScript. Il g√©n√®re des types automatiquement et offre une excellente DX (Developer Experience) avec autocomplete et type-safety.

---

## Bonnes pratiques de s√©curit√©

### 1. Validation des entr√©es

```javascript
// utils/validation.js
import validator from 'validator';

/**
 * Validateurs personnalis√©s
 */
export const validators = {
  
  /**
   * Valider un email
   */
  validateEmail(email) {
    if (!email || !validator.isEmail(email)) {
      throw new Error('Email invalide');
    }
    return email.toLowerCase();
  },
  
  /**
   * Valider un username
   */
  validateUsername(username) {
    if (!username || username.length < 3 || username.length > 50) {
      throw new Error('Username doit faire entre 3 et 50 caract√®res');
    }
    
    if (!/^[a-zA-Z0-9_]+$/.test(username)) {
      throw new Error('Username invalide (alphanum√©rique et _ uniquement)');
    }
    
    return username;
  },
  
  /**
   * Valider la force d'un mot de passe
   */
  validatePassword(password) {
    if (!password || password.length < 12) {
      throw new Error('Le mot de passe doit contenir au moins 12 caract√®res');
    }
    
    const checks = {
      hasUpper: /[A-Z]/.test(password),
      hasLower: /[a-z]/.test(password),
      hasNumber: /[0-9]/.test(password),
      hasSpecial: /[!@#$%^&*(),.?":{}|<>]/.test(password)
    };
    
    const failedChecks = Object.entries(checks)
      .filter(([_, passed]) => !passed)
      .map(([check]) => check);
    
    if (failedChecks.length > 0) {
      throw new Error(
        'Le mot de passe doit contenir majuscule, minuscule, chiffre et caract√®re sp√©cial'
      );
    }
    
    return password;
  },
  
  /**
   * Valider un ID
   */
  validateId(id) {
    const numId = parseInt(id);
    if (isNaN(numId) || numId < 1) {
      throw new Error('ID invalide');
    }
    return numId;
  },
  
  /**
   * Sanitize une cha√Æne
   */
  sanitize(str) {
    return validator.escape(validator.trim(str));
  }
};
```

### 2. Rate limiting et protection

```javascript
// middleware/security.js
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';

/**
 * Rate limiter pour authentification
 */
export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,  // 15 minutes
  max: 5,  // 5 tentatives max
  message: 'Trop de tentatives de connexion, r√©essayez plus tard',
  standardHeaders: true,
  legacyHeaders: false
});

/**
 * Rate limiter global
 */
export const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: 'Trop de requ√™tes, r√©essayez plus tard'
});

/**
 * Helmet pour s√©curit√© headers HTTP
 */
export const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"]
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
});
```

### 3. Gestion s√©curis√©e des sessions

```javascript
// middleware/auth.js
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
const JWT_EXPIRES_IN = '24h';

/**
 * G√©n√©rer un token JWT
 */
export function generateToken(user) {
  return jwt.sign(
    {
      id: user.id,
      username: user.username,
      isAdmin: user.isAdmin
    },
    JWT_SECRET,
    { expiresIn: JWT_EXPIRES_IN }
  );
}

/**
 * V√©rifier un token JWT
 */
export function verifyToken(token) {
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (error) {
    return null;
  }
}

/**
 * Middleware d'authentification
 */
export function authenticate(req, res, next) {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Token manquant' });
  }
  
  const token = authHeader.substring(7);
  const decoded = verifyToken(token);
  
  if (!decoded) {
    return res.status(401).json({ error: 'Token invalide' });
  }
  
  req.user = decoded;
  next();
}

/**
 * Hasher un mot de passe
 */
export async function hashPassword(password) {
  return bcrypt.hash(password, 12);
}

/**
 * V√©rifier un mot de passe
 */
export async function verifyPassword(password, hash) {
  return bcrypt.compare(password, hash);
}
```

---

## Exemple d'application compl√®te

### API Express.js avec architecture en couches

```javascript
// app.js
import express from 'express';
import { db } from './db/pool.js';
import { securityHeaders, apiLimiter } from './middleware/security.js';
import userRoutes from './routes/user.routes.js';
import orderRoutes from './routes/order.routes.js';

const app = express();
const PORT = process.env.PORT || 3000;

// Middlewares
app.use(securityHeaders);
app.use(express.json());
app.use(apiLimiter);

// Routes
app.use('/api/users', userRoutes);
app.use('/api/orders', orderRoutes);

// Health check
app.get('/health', async (req, res) => {
  try {
    await db.execute('SELECT 1');
    res.json({
      status: 'healthy',
      database: 'connected',
      poolStats: db.getStats()
    });
  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      error: error.message
    });
  }
});

// Error handler
app.use((error, req, res, next) => {
  console.error('Error:', error);
  
  res.status(error.status || 500).json({
    error: process.env.NODE_ENV === 'development' 
      ? error.message 
      : 'Erreur serveur'
  });
});

// D√©marrage
async function start() {
  try {
    await db.initialize();
    
    app.listen(PORT, () => {
      console.log(`‚úì Serveur d√©marr√© sur le port ${PORT}`);
    });
  } catch (error) {
    console.error('‚úó Erreur d√©marrage:', error);
    process.exit(1);
  }
}

start();

// Graceful shutdown
process.on('SIGTERM', async () => {
  console.log('SIGTERM re√ßu, arr√™t gracieux...');
  await db.close();
  process.exit(0);
});
```

```javascript
// routes/user.routes.js
import { Router } from 'express';
import { UserController } from '../controllers/user.controller.js';
import { authenticate } from '../middleware/auth.js';
import { authLimiter } from '../middleware/security.js';

const router = Router();
const userController = new UserController();

// Public routes
router.post('/register', authLimiter, (req, res) => userController.register(req, res));
router.post('/login', authLimiter, (req, res) => userController.login(req, res));

// Protected routes
router.get('/me', authenticate, (req, res) => userController.getProfile(req, res));
router.get('/:id', authenticate, (req, res) => userController.getById(req, res));
router.put('/:id', authenticate, (req, res) => userController.update(req, res));
router.delete('/:id', authenticate, (req, res) => userController.delete(req, res));

export default router;
```

```javascript
// controllers/user.controller.js
import { UserService } from '../services/user.service.js';
import { validators } from '../utils/validation.js';
import { generateToken } from '../middleware/auth.js';

/**
 * Controller utilisateur
 */
export class UserController {
  constructor() {
    this.userService = new UserService();
  }
  
  /**
   * Inscription
   */
  async register(req, res) {
    try {
      const { username, email, password } = req.body;
      
      // Validation
      validators.validateUsername(username);
      validators.validateEmail(email);
      validators.validatePassword(password);
      
      // Cr√©er l'utilisateur
      const user = await this.userService.register(username, email, password);
      
      // G√©n√©rer le token
      const token = generateToken(user);
      
      res.status(201).json({
        user,
        token
      });
      
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }
  
  /**
   * Connexion
   */
  async login(req, res) {
    try {
      const { email, password } = req.body;
      
      const user = await this.userService.login(email, password);
      
      if (!user) {
        return res.status(401).json({ error: 'Identifiants invalides' });
      }
      
      const token = generateToken(user);
      
      res.json({
        user,
        token
      });
      
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }
  
  /**
   * Profil utilisateur
   */
  async getProfile(req, res) {
    try {
      const user = await this.userService.getById(req.user.id);
      res.json(user);
    } catch (error) {
      res.status(404).json({ error: 'Utilisateur non trouv√©' });
    }
  }
  
  // Autres m√©thodes...
}
```

---

## ‚úÖ Points cl√©s √† retenir

1. **Connecteurs** : mysql2 recommand√© (performance, √©cosyst√®me), mariadb pour features sp√©cifiques
2. **Pool** : TOUJOURS utiliser un connection pool en production
3. **Async/Await** : Pattern moderne, √©viter les callbacks
4. **Prepared Statements** : Protection automatique contre injections SQL
5. **ORMs** : Prisma (TypeScript), Sequelize (JavaScript mature)
6. **S√©curit√©** : bcrypt (rounds 12), validation entr√©es, rate limiting, JWT
7. **Transactions** : beginTransaction/commit/rollback avec gestion d'erreurs
8. **Architecture** : Pattern MVC (Model-View-Controller) ou layered (Repository-Service-Controller)
9. **TypeScript** : Fortement recommand√© pour projets professionnels
10. **Monitoring** : Logs, pool stats, error tracking (Sentry)

---

## üîó Ressources et r√©f√©rences

### Documentation officielle
- [üìñ mysql2](https://github.com/sidorares/node-mysql2)
- [üìñ mariadb connector](https://github.com/mariadb-corporation/mariadb-connector-nodejs)
- [üìñ Sequelize](https://sequelize.org/)
- [üìñ Prisma](https://www.prisma.io/docs)

### Frameworks
- [Express.js](https://expressjs.com/)
- [Fastify](https://www.fastify.io/)
- [NestJS](https://nestjs.com/)

### S√©curit√©
- [OWASP Node.js Security](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html)
- [Helmet.js](https://helmetjs.github.io/)
- [express-rate-limit](https://www.npmjs.com/package/express-rate-limit)

### Outils
- [TypeORM](https://typeorm.io/) - Alternative ORM TypeScript
- [Knex.js](http://knexjs.org/) - SQL Query Builder
- [Drizzle ORM](https://orm.drizzle.team/) - TypeScript ORM moderne

---

## ‚û°Ô∏è Section suivante

**17.1.5 Go : go-sql-driver/mysql** : D√©couvrez comment int√©grer MariaDB dans vos applications Go avec le driver officiel, connection pooling natif, et les patterns idiomatiques Go pour la gestion des bases de donn√©es.

‚è≠Ô∏è [Go : go-sql-driver/mysql](/17-integration-developpement/01.5-go-connector.md)
