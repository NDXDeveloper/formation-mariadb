üîù Retour au [Sommaire](/SOMMAIRE.md)

# 17.3.4 Prisma (Node.js/TypeScript)

> **Niveau** : Interm√©diaire √† Avanc√©  
> **Dur√©e estim√©e** : 4-5 heures  
> **Pr√©requis** : Node.js 18+, TypeScript, async/await, concepts ORM

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre l'approche schema-first de Prisma
- Configurer Prisma avec MariaDB/MySQL
- Ma√Ætriser la syntaxe du schema Prisma
- Utiliser Prisma Client pour des requ√™tes type-safe
- G√©rer les migrations avec Prisma Migrate
- Optimiser les performances (relations, transactions)
- Int√©grer Prisma avec Next.js, Express, Fastify
- Utiliser Prisma Studio pour l'administration

---

## Introduction √† Prisma

### Qu'est-ce que Prisma ?

**Prisma** est un ORM moderne nouvelle g√©n√©ration qui adopte une approche **schema-first** et offre une **type-safety compl√®te** avec TypeScript. Contrairement aux ORMs traditionnels, Prisma g√©n√®re un client sur-mesure bas√© sur votre sch√©ma.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Architecture Prisma                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Application TypeScript         ‚îÇ
‚îÇ  (Next.js, Express, Fastify...)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Prisma Client (Generated)      ‚îÇ
‚îÇ  ‚Ä¢ Type-safe queries               ‚îÇ
‚îÇ  ‚Ä¢ Auto-completion                 ‚îÇ
‚îÇ  ‚Ä¢ Relations handling              ‚îÇ
‚îÇ  ‚Ä¢ Transaction API                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Prisma Schema (schema.prisma)  ‚îÇ
‚îÇ  ‚Ä¢ Model definitions               ‚îÇ
‚îÇ  ‚Ä¢ Relations                       ‚îÇ
‚îÇ  ‚Ä¢ Datasource config               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Prisma Migrate                 ‚îÇ
‚îÇ  ‚Ä¢ Schema migrations               ‚îÇ
‚îÇ  ‚Ä¢ Migration history               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        MariaDB Server              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Prisma vs Sequelize

| Aspect | Prisma | Sequelize |
|--------|--------|-----------|
| **Approche** | Schema-first | Code-first |
| **Type-safety** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellente | ‚≠ê‚≠ê‚≠ê Bonne (avec TS) |
| **DX** | Moderne, auto-completion | Traditionnel |
| **Migrations** | D√©claratives | Imp√©ratives |
| **Requ√™tes** | Fluent API | Query builder |
| **Raw SQL** | ‚úÖ Support | ‚úÖ Support |
| **Courbe d'apprentissage** | Rapide | Moyenne |
| **Performance** | Optimis√©e | Bonne |

üí° **Conseil** : Utilisez **Prisma** pour les nouveaux projets TypeScript o√π la type-safety et le DX sont prioritaires. Utilisez **Sequelize** pour les projets JavaScript legacy ou si vous pr√©f√©rez le code-first.

---

## Installation et configuration

### Installation

```bash
# Initialiser un projet TypeScript
npm init -y
npm install typescript ts-node @types/node --save-dev
npx tsc --init

# Installer Prisma
npm install prisma --save-dev
npm install @prisma/client

# Initialiser Prisma
npx prisma init
```

### Structure cr√©√©e

```
project/
‚îú‚îÄ‚îÄ node_modules/
‚îú‚îÄ‚îÄ prisma/
‚îÇ   ‚îî‚îÄ‚îÄ schema.prisma    # Sch√©ma de la base de donn√©es
‚îú‚îÄ‚îÄ .env                 # Variables d'environnement
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ tsconfig.json
```

### Configuration .env

```env
# .env
DATABASE_URL="mysql://app_user:SecureP@ssw0rd!@localhost:3306/production_db"

# Optionnel : Connection pool
# DATABASE_URL="mysql://app_user:SecureP@ssw0rd!@localhost:3306/production_db?connection_limit=10&pool_timeout=20"
```

### tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
```

---

## Schema Prisma

### Configuration de base

```prisma
// prisma/schema.prisma

// G√©n√©rateur du client Prisma
generator client {
  provider = "prisma-client-js"
  // Options
  previewFeatures = ["fullTextSearch", "fullTextIndex"]
  binaryTargets = ["native"]
}

// Datasource MariaDB/MySQL
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
  relationMode = "prisma"  // ou "foreignKeys" pour MariaDB 10.5+
}

// Mod√®le User
model User {
  id            Int       @id @default(autoincrement())
  username      String    @unique @db.VarChar(50)
  email         String    @unique @db.VarChar(255)
  passwordHash  String    @map("password_hash") @db.VarChar(255)
  firstName     String?   @map("first_name") @db.VarChar(100)
  lastName      String?   @map("last_name") @db.VarChar(100)
  isActive      Boolean   @default(true) @map("is_active")
  isAdmin       Boolean   @default(false) @map("is_admin")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  lastLogin     DateTime? @map("last_login")
  
  // Relations
  orders        Order[]
  roles         UserRole[]
  
  @@index([email])
  @@index([username])
  @@index([isActive, createdAt], name: "idx_active_created")
  @@map("users")
}

// Mod√®le Order
model Order {
  id          Int         @id @default(autoincrement())
  userId      Int         @map("user_id")
  totalAmount Decimal     @default(0) @map("total_amount") @db.Decimal(10, 2)
  status      OrderStatus @default(PENDING)
  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")
  
  // Relations
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  items       OrderItem[]
  
  @@index([userId, status])
  @@map("orders")
}

// Enum
enum OrderStatus {
  PENDING
  CONFIRMED
  SHIPPED
  DELIVERED
  CANCELLED
}

// Mod√®le OrderItem
model OrderItem {
  id        Int     @id @default(autoincrement())
  orderId   Int     @map("order_id")
  productId Int     @map("product_id")
  quantity  Int
  price     Decimal @db.Decimal(10, 2)
  
  // Relations
  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product   Product @relation(fields: [productId], references: [id])
  
  @@unique([orderId, productId])
  @@map("order_items")
}

// Mod√®le Product
model Product {
  id          Int         @id @default(autoincrement())
  name        String      @db.VarChar(255)
  description String?     @db.Text
  price       Decimal     @db.Decimal(10, 2)
  stock       Int         @default(0)
  isActive    Boolean     @default(true) @map("is_active")
  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")
  
  // Relations
  orderItems  OrderItem[]
  
  @@index([isActive, price])
  @@map("products")
}
```

### Types de donn√©es MariaDB

```prisma
model DataTypesExample {
  id            Int       @id @default(autoincrement())
  
  // Texte
  shortText     String    @db.VarChar(50)
  longText      String    @db.Text
  mediumText    String    @db.MediumText
  tinyText      String    @db.TinyText
  
  // Nombres
  tinyInt       Int       @db.TinyInt
  smallInt      Int       @db.SmallInt
  intValue      Int
  bigInt        BigInt
  
  // D√©cimaux
  price         Decimal   @db.Decimal(10, 2)
  floatValue    Float     @db.Float
  doubleValue   Float     @db.Double
  
  // Dates et temps
  dateOnly      DateTime  @db.Date
  timeOnly      DateTime  @db.Time(0)
  dateTime      DateTime  @db.DateTime(0)
  timestamp     DateTime  @default(now()) @db.Timestamp(0)
  
  // Boolean (TINYINT(1))
  flag          Boolean
  
  // JSON (MariaDB 10.2+)
  metadata      Json
  
  // Enum
  status        Status
  
  // UUID
  uuid          String    @db.Char(36)
  
  // Binary
  fileData      Bytes
  
  @@map("data_types_example")
}

enum Status {
  PENDING
  ACTIVE
  INACTIVE
}
```

### Relations

```prisma
// One-to-Many (User -> Orders)
model User {
  id     Int     @id @default(autoincrement())
  orders Order[] // Relation 1:N
  
  @@map("users")
}

model Order {
  id     Int  @id @default(autoincrement())
  userId Int  @map("user_id")
  
  user   User @relation(fields: [userId], references: [id])
  
  @@map("orders")
}

// Many-to-Many (User <-> Role)
model User {
  id    Int        @id @default(autoincrement())
  roles UserRole[]
  
  @@map("users")
}

model Role {
  id    Int        @id @default(autoincrement())
  name  String     @unique @db.VarChar(50)
  users UserRole[]
  
  @@map("roles")
}

// Table de jonction explicite
model UserRole {
  userId     Int      @map("user_id")
  roleId     Int      @map("role_id")
  assignedAt DateTime @default(now()) @map("assigned_at")
  
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role       Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  
  @@id([userId, roleId])
  @@map("user_roles")
}

// Self-relation (User -> Manager)
model User {
  id         Int     @id @default(autoincrement())
  managerId  Int?    @map("manager_id")
  
  manager    User?   @relation("UserManager", fields: [managerId], references: [id])
  employees  User[]  @relation("UserManager")
  
  @@map("users")
}
```

---

## Prisma Client

### G√©n√©ration et initialisation

```bash
# G√©n√©rer le client Prisma
npx prisma generate

# Le client est g√©n√©r√© dans node_modules/@prisma/client
```

```typescript
// src/lib/prisma.ts
import { PrismaClient } from '@prisma/client';

// PrismaClient Singleton
const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' 
      ? ['query', 'info', 'warn', 'error']
      : ['error'],
  });

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}

// Graceful shutdown
process.on('beforeExit', async () => {
  await prisma.$disconnect();
});
```

### CRUD de base

```typescript
// src/repositories/UserRepository.ts
import { prisma } from '../lib/prisma';
import { Prisma } from '@prisma/client';

export class UserRepository {
  
  // CREATE
  async create(data: Prisma.UserCreateInput) {
    return prisma.user.create({
      data,
      select: {
        id: true,
        username: true,
        email: true,
        firstName: true,
        lastName: true,
        isActive: true,
        createdAt: true
      }
    });
  }
  
  // READ - Par ID
  async findById(id: number) {
    return prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        username: true,
        email: true,
        firstName: true,
        lastName: true,
        isActive: true,
        isAdmin: true,
        createdAt: true,
        updatedAt: true
      }
    });
  }
  
  // READ - Par email
  async findByEmail(email: string) {
    return prisma.user.findUnique({
      where: { email }
    });
  }
  
  // READ - Liste avec pagination
  async findAll(page = 1, limit = 20) {
    const skip = (page - 1) * limit;
    
    const [users, total] = await Promise.all([
      prisma.user.findMany({
        where: { isActive: true },
        skip,
        take: limit,
        orderBy: { createdAt: 'desc' },
        select: {
          id: true,
          username: true,
          email: true,
          firstName: true,
          lastName: true,
          isActive: true,
          createdAt: true
        }
      }),
      prisma.user.count({
        where: { isActive: true }
      })
    ]);
    
    return {
      users,
      total,
      page,
      pages: Math.ceil(total / limit)
    };
  }
  
  // READ - Recherche
  async search(term: string, limit = 20) {
    return prisma.user.findMany({
      where: {
        isActive: true,
        OR: [
          { username: { contains: term } },
          { email: { contains: term } }
        ]
      },
      take: limit,
      orderBy: { username: 'asc' },
      select: {
        id: true,
        username: true,
        email: true
      }
    });
  }
  
  // UPDATE
  async update(id: number, data: Prisma.UserUpdateInput) {
    return prisma.user.update({
      where: { id },
      data,
      select: {
        id: true,
        username: true,
        email: true,
        firstName: true,
        lastName: true,
        updatedAt: true
      }
    });
  }
  
  // DELETE (soft delete)
  async softDelete(id: number) {
    return prisma.user.update({
      where: { id },
      data: { isActive: false }
    });
  }
  
  // DELETE (hard delete)
  async delete(id: number) {
    return prisma.user.delete({
      where: { id }
    });
  }
  
  // COUNT
  async count() {
    return prisma.user.count({
      where: { isActive: true }
    });
  }
  
  // EXISTS
  async exists(email: string) {
    const user = await prisma.user.findUnique({
      where: { email },
      select: { id: true }
    });
    return user !== null;
  }
}

export default new UserRepository();
```

### Requ√™tes avanc√©es

```typescript
export class UserRepository {
  
  // Avec relations (include)
  async findByIdWithOrders(id: number) {
    return prisma.user.findUnique({
      where: { id },
      include: {
        orders: {
          orderBy: { createdAt: 'desc' },
          take: 10,
          select: {
            id: true,
            totalAmount: true,
            status: true,
            createdAt: true
          }
        }
      }
    });
  }
  
  // Nested includes
  async findByIdWithOrdersAndItems(id: number) {
    return prisma.user.findUnique({
      where: { id },
      include: {
        orders: {
          include: {
            items: {
              include: {
                product: {
                  select: {
                    id: true,
                    name: true,
                    price: true
                  }
                }
              }
            }
          }
        }
      }
    });
  }
  
  // Filtres complexes
  async advancedSearch(params: {
    username?: string;
    email?: string;
    isActive?: boolean;
    createdAfter?: Date;
    createdBefore?: Date;
  }) {
    const where: Prisma.UserWhereInput = {};
    
    if (params.username) {
      where.username = { contains: params.username };
    }
    
    if (params.email) {
      where.email = { contains: params.email };
    }
    
    if (params.isActive !== undefined) {
      where.isActive = params.isActive;
    }
    
    if (params.createdAfter || params.createdBefore) {
      where.createdAt = {};
      if (params.createdAfter) {
        where.createdAt.gte = params.createdAfter;
      }
      if (params.createdBefore) {
        where.createdAt.lte = params.createdBefore;
      }
    }
    
    return prisma.user.findMany({
      where,
      orderBy: { createdAt: 'desc' }
    });
  }
  
  // Agr√©gations
  async getUserStats() {
    const users = await prisma.user.findMany({
      where: {
        orders: {
          some: {}  // Au moins une commande
        }
      },
      select: {
        id: true,
        username: true,
        _count: {
          select: { orders: true }
        },
        orders: {
          select: {
            totalAmount: true
          }
        }
      }
    });
    
    return users.map(user => ({
      id: user.id,
      username: user.username,
      orderCount: user._count.orders,
      totalSpent: user.orders.reduce((sum, order) => {
        return sum + Number(order.totalAmount);
      }, 0)
    }));
  }
  
  // Agr√©gations avec groupBy
  async getActiveUsersCount() {
    const result = await prisma.user.groupBy({
      by: ['isActive'],
      _count: {
        id: true
      }
    });
    
    return result.find(r => r.isActive)?._count.id || 0;
  }
  
  // Bulk operations
  async bulkUpdateStatus(userIds: number[], isActive: boolean) {
    return prisma.user.updateMany({
      where: {
        id: { in: userIds }
      },
      data: {
        isActive
      }
    });
  }
  
  async bulkCreate(usersData: Prisma.UserCreateManyInput[]) {
    return prisma.user.createMany({
      data: usersData,
      skipDuplicates: true  // Ignorer les doublons
    });
  }
  
  async bulkDelete(userIds: number[]) {
    return prisma.user.deleteMany({
      where: {
        id: { in: userIds }
      }
    });
  }
}
```

---

## Transactions

### Transaction simple

```typescript
// src/repositories/OrderRepository.ts
import { prisma } from '../lib/prisma';
import { Prisma } from '@prisma/client';

export class OrderRepository {
  
  async createOrderWithItems(
    userId: number,
    items: Array<{ productId: number; quantity: number }>
  ) {
    return prisma.$transaction(async (tx) => {
      // 1. Cr√©er la commande
      const order = await tx.order.create({
        data: {
          userId,
          status: 'PENDING',
          totalAmount: 0
        }
      });
      
      let totalAmount = 0;
      
      // 2. Traiter chaque item
      for (const item of items) {
        // R√©cup√©rer le produit
        const product = await tx.product.findUnique({
          where: { id: item.productId }
        });
        
        if (!product) {
          throw new Error(`Product ${item.productId} not found`);
        }
        
        if (product.stock < item.quantity) {
          throw new Error(`Insufficient stock for product ${product.id}`);
        }
        
        // Cr√©er l'item
        await tx.orderItem.create({
          data: {
            orderId: order.id,
            productId: product.id,
            quantity: item.quantity,
            price: product.price
          }
        });
        
        // D√©cr√©menter le stock
        await tx.product.update({
          where: { id: product.id },
          data: {
            stock: { decrement: item.quantity }
          }
        });
        
        totalAmount += Number(product.price) * item.quantity;
      }
      
      // 3. Mettre √† jour le total
      const updatedOrder = await tx.order.update({
        where: { id: order.id },
        data: {
          totalAmount
        },
        include: {
          items: {
            include: {
              product: true
            }
          }
        }
      });
      
      return updatedOrder;
    });
  }
  
  // Transaction avec isolation level
  async cancelOrder(orderId: number) {
    return prisma.$transaction(
      async (tx) => {
        // R√©cup√©rer la commande avec items
        const order = await tx.order.findUnique({
          where: { id: orderId },
          include: { items: true }
        });
        
        if (!order) {
          throw new Error('Order not found');
        }
        
        if (order.status === 'CANCELLED') {
          throw new Error('Order already cancelled');
        }
        
        // Remettre le stock
        for (const item of order.items) {
          await tx.product.update({
            where: { id: item.productId },
            data: {
              stock: { increment: item.quantity }
            }
          });
        }
        
        // Mettre √† jour le statut
        return tx.order.update({
          where: { id: orderId },
          data: { status: 'CANCELLED' }
        });
      },
      {
        isolationLevel: Prisma.TransactionIsolationLevel.Serializable,
        maxWait: 5000,  // Attente max 5s
        timeout: 10000  // Timeout 10s
      }
    );
  }
  
  // Transaction interactive
  async complexTransaction() {
    return prisma.$transaction(async (tx) => {
      // Transaction 1
      const user = await tx.user.create({
        data: {
          username: 'newuser',
          email: 'new@example.com',
          passwordHash: 'hashed'
        }
      });
      
      // Transaction 2 - d√©pend de 1
      const order = await tx.order.create({
        data: {
          userId: user.id,
          totalAmount: 100
        }
      });
      
      // Transaction 3 - d√©pend de 2
      await tx.orderItem.create({
        data: {
          orderId: order.id,
          productId: 1,
          quantity: 2,
          price: 50
        }
      });
      
      return { user, order };
    });
  }
}

export default new OrderRepository();
```

### Batch transactions

```typescript
// Transaction par batch pour performance
async bulkCreateOrders(ordersData: any[]) {
  const BATCH_SIZE = 100;
  const results = [];
  
  for (let i = 0; i < ordersData.length; i += BATCH_SIZE) {
    const batch = ordersData.slice(i, i + BATCH_SIZE);
    
    const batchResults = await prisma.$transaction(
      batch.map(orderData =>
        prisma.order.create({ data: orderData })
      )
    );
    
    results.push(...batchResults);
  }
  
  return results;
}
```

---

## Migrations avec Prisma Migrate

### Cr√©er et appliquer des migrations

```bash
# Cr√©er une migration (d√©veloppement)
npx prisma migrate dev --name create_users_table

# Appliquer les migrations (production)
npx prisma migrate deploy

# Reset de la base de donn√©es
npx prisma migrate reset

# Voir l'√©tat des migrations
npx prisma migrate status

# Cr√©er une migration vide (pour SQL custom)
npx prisma migrate dev --create-only --name custom_indexes
```

### Workflow de migration

```bash
# 1. Modifier schema.prisma
# Ajouter un nouveau champ par exemple

# 2. Cr√©er la migration
npx prisma migrate dev --name add_phone_to_users

# 3. La migration est cr√©√©e dans prisma/migrations/
# 4. Le client Prisma est r√©g√©n√©r√© automatiquement

# 5. En production
npx prisma migrate deploy
```

### Migration personnalis√©e

```sql
-- prisma/migrations/20240115000001_custom_indexes/migration.sql

-- CreateIndex
CREATE INDEX `idx_user_email_active` ON `users`(`email`, `is_active`);

-- CreateFullTextIndex (MariaDB 10.0.5+)
CREATE FULLTEXT INDEX `idx_product_name_description` 
ON `products`(`name`, `description`);

-- Custom function
DELIMITER $$
CREATE FUNCTION get_user_order_count(user_id INT) 
RETURNS INT
DETERMINISTIC
BEGIN
    DECLARE order_count INT;
    SELECT COUNT(*) INTO order_count 
    FROM orders 
    WHERE user_id = user_id;
    RETURN order_count;
END$$
DELIMITER ;
```

---

## Optimisations de performance

### √âviter le probl√®me N+1

```typescript
// ‚ùå MAUVAIS : N+1 queries
const orders = await prisma.order.findMany();

for (const order of orders) {
  const user = await prisma.user.findUnique({
    where: { id: order.userId }
  });
  console.log(user.username);  // 1 query par order !
}

// ‚úÖ BON : include (eager loading)
const orders = await prisma.order.findMany({
  include: {
    user: {
      select: {
        id: true,
        username: true,
        email: true
      }
    }
  }
});

for (const order of orders) {
  console.log(order.user.username);  // D√©j√† charg√©
}

// ‚úÖ BON : Nested includes
const users = await prisma.user.findMany({
  include: {
    orders: {
      include: {
        items: {
          include: {
            product: true
          }
        }
      }
    }
  }
});
```

### Select vs Include

```typescript
// Select : choisir les champs
const users = await prisma.user.findMany({
  select: {
    id: true,
    username: true,
    email: true
  }
});

// Include : charger les relations
const users = await prisma.user.findMany({
  include: {
    orders: true
  }
});

// Combiner select et include
const users = await prisma.user.findMany({
  select: {
    id: true,
    username: true,
    orders: {
      select: {
        id: true,
        totalAmount: true
      }
    }
  }
});
```

### Pagination cursor-based

```typescript
// Pagination offset (simple)
async findAllOffset(page = 1, limit = 20) {
  const skip = (page - 1) * limit;
  
  return prisma.user.findMany({
    skip,
    take: limit,
    orderBy: { id: 'asc' }
  });
}

// Pagination cursor (performante pour grandes tables)
async findAllCursor(cursor?: number, limit = 20) {
  return prisma.user.findMany({
    take: limit,
    ...(cursor && {
      skip: 1,  // Skip le cursor lui-m√™me
      cursor: { id: cursor }
    }),
    orderBy: { id: 'asc' }
  });
}

// Utilisation
const firstPage = await findAllCursor(undefined, 20);
const lastId = firstPage[firstPage.length - 1].id;
const secondPage = await findAllCursor(lastId, 20);
```

### Indexation et requ√™tes optimis√©es

```prisma
// schema.prisma

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  username  String   @unique
  isActive  Boolean
  createdAt DateTime @default(now())
  
  // Index composites pour requ√™tes fr√©quentes
  @@index([isActive, createdAt])
  @@index([email, isActive])
  
  @@map("users")
}

model Product {
  name        String
  description String? @db.Text
  price       Decimal @db.Decimal(10, 2)
  isActive    Boolean
  
  // Index full-text (MariaDB 10.0.5+)
  @@fulltext([name, description])
  
  // Index composite pour filtres
  @@index([isActive, price])
  
  @@map("products")
}
```

### Raw queries pour performance

```typescript
// Raw query pour requ√™tes complexes
async getUserStatsRaw() {
  const result = await prisma.$queryRaw<Array<{
    id: number;
    username: string;
    order_count: bigint;
    total_spent: number;
  }>>`
    SELECT 
      u.id,
      u.username,
      COUNT(o.id) as order_count,
      COALESCE(SUM(o.total_amount), 0) as total_spent
    FROM users u
    LEFT JOIN orders o ON u.id = o.user_id
    WHERE u.is_active = true
    GROUP BY u.id, u.username
    HAVING COUNT(o.id) > 0
    ORDER BY total_spent DESC
    LIMIT 10
  `;
  
  return result;
}

// Execute raw (pour INSERT, UPDATE, DELETE)
async bulkUpdateRaw(userIds: number[]) {
  return prisma.$executeRaw`
    UPDATE users 
    SET is_active = false, updated_at = NOW()
    WHERE id IN (${Prisma.join(userIds)})
  `;
}

// Type-safe raw queries avec Prisma.sql
import { Prisma } from '@prisma/client';

async findByEmailRaw(email: string) {
  return prisma.$queryRaw<User[]>`
    SELECT * FROM users 
    WHERE email = ${email}
  `;
}
```

---

## Int√©gration avec frameworks

### Express.js

```typescript
// src/app.ts
import express from 'express';
import { prisma } from './lib/prisma';
import userRoutes from './routes/userRoutes';

const app = express();

app.use(express.json());

// Routes
app.use('/api/users', userRoutes);

// Health check
app.get('/health', async (req, res) => {
  try {
    await prisma.$queryRaw`SELECT 1`;
    res.json({ status: 'ok', database: 'connected' });
  } catch (error) {
    res.status(500).json({ status: 'error', database: 'disconnected' });
  }
});

// Error handler
app.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error(err);
  res.status(500).json({ error: err.message });
});

const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

// Graceful shutdown
process.on('SIGTERM', async () => {
  await prisma.$disconnect();
  process.exit(0);
});

export default app;
```

```typescript
// src/routes/userRoutes.ts
import { Router } from 'express';
import UserController from '../controllers/UserController';

const router = Router();

router.get('/', UserController.list);
router.get('/:id', UserController.getById);
router.post('/', UserController.create);
router.put('/:id', UserController.update);
router.delete('/:id', UserController.delete);

export default router;

// src/controllers/UserController.ts
import { Request, Response } from 'express';
import { UserRepository } from '../repositories/UserRepository';
import { Prisma } from '@prisma/client';

const userRepo = new UserRepository();

class UserController {
  
  async list(req: Request, res: Response) {
    try {
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 20;
      
      const result = await userRepo.findAll(page, limit);
      res.json(result);
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
  }
  
  async getById(req: Request, res: Response) {
    try {
      const id = parseInt(req.params.id);
      const user = await userRepo.findById(id);
      
      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      res.json(user);
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
  }
  
  async create(req: Request, res: Response) {
    try {
      const user = await userRepo.create(req.body);
      res.status(201).json(user);
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
          return res.status(409).json({
            error: 'Unique constraint violation',
            field: error.meta?.target
          });
        }
      }
      res.status(500).json({ error: (error as Error).message });
    }
  }
  
  async update(req: Request, res: Response) {
    try {
      const id = parseInt(req.params.id);
      const user = await userRepo.update(id, req.body);
      res.json(user);
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2025') {
          return res.status(404).json({ error: 'User not found' });
        }
      }
      res.status(500).json({ error: (error as Error).message });
    }
  }
  
  async delete(req: Request, res: Response) {
    try {
      const id = parseInt(req.params.id);
      await userRepo.softDelete(id);
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: (error as Error).message });
    }
  }
}

export default new UserController();
```

### Next.js 13+ (App Router)

```typescript
// app/api/users/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');
    
    const skip = (page - 1) * limit;
    
    const [users, total] = await Promise.all([
      prisma.user.findMany({
        where: { isActive: true },
        skip,
        take: limit,
        orderBy: { createdAt: 'desc' },
        select: {
          id: true,
          username: true,
          email: true,
          createdAt: true
        }
      }),
      prisma.user.count({ where: { isActive: true } })
    ]);
    
    return NextResponse.json({
      users,
      total,
      page,
      pages: Math.ceil(total / limit)
    });
  } catch (error) {
    return NextResponse.json(
      { error: (error as Error).message },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    const user = await prisma.user.create({
      data: body,
      select: {
        id: true,
        username: true,
        email: true,
        createdAt: true
      }
    });
    
    return NextResponse.json(user, { status: 201 });
  } catch (error) {
    return NextResponse.json(
      { error: (error as Error).message },
      { status: 500 }
    );
  }
}

// app/api/users/[id]/route.ts
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const user = await prisma.user.findUnique({
      where: { id: parseInt(params.id) }
    });
    
    if (!user) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }
    
    return NextResponse.json(user);
  } catch (error) {
    return NextResponse.json(
      { error: (error as Error).message },
      { status: 500 }
    );
  }
}
```

---

## Prisma Studio

### Lancement

```bash
# Ouvrir Prisma Studio (GUI)
npx prisma studio

# Ouverture automatique dans le navigateur sur http://localhost:5555
```

**Fonctionnalit√©s** :
- Visualiser toutes les tables
- Cr√©er, modifier, supprimer des enregistrements
- Filtrer et trier les donn√©es
- Explorer les relations
- Ex√©cuter des requ√™tes

---

## ‚úÖ Points cl√©s √† retenir

1. **Schema-first** : D√©finir le sch√©ma dans `schema.prisma` puis g√©n√©rer le client
2. **Type-safety** : Types TypeScript g√©n√©r√©s automatiquement
3. **Prisma Client** : Auto-compl√©tion et validation compile-time
4. **Migrations** : `prisma migrate dev` pour d√©veloppement, `deploy` pour production
5. **Include** : Toujours charger les relations n√©cessaires pour √©viter N+1
6. **Select** : S√©lectionner uniquement les champs n√©cessaires
7. **Transactions** : `$transaction` pour op√©rations atomiques
8. **Raw queries** : `$queryRaw` pour requ√™tes SQL complexes
9. **Prisma Studio** : GUI pour l'administration
10. **Singleton** : Une seule instance de PrismaClient par application

---

## üîó Ressources

### Documentation officielle
- [üìñ Prisma Documentation](https://www.prisma.io/docs)
- [üìñ Prisma Client API](https://www.prisma.io/docs/concepts/components/prisma-client)
- [üìñ Prisma Migrate](https://www.prisma.io/docs/concepts/components/prisma-migrate)

### Guides
- [Prisma with Next.js](https://www.prisma.io/nextjs)
- [Prisma Best Practices](https://www.prisma.io/docs/guides/performance-and-optimization)

---

## ‚û°Ô∏è Section suivante

**17.3.5 Entity Framework Core (.NET)** : ORM Microsoft moderne avec LINQ, migrations code-first, et optimisations pour MariaDB avec MySqlConnector/MariaDB.Data.

‚è≠Ô∏è [Entity Framework Core (.NET)](/17-integration-developpement/03.5-entity-framework-core.md)
