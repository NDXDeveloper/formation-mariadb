ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 17.3.5 Entity Framework Core (.NET)

> **Niveau** : IntermÃ©diaire Ã  AvancÃ©  
> **DurÃ©e estimÃ©e** : 4-5 heures  
> **PrÃ©requis** : .NET 8+, C# 12+, LINQ, concepts ORM, async/await

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Configurer EF Core avec Pomelo.EntityFrameworkCore.MySql
- MaÃ®triser les approches Code-First et Database-First
- DÃ©finir des entitÃ©s et relations avec Fluent API
- GÃ©rer les migrations EF Core
- Utiliser LINQ to SQL efficacement
- Optimiser les performances (N+1, tracking, lazy loading)
- ImplÃ©menter les bonnes pratiques EF Core-MariaDB
- IntÃ©grer EF Core avec ASP.NET Core

---

## Introduction Ã  Entity Framework Core

### Qu'est-ce qu'EF Core ?

**Entity Framework Core** est l'ORM moderne de Microsoft pour .NET. C'est une rÃ©Ã©criture complÃ¨te et open-source d'Entity Framework, optimisÃ©e pour la performance et la compatibilitÃ© multi-plateforme.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Architecture EF Core                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Application .NET                â”‚
â”‚  (ASP.NET Core, Console, Blazor...) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Entity Framework Core           â”‚
â”‚  â€¢ DbContext                        â”‚
â”‚  â€¢ LINQ Provider                    â”‚
â”‚  â€¢ Change Tracker                   â”‚
â”‚  â€¢ Migrations                       â”‚
â”‚  â€¢ Query optimization               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Database Provider               â”‚
â”‚  â€¢ Pomelo.EntityFrameworkCore.MySql â”‚
â”‚  â€¢ MySql.EntityFrameworkCore        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     MySqlConnector / MariaDB        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        MariaDB Server               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Pomelo vs MySql.EntityFrameworkCore

| Aspect | Pomelo | MySql.EntityFrameworkCore |
|--------|--------|---------------------------|
| **Maintien** | â­â­â­â­â­ Actif | â­â­â­ Officiel Oracle |
| **Performance** | Excellente | Bonne |
| **MariaDB** | âœ… Support natif | âš ï¸ MySQL focus |
| **Async** | âœ… Natif | âœ… Support |
| **Community** | Grande | Oracle |
| **License** | MIT | GPL |

ğŸ’¡ **Recommandation** : Utilisez **Pomelo.EntityFrameworkCore.MySql** pour MariaDB - meilleur support, performance, et license MIT.

---

## Installation et configuration

### Packages NuGet

```xml
<!-- .csproj -->
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <!-- EF Core -->
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.0">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="8.0.0">
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    
    <!-- Provider Pomelo (recommandÃ©) -->
    <PackageReference Include="Pomelo.EntityFrameworkCore.MySql" Version="8.0.0" />
    
    <!-- Configuration -->
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="8.0.0" />
  </ItemGroup>
</Project>
```

### Installation via CLI

```bash
# Pomelo provider
dotnet add package Pomelo.EntityFrameworkCore.MySql

# EF Core tools
dotnet add package Microsoft.EntityFrameworkCore.Design
dotnet add package Microsoft.EntityFrameworkCore.Tools

# CLI tools (global)
dotnet tool install --global dotnet-ef
```

### Configuration appsettings.json

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost;Port=3306;Database=production_db;User=app_user;Password=SecureP@ssw0rd!;CharSet=utf8mb4;",
    "MariaDbConnection": "Server=localhost;Port=3306;Database=production_db;User=app_user;Password=SecureP@ssw0rd!;CharSet=utf8mb4;SslMode=Preferred;AllowPublicKeyRetrieval=true;"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.EntityFrameworkCore.Database.Command": "Information"
    }
  }
}
```

---

## DbContext de base

### Configuration Code-First

```csharp
// Data/ApplicationDbContext.cs
using Microsoft.EntityFrameworkCore;
using YourApp.Models;

namespace YourApp.Data;

public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }
    
    // DbSets (Tables)
    public DbSet<User> Users => Set<User>();
    public DbSet<Order> Orders => Set<Order>();
    public DbSet<OrderItem> OrderItems => Set<OrderItem>();
    public DbSet<Product> Products => Set<Product>();
    public DbSet<Role> Roles => Set<Role>();
    public DbSet<UserRole> UserRoles => Set<UserRole>();
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        
        // Appliquer les configurations
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(ApplicationDbContext).Assembly);
        
        // Ou configurer directement
        ConfigureUser(modelBuilder);
        ConfigureOrder(modelBuilder);
        ConfigureOrderItem(modelBuilder);
        ConfigureProduct(modelBuilder);
        ConfigureUserRole(modelBuilder);
    }
    
    private void ConfigureUser(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<User>(entity =>
        {
            entity.ToTable("users");
            
            entity.HasKey(e => e.Id);
            
            entity.Property(e => e.Id)
                .HasColumnName("id");
            
            entity.Property(e => e.Username)
                .HasColumnName("username")
                .HasMaxLength(50)
                .IsRequired();
            
            entity.Property(e => e.Email)
                .HasColumnName("email")
                .HasMaxLength(255)
                .IsRequired();
            
            entity.Property(e => e.PasswordHash)
                .HasColumnName("password_hash")
                .HasMaxLength(255)
                .IsRequired();
            
            entity.Property(e => e.FirstName)
                .HasColumnName("first_name")
                .HasMaxLength(100);
            
            entity.Property(e => e.LastName)
                .HasColumnName("last_name")
                .HasMaxLength(100);
            
            entity.Property(e => e.IsActive)
                .HasColumnName("is_active")
                .HasDefaultValue(true)
                .IsRequired();
            
            entity.Property(e => e.IsAdmin)
                .HasColumnName("is_admin")
                .HasDefaultValue(false)
                .IsRequired();
            
            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .HasDefaultValueSql("CURRENT_TIMESTAMP")
                .IsRequired();
            
            entity.Property(e => e.UpdatedAt)
                .HasColumnName("updated_at")
                .ValueGeneratedOnAddOrUpdate();
            
            entity.Property(e => e.LastLogin)
                .HasColumnName("last_login");
            
            // Index
            entity.HasIndex(e => e.Email)
                .IsUnique()
                .HasDatabaseName("idx_email");
            
            entity.HasIndex(e => e.Username)
                .IsUnique()
                .HasDatabaseName("idx_username");
            
            entity.HasIndex(e => new { e.IsActive, e.CreatedAt })
                .HasDatabaseName("idx_active_created");
            
            // Relations
            entity.HasMany(e => e.Orders)
                .WithOne(e => e.User)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);
        });
    }
    
    private void ConfigureOrder(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Order>(entity =>
        {
            entity.ToTable("orders");
            
            entity.HasKey(e => e.Id);
            
            entity.Property(e => e.TotalAmount)
                .HasColumnName("total_amount")
                .HasColumnType("DECIMAL(10,2)")
                .HasDefaultValue(0)
                .IsRequired();
            
            entity.Property(e => e.Status)
                .HasColumnName("status")
                .HasMaxLength(20)
                .HasConversion<string>()
                .IsRequired();
            
            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .HasDefaultValueSql("CURRENT_TIMESTAMP");
            
            // Relations
            entity.HasMany(e => e.Items)
                .WithOne(e => e.Order)
                .HasForeignKey(e => e.OrderId)
                .OnDelete(DeleteBehavior.Cascade);
        });
    }
    
    private void ConfigureOrderItem(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<OrderItem>(entity =>
        {
            entity.ToTable("order_items");
            
            entity.HasKey(e => e.Id);
            
            entity.Property(e => e.Quantity)
                .HasColumnName("quantity")
                .IsRequired();
            
            entity.Property(e => e.Price)
                .HasColumnName("price")
                .HasColumnType("DECIMAL(10,2)")
                .IsRequired();
            
            // Relations
            entity.HasOne(e => e.Product)
                .WithMany()
                .HasForeignKey(e => e.ProductId)
                .OnDelete(DeleteBehavior.Restrict);
        });
    }
    
    private void ConfigureProduct(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Product>(entity =>
        {
            entity.ToTable("products");
            
            entity.Property(e => e.Name)
                .HasColumnName("name")
                .HasMaxLength(255)
                .IsRequired();
            
            entity.Property(e => e.Description)
                .HasColumnName("description")
                .HasColumnType("TEXT");
            
            entity.Property(e => e.Price)
                .HasColumnName("price")
                .HasColumnType("DECIMAL(10,2)")
                .IsRequired();
            
            entity.Property(e => e.Stock)
                .HasColumnName("stock")
                .HasDefaultValue(0)
                .IsRequired();
            
            entity.HasIndex(e => new { e.IsActive, e.Price })
                .HasDatabaseName("idx_active_price");
        });
    }
    
    private void ConfigureUserRole(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<UserRole>(entity =>
        {
            entity.ToTable("user_roles");
            
            // ClÃ© composite
            entity.HasKey(e => new { e.UserId, e.RoleId });
            
            entity.Property(e => e.AssignedAt)
                .HasColumnName("assigned_at")
                .HasDefaultValueSql("CURRENT_TIMESTAMP");
            
            // Relations Many-to-Many
            entity.HasOne(e => e.User)
                .WithMany(e => e.UserRoles)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);
            
            entity.HasOne(e => e.Role)
                .WithMany(e => e.UserRoles)
                .HasForeignKey(e => e.RoleId)
                .OnDelete(DeleteBehavior.Cascade);
        });
    }
}
```

---

## ModÃ¨les (EntitÃ©s)

### ModÃ¨le de base

```csharp
// Models/User.cs
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace YourApp.Models;

public class User
{
    public int Id { get; set; }
    
    [Required]
    [MaxLength(50)]
    public string Username { get; set; } = string.Empty;
    
    [Required]
    [MaxLength(255)]
    [EmailAddress]
    public string Email { get; set; } = string.Empty;
    
    [Required]
    [MaxLength(255)]
    public string PasswordHash { get; set; } = string.Empty;
    
    [MaxLength(100)]
    public string? FirstName { get; set; }
    
    [MaxLength(100)]
    public string? LastName { get; set; }
    
    public bool IsActive { get; set; } = true;
    
    public bool IsAdmin { get; set; } = false;
    
    public DateTime CreatedAt { get; set; }
    
    public DateTime? UpdatedAt { get; set; }
    
    public DateTime? LastLogin { get; set; }
    
    // Relations
    public ICollection<Order> Orders { get; set; } = new List<Order>();
    public ICollection<UserRole> UserRoles { get; set; } = new List<UserRole>();
    
    // PropriÃ©tÃ©s calculÃ©es
    [NotMapped]
    public string FullName => $"{FirstName} {LastName}".Trim();
    
    [NotMapped]
    public IEnumerable<Role> Roles => UserRoles.Select(ur => ur.Role);
}

// Models/Order.cs
public class Order
{
    public int Id { get; set; }
    
    public int UserId { get; set; }
    
    public decimal TotalAmount { get; set; }
    
    public OrderStatus Status { get; set; }
    
    public DateTime CreatedAt { get; set; }
    
    public DateTime? UpdatedAt { get; set; }
    
    // Relations
    public User User { get; set; } = null!;
    public ICollection<OrderItem> Items { get; set; } = new List<OrderItem>();
    
    // MÃ©thodes
    public void RecalculateTotal()
    {
        TotalAmount = Items.Sum(item => item.Subtotal);
    }
}

public enum OrderStatus
{
    Pending,
    Confirmed,
    Shipped,
    Delivered,
    Cancelled
}

// Models/OrderItem.cs
public class OrderItem
{
    public int Id { get; set; }
    
    public int OrderId { get; set; }
    
    public int ProductId { get; set; }
    
    public int Quantity { get; set; }
    
    public decimal Price { get; set; }
    
    // Relations
    public Order Order { get; set; } = null!;
    public Product Product { get; set; } = null!;
    
    // PropriÃ©tÃ©s calculÃ©es
    [NotMapped]
    public decimal Subtotal => Price * Quantity;
}

// Models/Product.cs
public class Product
{
    public int Id { get; set; }
    
    [Required]
    [MaxLength(255)]
    public string Name { get; set; } = string.Empty;
    
    public string? Description { get; set; }
    
    public decimal Price { get; set; }
    
    public int Stock { get; set; }
    
    public bool IsActive { get; set; } = true;
    
    public DateTime CreatedAt { get; set; }
    
    public DateTime? UpdatedAt { get; set; }
}

// Models/Role.cs
public class Role
{
    public int Id { get; set; }
    
    [Required]
    [MaxLength(50)]
    public string Name { get; set; } = string.Empty;
    
    public string? Description { get; set; }
    
    public ICollection<UserRole> UserRoles { get; set; } = new List<UserRole>();
    
    [NotMapped]
    public IEnumerable<User> Users => UserRoles.Select(ur => ur.User);
}

// Models/UserRole.cs (Many-to-Many)
public class UserRole
{
    public int UserId { get; set; }
    
    public int RoleId { get; set; }
    
    public DateTime AssignedAt { get; set; }
    
    // Relations
    public User User { get; set; } = null!;
    public Role Role { get; set; } = null!;
}
```

---

## Configuration avec Fluent API

### IEntityTypeConfiguration

```csharp
// Data/Configurations/UserConfiguration.cs
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using YourApp.Models;

namespace YourApp.Data.Configurations;

public class UserConfiguration : IEntityTypeConfiguration<User>
{
    public void Configure(EntityTypeBuilder<User> builder)
    {
        builder.ToTable("users");
        
        builder.HasKey(e => e.Id);
        
        builder.Property(e => e.Username)
            .HasMaxLength(50)
            .IsRequired();
        
        builder.Property(e => e.Email)
            .HasMaxLength(255)
            .IsRequired();
        
        builder.Property(e => e.CreatedAt)
            .HasDefaultValueSql("CURRENT_TIMESTAMP");
        
        // Index
        builder.HasIndex(e => e.Email).IsUnique();
        builder.HasIndex(e => e.Username).IsUnique();
        builder.HasIndex(e => new { e.IsActive, e.CreatedAt });
        
        // Relations
        builder.HasMany(e => e.Orders)
            .WithOne(e => e.User)
            .HasForeignKey(e => e.UserId)
            .OnDelete(DeleteBehavior.Cascade);
    }
}

// Dans ApplicationDbContext
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    // Appliquer toutes les configurations
    modelBuilder.ApplyConfigurationsFromAssembly(typeof(ApplicationDbContext).Assembly);
}
```

---

## Migrations EF Core

### Commandes de migration

```bash
# CrÃ©er une migration
dotnet ef migrations add InitialCreate

# Appliquer les migrations
dotnet ef database update

# Annuler la derniÃ¨re migration
dotnet ef migrations remove

# GÃ©nÃ©rer un script SQL
dotnet ef migrations script

# Voir les migrations
dotnet ef migrations list

# Revenir Ã  une migration spÃ©cifique
dotnet ef database update MigrationName
```

### Exemple de migration

```csharp
// Migrations/20240115000001_InitialCreate.cs
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace YourApp.Migrations
{
    public partial class InitialCreate : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "users",
                columns: table => new
                {
                    id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("MySql:ValueGenerationStrategy", 
                            MySqlValueGenerationStrategy.IdentityColumn),
                    username = table.Column<string>(type: "varchar(50)", 
                        maxLength: 50, nullable: false)
                        .Annotation("MySql:CharSet", "utf8mb4"),
                    email = table.Column<string>(type: "varchar(255)", 
                        maxLength: 255, nullable: false)
                        .Annotation("MySql:CharSet", "utf8mb4"),
                    password_hash = table.Column<string>(type: "varchar(255)", 
                        maxLength: 255, nullable: false)
                        .Annotation("MySql:CharSet", "utf8mb4"),
                    first_name = table.Column<string>(type: "varchar(100)", 
                        maxLength: 100, nullable: true)
                        .Annotation("MySql:CharSet", "utf8mb4"),
                    last_name = table.Column<string>(type: "varchar(100)", 
                        maxLength: 100, nullable: true)
                        .Annotation("MySql:CharSet", "utf8mb4"),
                    is_active = table.Column<bool>(type: "tinyint(1)", 
                        nullable: false, defaultValue: true),
                    is_admin = table.Column<bool>(type: "tinyint(1)", 
                        nullable: false, defaultValue: false),
                    created_at = table.Column<DateTime>(type: "datetime(6)", 
                        nullable: false, 
                        defaultValueSql: "CURRENT_TIMESTAMP(6)"),
                    updated_at = table.Column<DateTime>(type: "datetime(6)", 
                        nullable: true),
                    last_login = table.Column<DateTime>(type: "datetime(6)", 
                        nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_users", x => x.id);
                })
                .Annotation("MySql:CharSet", "utf8mb4");

            migrationBuilder.CreateIndex(
                name: "idx_email",
                table: "users",
                column: "email",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "idx_username",
                table: "users",
                column: "username",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "idx_active_created",
                table: "users",
                columns: new[] { "is_active", "created_at" });
        }

        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(name: "users");
        }
    }
}
```

---

## RequÃªtes avec LINQ

### CRUD de base

```csharp
// Repositories/UserRepository.cs
using Microsoft.EntityFrameworkCore;
using YourApp.Data;
using YourApp.Models;

namespace YourApp.Repositories;

public class UserRepository
{
    private readonly ApplicationDbContext _context;
    
    public UserRepository(ApplicationDbContext context)
    {
        _context = context;
    }
    
    // CREATE
    public async Task<User> CreateAsync(User user, CancellationToken ct = default)
    {
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);
        return user;
    }
    
    // READ - Par ID
    public async Task<User?> GetByIdAsync(int id, CancellationToken ct = default)
    {
        return await _context.Users
            .AsNoTracking()
            .FirstOrDefaultAsync(u => u.Id == id, ct);
    }
    
    // READ - Par email
    public async Task<User?> GetByEmailAsync(string email, CancellationToken ct = default)
    {
        return await _context.Users
            .AsNoTracking()
            .FirstOrDefaultAsync(u => u.Email == email, ct);
    }
    
    // READ - Liste avec pagination
    public async Task<(List<User> Users, int Total)> GetAllAsync(
        int page = 1, 
        int pageSize = 20, 
        CancellationToken ct = default)
    {
        var query = _context.Users
            .AsNoTracking()
            .Where(u => u.IsActive);
        
        var total = await query.CountAsync(ct);
        
        var users = await query
            .OrderByDescending(u => u.CreatedAt)
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync(ct);
        
        return (users, total);
    }
    
    // READ - Recherche
    public async Task<List<User>> SearchAsync(
        string term, 
        int limit = 20, 
        CancellationToken ct = default)
    {
        return await _context.Users
            .AsNoTracking()
            .Where(u => u.IsActive && 
                (EF.Functions.Like(u.Username, $"%{term}%") ||
                 EF.Functions.Like(u.Email, $"%{term}%")))
            .OrderBy(u => u.Username)
            .Take(limit)
            .ToListAsync(ct);
    }
    
    // UPDATE
    public async Task<User> UpdateAsync(User user, CancellationToken ct = default)
    {
        _context.Users.Update(user);
        await _context.SaveChangesAsync(ct);
        return user;
    }
    
    // DELETE (soft delete)
    public async Task<bool> SoftDeleteAsync(int id, CancellationToken ct = default)
    {
        var user = await _context.Users.FindAsync(new object[] { id }, ct);
        if (user == null) return false;
        
        user.IsActive = false;
        user.UpdatedAt = DateTime.UtcNow;
        await _context.SaveChangesAsync(ct);
        
        return true;
    }
    
    // DELETE (hard delete)
    public async Task<bool> DeleteAsync(int id, CancellationToken ct = default)
    {
        var user = await _context.Users.FindAsync(new object[] { id }, ct);
        if (user == null) return false;
        
        _context.Users.Remove(user);
        await _context.SaveChangesAsync(ct);
        
        return true;
    }
    
    // COUNT
    public async Task<int> CountActiveAsync(CancellationToken ct = default)
    {
        return await _context.Users.CountAsync(u => u.IsActive, ct);
    }
    
    // EXISTS
    public async Task<bool> ExistsAsync(string email, CancellationToken ct = default)
    {
        return await _context.Users.AnyAsync(u => u.Email == email, ct);
    }
}
```

### RequÃªtes avancÃ©es avec LINQ

```csharp
public class UserRepository
{
    // Eager loading avec Include
    public async Task<User?> GetByIdWithOrdersAsync(
        int id, 
        CancellationToken ct = default)
    {
        return await _context.Users
            .Include(u => u.Orders.OrderByDescending(o => o.CreatedAt).Take(10))
            .AsNoTracking()
            .FirstOrDefaultAsync(u => u.Id == id, ct);
    }
    
    // Nested includes
    public async Task<User?> GetByIdWithOrdersAndItemsAsync(
        int id, 
        CancellationToken ct = default)
    {
        return await _context.Users
            .Include(u => u.Orders)
                .ThenInclude(o => o.Items)
                    .ThenInclude(i => i.Product)
            .AsNoTracking()
            .FirstOrDefaultAsync(u => u.Id == id, ct);
    }
    
    // Projection avec Select
    public async Task<List<UserDto>> GetAllDtoAsync(CancellationToken ct = default)
    {
        return await _context.Users
            .Where(u => u.IsActive)
            .Select(u => new UserDto
            {
                Id = u.Id,
                Username = u.Username,
                Email = u.Email,
                FullName = u.FirstName + " " + u.LastName,
                OrderCount = u.Orders.Count
            })
            .ToListAsync(ct);
    }
    
    // Filtres complexes
    public async Task<List<User>> AdvancedSearchAsync(
        UserSearchParams searchParams,
        CancellationToken ct = default)
    {
        var query = _context.Users.AsQueryable();
        
        if (!string.IsNullOrEmpty(searchParams.Username))
        {
            query = query.Where(u => EF.Functions.Like(u.Username, $"%{searchParams.Username}%"));
        }
        
        if (!string.IsNullOrEmpty(searchParams.Email))
        {
            query = query.Where(u => EF.Functions.Like(u.Email, $"%{searchParams.Email}%"));
        }
        
        if (searchParams.IsActive.HasValue)
        {
            query = query.Where(u => u.IsActive == searchParams.IsActive.Value);
        }
        
        if (searchParams.CreatedAfter.HasValue)
        {
            query = query.Where(u => u.CreatedAt >= searchParams.CreatedAfter.Value);
        }
        
        if (searchParams.CreatedBefore.HasValue)
        {
            query = query.Where(u => u.CreatedAt <= searchParams.CreatedBefore.Value);
        }
        
        return await query
            .AsNoTracking()
            .OrderByDescending(u => u.CreatedAt)
            .ToListAsync(ct);
    }
    
    // AgrÃ©gations
    public async Task<List<UserStatsDto>> GetUserStatsAsync(CancellationToken ct = default)
    {
        return await _context.Users
            .Where(u => u.Orders.Any())
            .Select(u => new UserStatsDto
            {
                UserId = u.Id,
                Username = u.Username,
                OrderCount = u.Orders.Count,
                TotalSpent = u.Orders.Sum(o => o.TotalAmount)
            })
            .OrderByDescending(s => s.TotalSpent)
            .Take(10)
            .ToListAsync(ct);
    }
    
    // GroupBy
    public async Task<List<UserCountByStatusDto>> GetUserCountsByStatusAsync(
        CancellationToken ct = default)
    {
        return await _context.Users
            .GroupBy(u => u.IsActive)
            .Select(g => new UserCountByStatusDto
            {
                IsActive = g.Key,
                Count = g.Count()
            })
            .ToListAsync(ct);
    }
    
    // Bulk update
    public async Task<int> BulkUpdateStatusAsync(
        List<int> userIds, 
        bool isActive,
        CancellationToken ct = default)
    {
        return await _context.Users
            .Where(u => userIds.Contains(u.Id))
            .ExecuteUpdateAsync(
                setters => setters
                    .SetProperty(u => u.IsActive, isActive)
                    .SetProperty(u => u.UpdatedAt, DateTime.UtcNow),
                ct
            );
    }
    
    // Bulk delete
    public async Task<int> BulkDeleteInactiveAsync(
        int daysInactive,
        CancellationToken ct = default)
    {
        var threshold = DateTime.UtcNow.AddDays(-daysInactive);
        
        return await _context.Users
            .Where(u => !u.IsActive && u.UpdatedAt < threshold)
            .ExecuteDeleteAsync(ct);
    }
}

// DTOs
public record UserDto
{
    public int Id { get; init; }
    public string Username { get; init; } = string.Empty;
    public string Email { get; init; } = string.Empty;
    public string FullName { get; init; } = string.Empty;
    public int OrderCount { get; init; }
}

public record UserStatsDto
{
    public int UserId { get; init; }
    public string Username { get; init; } = string.Empty;
    public int OrderCount { get; init; }
    public decimal TotalSpent { get; init; }
}

public record UserSearchParams
{
    public string? Username { get; init; }
    public string? Email { get; init; }
    public bool? IsActive { get; init; }
    public DateTime? CreatedAfter { get; init; }
    public DateTime? CreatedBefore { get; init; }
}
```

---

## Transactions

```csharp
// Repositories/OrderRepository.cs
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Storage;

public class OrderRepository
{
    private readonly ApplicationDbContext _context;
    
    public OrderRepository(ApplicationDbContext context)
    {
        _context = context;
    }
    
    // Transaction manuelle
    public async Task<Order> CreateOrderWithItemsAsync(
        int userId,
        List<OrderItemRequest> items,
        CancellationToken ct = default)
    {
        await using var transaction = await _context.Database.BeginTransactionAsync(ct);
        
        try
        {
            // 1. CrÃ©er la commande
            var order = new Order
            {
                UserId = userId,
                Status = OrderStatus.Pending,
                TotalAmount = 0,
                CreatedAt = DateTime.UtcNow
            };
            
            _context.Orders.Add(order);
            await _context.SaveChangesAsync(ct);
            
            decimal totalAmount = 0;
            
            // 2. Traiter chaque item
            foreach (var item in items)
            {
                // RÃ©cupÃ©rer et locker le produit
                var product = await _context.Products
                    .FromSqlRaw("SELECT * FROM products WHERE id = {0} FOR UPDATE", item.ProductId)
                    .FirstOrDefaultAsync(ct);
                
                if (product == null)
                {
                    throw new InvalidOperationException($"Product {item.ProductId} not found");
                }
                
                if (product.Stock < item.Quantity)
                {
                    throw new InvalidOperationException(
                        $"Insufficient stock for product {product.Id}"
                    );
                }
                
                // CrÃ©er l'item
                var orderItem = new OrderItem
                {
                    OrderId = order.Id,
                    ProductId = product.Id,
                    Quantity = item.Quantity,
                    Price = product.Price
                };
                
                _context.OrderItems.Add(orderItem);
                
                // DÃ©crÃ©menter le stock
                product.Stock -= item.Quantity;
                product.UpdatedAt = DateTime.UtcNow;
                
                totalAmount += product.Price * item.Quantity;
            }
            
            // 3. Mettre Ã  jour le total
            order.TotalAmount = totalAmount;
            
            await _context.SaveChangesAsync(ct);
            await transaction.CommitAsync(ct);
            
            // Recharger avec includes
            return await _context.Orders
                .Include(o => o.Items)
                    .ThenInclude(i => i.Product)
                .FirstAsync(o => o.Id == order.Id, ct);
        }
        catch
        {
            await transaction.RollbackAsync(ct);
            throw;
        }
    }
    
    // Transaction avec SaveChanges automatique
    public async Task<Order> CancelOrderAsync(
        int orderId,
        CancellationToken ct = default)
    {
        using var transaction = await _context.Database.BeginTransactionAsync(
            System.Data.IsolationLevel.Serializable, 
            ct
        );
        
        try
        {
            // RÃ©cupÃ©rer la commande avec items
            var order = await _context.Orders
                .Include(o => o.Items)
                .FirstOrDefaultAsync(o => o.Id == orderId, ct);
            
            if (order == null)
            {
                throw new InvalidOperationException("Order not found");
            }
            
            if (order.Status == OrderStatus.Cancelled)
            {
                throw new InvalidOperationException("Order already cancelled");
            }
            
            // Remettre le stock
            foreach (var item in order.Items)
            {
                var product = await _context.Products.FindAsync(
                    new object[] { item.ProductId }, 
                    ct
                );
                
                if (product != null)
                {
                    product.Stock += item.Quantity;
                }
            }
            
            // Mettre Ã  jour le statut
            order.Status = OrderStatus.Cancelled;
            order.UpdatedAt = DateTime.UtcNow;
            
            await _context.SaveChangesAsync(ct);
            await transaction.CommitAsync(ct);
            
            return order;
        }
        catch
        {
            await transaction.RollbackAsync(ct);
            throw;
        }
    }
}

public record OrderItemRequest(int ProductId, int Quantity);
```

---

## Optimisations de performance

### Ã‰viter le problÃ¨me N+1

```csharp
// âŒ MAUVAIS : N+1 queries
var orders = await _context.Orders.ToListAsync();
foreach (var order in orders)
{
    var user = await _context.Users.FindAsync(order.UserId); // 1 query par order !
    Console.WriteLine(user.Username);
}

// âœ… BON : Include (eager loading)
var orders = await _context.Orders
    .Include(o => o.User)
    .ToListAsync();

foreach (var order in orders)
{
    Console.WriteLine(order.User.Username); // DÃ©jÃ  chargÃ©
}

// âœ… BON : Nested includes
var users = await _context.Users
    .Include(u => u.Orders)
        .ThenInclude(o => o.Items)
            .ThenInclude(i => i.Product)
    .ToListAsync();
```

### AsNoTracking

```csharp
// Pour lecture seule (plus rapide)
var users = await _context.Users
    .AsNoTracking()
    .Where(u => u.IsActive)
    .ToListAsync();

// Avec tracking (pour update)
var user = await _context.Users
    .FirstOrDefaultAsync(u => u.Id == id);

user.Email = "newemail@example.com";
await _context.SaveChangesAsync();
```

### Split queries

```csharp
// Pour Ã©viter les jointures cartÃ©siennes
var users = await _context.Users
    .Include(u => u.Orders)
    .Include(u => u.UserRoles)
    .AsSplitQuery() // Plusieurs queries sÃ©parÃ©es
    .ToListAsync();
```

### Compiled queries

```csharp
// Queries compilÃ©es pour performance
private static readonly Func<ApplicationDbContext, int, Task<User?>> GetUserById =
    EF.CompileAsyncQuery((ApplicationDbContext context, int id) =>
        context.Users.FirstOrDefault(u => u.Id == id)
    );

public async Task<User?> GetByIdFastAsync(int id)
{
    return await GetUserById(_context, id);
}
```

---

## Configuration Program.cs (ASP.NET Core)

```csharp
// Program.cs
using Microsoft.EntityFrameworkCore;
using YourApp.Data;
using Pomelo.EntityFrameworkCore.MySql.Infrastructure;

var builder = WebApplication.CreateBuilder(args);

// Configuration DbContext
builder.Services.AddDbContext<ApplicationDbContext>(options =>
{
    var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
    var serverVersion = ServerVersion.AutoDetect(connectionString);
    
    options.UseMySql(connectionString, serverVersion, mySqlOptions =>
    {
        // Retry on failure
        mySqlOptions.EnableRetryOnFailure(
            maxRetryCount: 3,
            maxRetryDelay: TimeSpan.FromSeconds(10),
            errorNumbersToAdd: null
        );
        
        // String comparison
        mySqlOptions.EnableStringComparisonTranslations();
        
        // Charset
        mySqlOptions.CharSet(CharSet.Utf8Mb4);
        
        // Command timeout
        mySqlOptions.CommandTimeout(30);
    });
    
    // Logging (dÃ©veloppement)
    if (builder.Environment.IsDevelopment())
    {
        options.EnableSensitiveDataLogging();
        options.EnableDetailedErrors();
    }
});

// Repositories
builder.Services.AddScoped<UserRepository>();
builder.Services.AddScoped<OrderRepository>();

var app = builder.Build();

// Appliquer les migrations au dÃ©marrage (optionnel, dev seulement)
if (app.Environment.IsDevelopment())
{
    using var scope = app.Services.CreateScope();
    var context = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
    await context.Database.MigrateAsync();
}

app.Run();
```

---

## Database-First

### Scaffold depuis une base existante

```bash
# GÃ©nÃ©rer les modÃ¨les depuis la base de donnÃ©es
dotnet ef dbcontext scaffold "Server=localhost;Database=production_db;User=app_user;Password=password;" Pomelo.EntityFrameworkCore.MySql --output-dir Models --context-dir Data --context ApplicationDbContext --force

# Options utiles
--data-annotations     # Utiliser les annotations
--force               # Ã‰craser les fichiers existants
--no-onconfiguring    # Ne pas gÃ©nÃ©rer OnConfiguring
--table users         # Seulement la table users
--schema dbo          # SchÃ©ma spÃ©cifique
```

---

## âœ… Points clÃ©s Ã  retenir

1. **Pomelo** : Provider recommandÃ© pour MariaDB (MIT license, performance)
2. **AsNoTracking** : Pour read-only queries (meilleures performances)
3. **Include** : Toujours charger les relations nÃ©cessaires pour Ã©viter N+1
4. **Migrations** : Versionnement du schÃ©ma avec `dotnet ef migrations`
5. **LINQ** : Type-safe queries avec IntelliSense complet
6. **Transactions** : `BeginTransactionAsync` pour opÃ©rations atomiques
7. **ExecuteUpdate/Delete** : Bulk operations sans charger en mÃ©moire
8. **Split queries** : Pour Ã©viter jointures cartÃ©siennes
9. **Compiled queries** : Pour queries frÃ©quentes (cache)
10. **Connection pooling** : GÃ©rÃ© automatiquement par EF Core

---

## ğŸ”— Ressources

### Documentation officielle
- [ğŸ“– EF Core Documentation](https://learn.microsoft.com/en-us/ef/core/)
- [ğŸ“– Pomelo.EntityFrameworkCore.MySql](https://github.com/PomeloFoundation/Pomelo.EntityFrameworkCore.MySql)
- [ğŸ“– EF Core Performance](https://learn.microsoft.com/en-us/ef/core/performance/)

### Guides
- [EF Core Best Practices](https://learn.microsoft.com/en-us/ef/core/miscellaneous/best-practices)
- [LINQ to SQL](https://learn.microsoft.com/en-us/ef/core/querying/)

---

## ğŸ¯ Conclusion du chapitre 17

Vous avez maintenant une **vision complÃ¨te** de l'intÃ©gration et du dÃ©veloppement avec MariaDB :

### ğŸ“ CompÃ©tences acquises
- Configuration de connexions sÃ©curisÃ©es
- Gestion du pooling applicatif et centralisÃ©
- Utilisation d'ORMs pour productivitÃ©
- Migrations et versioning de schÃ©ma
- Optimisations de performance
- PrÃ©vention des injections SQL
- Bonnes pratiques par langage

**Prochaine Ã©tape** : Mettre en pratique ces connaissances dans vos projets MariaDB ! ğŸš€

â­ï¸ [Bonnes pratiques de dÃ©veloppement](/17-integration-developpement/04-bonnes-pratiques.md)
