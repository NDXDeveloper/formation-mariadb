üîù Retour au [Sommaire](/SOMMAIRE.md)

# 17.1.3 Java : JDBC, MariaDB Connector/J

> **Niveau** : Interm√©diaire √† Avanc√©  
> **Dur√©e estim√©e** : 3-4 heures  
> **Pr√©requis** : Java 11+, Maven/Gradle, concepts POO, bases de donn√©es relationnelles

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Configurer MariaDB Connector/J dans un projet Java/Maven/Gradle
- √âtablir des connexions JDBC s√©curis√©es avec try-with-resources
- Utiliser PreparedStatement pour pr√©venir les injections SQL
- Impl√©menter un connection pool performant avec HikariCP
- Ma√Ætriser Hibernate/JPA pour le mapping objet-relationnel
- Int√©grer MariaDB dans Spring Boot avec Spring Data JPA
- Appliquer les patterns DAO et Repository
- G√©rer les transactions programmatiques et d√©claratives

---

## Introduction

Java offre plusieurs approches pour interagir avec MariaDB, du JDBC bas niveau aux frameworks ORM modernes :

### √âcosyst√®me Java-MariaDB

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        Application Java                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Framework Layer (optionnel)                 ‚îÇ
‚îÇ  ‚îú‚îÄ Spring Data JPA (recommand√©)             ‚îÇ
‚îÇ  ‚îú‚îÄ Hibernate (JPA implementation)           ‚îÇ
‚îÇ  ‚îú‚îÄ jOOQ (type-safe SQL)                     ‚îÇ
‚îÇ  ‚îî‚îÄ MyBatis (SQL mapper)                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  JPA/Hibernate ORM                           ‚îÇ
‚îÇ  ‚îî‚îÄ Entity Mapping, Caching, Lazy Loading    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  JDBC Layer                                  ‚îÇ
‚îÇ  ‚îú‚îÄ MariaDB Connector/J (driver)             ‚îÇ
‚îÇ  ‚îî‚îÄ Connection Pool (HikariCP)               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ          MariaDB Server                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

üí° **Conseil** : Pour les nouveaux projets, utilisez **Spring Boot** + **Spring Data JPA** + **HikariCP**. Cette stack est le standard de l'industrie Java et offre le meilleur √©quilibre entre productivit√©, performance et maintenabilit√©.

---

## Comparaison des approches Java

### Tableau comparatif

| Approche | Complexit√© | Performance | Productivit√© | Maintenance | Cas d'usage |
|----------|-----------|-------------|--------------|-------------|-------------|
| **JDBC pur** | Faible | Tr√®s √©lev√©e | Faible | Difficile | Requ√™tes simples, batch |
| **Spring JdbcTemplate** | Moyenne | √âlev√©e | Moyenne | Moyenne | Apps Spring existantes |
| **Hibernate/JPA** | √âlev√©e | Moyenne | √âlev√©e | Facile | CRUD, relations complexes |
| **Spring Data JPA** | Moyenne | Moyenne | Tr√®s √©lev√©e | Tr√®s facile | Apps modernes, REST API |
| **jOOQ** | Moyenne | √âlev√©e | √âlev√©e | Moyenne | Type-safety, SQL complexe |
| **MyBatis** | Moyenne | √âlev√©e | Moyenne | Moyenne | SQL personnalis√©, legacy |

### Recommandations par contexte

#### JDBC pur
**Utiliser quand :**
- Batch processing haute performance
- Microservices ultra-l√©gers
- Contr√¥le total n√©cessaire
- Scripts utilitaires

**√âviter si :**
- Mod√®le objet complexe
- Productivit√© prioritaire
- √âquipe peu exp√©riment√©e en SQL

#### Hibernate/JPA
**Utiliser quand :**
- Domain-driven design
- Relations complexes (OneToMany, ManyToMany)
- Portabilit√© entre SGBD
- Caching de second niveau

**√âviter si :**
- Performance critique
- Requ√™tes analytiques complexes
- Bulk operations massives

#### Spring Data JPA
**Utiliser quand :**
- Application Spring Boot
- REST API CRUD
- D√©veloppement rapide
- Standards Java EE

**√âviter si :**
- Pas de Spring dans le projet
- Besoin de contr√¥le fin sur SQL

---

## Configuration Maven/Gradle

### Configuration Maven (pom.xml)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>com.example</groupId>
    <artifactId>mariadb-demo</artifactId>
    <version>1.0.0</version>
    
    <properties>
        <java.version>17</java.version>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        
        <!-- Versions des d√©pendances -->
        <mariadb.version>3.3.2</mariadb.version>
        <hikaricp.version>5.1.0</hikaricp.version>
        <hibernate.version>6.4.1.Final</hibernate.version>
        <spring.boot.version>3.2.1</spring.boot.version>
    </properties>
    
    <dependencies>
        <!-- MariaDB Connector/J -->
        <dependency>
            <groupId>org.mariadb.jdbc</groupId>
            <artifactId>mariadb-java-client</artifactId>
            <version>${mariadb.version}</version>
        </dependency>
        
        <!-- Connection Pool HikariCP -->
        <dependency>
            <groupId>com.zaxxer</groupId>
            <artifactId>HikariCP</artifactId>
            <version>${hikaricp.version}</version>
        </dependency>
        
        <!-- Hibernate Core (JPA) -->
        <dependency>
            <groupId>org.hibernate.orm</groupId>
            <artifactId>hibernate-core</artifactId>
            <version>${hibernate.version}</version>
        </dependency>
        
        <!-- Logging (SLF4J + Logback) -->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.4.14</version>
        </dependency>
        
        <!-- Validation -->
        <dependency>
            <groupId>jakarta.validation</groupId>
            <artifactId>jakarta.validation-api</artifactId>
            <version>3.0.2</version>
        </dependency>
        
        <!-- Lombok (optionnel, pour r√©duire le boilerplate) -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.30</version>
            <scope>provided</scope>
        </dependency>
        
        <!-- JUnit 5 pour les tests -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>5.10.1</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
            </plugin>
        </plugins>
    </build>
</project>
```

### Configuration Gradle (build.gradle)

```gradle
plugins {
    id 'java'
    id 'application'
}

group = 'com.example'
version = '1.0.0'

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

dependencies {
    // MariaDB Connector/J
    implementation 'org.mariadb.jdbc:mariadb-java-client:3.3.2'
    
    // Connection Pool
    implementation 'com.zaxxer:HikariCP:5.1.0'
    
    // Hibernate
    implementation 'org.hibernate.orm:hibernate-core:6.4.1.Final'
    
    // Logging
    implementation 'ch.qos.logback:logback-classic:1.4.14'
    
    // Validation
    implementation 'jakarta.validation:jakarta.validation-api:3.0.2'
    
    // Lombok
    compileOnly 'org.projectlombok:lombok:1.18.30'
    annotationProcessor 'org.projectlombok:lombok:1.18.30'
    
    // Tests
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.1'
}

test {
    useJUnitPlatform()
}
```

---

## Connexion JDBC de base

### Connexion simple avec try-with-resources

```java
package com.example.mariadb;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * Exemple de connexion JDBC basique √† MariaDB
 * Utilise try-with-resources pour gestion automatique des ressources
 */
public class BasicJdbcExample {
    
    // Configuration de connexion
    private static final String URL = "jdbc:mariadb://localhost:3306/production_db";
    private static final String USER = "app_user";
    private static final String PASSWORD = "SecureP@ssw0rd!";
    
    public static void main(String[] args) {
        // Le driver est charg√© automatiquement depuis JDBC 4.0
        // Pas besoin de Class.forName("org.mariadb.jdbc.Driver")
        
        // try-with-resources : fermeture automatique
        try (Connection connection = DriverManager.getConnection(URL, USER, PASSWORD)) {
            
            System.out.println("‚úì Connect√© √† MariaDB");
            
            // Informations sur la connexion
            var metadata = connection.getMetaData();
            System.out.println("Database: " + metadata.getDatabaseProductName());
            System.out.println("Version: " + metadata.getDatabaseProductVersion());
            System.out.println("Driver: " + metadata.getDriverName() + " " + 
                             metadata.getDriverVersion());
            
            // Requ√™te simple
            try (Statement stmt = connection.createStatement();
                 ResultSet rs = stmt.executeQuery("SELECT VERSION() as version, DATABASE() as db")) {
                
                if (rs.next()) {
                    System.out.println("MariaDB version: " + rs.getString("version"));
                    System.out.println("Current database: " + rs.getString("db"));
                }
            }
            
        } catch (SQLException e) {
            System.err.println("‚úó Erreur de connexion: " + e.getMessage());
            e.printStackTrace();
        }
        // Connection, Statement et ResultSet sont ferm√©s automatiquement
    }
}
```

### Configuration avanc√©e de la connexion

```java
package com.example.mariadb;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Properties;

/**
 * Configuration avanc√©e de la connexion MariaDB
 */
public class AdvancedConnection {
    
    public static Connection getConnection() throws SQLException {
        String url = "jdbc:mariadb://localhost:3306/production_db";
        
        // Propri√©t√©s de connexion avanc√©es
        Properties props = new Properties();
        props.setProperty("user", "app_user");
        props.setProperty("password", "SecureP@ssw0rd!");
        
        // Charset et collation (üÜï utf8mb4 par d√©faut en MariaDB 11.8)
        props.setProperty("characterEncoding", "UTF-8");
        props.setProperty("connectionCollation", "utf8mb4_unicode_ci");
        
        // SSL/TLS (üÜï activ√© par d√©faut en MariaDB 11.8)
        props.setProperty("useSSL", "true");
        props.setProperty("trustServerCertificate", "false");
        
        // Performance
        props.setProperty("cachePrepStmts", "true");
        props.setProperty("prepStmtCacheSize", "250");
        props.setProperty("prepStmtCacheSqlLimit", "2048");
        props.setProperty("useServerPrepStmts", "true");
        
        // Timeouts
        props.setProperty("connectTimeout", "10000");  // 10 secondes
        props.setProperty("socketTimeout", "30000");   // 30 secondes
        
        // Timezone UTC
        props.setProperty("serverTimezone", "UTC");
        
        // Logs
        props.setProperty("logger", "org.mariadb.jdbc.util.LoggerImpl");
        props.setProperty("maxQuerySizeToLog", "1024");
        
        // R√©essayer la connexion
        props.setProperty("autoReconnect", "true");
        props.setProperty("maxReconnects", "3");
        
        return DriverManager.getConnection(url, props);
    }
    
    // Alternative : URL avec param√®tres
    public static Connection getConnectionWithUrlParams() throws SQLException {
        String url = "jdbc:mariadb://localhost:3306/production_db" +
                     "?user=app_user" +
                     "&password=SecureP%40ssw0rd!" +  // URL-encoded
                     "&characterEncoding=UTF-8" +
                     "&useSSL=true" +
                     "&serverTimezone=UTC" +
                     "&cachePrepStmts=true";
        
        return DriverManager.getConnection(url);
    }
}
```

---

## PreparedStatement : S√©curit√© et Performance

### Exemples de PreparedStatement

```java
package com.example.mariadb.jdbc;

import java.math.BigDecimal;
import java.sql.*;
import java.time.LocalDateTime;

/**
 * Exemples de PreparedStatement pour s√©curit√© et performance
 * TOUJOURS utiliser PreparedStatement, JAMAIS de concat√©nation SQL
 */
public class PreparedStatementExamples {
    
    private Connection connection;
    
    public PreparedStatementExamples(Connection connection) {
        this.connection = connection;
    }
    
    // ========================================
    // SELECT avec param√®tres
    // ========================================
    
    public User findUserByEmail(String email) throws SQLException {
        String sql = "SELECT id, username, email, created_at FROM users WHERE email = ?";
        
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            // D√©finir les param√®tres (index commence √† 1)
            pstmt.setString(1, email);
            
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    return new User(
                        rs.getLong("id"),
                        rs.getString("username"),
                        rs.getString("email"),
                        rs.getTimestamp("created_at").toLocalDateTime()
                    );
                }
            }
        }
        
        return null;
    }
    
    // ========================================
    // INSERT avec r√©cup√©ration de l'ID g√©n√©r√©
    // ========================================
    
    public long createUser(String username, String email, String passwordHash) 
            throws SQLException {
        
        String sql = """
            INSERT INTO users (username, email, password_hash, created_at)
            VALUES (?, ?, ?, ?)
            """;
        
        try (PreparedStatement pstmt = connection.prepareStatement(
                sql, Statement.RETURN_GENERATED_KEYS)) {
            
            pstmt.setString(1, username);
            pstmt.setString(2, email);
            pstmt.setString(3, passwordHash);
            pstmt.setTimestamp(4, Timestamp.valueOf(LocalDateTime.now()));
            
            int affectedRows = pstmt.executeUpdate();
            
            if (affectedRows == 0) {
                throw new SQLException("√âchec de la cr√©ation, aucune ligne ins√©r√©e");
            }
            
            // R√©cup√©rer l'ID g√©n√©r√©
            try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    return generatedKeys.getLong(1);
                } else {
                    throw new SQLException("√âchec de la cr√©ation, pas d'ID obtenu");
                }
            }
        }
    }
    
    // ========================================
    // UPDATE avec v√©rification
    // ========================================
    
    public boolean updateUserEmail(long userId, String newEmail) throws SQLException {
        String sql = "UPDATE users SET email = ?, updated_at = ? WHERE id = ?";
        
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, newEmail);
            pstmt.setTimestamp(2, Timestamp.valueOf(LocalDateTime.now()));
            pstmt.setLong(3, userId);
            
            int rowsAffected = pstmt.executeUpdate();
            return rowsAffected > 0;
        }
    }
    
    // ========================================
    // DELETE avec condition
    // ========================================
    
    public int deleteInactiveUsers(LocalDateTime olderThan) throws SQLException {
        String sql = """
            DELETE FROM users 
            WHERE last_login < ? AND is_active = false
            """;
        
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setTimestamp(1, Timestamp.valueOf(olderThan));
            
            return pstmt.executeUpdate();
        }
    }
    
    // ========================================
    // Requ√™te avec multiple param√®tres
    // ========================================
    
    public List<Product> searchProducts(String searchTerm, BigDecimal minPrice, 
                                        BigDecimal maxPrice, int limit) 
            throws SQLException {
        
        String sql = """
            SELECT id, name, description, price, stock
            FROM products
            WHERE name LIKE ? 
              AND price BETWEEN ? AND ?
              AND is_active = true
            ORDER BY price ASC
            LIMIT ?
            """;
        
        List<Product> products = new ArrayList<>();
        
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, "%" + searchTerm + "%");
            pstmt.setBigDecimal(2, minPrice);
            pstmt.setBigDecimal(3, maxPrice);
            pstmt.setInt(4, limit);
            
            try (ResultSet rs = pstmt.executeQuery()) {
                while (rs.next()) {
                    products.add(new Product(
                        rs.getLong("id"),
                        rs.getString("name"),
                        rs.getString("description"),
                        rs.getBigDecimal("price"),
                        rs.getInt("stock")
                    ));
                }
            }
        }
        
        return products;
    }
    
    // ========================================
    // Batch INSERT pour performances
    // ========================================
    
    public void createProductsBatch(List<Product> products) throws SQLException {
        String sql = "INSERT INTO products (name, description, price, stock) VALUES (?, ?, ?, ?)";
        
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            
            connection.setAutoCommit(false);  // Transaction manuelle
            
            for (Product product : products) {
                pstmt.setString(1, product.getName());
                pstmt.setString(2, product.getDescription());
                pstmt.setBigDecimal(3, product.getPrice());
                pstmt.setInt(4, product.getStock());
                
                pstmt.addBatch();  // Ajouter au batch
                
                // Ex√©cuter par lots de 1000
                if (products.indexOf(product) % 1000 == 0) {
                    pstmt.executeBatch();
                }
            }
            
            pstmt.executeBatch();  // Ex√©cuter le reste
            connection.commit();
            
        } catch (SQLException e) {
            connection.rollback();
            throw e;
        } finally {
            connection.setAutoCommit(true);
        }
    }
}
```

‚ö†Ô∏è **Attention** : Ne JAMAIS construire des requ√™tes SQL par concat√©nation de cha√Ænes avec des donn√©es utilisateur. C'est la porte ouverte aux injections SQL !

```java
// ‚ùå DANGEREUX - Injection SQL possible
String sql = "SELECT * FROM users WHERE username = '" + username + "'";
// Si username = "admin' OR '1'='1" ‚Üí contournement de la s√©curit√© !

// ‚úÖ S√âCURIS√â - PreparedStatement
String sql = "SELECT * FROM users WHERE username = ?";
PreparedStatement pstmt = connection.prepareStatement(sql);
pstmt.setString(1, username);  // √âchappement automatique
```

---

## Gestion des transactions

### Transactions JDBC

```java
package com.example.mariadb.jdbc;

import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Savepoint;

/**
 * Gestion des transactions JDBC
 * Exemple : Syst√®me de transfert bancaire atomique
 */
public class TransactionExample {
    
    private Connection connection;
    
    public TransactionExample(Connection connection) {
        this.connection = connection;
    }
    
    /**
     * Transfert bancaire avec transaction ACID
     */
    public void transferMoney(long fromAccountId, long toAccountId, BigDecimal amount) 
            throws SQLException {
        
        // V√©rifier le montant
        if (amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Le montant doit √™tre positif");
        }
        
        // Sauvegarder l'√©tat de l'auto-commit
        boolean originalAutoCommit = connection.getAutoCommit();
        
        try {
            // D√©sactiver l'auto-commit pour g√©rer la transaction manuellement
            connection.setAutoCommit(false);
            
            // √âtape 1 : D√©biter le compte source
            String debitSql = """
                UPDATE accounts 
                SET balance = balance - ? 
                WHERE id = ? AND balance >= ?
                """;
            
            try (PreparedStatement debitStmt = connection.prepareStatement(debitSql)) {
                debitStmt.setBigDecimal(1, amount);
                debitStmt.setLong(2, fromAccountId);
                debitStmt.setBigDecimal(3, amount);  // V√©rifier le solde
                
                int rowsAffected = debitStmt.executeUpdate();
                if (rowsAffected == 0) {
                    throw new SQLException("Solde insuffisant ou compte introuvable");
                }
            }
            
            // √âtape 2 : Cr√©diter le compte destination
            String creditSql = "UPDATE accounts SET balance = balance + ? WHERE id = ?";
            
            try (PreparedStatement creditStmt = connection.prepareStatement(creditSql)) {
                creditStmt.setBigDecimal(1, amount);
                creditStmt.setLong(2, toAccountId);
                
                int rowsAffected = creditStmt.executeUpdate();
                if (rowsAffected == 0) {
                    throw new SQLException("Compte destination introuvable");
                }
            }
            
            // √âtape 3 : Enregistrer la transaction dans l'historique
            String logSql = """
                INSERT INTO transactions (from_account, to_account, amount, created_at)
                VALUES (?, ?, ?, NOW())
                """;
            
            try (PreparedStatement logStmt = connection.prepareStatement(logSql)) {
                logStmt.setLong(1, fromAccountId);
                logStmt.setLong(2, toAccountId);
                logStmt.setBigDecimal(3, amount);
                logStmt.executeUpdate();
            }
            
            // Tout s'est bien pass√© : valider la transaction
            connection.commit();
            System.out.println("‚úì Transfert de " + amount + "‚Ç¨ effectu√© avec succ√®s");
            
        } catch (SQLException e) {
            // Erreur : annuler toutes les modifications
            try {
                connection.rollback();
                System.out.println("‚úó Transaction annul√©e : " + e.getMessage());
            } catch (SQLException rollbackEx) {
                System.err.println("Erreur lors du rollback : " + rollbackEx.getMessage());
            }
            throw e;
            
        } finally {
            // Restaurer l'√©tat original de l'auto-commit
            try {
                connection.setAutoCommit(originalAutoCommit);
            } catch (SQLException e) {
                System.err.println("Erreur lors de la restauration auto-commit : " + 
                                 e.getMessage());
            }
        }
    }
    
    /**
     * Exemple avec Savepoints (points de sauvegarde)
     */
    public void complexTransactionWithSavepoints() throws SQLException {
        connection.setAutoCommit(false);
        Savepoint savepoint1 = null;
        Savepoint savepoint2 = null;
        
        try {
            // Op√©ration 1
            executeOperation1();
            savepoint1 = connection.setSavepoint("Savepoint1");
            
            // Op√©ration 2
            executeOperation2();
            savepoint2 = connection.setSavepoint("Savepoint2");
            
            // Op√©ration 3 (risqu√©e)
            try {
                executeOperation3();
            } catch (SQLException e) {
                // Annuler seulement l'op√©ration 3, garder 1 et 2
                connection.rollback(savepoint2);
                System.out.println("Op√©ration 3 annul√©e, 1 et 2 conserv√©es");
            }
            
            // Valider toutes les op√©rations r√©ussies
            connection.commit();
            
        } catch (SQLException e) {
            connection.rollback();  // Tout annuler
            throw e;
        } finally {
            connection.setAutoCommit(true);
        }
    }
    
    /**
     * Configurer le niveau d'isolation de la transaction
     */
    public void setTransactionIsolation() throws SQLException {
        // Niveaux disponibles :
        // - TRANSACTION_READ_UNCOMMITTED (pas recommand√©)
        // - TRANSACTION_READ_COMMITTED
        // - TRANSACTION_REPEATABLE_READ (d√©faut InnoDB)
        // - TRANSACTION_SERIALIZABLE (le plus strict)
        
        connection.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
        
        // V√©rifier le niveau actuel
        int level = connection.getTransactionIsolation();
        System.out.println("Isolation level: " + getIsolationLevelName(level));
    }
    
    private String getIsolationLevelName(int level) {
        return switch (level) {
            case Connection.TRANSACTION_READ_UNCOMMITTED -> "READ UNCOMMITTED";
            case Connection.TRANSACTION_READ_COMMITTED -> "READ COMMITTED";
            case Connection.TRANSACTION_REPEATABLE_READ -> "REPEATABLE READ";
            case Connection.TRANSACTION_SERIALIZABLE -> "SERIALIZABLE";
            default -> "UNKNOWN";
        };
    }
    
    // M√©thodes d'exemple
    private void executeOperation1() throws SQLException { /* ... */ }
    private void executeOperation2() throws SQLException { /* ... */ }
    private void executeOperation3() throws SQLException { /* ... */ }
}
```

---

## Connection Pooling avec HikariCP

### Configuration HikariCP

```java
package com.example.mariadb.pool;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

import javax.sql.DataSource;

/**
 * Configuration HikariCP - Le connection pool le plus performant
 * Recommand√© pour la production
 */
public class HikariCPConfiguration {
    
    private static HikariDataSource dataSource;
    
    /**
     * Initialiser le pool de connexions
     */
    public static DataSource getDataSource() {
        if (dataSource == null) {
            synchronized (HikariCPConfiguration.class) {
                if (dataSource == null) {
                    HikariConfig config = new HikariConfig();
                    
                    // Configuration JDBC
                    config.setJdbcUrl("jdbc:mariadb://localhost:3306/production_db");
                    config.setUsername("app_user");
                    config.setPassword("SecureP@ssw0rd!");
                    config.setDriverClassName("org.mariadb.jdbc.Driver");
                    
                    // Pool sizing (r√®gle g√©n√©rale : connections = cores * 2 + disks)
                    config.setMaximumPoolSize(10);        // Max connexions
                    config.setMinimumIdle(5);             // Connexions idle minimum
                    
                    // Timeouts
                    config.setConnectionTimeout(30000);    // 30s pour obtenir connexion
                    config.setIdleTimeout(600000);         // 10min idle avant fermeture
                    config.setMaxLifetime(1800000);        // 30min lifetime max
                    
                    // Validation
                    config.setConnectionTestQuery("SELECT 1");
                    config.setValidationTimeout(5000);     // 5s pour valider
                    
                    // Performance
                    config.setAutoCommit(true);
                    config.setCachePrepStmts(true);
                    config.setPrepStmtCacheSize(250);
                    config.setPrepStmtCacheSqlLimit(2048);
                    
                    // Pool name pour monitoring
                    config.setPoolName("MariaDB-Pool");
                    
                    // Leak detection (d√©veloppement)
                    config.setLeakDetectionThreshold(60000);  // 60s
                    
                    // Properties MariaDB sp√©cifiques
                    config.addDataSourceProperty("cachePrepStmts", "true");
                    config.addDataSourceProperty("prepStmtCacheSize", "250");
                    config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
                    config.addDataSourceProperty("useServerPrepStmts", "true");
                    config.addDataSourceProperty("useLocalSessionState", "true");
                    config.addDataSourceProperty("rewriteBatchedStatements", "true");
                    config.addDataSourceProperty("cacheResultSetMetadata", "true");
                    config.addDataSourceProperty("cacheServerConfiguration", "true");
                    config.addDataSourceProperty("elideSetAutoCommits", "true");
                    config.addDataSourceProperty("maintainTimeStats", "false");
                    
                    // Charset
                    config.addDataSourceProperty("characterEncoding", "utf8mb4");
                    config.addDataSourceProperty("connectionCollation", "utf8mb4_unicode_ci");
                    
                    // Timezone
                    config.addDataSourceProperty("serverTimezone", "UTC");
                    
                    dataSource = new HikariDataSource(config);
                }
            }
        }
        return dataSource;
    }
    
    /**
     * Fermer le pool (shutdown graceful)
     */
    public static void closeDataSource() {
        if (dataSource != null && !dataSource.isClosed()) {
            dataSource.close();
            System.out.println("‚úì HikariCP pool ferm√©");
        }
    }
    
    /**
     * Statistiques du pool
     */
    public static void printPoolStats() {
        if (dataSource != null) {
            var poolStats = dataSource.getHikariPoolMXBean();
            
            System.out.println("=== HikariCP Pool Stats ===");
            System.out.println("Active connections: " + poolStats.getActiveConnections());
            System.out.println("Idle connections: " + poolStats.getIdleConnections());
            System.out.println("Total connections: " + poolStats.getTotalConnections());
            System.out.println("Threads awaiting: " + poolStats.getThreadsAwaitingConnection());
        }
    }
}
```

### Utilisation du pool

```java
package com.example.mariadb.pool;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import javax.sql.DataSource;

/**
 * Utilisation du connection pool HikariCP
 */
public class HikariCPExample {
    
    private DataSource dataSource;
    
    public HikariCPExample() {
        this.dataSource = HikariCPConfiguration.getDataSource();
    }
    
    /**
     * Ex√©cuter une requ√™te avec le pool
     */
    public void executeQuery() {
        // Obtenir une connexion du pool (rapide, pas de cr√©ation)
        try (Connection conn = dataSource.getConnection();
             PreparedStatement pstmt = conn.prepareStatement("SELECT * FROM users LIMIT 10");
             ResultSet rs = pstmt.executeQuery()) {
            
            while (rs.next()) {
                System.out.println("User: " + rs.getString("username"));
            }
            
        } catch (SQLException e) {
            System.err.println("Erreur : " + e.getMessage());
        }
        // La connexion retourne automatiquement au pool (pas ferm√©e vraiment)
    }
    
    /**
     * Test de charge du pool
     */
    public void stressTest() throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(20);
        
        for (int i = 0; i < 100; i++) {
            final int taskId = i;
            executor.submit(() -> {
                try (Connection conn = dataSource.getConnection();
                     PreparedStatement pstmt = conn.prepareStatement(
                         "SELECT SLEEP(0.1), ? as task_id")) {
                    
                    pstmt.setInt(1, taskId);
                    pstmt.executeQuery();
                    System.out.println("Task " + taskId + " completed");
                    
                } catch (SQLException e) {
                    System.err.println("Task " + taskId + " failed: " + e.getMessage());
                }
            });
        }
        
        executor.shutdown();
        executor.awaitTermination(1, TimeUnit.MINUTES);
        
        // Afficher les statistiques
        HikariCPConfiguration.printPoolStats();
    }
}
```

üí° **Conseil** : HikariCP est le pool recommand√© pour la production Java. Il est utilis√© par d√©faut dans Spring Boot et offre les meilleures performances.

---

## Hibernate/JPA : ORM Java

### Configuration Hibernate

```xml
<!-- src/main/resources/META-INF/persistence.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="https://jakarta.ee/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="https://jakarta.ee/xml/ns/persistence
             https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd"
             version="3.0">
    
    <persistence-unit name="MariaDBPU" transaction-type="RESOURCE_LOCAL">
        
        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
        
        <!-- Entit√©s JPA -->
        <class>com.example.model.User</class>
        <class>com.example.model.Product</class>
        <class>com.example.model.Order</class>
        
        <properties>
            <!-- Configuration MariaDB -->
            <property name="jakarta.persistence.jdbc.driver" 
                      value="org.mariadb.jdbc.Driver"/>
            <property name="jakarta.persistence.jdbc.url" 
                      value="jdbc:mariadb://localhost:3306/production_db"/>
            <property name="jakarta.persistence.jdbc.user" 
                      value="app_user"/>
            <property name="jakarta.persistence.jdbc.password" 
                      value="SecureP@ssw0rd!"/>
            
            <!-- Dialecte MariaDB -->
            <property name="hibernate.dialect" 
                      value="org.hibernate.dialect.MariaDBDialect"/>
            
            <!-- Sch√©ma auto (dev only) -->
            <property name="hibernate.hbm2ddl.auto" value="update"/>
            <!-- Options: validate, update, create, create-drop -->
            
            <!-- Logs SQL (dev only) -->
            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.format_sql" value="true"/>
            <property name="hibernate.use_sql_comments" value="true"/>
            
            <!-- Performance -->
            <property name="hibernate.jdbc.batch_size" value="20"/>
            <property name="hibernate.order_inserts" value="true"/>
            <property name="hibernate.order_updates" value="true"/>
            <property name="hibernate.jdbc.fetch_size" value="50"/>
            
            <!-- Second-level cache (optionnel) -->
            <property name="hibernate.cache.use_second_level_cache" value="true"/>
            <property name="hibernate.cache.region.factory_class" 
                      value="org.hibernate.cache.jcache.JCacheRegionFactory"/>
            
            <!-- Connection pool HikariCP -->
            <property name="hibernate.hikari.minimumIdle" value="5"/>
            <property name="hibernate.hikari.maximumPoolSize" value="10"/>
            <property name="hibernate.hikari.idleTimeout" value="30000"/>
            <property name="hibernate.hikari.connectionTimeout" value="20000"/>
            
            <!-- Charset -->
            <property name="hibernate.connection.characterEncoding" value="UTF-8"/>
            <property name="hibernate.connection.CharSet" value="utf8mb4"/>
            <property name="hibernate.connection.useUnicode" value="true"/>
        </properties>
    </persistence-unit>
</persistence>
```

### Entit√©s JPA

```java
package com.example.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * Entit√© User avec JPA/Hibernate
 */
@Entity
@Table(name = "users", indexes = {
    @Index(name = "idx_user_email", columnList = "email"),
    @Index(name = "idx_user_username", columnList = "username"),
    @Index(name = "idx_user_active_created", columnList = "is_active, created_at")
})
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "username", nullable = false, unique = true, length = 50)
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50)
    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "Invalid username format")
    private String username;
    
    @Column(name = "email", nullable = false, unique = true)
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;
    
    @Column(name = "password_hash", nullable = false)
    @NotBlank
    private String passwordHash;
    
    @Column(name = "first_name", length = 100)
    private String firstName;
    
    @Column(name = "last_name", length = 100)
    private String lastName;
    
    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;
    
    @Column(name = "is_admin", nullable = false)
    private Boolean isAdmin = false;
    
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @Column(name = "last_login")
    private LocalDateTime lastLogin;
    
    // Relations
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Order> orders = new ArrayList<>();
    
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Address> addresses = new ArrayList<>();
    
    // Constructeurs
    public User() {}
    
    public User(String username, String email, String passwordHash) {
        this.username = username;
        this.email = email;
        this.passwordHash = passwordHash;
    }
    
    // Getters et Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public String getPasswordHash() { return passwordHash; }
    public void setPasswordHash(String passwordHash) { this.passwordHash = passwordHash; }
    
    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }
    
    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
    
    public Boolean getIsActive() { return isActive; }
    public void setIsActive(Boolean isActive) { this.isActive = isActive; }
    
    public Boolean getIsAdmin() { return isAdmin; }
    public void setIsAdmin(Boolean isAdmin) { this.isAdmin = isAdmin; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public LocalDateTime getLastLogin() { return lastLogin; }
    public void setLastLogin(LocalDateTime lastLogin) { this.lastLogin = lastLogin; }
    
    public List<Order> getOrders() { return orders; }
    public void setOrders(List<Order> orders) { this.orders = orders; }
    
    public List<Address> getAddresses() { return addresses; }
    public void setAddresses(List<Address> addresses) { this.addresses = addresses; }
    
    // Helper methods
    public void addOrder(Order order) {
        orders.add(order);
        order.setUser(this);
    }
    
    public void removeOrder(Order order) {
        orders.remove(order);
        order.setUser(null);
    }
    
    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", email='" + email + '\'' +
                ", isActive=" + isActive +
                '}';
    }
}
```

```java
package com.example.model;

import jakarta.persistence.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * Entit√© Order
 */
@Entity
@Table(name = "orders", indexes = {
    @Index(name = "idx_order_user_status", columnList = "user_id, status"),
    @Index(name = "idx_order_created", columnList = "created_at")
})
public class Order {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    @Column(name = "total_amount", nullable = false, precision = 10, scale = 2)
    private BigDecimal totalAmount;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", length = 20, nullable = false)
    private OrderStatus status = OrderStatus.PENDING;
    
    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<OrderItem> items = new ArrayList<>();
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt = LocalDateTime.now();
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // Constructeurs, getters, setters...
    
    public enum OrderStatus {
        PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
    }
}
```

### Op√©rations CRUD avec JPA

```java
package com.example.repository;

import com.example.model.User;
import jakarta.persistence.*;
import java.util.List;
import java.util.Optional;

/**
 * Repository pour les op√©rations CRUD avec JPA
 */
public class UserRepository {
    
    private EntityManagerFactory emf;
    
    public UserRepository() {
        this.emf = Persistence.createEntityManagerFactory("MariaDBPU");
    }
    
    /**
     * Cr√©er un utilisateur
     */
    public User create(User user) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        
        try {
            tx.begin();
            em.persist(user);
            tx.commit();
            return user;
        } catch (Exception e) {
            if (tx.isActive()) {
                tx.rollback();
            }
            throw new RuntimeException("Erreur lors de la cr√©ation", e);
        } finally {
            em.close();
        }
    }
    
    /**
     * Trouver par ID
     */
    public Optional<User> findById(Long id) {
        EntityManager em = emf.createEntityManager();
        try {
            User user = em.find(User.class, id);
            return Optional.ofNullable(user);
        } finally {
            em.close();
        }
    }
    
    /**
     * Trouver par email
     */
    public Optional<User> findByEmail(String email) {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<User> query = em.createQuery(
                "SELECT u FROM User u WHERE u.email = :email", 
                User.class
            );
            query.setParameter("email", email);
            
            List<User> results = query.getResultList();
            return results.isEmpty() ? Optional.empty() : Optional.of(results.get(0));
            
        } finally {
            em.close();
        }
    }
    
    /**
     * Trouver tous avec pagination
     */
    public List<User> findAll(int page, int pageSize) {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<User> query = em.createQuery(
                "SELECT u FROM User u WHERE u.isActive = true ORDER BY u.createdAt DESC",
                User.class
            );
            query.setFirstResult(page * pageSize);
            query.setMaxResults(pageSize);
            
            return query.getResultList();
        } finally {
            em.close();
        }
    }
    
    /**
     * Mettre √† jour
     */
    public User update(User user) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        
        try {
            tx.begin();
            User updated = em.merge(user);
            tx.commit();
            return updated;
        } catch (Exception e) {
            if (tx.isActive()) {
                tx.rollback();
            }
            throw new RuntimeException("Erreur lors de la mise √† jour", e);
        } finally {
            em.close();
        }
    }
    
    /**
     * Supprimer
     */
    public void delete(Long id) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        
        try {
            tx.begin();
            User user = em.find(User.class, id);
            if (user != null) {
                em.remove(user);
            }
            tx.commit();
        } catch (Exception e) {
            if (tx.isActive()) {
                tx.rollback();
            }
            throw new RuntimeException("Erreur lors de la suppression", e);
        } finally {
            em.close();
        }
    }
    
    /**
     * Requ√™te JPQL avanc√©e avec jointure
     */
    public List<User> findUsersWithRecentOrders(int days) {
        EntityManager em = emf.createEntityManager();
        try {
            String jpql = """
                SELECT DISTINCT u FROM User u
                JOIN u.orders o
                WHERE o.createdAt >= :sinceDate
                ORDER BY u.username
                """;
            
            TypedQuery<User> query = em.createQuery(jpql, User.class);
            query.setParameter("sinceDate", LocalDateTime.now().minusDays(days));
            
            return query.getResultList();
        } finally {
            em.close();
        }
    }
    
    /**
     * Requ√™te native SQL
     */
    public List<Object[]> getUserOrderStats() {
        EntityManager em = emf.createEntityManager();
        try {
            String sql = """
                SELECT 
                    u.username,
                    COUNT(o.id) as order_count,
                    COALESCE(SUM(o.total_amount), 0) as total_spent
                FROM users u
                LEFT JOIN orders o ON u.id = o.user_id
                GROUP BY u.id, u.username
                HAVING order_count > 0
                ORDER BY total_spent DESC
                """;
            
            Query query = em.createNativeQuery(sql);
            return query.getResultList();
        } finally {
            em.close();
        }
    }
    
    /**
     * Fermer le factory
     */
    public void close() {
        if (emf != null && emf.isOpen()) {
            emf.close();
        }
    }
}
```

---

## Spring Boot + Spring Data JPA

### Configuration Spring Boot

```java
// src/main/resources/application.yml
spring:
  datasource:
    url: jdbc:mariadb://localhost:3306/production_db
    username: app_user
    password: SecureP@ssw0rd!
    driver-class-name: org.mariadb.jdbc.Driver
    
    # HikariCP configuration
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      pool-name: SpringBootHikariCP
      
  jpa:
    hibernate:
      ddl-auto: validate  # validate, update, create, create-drop
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MariaDBDialect
        format_sql: true
        use_sql_comments: true
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true
        
logging:
  level:
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
```

### Repository Spring Data JPA

```java
package com.example.repository;

import com.example.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Repository Spring Data JPA
 * Pas besoin d'impl√©mentation, Spring g√©n√®re automatiquement !
 */
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // M√©thodes d√©riv√©es du nom (Query Methods)
    Optional<User> findByEmail(String email);
    Optional<User> findByUsername(String username);
    List<User> findByIsActiveTrue();
    List<User> findByCreatedAtAfter(LocalDateTime date);
    Long countByIsActiveTrue();
    Boolean existsByEmail(String email);
    
    // Requ√™tes JPQL personnalis√©es
    @Query("SELECT u FROM User u WHERE u.email LIKE %:domain%")
    List<User> findByEmailDomain(@Param("domain") String domain);
    
    @Query("""
        SELECT u FROM User u 
        JOIN u.orders o 
        WHERE o.createdAt >= :sinceDate
        GROUP BY u.id
        HAVING COUNT(o.id) >= :minOrders
        """)
    List<User> findActiveUsers(
        @Param("sinceDate") LocalDateTime sinceDate,
        @Param("minOrders") long minOrders
    );
    
    // Requ√™te native SQL
    @Query(value = """
        SELECT * FROM users u
        WHERE u.is_active = true
          AND u.created_at >= :sinceDate
        ORDER BY u.created_at DESC
        LIMIT :limit
        """, nativeQuery = true)
    List<User> findRecentActiveUsers(
        @Param("sinceDate") LocalDateTime sinceDate,
        @Param("limit") int limit
    );
    
    // Modification avec @Modifying
    @Modifying
    @Query("UPDATE User u SET u.isActive = false WHERE u.lastLogin < :date")
    int deactivateInactiveUsers(@Param("date") LocalDateTime date);
}
```

### Service Layer avec Spring

```java
package com.example.service;

import com.example.model.User;
import com.example.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Service utilisateur avec transactions d√©claratives Spring
 */
@Service
@Transactional(readOnly = true)  // Par d√©faut : lecture seule
public class UserService {
    
    private final UserRepository userRepository;
    private final BCryptPasswordEncoder passwordEncoder;
    
    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
        this.passwordEncoder = new BCryptPasswordEncoder(12);
    }
    
    /**
     * Cr√©er un utilisateur (transactional en √©criture)
     */
    @Transactional  // Override : lecture/√©criture
    public User createUser(String username, String email, String password) {
        // V√©rifier si l'email existe d√©j√†
        if (userRepository.existsByEmail(email)) {
            throw new IllegalArgumentException("Email d√©j√† utilis√©");
        }
        
        // Hasher le mot de passe
        String passwordHash = passwordEncoder.encode(password);
        
        // Cr√©er et sauvegarder
        User user = new User(username, email, passwordHash);
        return userRepository.save(user);
    }
    
    /**
     * Authentifier un utilisateur
     */
    @Transactional
    public Optional<User> authenticate(String email, String password) {
        Optional<User> userOpt = userRepository.findByEmail(email);
        
        if (userOpt.isEmpty()) {
            return Optional.empty();
        }
        
        User user = userOpt.get();
        
        // V√©rifier le mot de passe
        if (passwordEncoder.matches(password, user.getPasswordHash())) {
            // Mettre √† jour lastLogin
            user.setLastLogin(LocalDateTime.now());
            userRepository.save(user);
            return Optional.of(user);
        }
        
        return Optional.empty();
    }
    
    /**
     * Lister les utilisateurs actifs
     */
    public List<User> getActiveUsers() {
        return userRepository.findByIsActiveTrue();
    }
    
    /**
     * D√©sactiver les utilisateurs inactifs (batch operation)
     */
    @Transactional
    public int deactivateInactiveUsers(int daysInactive) {
        LocalDateTime cutoffDate = LocalDateTime.now().minusDays(daysInactive);
        return userRepository.deactivateInactiveUsers(cutoffDate);
    }
    
    /**
     * Supprimer un utilisateur
     */
    @Transactional
    public void deleteUser(Long userId) {
        userRepository.deleteById(userId);
    }
}
```

---

## Bonnes pratiques de s√©curit√©

### 1. Hashing s√©curis√© des mots de passe

```java
package com.example.security;

import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

/**
 * Gestion s√©curis√©e des mots de passe avec BCrypt
 */
public class PasswordHashingExample {
    
    private static final PasswordEncoder encoder = new BCryptPasswordEncoder(12);
    
    /**
     * Hasher un mot de passe
     */
    public static String hashPassword(String plainPassword) {
        // BCrypt g√©n√®re automatiquement un salt unique
        return encoder.encode(plainPassword);
    }
    
    /**
     * V√©rifier un mot de passe
     */
    public static boolean verifyPassword(String plainPassword, String hashedPassword) {
        // V√©rification en temps constant (protection contre timing attacks)
        return encoder.matches(plainPassword, hashedPassword);
    }
    
    /**
     * Exemple d'utilisation
     */
    public static void main(String[] args) {
        String password = "SecureP@ssw0rd!";
        
        // Hashing
        String hash1 = hashPassword(password);
        String hash2 = hashPassword(password);
        
        System.out.println("Hash 1: " + hash1);
        System.out.println("Hash 2: " + hash2);
        System.out.println("Les hash sont diff√©rents : " + !hash1.equals(hash2));
        
        // V√©rification
        boolean valid = verifyPassword(password, hash1);
        System.out.println("Mot de passe valide : " + valid);
        
        boolean invalid = verifyPassword("WrongPassword", hash1);
        System.out.println("Mauvais mot de passe : " + !invalid);
    }
}
```

### 2. Validation des entr√©es

```java
package com.example.validation;

import jakarta.validation.constraints.*;

/**
 * DTO avec validation Bean Validation
 */
public class UserRegistrationDTO {
    
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "Username can only contain letters, numbers and underscores")
    private String username;
    
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    private String email;
    
    @NotBlank(message = "Password is required")
    @Size(min = 12, message = "Password must be at least 12 characters")
    @Pattern(
        regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]+$",
        message = "Password must contain uppercase, lowercase, digit and special character"
    )
    private String password;
    
    // Getters et setters...
}

// Utilisation dans un controller
@PostMapping("/register")
public ResponseEntity<?> register(@Valid @RequestBody UserRegistrationDTO dto) {
    // Si validation √©choue, Spring renvoie automatiquement une erreur 400
    User user = userService.createUser(dto.getUsername(), dto.getEmail(), dto.getPassword());
    return ResponseEntity.ok(user);
}
```

### 3. Protection contre les injections SQL

```java
/**
 * Exemples d'injections SQL et pr√©vention
 */
public class SqlInjectionPrevention {
    
    // ‚ùå VULN√âRABLE - NE JAMAIS FAIRE
    public void vulnerableQuery(EntityManager em, String username) {
        String jpql = "SELECT u FROM User u WHERE u.username = '" + username + "'";
        // Si username = "admin' OR '1'='1" ‚Üí contournement !
        Query query = em.createQuery(jpql);
        query.getResultList();
    }
    
    // ‚úÖ S√âCURIS√â - PreparedStatement JDBC
    public void secureJdbc(Connection conn, String username) throws SQLException {
        String sql = "SELECT * FROM users WHERE username = ?";
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, username);  // √âchappement automatique
            pstmt.executeQuery();
        }
    }
    
    // ‚úÖ S√âCURIS√â - JPQL avec param√®tres nomm√©s
    public void secureJpql(EntityManager em, String username) {
        TypedQuery<User> query = em.createQuery(
            "SELECT u FROM User u WHERE u.username = :username",
            User.class
        );
        query.setParameter("username", username);  // S√©curis√©
        query.getResultList();
    }
    
    // ‚úÖ S√âCURIS√â - Criteria API (type-safe)
    public void secureCriteria(EntityManager em, String username) {
        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<User> cq = cb.createQuery(User.class);
        Root<User> user = cq.from(User.class);
        
        cq.select(user)
          .where(cb.equal(user.get("username"), username));  // Param√©tris√©
        
        em.createQuery(cq).getResultList();
    }
}
```

---

## ‚úÖ Points cl√©s √† retenir

1. **Driver** : MariaDB Connector/J 3.x pour MariaDB 11.8+
2. **Connection Pool** : HikariCP recommand√© (le plus performant)
3. **PreparedStatement** : TOUJOURS utiliser, jamais de concat√©nation SQL
4. **Transactions** : try-with-resources pour JDBC, @Transactional pour Spring
5. **ORM** : Spring Data JPA pour productivit√© maximale en production
6. **S√©curit√©** : BCrypt (strength 12), validation Bean Validation, parameterized queries
7. **Configuration** : Pool size = cores √ó 2, timeout appropri√©s, charset utf8mb4
8. **Performance** : Batch operations, lazy loading, prepared statement cache
9. **Migration** : Utiliser Flyway ou Liquibase pour gestion de sch√©ma
10. **Tests** : Testcontainers pour tests d'int√©gration avec vraie base MariaDB

---

## üîó Ressources et r√©f√©rences

### Documentation officielle
- [üìñ MariaDB Connector/J](https://mariadb.com/kb/en/about-mariadb-connector-j/)
- [üìñ Hibernate Documentation](https://hibernate.org/orm/documentation/)
- [üìñ Spring Data JPA](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/)
- [üìñ HikariCP](https://github.com/brettwooldridge/HikariCP)

### Guides et tutoriels
- [Spring Boot with MariaDB](https://spring.io/guides/gs/accessing-data-mysql/)
- [JPA Tutorial](https://www.baeldung.com/learn-jpa-hibernate)
- [JDBC Best Practices](https://www.baeldung.com/java-jdbc)

### S√©curit√©
- [OWASP Java Security](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [Spring Security](https://spring.io/projects/spring-security)

### Outils
- [Flyway](https://flywaydb.org/) - Migrations de sch√©ma
- [Liquibase](https://www.liquibase.org/) - Alternative √† Flyway
- [Testcontainers](https://www.testcontainers.org/) - Tests d'int√©gration
- [jOOQ](https://www.jooq.org/) - Type-safe SQL builder

---

## ‚û°Ô∏è Section suivante

**17.1.4 Node.js : mysql2, mariadb** : D√©couvrez comment int√©grer MariaDB dans vos applications Node.js avec les connecteurs modernes, async/await, connection pooling, et les ORMs Sequelize et Prisma.

‚è≠Ô∏è [Node.js : mysql2, mariadb](/17-integration-developpement/01.4-nodejs-connectors.md)
