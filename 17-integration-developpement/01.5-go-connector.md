ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 17.1.5 Go : go-sql-driver/mysql

> **Niveau** : IntermÃ©diaire Ã  AvancÃ©  
> **DurÃ©e estimÃ©e** : 3-4 heures  
> **PrÃ©requis** : Go 1.21+, bases de la concurrence Go, error handling, interfaces

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Utiliser database/sql et go-sql-driver/mysql pour MariaDB
- MaÃ®triser le connection pooling natif de Go
- ImplÃ©menter des prepared statements type-safe
- GÃ©rer les transactions avec context.Context
- Utiliser sqlx et GORM pour plus de productivitÃ©
- Appliquer les patterns Go idiomatiques (defer, error handling)
- ImplÃ©menter la concurrence sÃ»re avec goroutines
- GÃ©rer les timeouts et cancellations avec Context

---

## Introduction

Go (Golang) offre une excellente intÃ©gration avec MariaDB grÃ¢ce Ã  son package `database/sql` de la bibliothÃ¨que standard et au driver `go-sql-driver/mysql`. Go est particuliÃ¨rement adaptÃ© aux applications haute performance, microservices et systÃ¨mes distribuÃ©s.

### Ã‰cosystÃ¨me Go-MariaDB

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Application Go                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Framework Layer (optionnel)                â”‚
â”‚  â”œâ”€ Gin (web framework)                     â”‚
â”‚  â”œâ”€ Echo (high performance)                 â”‚
â”‚  â”œâ”€ Fiber (Express-like)                    â”‚
â”‚  â””â”€ Chi (lightweight router)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ORM/Query Builder                          â”‚
â”‚  â”œâ”€ GORM (ORM complet)                      â”‚
â”‚  â”œâ”€ sqlx (extensions database/sql)          â”‚
â”‚  â”œâ”€ sqlc (code generation)                  â”‚
â”‚  â””â”€ ent (Facebook, schema-first)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Standard Library                           â”‚
â”‚  â””â”€ database/sql (interface standard)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Driver                                     â”‚
â”‚  â””â”€ go-sql-driver/mysql                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          MariaDB Server                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

ğŸ’¡ **Conseil** : Pour les applications production, utilisez **database/sql** directement avec **sqlx** pour la simplicitÃ©, ou **GORM** pour les projets avec beaucoup de relations. Go privilÃ©gie la simplicitÃ© et les performances sur l'abstraction.

---

## Pourquoi Go est excellent pour MariaDB

### Avantages de Go

| Aspect | Avantage |
|--------|----------|
| **Performance** | Compilation native, pas de VM, goroutines lÃ©gÃ¨res |
| **Concurrence** | Goroutines et channels pour parallÃ©lisme facile |
| **Typage** | Typage fort compile-time, moins d'erreurs runtime |
| **DÃ©ploiement** | Binaire unique, pas de dÃ©pendances |
| **Memory** | Garbage collector efficace, faible empreinte |
| **Standard Library** | database/sql robuste et bien conÃ§u |
| **Connection Pool** | IntÃ©grÃ© et optimisÃ© par dÃ©faut |

### Philosophie Go

- **SimplicitÃ©** : Code explicite, peu de magie
- **Performance** : Proche du C, plus simple que le C++
- **Concurrence** : Goroutines vs threads traditionnels
- **Error handling** : Explicite, pas d'exceptions cachÃ©es
- **Interfaces** : Petites et composables

---

## Installation et configuration

### Installation du driver

```bash
# Initialiser un module Go
go mod init myapp

# Installer le driver MySQL/MariaDB
go get -u github.com/go-sql-driver/mysql
```

### Structure de projet recommandÃ©e

```
myapp/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ main.go          # Point d'entrÃ©e
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ config.go        # Configuration
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â”œâ”€â”€ db.go            # Pool de connexions
â”‚   â”‚   â””â”€â”€ migrations.go    # Migrations
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ user.go          # ModÃ¨le User
â”‚   â”‚   â””â”€â”€ order.go         # ModÃ¨le Order
â”‚   â”œâ”€â”€ repository/
â”‚   â”‚   â”œâ”€â”€ user_repo.go     # Repository User
â”‚   â”‚   â””â”€â”€ order_repo.go    # Repository Order
â”‚   â”œâ”€â”€ service/
â”‚   â”‚   â””â”€â”€ user_service.go  # Business logic
â”‚   â””â”€â”€ handler/
â”‚       â””â”€â”€ user_handler.go  # HTTP handlers
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â””â”€â”€ .env
```

### Configuration avec variables d'environnement

```go
// internal/config/config.go
package config

import (
	"fmt"
	"os"
	"strconv"
	"time"
)

// Config contient la configuration de l'application
type Config struct {
	Database DatabaseConfig
	Server   ServerConfig
}

// DatabaseConfig contient la configuration de la base de donnÃ©es
type DatabaseConfig struct {
	Host            string
	Port            int
	User            string
	Password        string
	Database        string
	Charset         string
	Collation       string
	ParseTime       bool
	Loc             string
	Timeout         time.Duration
	ReadTimeout     time.Duration
	WriteTimeout    time.Duration
	MaxOpenConns    int
	MaxIdleConns    int
	ConnMaxLifetime time.Duration
	ConnMaxIdleTime time.Duration
}

// ServerConfig contient la configuration du serveur
type ServerConfig struct {
	Port         int
	ReadTimeout  time.Duration
	WriteTimeout time.Duration
}

// Load charge la configuration depuis les variables d'environnement
func Load() (*Config, error) {
	cfg := &Config{
		Database: DatabaseConfig{
			Host:            getEnv("DB_HOST", "localhost"),
			Port:            getEnvAsInt("DB_PORT", 3306),
			User:            getEnv("DB_USER", "app_user"),
			Password:        getEnv("DB_PASSWORD", ""),
			Database:        getEnv("DB_NAME", "production_db"),
			Charset:         getEnv("DB_CHARSET", "utf8mb4"),
			Collation:       getEnv("DB_COLLATION", "utf8mb4_unicode_ci"),
			ParseTime:       true,  // Parse TIME/DATE to time.Time
			Loc:             "UTC",
			Timeout:         getEnvAsDuration("DB_TIMEOUT", 10*time.Second),
			ReadTimeout:     getEnvAsDuration("DB_READ_TIMEOUT", 30*time.Second),
			WriteTimeout:    getEnvAsDuration("DB_WRITE_TIMEOUT", 30*time.Second),
			MaxOpenConns:    getEnvAsInt("DB_MAX_OPEN_CONNS", 25),
			MaxIdleConns:    getEnvAsInt("DB_MAX_IDLE_CONNS", 5),
			ConnMaxLifetime: getEnvAsDuration("DB_CONN_MAX_LIFETIME", 5*time.Minute),
			ConnMaxIdleTime: getEnvAsDuration("DB_CONN_MAX_IDLE_TIME", 5*time.Minute),
		},
		Server: ServerConfig{
			Port:         getEnvAsInt("SERVER_PORT", 8080),
			ReadTimeout:  getEnvAsDuration("SERVER_READ_TIMEOUT", 15*time.Second),
			WriteTimeout: getEnvAsDuration("SERVER_WRITE_TIMEOUT", 15*time.Second),
		},
	}
	
	return cfg, nil
}

// DSN gÃ©nÃ¨re la Data Source Name pour la connexion
func (c *DatabaseConfig) DSN() string {
	return fmt.Sprintf(
		"%s:%s@tcp(%s:%d)/%s?charset=%s&collation=%s&parseTime=%t&loc=%s&timeout=%s&readTimeout=%s&writeTimeout=%s",
		c.User,
		c.Password,
		c.Host,
		c.Port,
		c.Database,
		c.Charset,
		c.Collation,
		c.ParseTime,
		c.Loc,
		c.Timeout,
		c.ReadTimeout,
		c.WriteTimeout,
	)
}

// Helper functions
func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

func getEnvAsInt(key string, defaultValue int) int {
	if value := os.Getenv(key); value != "" {
		if intVal, err := strconv.Atoi(value); err == nil {
			return intVal
		}
	}
	return defaultValue
}

func getEnvAsDuration(key string, defaultValue time.Duration) time.Duration {
	if value := os.Getenv(key); value != "" {
		if duration, err := time.ParseDuration(value); err == nil {
			return duration
		}
	}
	return defaultValue
}
```

---

## Connexion avec database/sql

### Initialisation du pool de connexions

```go
// internal/database/db.go
package database

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"time"
	
	_ "github.com/go-sql-driver/mysql" // Import du driver
	"myapp/internal/config"
)

// DB encapsule le pool de connexions
type DB struct {
	*sql.DB
}

// New crÃ©e une nouvelle instance de DB avec pool de connexions
func New(cfg *config.DatabaseConfig) (*DB, error) {
	// Ouvrir la connexion
	db, err := sql.Open("mysql", cfg.DSN())
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}
	
	// Configuration du pool
	db.SetMaxOpenConns(cfg.MaxOpenConns)
	db.SetMaxIdleConns(cfg.MaxIdleConns)
	db.SetConnMaxLifetime(cfg.ConnMaxLifetime)
	db.SetConnMaxIdleTime(cfg.ConnMaxIdleTime)
	
	// VÃ©rifier la connexion avec timeout
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	if err := db.PingContext(ctx); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}
	
	log.Println("âœ“ Connected to MariaDB")
	
	return &DB{db}, nil
}

// Close ferme proprement la connexion
func (db *DB) Close() error {
	log.Println("Closing database connection...")
	return db.DB.Close()
}

// Stats retourne les statistiques du pool
func (db *DB) Stats() sql.DBStats {
	return db.DB.Stats()
}

// Health vÃ©rifie la santÃ© de la connexion
func (db *DB) Health(ctx context.Context) error {
	return db.PingContext(ctx)
}
```

### Utilisation basique

```go
// cmd/api/main.go
package main

import (
	"context"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"
	
	"myapp/internal/config"
	"myapp/internal/database"
)

func main() {
	// Charger la configuration
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}
	
	// Initialiser la base de donnÃ©es
	db, err := database.New(&cfg.Database)
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}
	defer db.Close()
	
	// Test query
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	var version string
	err = db.QueryRowContext(ctx, "SELECT VERSION()").Scan(&version)
	if err != nil {
		log.Fatalf("Failed to query version: %v", err)
	}
	
	log.Printf("MariaDB version: %s", version)
	
	// Afficher les stats du pool
	stats := db.Stats()
	log.Printf("Pool stats: Open=%d Idle=%d InUse=%d", 
		stats.OpenConnections, 
		stats.Idle, 
		stats.InUse,
	)
	
	// Graceful shutdown
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	
	log.Println("Shutting down gracefully...")
}
```

---

## Prepared Statements et requÃªtes paramÃ©trÃ©es

### ModÃ¨le User

```go
// internal/models/user.go
package models

import (
	"time"
)

// User reprÃ©sente un utilisateur
type User struct {
	ID           int64      `db:"id"`
	Username     string     `db:"username"`
	Email        string     `db:"email"`
	PasswordHash string     `db:"password_hash"`
	FirstName    *string    `db:"first_name"`  // Nullable
	LastName     *string    `db:"last_name"`   // Nullable
	IsActive     bool       `db:"is_active"`
	IsAdmin      bool       `db:"is_admin"`
	CreatedAt    time.Time  `db:"created_at"`
	UpdatedAt    *time.Time `db:"updated_at"`  // Nullable
	LastLogin    *time.Time `db:"last_login"`  // Nullable
}

// UserCreate reprÃ©sente les donnÃ©es pour crÃ©er un utilisateur
type UserCreate struct {
	Username     string
	Email        string
	PasswordHash string
	FirstName    *string
	LastName     *string
}

// UserUpdate reprÃ©sente les donnÃ©es pour mettre Ã  jour un utilisateur
type UserUpdate struct {
	Email     *string
	FirstName *string
	LastName  *string
	IsActive  *bool
}
```

### Repository avec prepared statements

```go
// internal/repository/user_repo.go
package repository

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"
	
	"myapp/internal/models"
)

var (
	ErrUserNotFound      = errors.New("user not found")
	ErrUserAlreadyExists = errors.New("user already exists")
)

// UserRepository gÃ¨re les opÃ©rations CRUD pour les utilisateurs
type UserRepository struct {
	db *sql.DB
}

// NewUserRepository crÃ©e une nouvelle instance
func NewUserRepository(db *sql.DB) *UserRepository {
	return &UserRepository{db: db}
}

// Create crÃ©e un nouvel utilisateur
func (r *UserRepository) Create(ctx context.Context, user *models.UserCreate) (*models.User, error) {
	query := `
		INSERT INTO users (username, email, password_hash, first_name, last_name, created_at)
		VALUES (?, ?, ?, ?, ?, NOW())
	`
	
	// Prepared statement automatique avec ExecContext
	result, err := r.db.ExecContext(
		ctx,
		query,
		user.Username,
		user.Email,
		user.PasswordHash,
		user.FirstName,
		user.LastName,
	)
	if err != nil {
		// GÃ©rer l'erreur de contrainte unique
		if isDuplicateError(err) {
			return nil, ErrUserAlreadyExists
		}
		return nil, fmt.Errorf("failed to create user: %w", err)
	}
	
	// RÃ©cupÃ©rer l'ID gÃ©nÃ©rÃ©
	id, err := result.LastInsertId()
	if err != nil {
		return nil, fmt.Errorf("failed to get last insert id: %w", err)
	}
	
	// RÃ©cupÃ©rer l'utilisateur crÃ©Ã©
	return r.GetByID(ctx, id)
}

// GetByID rÃ©cupÃ¨re un utilisateur par son ID
func (r *UserRepository) GetByID(ctx context.Context, id int64) (*models.User, error) {
	query := `
		SELECT id, username, email, password_hash, first_name, last_name,
		       is_active, is_admin, created_at, updated_at, last_login
		FROM users
		WHERE id = ?
	`
	
	user := &models.User{}
	
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&user.ID,
		&user.Username,
		&user.Email,
		&user.PasswordHash,
		&user.FirstName,
		&user.LastName,
		&user.IsActive,
		&user.IsAdmin,
		&user.CreatedAt,
		&user.UpdatedAt,
		&user.LastLogin,
	)
	
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrUserNotFound
		}
		return nil, fmt.Errorf("failed to get user: %w", err)
	}
	
	return user, nil
}

// GetByEmail rÃ©cupÃ¨re un utilisateur par son email
func (r *UserRepository) GetByEmail(ctx context.Context, email string) (*models.User, error) {
	query := `
		SELECT id, username, email, password_hash, first_name, last_name,
		       is_active, is_admin, created_at, updated_at, last_login
		FROM users
		WHERE email = ?
	`
	
	user := &models.User{}
	
	err := r.db.QueryRowContext(ctx, query, email).Scan(
		&user.ID,
		&user.Username,
		&user.Email,
		&user.PasswordHash,
		&user.FirstName,
		&user.LastName,
		&user.IsActive,
		&user.IsAdmin,
		&user.CreatedAt,
		&user.UpdatedAt,
		&user.LastLogin,
	)
	
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrUserNotFound
		}
		return nil, fmt.Errorf("failed to get user by email: %w", err)
	}
	
	return user, nil
}

// List rÃ©cupÃ¨re une liste d'utilisateurs avec pagination
func (r *UserRepository) List(ctx context.Context, limit, offset int) ([]*models.User, error) {
	query := `
		SELECT id, username, email, first_name, last_name,
		       is_active, created_at
		FROM users
		WHERE is_active = true
		ORDER BY created_at DESC
		LIMIT ? OFFSET ?
	`
	
	rows, err := r.db.QueryContext(ctx, query, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to list users: %w", err)
	}
	defer rows.Close()
	
	users := make([]*models.User, 0)
	
	for rows.Next() {
		user := &models.User{}
		err := rows.Scan(
			&user.ID,
			&user.Username,
			&user.Email,
			&user.FirstName,
			&user.LastName,
			&user.IsActive,
			&user.CreatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan user: %w", err)
		}
		users = append(users, user)
	}
	
	// VÃ©rifier les erreurs de rows
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}
	
	return users, nil
}

// Update met Ã  jour un utilisateur
func (r *UserRepository) Update(ctx context.Context, id int64, update *models.UserUpdate) error {
	// Construction dynamique de la requÃªte
	query := "UPDATE users SET updated_at = NOW()"
	args := make([]interface{}, 0)
	
	if update.Email != nil {
		query += ", email = ?"
		args = append(args, *update.Email)
	}
	if update.FirstName != nil {
		query += ", first_name = ?"
		args = append(args, *update.FirstName)
	}
	if update.LastName != nil {
		query += ", last_name = ?"
		args = append(args, *update.LastName)
	}
	if update.IsActive != nil {
		query += ", is_active = ?"
		args = append(args, *update.IsActive)
	}
	
	query += " WHERE id = ?"
	args = append(args, id)
	
	result, err := r.db.ExecContext(ctx, query, args...)
	if err != nil {
		if isDuplicateError(err) {
			return ErrUserAlreadyExists
		}
		return fmt.Errorf("failed to update user: %w", err)
	}
	
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	
	if rowsAffected == 0 {
		return ErrUserNotFound
	}
	
	return nil
}

// Delete supprime un utilisateur (soft delete)
func (r *UserRepository) Delete(ctx context.Context, id int64) error {
	query := `UPDATE users SET is_active = false, updated_at = NOW() WHERE id = ?`
	
	result, err := r.db.ExecContext(ctx, query, id)
	if err != nil {
		return fmt.Errorf("failed to delete user: %w", err)
	}
	
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	
	if rowsAffected == 0 {
		return ErrUserNotFound
	}
	
	return nil
}

// Count compte le nombre total d'utilisateurs
func (r *UserRepository) Count(ctx context.Context) (int64, error) {
	query := `SELECT COUNT(*) FROM users WHERE is_active = true`
	
	var count int64
	err := r.db.QueryRowContext(ctx, query).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("failed to count users: %w", err)
	}
	
	return count, nil
}

// UpdateLastLogin met Ã  jour la date de derniÃ¨re connexion
func (r *UserRepository) UpdateLastLogin(ctx context.Context, id int64) error {
	query := `UPDATE users SET last_login = NOW() WHERE id = ?`
	
	_, err := r.db.ExecContext(ctx, query, id)
	if err != nil {
		return fmt.Errorf("failed to update last login: %w", err)
	}
	
	return nil
}

// Helper function pour dÃ©tecter les erreurs de contrainte unique
func isDuplicateError(err error) bool {
	// go-sql-driver/mysql retourne une erreur avec le code 1062 pour duplicate entry
	return err != nil && (
		containsString(err.Error(), "Error 1062") ||
		containsString(err.Error(), "Duplicate entry"))
}

func containsString(s, substr string) bool {
	return len(s) >= len(substr) && 
		(s == substr || len(s) > len(substr) && 
		(s[:len(substr)] == substr || s[len(s)-len(substr):] == substr || 
		containsString(s[1:], substr)))
}
```

âš ï¸ **Attention** : En Go, TOUJOURS utiliser les placeholders `?` et JAMAIS de concatÃ©nation ou fmt.Sprintf pour construire des requÃªtes SQL !

```go
// âŒ DANGEREUX - Injection SQL possible
username := "admin' OR '1'='1"
query := fmt.Sprintf("SELECT * FROM users WHERE username = '%s'", username)
rows, _ := db.Query(query)  // VULNÃ‰RABLE !

// âœ… SÃ‰CURISÃ‰ - Prepared statement
username := "admin' OR '1'='1"
query := "SELECT * FROM users WHERE username = ?"
rows, _ := db.QueryContext(ctx, query, username)  // SÃ‰CURISÃ‰
```

---

## Gestion des transactions

### Transactions avec Context

```go
// internal/repository/order_repo.go
package repository

import (
	"context"
	"database/sql"
	"fmt"
	"time"
	
	"myapp/internal/models"
)

// OrderRepository gÃ¨re les opÃ©rations sur les commandes
type OrderRepository struct {
	db *sql.DB
}

// NewOrderRepository crÃ©e une nouvelle instance
func NewOrderRepository(db *sql.DB) *OrderRepository {
	return &OrderRepository{db: db}
}

// CreateOrder crÃ©e une commande avec ses items (transaction atomique)
func (r *OrderRepository) CreateOrder(ctx context.Context, userID int64, items []models.OrderItem) (*models.Order, error) {
	// DÃ©marrer la transaction
	tx, err := r.db.BeginTx(ctx, &sql.TxOptions{
		Isolation: sql.LevelRepeatableRead,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	
	// defer pour rollback en cas d'erreur
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()
	
	// 1. CrÃ©er la commande
	orderQuery := `
		INSERT INTO orders (user_id, total_amount, status, created_at)
		VALUES (?, 0, 'pending', NOW())
	`
	
	result, err := tx.ExecContext(ctx, orderQuery, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to create order: %w", err)
	}
	
	orderID, err := result.LastInsertId()
	if err != nil {
		return nil, fmt.Errorf("failed to get order id: %w", err)
	}
	
	var totalAmount float64
	
	// 2. Traiter chaque item
	for _, item := range items {
		// RÃ©cupÃ©rer le produit avec lock
		productQuery := `
			SELECT id, price, stock 
			FROM products 
			WHERE id = ? 
			FOR UPDATE
		`
		
		var product struct {
			ID    int64
			Price float64
			Stock int
		}
		
		err = tx.QueryRowContext(ctx, productQuery, item.ProductID).Scan(
			&product.ID,
			&product.Price,
			&product.Stock,
		)
		if err != nil {
			if errors.Is(err, sql.ErrNoRows) {
				return nil, fmt.Errorf("product %d not found", item.ProductID)
			}
			return nil, fmt.Errorf("failed to get product: %w", err)
		}
		
		// VÃ©rifier le stock
		if product.Stock < item.Quantity {
			return nil, fmt.Errorf("insufficient stock for product %d", item.ProductID)
		}
		
		// Calculer le sous-total
		subtotal := product.Price * float64(item.Quantity)
		totalAmount += subtotal
		
		// InsÃ©rer l'item
		itemQuery := `
			INSERT INTO order_items (order_id, product_id, quantity, price)
			VALUES (?, ?, ?, ?)
		`
		
		_, err = tx.ExecContext(ctx, itemQuery, orderID, item.ProductID, item.Quantity, product.Price)
		if err != nil {
			return nil, fmt.Errorf("failed to create order item: %w", err)
		}
		
		// DÃ©crÃ©menter le stock
		updateStockQuery := `UPDATE products SET stock = stock - ? WHERE id = ?`
		_, err = tx.ExecContext(ctx, updateStockQuery, item.Quantity, item.ProductID)
		if err != nil {
			return nil, fmt.Errorf("failed to update stock: %w", err)
		}
	}
	
	// 3. Mettre Ã  jour le montant total
	updateOrderQuery := `UPDATE orders SET total_amount = ? WHERE id = ?`
	_, err = tx.ExecContext(ctx, updateOrderQuery, totalAmount, orderID)
	if err != nil {
		return nil, fmt.Errorf("failed to update order total: %w", err)
	}
	
	// 4. Valider la transaction
	if err = tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}
	
	// RÃ©cupÃ©rer la commande crÃ©Ã©e
	return r.GetByID(ctx, orderID)
}

// CancelOrder annule une commande et remet le stock
func (r *OrderRepository) CancelOrder(ctx context.Context, orderID int64) error {
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()
	
	// 1. RÃ©cupÃ©rer les items
	itemsQuery := `
		SELECT product_id, quantity 
		FROM order_items 
		WHERE order_id = ?
	`
	
	rows, err := tx.QueryContext(ctx, itemsQuery, orderID)
	if err != nil {
		return fmt.Errorf("failed to get order items: %w", err)
	}
	defer rows.Close()
	
	// 2. Remettre le stock pour chaque item
	for rows.Next() {
		var productID int64
		var quantity int
		
		if err := rows.Scan(&productID, &quantity); err != nil {
			return fmt.Errorf("failed to scan order item: %w", err)
		}
		
		updateQuery := `UPDATE products SET stock = stock + ? WHERE id = ?`
		_, err = tx.ExecContext(ctx, updateQuery, quantity, productID)
		if err != nil {
			return fmt.Errorf("failed to restore stock: %w", err)
		}
	}
	
	if err := rows.Err(); err != nil {
		return fmt.Errorf("rows error: %w", err)
	}
	
	// 3. Mettre Ã  jour le statut de la commande
	cancelQuery := `
		UPDATE orders 
		SET status = 'cancelled', updated_at = NOW() 
		WHERE id = ? AND status IN ('pending', 'confirmed')
	`
	
	result, err := tx.ExecContext(ctx, cancelQuery, orderID)
	if err != nil {
		return fmt.Errorf("failed to cancel order: %w", err)
	}
	
	affected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	
	if affected == 0 {
		return fmt.Errorf("order not found or already cancelled")
	}
	
	// 4. Commit
	if err = tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit: %w", err)
	}
	
	return nil
}

// GetByID rÃ©cupÃ¨re une commande par ID
func (r *OrderRepository) GetByID(ctx context.Context, id int64) (*models.Order, error) {
	query := `
		SELECT id, user_id, total_amount, status, created_at, updated_at
		FROM orders
		WHERE id = ?
	`
	
	order := &models.Order{}
	err := r.db.QueryRowContext(ctx, query, id).Scan(
		&order.ID,
		&order.UserID,
		&order.TotalAmount,
		&order.Status,
		&order.CreatedAt,
		&order.UpdatedAt,
	)
	
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, fmt.Errorf("order not found")
		}
		return nil, fmt.Errorf("failed to get order: %w", err)
	}
	
	return order, nil
}
```

ğŸ’¡ **Conseil** : Utilisez toujours `defer tx.Rollback()` aprÃ¨s `BeginTx()`. Si la transaction est dÃ©jÃ  committed, Rollback() ne fait rien. C'est la maniÃ¨re idiomatique Go.

---

## sqlx : Extensions utiles

### Installation

```bash
go get github.com/jmoiron/sqlx
```

### Utilisation de sqlx

```go
// internal/repository/user_repo_sqlx.go
package repository

import (
	"context"
	"fmt"
	
	"github.com/jmoiron/sqlx"
	"myapp/internal/models"
)

// UserRepositorySqlx utilise sqlx pour simplifier le code
type UserRepositorySqlx struct {
	db *sqlx.DB
}

// NewUserRepositorySqlx crÃ©e une nouvelle instance
func NewUserRepositorySqlx(db *sqlx.DB) *UserRepositorySqlx {
	return &UserRepositorySqlx{db: db}
}

// GetByID rÃ©cupÃ¨re un utilisateur (syntaxe simplifiÃ©e)
func (r *UserRepositorySqlx) GetByID(ctx context.Context, id int64) (*models.User, error) {
	query := `
		SELECT id, username, email, password_hash, first_name, last_name,
		       is_active, is_admin, created_at, updated_at, last_login
		FROM users
		WHERE id = ?
	`
	
	var user models.User
	
	// Get automatiquement le scan avec les struct tags
	err := r.db.GetContext(ctx, &user, query, id)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, ErrUserNotFound
		}
		return nil, fmt.Errorf("failed to get user: %w", err)
	}
	
	return &user, nil
}

// List rÃ©cupÃ¨re une liste d'utilisateurs (syntaxe simplifiÃ©e)
func (r *UserRepositorySqlx) List(ctx context.Context, limit, offset int) ([]*models.User, error) {
	query := `
		SELECT id, username, email, first_name, last_name,
		       is_active, created_at
		FROM users
		WHERE is_active = true
		ORDER BY created_at DESC
		LIMIT ? OFFSET ?
	`
	
	var users []*models.User
	
	// Select automatiquement le scan multiple
	err := r.db.SelectContext(ctx, &users, query, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to list users: %w", err)
	}
	
	return users, nil
}

// NamedCreate utilise les named parameters
func (r *UserRepositorySqlx) NamedCreate(ctx context.Context, user *models.UserCreate) error {
	query := `
		INSERT INTO users (username, email, password_hash, first_name, last_name, created_at)
		VALUES (:username, :email, :password_hash, :first_name, :last_name, NOW())
	`
	
	// NamedExec avec une struct ou map
	_, err := r.db.NamedExecContext(ctx, query, user)
	if err != nil {
		return fmt.Errorf("failed to create user: %w", err)
	}
	
	return nil
}

// BatchInsert insÃ¨re plusieurs utilisateurs efficacement
func (r *UserRepositorySqlx) BatchInsert(ctx context.Context, users []*models.UserCreate) error {
	query := `
		INSERT INTO users (username, email, password_hash, first_name, last_name, created_at)
		VALUES (:username, :email, :password_hash, :first_name, :last_name, NOW())
	`
	
	// Transaction pour le batch
	tx, err := r.db.BeginTxx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()
	
	// Prepare statement
	stmt, err := tx.PrepareNamedContext(ctx, query)
	if err != nil {
		return fmt.Errorf("failed to prepare statement: %w", err)
	}
	defer stmt.Close()
	
	// ExÃ©cuter pour chaque utilisateur
	for _, user := range users {
		_, err := stmt.ExecContext(ctx, user)
		if err != nil {
			return fmt.Errorf("failed to insert user: %w", err)
		}
	}
	
	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit: %w", err)
	}
	
	return nil
}
```

ğŸ’¡ **Conseil** : sqlx simplifie grandement le code avec `Get`, `Select` et les named parameters, tout en gardant la performance de database/sql.

---

## GORM : ORM complet

### Installation et configuration

```bash
go get -u gorm.io/gorm
go get -u gorm.io/driver/mysql
```

```go
// internal/database/gorm.go
package database

import (
	"fmt"
	"log"
	"time"
	
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"myapp/internal/config"
)

// NewGORM crÃ©e une nouvelle instance GORM
func NewGORM(cfg *config.DatabaseConfig) (*gorm.DB, error) {
	dsn := cfg.DSN()
	
	// Configuration GORM
	gormConfig := &gorm.Config{
		Logger: logger.Default.LogMode(logger.Info),
		NowFunc: func() time.Time {
			return time.Now().UTC()
		},
		PrepareStmt:            true, // PrÃ©parer les statements
		DisableNestedTransaction: false,
	}
	
	// Ouvrir la connexion
	db, err := gorm.Open(mysql.Open(dsn), gormConfig)
	if err != nil {
		return nil, fmt.Errorf("failed to connect: %w", err)
	}
	
	// RÃ©cupÃ©rer le *sql.DB sous-jacent pour configurer le pool
	sqlDB, err := db.DB()
	if err != nil {
		return nil, fmt.Errorf("failed to get sql.DB: %w", err)
	}
	
	// Configuration du pool
	sqlDB.SetMaxOpenConns(cfg.MaxOpenConns)
	sqlDB.SetMaxIdleConns(cfg.MaxIdleConns)
	sqlDB.SetConnMaxLifetime(cfg.ConnMaxLifetime)
	
	log.Println("âœ“ GORM connected to MariaDB")
	
	return db, nil
}
```

### ModÃ¨les GORM

```go
// internal/models/user_gorm.go
package models

import (
	"time"
	"gorm.io/gorm"
)

// UserGORM modÃ¨le GORM avec hooks
type UserGORM struct {
	ID           uint           `gorm:"primaryKey"`
	Username     string         `gorm:"uniqueIndex;size:50;not null"`
	Email        string         `gorm:"uniqueIndex;size:255;not null"`
	PasswordHash string         `gorm:"size:255;not null"`
	FirstName    *string        `gorm:"size:100"`
	LastName     *string        `gorm:"size:100"`
	IsActive     bool           `gorm:"default:true;not null"`
	IsAdmin      bool           `gorm:"default:false;not null"`
	CreatedAt    time.Time      `gorm:"not null"`
	UpdatedAt    time.Time
	LastLogin    *time.Time
	DeletedAt    gorm.DeletedAt `gorm:"index"` // Soft delete
	
	// Relations
	Orders []OrderGORM `gorm:"foreignKey:UserID"`
}

// TableName spÃ©cifie le nom de la table
func (UserGORM) TableName() string {
	return "users"
}

// BeforeCreate hook avant crÃ©ation
func (u *UserGORM) BeforeCreate(tx *gorm.DB) error {
	// Normaliser l'email
	if u.Email != "" {
		u.Email = strings.ToLower(u.Email)
	}
	return nil
}

// OrderGORM modÃ¨le de commande
type OrderGORM struct {
	ID          uint           `gorm:"primaryKey"`
	UserID      uint           `gorm:"not null;index"`
	TotalAmount float64        `gorm:"type:decimal(10,2);not null"`
	Status      string         `gorm:"size:20;default:'pending';not null"`
	CreatedAt   time.Time      `gorm:"not null"`
	UpdatedAt   time.Time
	DeletedAt   gorm.DeletedAt `gorm:"index"`
	
	// Relations
	User  UserGORM      `gorm:"foreignKey:UserID"`
	Items []OrderItemGORM `gorm:"foreignKey:OrderID"`
}

func (OrderGORM) TableName() string {
	return "orders"
}

// OrderItemGORM item de commande
type OrderItemGORM struct {
	ID        uint    `gorm:"primaryKey"`
	OrderID   uint    `gorm:"not null;index"`
	ProductID uint    `gorm:"not null;index"`
	Quantity  int     `gorm:"not null"`
	Price     float64 `gorm:"type:decimal(10,2);not null"`
	
	Order   OrderGORM   `gorm:"foreignKey:OrderID"`
	Product ProductGORM `gorm:"foreignKey:ProductID"`
}

func (OrderItemGORM) TableName() string {
	return "order_items"
}

// ProductGORM produit
type ProductGORM struct {
	ID        uint      `gorm:"primaryKey"`
	Name      string    `gorm:"size:255;not null"`
	Price     float64   `gorm:"type:decimal(10,2);not null"`
	Stock     int       `gorm:"default:0;not null"`
	IsActive  bool      `gorm:"default:true;not null"`
	CreatedAt time.Time `gorm:"not null"`
	UpdatedAt time.Time
}

func (ProductGORM) TableName() string {
	return "products"
}
```

### Repository GORM

```go
// internal/repository/user_repo_gorm.go
package repository

import (
	"context"
	"errors"
	
	"gorm.io/gorm"
	"myapp/internal/models"
)

// UserRepositoryGORM repository avec GORM
type UserRepositoryGORM struct {
	db *gorm.DB
}

// NewUserRepositoryGORM crÃ©e une nouvelle instance
func NewUserRepositoryGORM(db *gorm.DB) *UserRepositoryGORM {
	return &UserRepositoryGORM{db: db}
}

// Create crÃ©e un utilisateur
func (r *UserRepositoryGORM) Create(ctx context.Context, user *models.UserGORM) error {
	result := r.db.WithContext(ctx).Create(user)
	if result.Error != nil {
		// GORM retourne ErrDuplicatedKey pour contraintes uniques
		if errors.Is(result.Error, gorm.ErrDuplicatedKey) {
			return ErrUserAlreadyExists
		}
		return result.Error
	}
	return nil
}

// GetByID rÃ©cupÃ¨re par ID
func (r *UserRepositoryGORM) GetByID(ctx context.Context, id uint) (*models.UserGORM, error) {
	var user models.UserGORM
	
	result := r.db.WithContext(ctx).First(&user, id)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return nil, ErrUserNotFound
		}
		return nil, result.Error
	}
	
	return &user, nil
}

// GetByEmail rÃ©cupÃ¨re par email
func (r *UserRepositoryGORM) GetByEmail(ctx context.Context, email string) (*models.UserGORM, error) {
	var user models.UserGORM
	
	result := r.db.WithContext(ctx).
		Where("email = ?", email).
		First(&user)
	
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return nil, ErrUserNotFound
		}
		return nil, result.Error
	}
	
	return &user, nil
}

// List avec pagination et preload
func (r *UserRepositoryGORM) List(ctx context.Context, page, pageSize int) ([]*models.UserGORM, int64, error) {
	var users []*models.UserGORM
	var total int64
	
	offset := (page - 1) * pageSize
	
	// Compter le total
	if err := r.db.WithContext(ctx).
		Model(&models.UserGORM{}).
		Where("is_active = ?", true).
		Count(&total).Error; err != nil {
		return nil, 0, err
	}
	
	// RÃ©cupÃ©rer les utilisateurs
	if err := r.db.WithContext(ctx).
		Where("is_active = ?", true).
		Order("created_at DESC").
		Limit(pageSize).
		Offset(offset).
		Find(&users).Error; err != nil {
		return nil, 0, err
	}
	
	return users, total, nil
}

// Update met Ã  jour
func (r *UserRepositoryGORM) Update(ctx context.Context, user *models.UserGORM) error {
	result := r.db.WithContext(ctx).Save(user)
	return result.Error
}

// Delete supprime (soft delete par dÃ©faut)
func (r *UserRepositoryGORM) Delete(ctx context.Context, id uint) error {
	result := r.db.WithContext(ctx).Delete(&models.UserGORM{}, id)
	if result.Error != nil {
		return result.Error
	}
	if result.RowsAffected == 0 {
		return ErrUserNotFound
	}
	return nil
}

// GetWithOrders rÃ©cupÃ¨re avec orders (eager loading)
func (r *UserRepositoryGORM) GetWithOrders(ctx context.Context, id uint) (*models.UserGORM, error) {
	var user models.UserGORM
	
	result := r.db.WithContext(ctx).
		Preload("Orders", func(db *gorm.DB) *gorm.DB {
			return db.Order("created_at DESC").Limit(10)
		}).
		First(&user, id)
	
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return nil, ErrUserNotFound
		}
		return nil, result.Error
	}
	
	return &user, nil
}

// Search recherche par terme
func (r *UserRepositoryGORM) Search(ctx context.Context, term string, limit int) ([]*models.UserGORM, error) {
	var users []*models.UserGORM
	
	searchTerm := "%" + term + "%"
	
	err := r.db.WithContext(ctx).
		Where("username LIKE ? OR email LIKE ?", searchTerm, searchTerm).
		Where("is_active = ?", true).
		Limit(limit).
		Find(&users).Error
	
	return users, err
}
```

ğŸ’¡ **Conseil** : GORM est excellent pour le dÃ©veloppement rapide avec des relations complexes. Pour la performance maximale sur des requÃªtes simples, prÃ©fÃ©rez database/sql ou sqlx.

---

## Concurrence avec goroutines

### RequÃªtes parallÃ¨les sÃ»res

```go
// internal/service/user_service.go
package service

import (
	"context"
	"fmt"
	"sync"
	
	"myapp/internal/models"
	"myapp/internal/repository"
)

// UserService gÃ¨re la logique mÃ©tier
type UserService struct {
	repo *repository.UserRepository
}

// NewUserService crÃ©e une nouvelle instance
func NewUserService(repo *repository.UserRepository) *UserService {
	return &UserService{repo: repo}
}

// GetMultipleUsers rÃ©cupÃ¨re plusieurs utilisateurs en parallÃ¨le
func (s *UserService) GetMultipleUsers(ctx context.Context, ids []int64) ([]*models.User, error) {
	// WaitGroup pour synchroniser les goroutines
	var wg sync.WaitGroup
	
	// Channel pour collecter les rÃ©sultats
	usersChan := make(chan *models.User, len(ids))
	errorsChan := make(chan error, len(ids))
	
	// Lancer une goroutine par ID
	for _, id := range ids {
		wg.Add(1)
		
		go func(userID int64) {
			defer wg.Done()
			
			user, err := s.repo.GetByID(ctx, userID)
			if err != nil {
				errorsChan <- err
				return
			}
			
			usersChan <- user
		}(id)
	}
	
	// Attendre la fin de toutes les goroutines
	wg.Wait()
	close(usersChan)
	close(errorsChan)
	
	// VÃ©rifier les erreurs
	if len(errorsChan) > 0 {
		return nil, <-errorsChan
	}
	
	// Collecter les rÃ©sultats
	users := make([]*models.User, 0, len(ids))
	for user := range usersChan {
		users = append(users, user)
	}
	
	return users, nil
}

// BulkUpdate met Ã  jour plusieurs utilisateurs en parallÃ¨le
func (s *UserService) BulkUpdate(ctx context.Context, updates map[int64]*models.UserUpdate) error {
	var wg sync.WaitGroup
	errChan := make(chan error, len(updates))
	
	// Limiter la concurrence avec un semaphore
	semaphore := make(chan struct{}, 10) // Max 10 goroutines parallÃ¨les
	
	for id, update := range updates {
		wg.Add(1)
		
		go func(userID int64, upd *models.UserUpdate) {
			defer wg.Done()
			
			// AcquÃ©rir le semaphore
			semaphore <- struct{}{}
			defer func() { <-semaphore }()
			
			if err := s.repo.Update(ctx, userID, upd); err != nil {
				errChan <- fmt.Errorf("failed to update user %d: %w", userID, err)
			}
		}(id, update)
	}
	
	wg.Wait()
	close(errChan)
	
	// Retourner la premiÃ¨re erreur
	if len(errChan) > 0 {
		return <-errChan
	}
	
	return nil
}
```

ğŸ’¡ **Conseil** : Le pool de connexions de database/sql est safe pour la concurrence. Vous pouvez utiliser `db.QueryContext()` depuis plusieurs goroutines sans problÃ¨me.

---

## Bonnes pratiques de sÃ©curitÃ©

### Validation des entrÃ©es

```go
// internal/validation/user.go
package validation

import (
	"errors"
	"regexp"
	"strings"
)

var (
	ErrInvalidEmail    = errors.New("invalid email format")
	ErrInvalidUsername = errors.New("invalid username format")
	ErrWeakPassword    = errors.New("password too weak")
)

var (
	emailRegex    = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	usernameRegex = regexp.MustCompile(`^[a-zA-Z0-9_]{3,50}$`)
)

// ValidateEmail valide un email
func ValidateEmail(email string) error {
	if !emailRegex.MatchString(email) {
		return ErrInvalidEmail
	}
	return nil
}

// ValidateUsername valide un username
func ValidateUsername(username string) error {
	if !usernameRegex.MatchString(username) {
		return ErrInvalidUsername
	}
	return nil
}

// ValidatePassword valide un mot de passe
func ValidatePassword(password string) error {
	if len(password) < 12 {
		return errors.New("password must be at least 12 characters")
	}
	
	var (
		hasUpper   = regexp.MustCompile(`[A-Z]`).MatchString(password)
		hasLower   = regexp.MustCompile(`[a-z]`).MatchString(password)
		hasNumber  = regexp.MustCompile(`[0-9]`).MatchString(password)
		hasSpecial = regexp.MustCompile(`[!@#$%^&*(),.?":{}|<>]`).MatchString(password)
	)
	
	if !hasUpper || !hasLower || !hasNumber || !hasSpecial {
		return ErrWeakPassword
	}
	
	return nil
}

// SanitizeString nettoie une chaÃ®ne
func SanitizeString(s string) string {
	return strings.TrimSpace(s)
}
```

### Hashing des mots de passe

```go
// internal/auth/password.go
package auth

import (
	"fmt"
	"golang.org/x/crypto/bcrypt"
)

const bcryptCost = 12

// HashPassword hashe un mot de passe avec bcrypt
func HashPassword(password string) (string, error) {
	hash, err := bcrypt.GenerateFromPassword([]byte(password), bcryptCost)
	if err != nil {
		return "", fmt.Errorf("failed to hash password: %w", err)
	}
	return string(hash), nil
}

// VerifyPassword vÃ©rifie un mot de passe
func VerifyPassword(password, hash string) error {
	return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
}
```

---

## âœ… Points clÃ©s Ã  retenir

1. **Driver** : go-sql-driver/mysql standard pour MariaDB
2. **Pool natif** : database/sql gÃ¨re automatiquement le pooling
3. **Context** : TOUJOURS utiliser context.Context pour timeout/cancellation
4. **Error handling** : VÃ©rifier TOUTES les erreurs, utiliser errors.Is/As
5. **Transactions** : defer tx.Rollback() systÃ©matique
6. **Prepared statements** : Utiliser `?` placeholders, jamais de fmt.Sprintf
7. **Concurrence** : database/sql est goroutine-safe
8. **sqlx** : Pour simplifier le code sans overhead
9. **GORM** : Pour dÃ©veloppement rapide avec relations
10. **Performance** : database/sql direct pour maximum de performance

---

## ğŸ”— Ressources et rÃ©fÃ©rences

### Documentation officielle
- [ğŸ“– database/sql](https://pkg.go.dev/database/sql)
- [ğŸ“– go-sql-driver/mysql](https://github.com/go-sql-driver/mysql)
- [ğŸ“– sqlx](https://github.com/jmoiron/sqlx)
- [ğŸ“– GORM](https://gorm.io/)

### Guides et tutoriels
- [Go database/sql Tutorial](https://go.dev/doc/database/overview)
- [Effective Go](https://go.dev/doc/effective_go)

### Outils
- [sqlc](https://sqlc.dev/) - Code generation from SQL
- [ent](https://entgo.io/) - Entity framework
- [migrate](https://github.com/golang-migrate/migrate) - Migrations

---

## â¡ï¸ Section suivante

**17.1.6 .NET : MySqlConnector, MariaDB.Data, ADO.NET** : DÃ©couvrez comment intÃ©grer MariaDB dans vos applications .NET avec les connecteurs modernes, Entity Framework Core, et Dapper pour la performance.

â­ï¸ [.NET : MySqlConnector, MariaDB.Data, ADO.NET](/17-integration-developpement/01.6-dotnet-connectors.md)
