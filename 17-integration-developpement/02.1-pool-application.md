ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 17.2.1 Pool cÃ´tÃ© application

> **Niveau** : IntermÃ©diaire Ã  AvancÃ©  
> **DurÃ©e estimÃ©e** : 2-3 heures  
> **PrÃ©requis** : ComprÃ©hension des connexions bases de donnÃ©es, concepts de concurrence

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre le fonctionnement et les bÃ©nÃ©fices du connection pooling
- Configurer et dimensionner un pool pour chaque langage
- Monitorer et diagnostiquer les problÃ¨mes de pool
- Optimiser les performances avec les bonnes pratiques
- Ã‰viter les anti-patterns courants (pool exhaustion, connexion leaks)
- Choisir entre pooling applicatif et pooling serveur (ProxySQL)

---

## Introduction au Connection Pooling

### ProblÃ¨me : CoÃ»t de crÃ©ation d'une connexion

CrÃ©er une nouvelle connexion Ã  chaque requÃªte est **coÃ»teux** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CoÃ»t d'une nouvelle connexion            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. RÃ©solution DNS              ~5-20ms   â”‚
â”‚ 2. Ã‰tablissement TCP           ~10-50ms  â”‚
â”‚ 3. Authentification MariaDB    ~5-20ms   â”‚
â”‚ 4. Setup session (charset, tz) ~2-10ms   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ TOTAL                          ~20-100ms â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Pour 1000 requÃªtes/seconde :
âŒ Sans pool : 20-100 SECONDES de overhead !
âœ… Avec pool  : ~0 ms (connexions rÃ©utilisÃ©es)
```

### Solution : Connection Pooling

Le pool maintient un ensemble de connexions **rÃ©utilisables** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Connection Pool                    â”‚
â”‚                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”          â”‚
â”‚  â”‚ C1 â”‚ â”‚ C2 â”‚ â”‚ C3 â”‚ â”‚ C4 â”‚ â”‚ C5 â”‚  Idle    â”‚
â”‚  â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜          â”‚
â”‚                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”                        â”‚
â”‚  â”‚ C6 â”‚ â”‚ C7 â”‚ â”‚ C8 â”‚            In Use      â”‚
â”‚  â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜                        â”‚
â”‚    â†“      â†“      â†“                           â”‚
â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     â”‚      â”‚      â”‚
  Thread1 Thread2 Thread3
```

### BÃ©nÃ©fices du pooling

| Avantage | Impact |
|----------|--------|
| **Performance** | 10-100x plus rapide que crÃ©ation Ã  la demande |
| **Latence** | RÃ©duction de 20-100ms par requÃªte |
| **ScalabilitÃ©** | Support de milliers de requÃªtes/sec |
| **Ressources serveur** | Limite le nombre de connexions MariaDB |
| **Throughput** | Maximise l'utilisation des connexions |

---

## Concepts fondamentaux

### ParamÃ¨tres clÃ©s d'un pool

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Configuration du pool                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  minSize (minIdle)                              â”‚
â”‚  â”œâ”€ Nombre minimum de connexions maintenues     â”‚
â”‚  â””â”€ Valeur typique : 2-5                        â”‚
â”‚                                                 â”‚
â”‚  maxSize (maxPoolSize)                          â”‚
â”‚  â”œâ”€ Nombre maximum de connexions                â”‚
â”‚  â””â”€ Valeur typique : 10-50                      â”‚
â”‚                                                 â”‚
â”‚  acquireTimeout (connectionTimeout)             â”‚
â”‚  â”œâ”€ Temps max pour obtenir une connexion        â”‚
â”‚  â””â”€ Valeur typique : 10-30 secondes             â”‚
â”‚                                                 â”‚
â”‚  idleTimeout                                    â”‚
â”‚  â”œâ”€ DurÃ©e max d'inactivitÃ© avant fermeture      â”‚
â”‚  â””â”€ Valeur typique : 5-10 minutes               â”‚
â”‚                                                 â”‚
â”‚  maxLifetime (connectionLifetime)               â”‚
â”‚  â”œâ”€ DurÃ©e de vie max d'une connexion            â”‚
â”‚  â””â”€ Valeur typique : 30-60 minutes              â”‚
â”‚                                                 â”‚
â”‚  testQuery (validationQuery)                    â”‚
â”‚  â”œâ”€ RequÃªte pour tester la validitÃ©             â”‚
â”‚  â””â”€ Exemple : "SELECT 1"                        â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Cycle de vie d'une connexion poolÃ©e

```
1. CRÃ‰ATION
   â†“
2. IDLE (disponible dans le pool)
   â†“
3. ACQUISITION (empruntÃ©e par un thread)
   â†“
4. IN USE (requÃªtes en cours)
   â†“
5. RELEASE (retour au pool)
   â†“
6. VALIDATION (test de vivacitÃ©)
   â†“
7. Retour en IDLE ou FERMETURE si expirÃ©e
```

---

## Dimensionnement du pool

### Formule de calcul

**RÃ¨gle gÃ©nÃ©rale** :

```
maxPoolSize = ((nombre_de_cores Ã— 2) + nombre_de_disques_effectifs)
```

**Exemple** :
- Serveur : 8 cores, 1 SSD
- maxPoolSize = (8 Ã— 2) + 1 = **17 connexions**

### Dimensionnement par contexte

| Type d'application | minSize | maxSize | Ratio |
|-------------------|---------|---------|-------|
| **API REST** (stateless) | 5 | 20-30 | 1:4-6 |
| **Web app** (sessions) | 10 | 50-100 | 1:5-10 |
| **Batch processing** | 2 | 10-15 | 1:5-7 |
| **Microservice** | 3 | 15-25 | 1:5-8 |
| **Worker queue** | 5 | 20-40 | 1:4-8 |

### ConsidÃ©rations MariaDB

MariaDB a aussi des limites :

```sql
-- VÃ©rifier la limite de connexions
SHOW VARIABLES LIKE 'max_connections';
-- DÃ©faut : 151 connexions

-- Surveiller l'utilisation
SHOW STATUS LIKE 'Threads_connected';
SHOW STATUS LIKE 'Max_used_connections';
```

**Calcul global** :
```
max_connections_mariadb â‰¥ 
  (nb_instances_app Ã— maxPoolSize) + marge_admin
```

Exemple :
- 5 instances d'application
- maxPoolSize = 20 par instance
- Marge admin = 20
- MariaDB : `max_connections` â‰¥ (5 Ã— 20) + 20 = **120**

ğŸ’¡ **Conseil** : Toujours garder une marge de 10-20% pour les connexions admin, monitoring et maintenance.

---

## Configuration par langage

### PHP (PDO - pas de vrai pool natif)

PHP ne dispose **pas de pool natif** car chaque requÃªte HTTP est isolÃ©e. Solutions :

#### 1. Connexions persistantes PDO

```php
<?php
/**
 * PDO avec connexions persistantes
 * âš ï¸ Limitations : pas de vrai pool, partage entre workers PHP-FPM
 */

class Database {
    private static ?PDO $pdo = null;
    
    public static function getConnection(): PDO {
        if (self::$pdo === null) {
            $options = [
                // Activer les connexions persistantes
                PDO::ATTR_PERSISTENT => true,
                
                // Autres options
                PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                PDO::ATTR_EMULATE_PREPARES => false,
            ];
            
            self::$pdo = new PDO(
                'mysql:host=localhost;dbname=db;charset=utf8mb4',
                'user',
                'password',
                $options
            );
        }
        
        return self::$pdo;
    }
}

// Utilisation
$pdo = Database::getConnection();
// La connexion persiste entre les requÃªtes du mÃªme worker PHP-FPM
```

**Limitations PHP** :
- âŒ Pas de contrÃ´le fin (min/max size)
- âŒ Pas de monitoring du pool
- âŒ Partage limitÃ© aux workers PHP-FPM

**Solution recommandÃ©e** : Utiliser **ProxySQL** devant MariaDB (voir section 17.2.2)

---

### Python (avec SQLAlchemy)

```python
"""
Connection pooling avec SQLAlchemy
Pool intÃ©grÃ© et configurable
"""
from sqlalchemy import create_engine, pool
from sqlalchemy.orm import sessionmaker
from contextlib import contextmanager

# Configuration du pool
engine = create_engine(
    'mysql+pymysql://user:password@localhost/db',
    
    # QueuePool (par dÃ©faut, recommandÃ©)
    poolclass=pool.QueuePool,
    
    # Taille du pool
    pool_size=10,              # Connexions permanentes
    max_overflow=20,           # Connexions supplÃ©mentaires temporaires
                              # Total max = pool_size + max_overflow = 30
    
    # Timeouts
    pool_timeout=30,           # Timeout pour obtenir connexion (secondes)
    pool_recycle=3600,         # Recycler aprÃ¨s 1h (Ã©vite timeouts MariaDB)
    
    # Validation
    pool_pre_ping=True,        # Test avant utilisation (recommandÃ©)
    
    # Pool LIFO vs FIFO
    pool_use_lifo=True,        # LIFO garde connexions chaudes
    
    # Logging (dÃ©veloppement)
    echo_pool='debug',
)

# Session factory
SessionLocal = sessionmaker(bind=engine)

@contextmanager
def get_db_session():
    """Context manager pour session avec gestion automatique"""
    session = SessionLocal()
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()  # Retourne la connexion au pool

# Utilisation
def get_user(user_id: int):
    with get_db_session() as session:
        user = session.query(User).filter(User.id == user_id).first()
        return user

# Statistiques du pool
def print_pool_stats():
    pool = engine.pool
    print(f"Pool size: {pool.size()}")
    print(f"Checked in: {pool.checkedin()}")
    print(f"Overflow: {pool.overflow()}")
    print(f"Checked out: {pool.size() - pool.checkedin()}")

# Fermeture propre
def shutdown():
    engine.dispose()
```

**Types de pools SQLAlchemy** :

```python
from sqlalchemy import pool

# QueuePool (dÃ©faut, recommandÃ©)
poolclass=pool.QueuePool

# NullPool (pas de pool, debug)
poolclass=pool.NullPool

# StaticPool (1 connexion partagÃ©e, tests)
poolclass=pool.StaticPool

# SingletonThreadPool (1 connexion par thread)
poolclass=pool.SingletonThreadPool
```

---

### Java (HikariCP)

```java
/**
 * HikariCP - Le pool le plus performant pour Java
 */
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import javax.sql.DataSource;

public class DatabaseConfig {
    
    private static HikariDataSource dataSource;
    
    public static DataSource getDataSource() {
        if (dataSource == null) {
            HikariConfig config = new HikariConfig();
            
            // JDBC URL
            config.setJdbcUrl("jdbc:mariadb://localhost:3306/db");
            config.setUsername("user");
            config.setPassword("password");
            config.setDriverClassName("org.mariadb.jdbc.Driver");
            
            // Pool sizing
            config.setMinimumIdle(5);           // Min connexions idle
            config.setMaximumPoolSize(20);      // Max connexions
            
            // Timeouts
            config.setConnectionTimeout(30000);  // 30s pour obtenir connexion
            config.setIdleTimeout(600000);       // 10min idle avant fermeture
            config.setMaxLifetime(1800000);      // 30min lifetime max
            config.setValidationTimeout(5000);   // 5s pour valider
            
            // Validation
            config.setConnectionTestQuery("SELECT 1");
            
            // Performance
            config.setAutoCommit(true);
            config.setCachePrepStmts(true);
            config.setPrepStmtCacheSize(250);
            config.setPrepStmtCacheSqlLimit(2048);
            
            // Pool name pour monitoring
            config.setPoolName("MariaDB-HikariPool");
            
            // Leak detection (dÃ©veloppement)
            config.setLeakDetectionThreshold(60000); // 60s
            
            // Register MBean pour JMX monitoring
            config.setRegisterMbeans(true);
            
            // Properties MariaDB spÃ©cifiques
            config.addDataSourceProperty("cachePrepStmts", "true");
            config.addDataSourceProperty("prepStmtCacheSize", "250");
            config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
            config.addDataSourceProperty("useServerPrepStmts", "true");
            config.addDataSourceProperty("useLocalSessionState", "true");
            config.addDataSourceProperty("rewriteBatchedStatements", "true");
            config.addDataSourceProperty("cacheResultSetMetadata", "true");
            config.addDataSourceProperty("cacheServerConfiguration", "true");
            config.addDataSourceProperty("maintainTimeStats", "false");
            
            dataSource = new HikariDataSource(config);
        }
        
        return dataSource;
    }
    
    /**
     * Statistiques du pool
     */
    public static void printPoolStats() {
        HikariPoolMXBean poolMXBean = dataSource.getHikariPoolMXBean();
        
        System.out.println("=== HikariCP Pool Stats ===");
        System.out.println("Active connections: " + poolMXBean.getActiveConnections());
        System.out.println("Idle connections: " + poolMXBean.getIdleConnections());
        System.out.println("Total connections: " + poolMXBean.getTotalConnections());
        System.out.println("Threads awaiting: " + poolMXBean.getThreadsAwaitingConnection());
    }
    
    /**
     * Fermeture propre
     */
    public static void shutdown() {
        if (dataSource != null && !dataSource.isClosed()) {
            dataSource.close();
        }
    }
}

// Utilisation
public class UserRepository {
    
    public User findById(long id) throws SQLException {
        // Obtenir connexion du pool
        try (Connection conn = DatabaseConfig.getDataSource().getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT * FROM users WHERE id = ?")) {
            
            stmt.setLong(1, id);
            
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return mapUser(rs);
                }
            }
        }
        // Connexion retourne automatiquement au pool (try-with-resources)
        
        return null;
    }
}
```

**Configuration HikariCP optimale** :

```properties
# application.properties (Spring Boot)
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.connection-test-query=SELECT 1
spring.datasource.hikari.pool-name=MariaDB-HikariCP
spring.datasource.hikari.leak-detection-threshold=60000
```

---

### Node.js (mysql2)

```javascript
/**
 * Connection pooling avec mysql2
 * Pool intÃ©grÃ© et performant
 */
import mysql from 'mysql2/promise';

// Configuration du pool
const pool = mysql.createPool({
  // Connexion
  host: 'localhost',
  port: 3306,
  user: 'app_user',
  password: 'password',
  database: 'production_db',
  
  // Pool sizing
  connectionLimit: 10,      // Max connexions (Ã©quivalent maxSize)
  queueLimit: 0,            // Pas de limite de queue (0 = illimitÃ©)
  
  // Timeouts
  connectTimeout: 10000,    // 10s connexion timeout
  acquireTimeout: 10000,    // 10s pour obtenir du pool
  timeout: 60000,           // 60s query timeout
  
  // Charset
  charset: 'utf8mb4',
  
  // Timezone UTC
  timezone: '+00:00',
  
  // Multiple statements (sÃ©curitÃ© : false)
  multipleStatements: false,
  
  // Date handling
  dateStrings: false,       // Parser en Date objects
  
  // Connection management
  enableKeepAlive: true,
  keepAliveInitialDelay: 0,
  
  // Validation
  waitForConnections: true, // Attendre si pool plein
});

// Event listeners pour monitoring
pool.on('connection', (connection) => {
  console.log('New connection created:', connection.threadId);
});

pool.on('acquire', (connection) => {
  console.log('Connection acquired:', connection.threadId);
});

pool.on('release', (connection) => {
  console.log('Connection released:', connection.threadId);
});

pool.on('enqueue', () => {
  console.log('Waiting for available connection slot');
});

/**
 * Utilisation du pool
 */
export async function getUser(userId) {
  // Option 1 : Execute directement sur le pool
  const [rows] = await pool.execute(
    'SELECT * FROM users WHERE id = ?',
    [userId]
  );
  return rows[0];
}

/**
 * Utilisation avec connexion dÃ©diÃ©e
 */
export async function getUserWithOrders(userId) {
  // Option 2 : Obtenir une connexion pour plusieurs requÃªtes
  const connection = await pool.getConnection();
  
  try {
    const [users] = await connection.execute(
      'SELECT * FROM users WHERE id = ?',
      [userId]
    );
    
    const [orders] = await connection.execute(
      'SELECT * FROM orders WHERE user_id = ? ORDER BY created_at DESC',
      [userId]
    );
    
    return {
      user: users[0],
      orders: orders
    };
    
  } finally {
    // IMPORTANT : toujours relÃ¢cher la connexion
    connection.release();
  }
}

/**
 * Statistiques du pool
 */
export function getPoolStats() {
  return {
    totalConnections: pool._allConnections.length,
    freeConnections: pool._freeConnections.length,
    queuedRequests: pool._connectionQueue.length,
    activeConnections: pool._allConnections.length - pool._freeConnections.length
  };
}

/**
 * Fermeture propre
 */
export async function closePool() {
  await pool.end();
  console.log('Pool closed');
}

// Graceful shutdown
process.on('SIGTERM', async () => {
  await closePool();
  process.exit(0);
});

process.on('SIGINT', async () => {
  await closePool();
  process.exit(0);
});
```

---

### Go (database/sql)

```go
/**
 * Connection pooling avec database/sql
 * Pool natif intÃ©grÃ© dans la standard library
 */
package database

import (
    "context"
    "database/sql"
    "fmt"
    "log"
    "time"
    
    _ "github.com/go-sql-driver/mysql"
)

type Database struct {
    *sql.DB
}

func NewDatabase(dsn string) (*Database, error) {
    // Ouvrir la connexion
    db, err := sql.Open("mysql", dsn)
    if err != nil {
        return nil, fmt.Errorf("failed to open database: %w", err)
    }
    
    // Configuration du pool
    db.SetMaxOpenConns(25)              // Max connexions ouvertes
    db.SetMaxIdleConns(5)               // Max connexions idle
    db.SetConnMaxLifetime(5 * time.Minute)   // Lifetime max
    db.SetConnMaxIdleTime(5 * time.Minute)   // Idle time max
    
    // Test de connexion
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := db.PingContext(ctx); err != nil {
        return nil, fmt.Errorf("failed to ping database: %w", err)
    }
    
    log.Println("âœ“ Database pool initialized")
    
    return &Database{db}, nil
}

/**
 * Statistiques du pool
 */
func (db *Database) Stats() sql.DBStats {
    return db.DB.Stats()
}

func (db *Database) PrintStats() {
    stats := db.Stats()
    
    fmt.Println("=== Database Pool Stats ===")
    fmt.Printf("Max open connections: %d\n", stats.MaxOpenConnections)
    fmt.Printf("Open connections: %d\n", stats.OpenConnections)
    fmt.Printf("In use: %d\n", stats.InUse)
    fmt.Printf("Idle: %d\n", stats.Idle)
    fmt.Printf("Wait count: %d\n", stats.WaitCount)
    fmt.Printf("Wait duration: %v\n", stats.WaitDuration)
    fmt.Printf("Max idle closed: %d\n", stats.MaxIdleClosed)
    fmt.Printf("Max lifetime closed: %d\n", stats.MaxLifetimeClosed)
}

/**
 * Utilisation du pool
 */
func (db *Database) GetUser(ctx context.Context, id int64) (*User, error) {
    query := `SELECT id, username, email FROM users WHERE id = ?`
    
    var user User
    err := db.QueryRowContext(ctx, query, id).Scan(
        &user.ID,
        &user.Username,
        &user.Email,
    )
    
    if err != nil {
        if err == sql.ErrNoRows {
            return nil, ErrUserNotFound
        }
        return nil, fmt.Errorf("query failed: %w", err)
    }
    
    return &user, nil
}

/**
 * Monitoring du pool avec mÃ©triques Prometheus
 */
func (db *Database) MonitorPool(interval time.Duration) {
    ticker := time.NewTicker(interval)
    defer ticker.Stop()
    
    for range ticker.C {
        stats := db.Stats()
        
        // Exposer les mÃ©triques (Prometheus, etc.)
        dbOpenConnections.Set(float64(stats.OpenConnections))
        dbInUse.Set(float64(stats.InUse))
        dbIdle.Set(float64(stats.Idle))
        dbWaitCount.Add(float64(stats.WaitCount))
        dbWaitDuration.Add(stats.WaitDuration.Seconds())
    }
}

/**
 * Fermeture propre
 */
func (db *Database) Close() error {
    log.Println("Closing database connection pool...")
    return db.DB.Close()
}
```

**Monitoring continu** :

```go
// main.go
func main() {
    db, err := database.NewDatabase(dsn)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // Monitoring continu en arriÃ¨re-plan
    go db.MonitorPool(10 * time.Second)
    
    // Afficher les stats pÃ©riodiquement
    ticker := time.NewTicker(30 * time.Second)
    go func() {
        for range ticker.C {
            db.PrintStats()
        }
    }()
    
    // Application...
}
```

---

### .NET (MySqlConnector)

```csharp
/**
 * Connection pooling avec MySqlConnector
 * Pool natif intÃ©grÃ© et performant
 */
using MySqlConnector;

public class DatabaseConfig
{
    private static string _connectionString;
    
    public static void Initialize()
    {
        // Construction de la connection string avec pooling
        var builder = new MySqlConnectionStringBuilder
        {
            // Connexion
            Server = "localhost",
            Port = 3306,
            Database = "production_db",
            UserID = "app_user",
            Password = "SecureP@ssw0rd!",
            
            // Charset
            CharacterSet = "utf8mb4",
            
            // Pool configuration
            Pooling = true,                     // Activer le pooling
            MinimumPoolSize = 5,               // Min connexions idle
            MaximumPoolSize = 25,              // Max connexions
            ConnectionLifeTime = 600,          // 10min lifetime (secondes)
            ConnectionIdleTimeout = 300,       // 5min idle timeout
            
            // Timeouts
            ConnectionTimeout = 10,            // 10s connexion timeout
            DefaultCommandTimeout = 30,        // 30s query timeout
            
            // Performance
            AllowUserVariables = true,
            UseAffectedRows = false,
            
            // SSL
            SslMode = MySqlSslMode.Preferred,
        };
        
        _connectionString = builder.ConnectionString;
    }
    
    public static MySqlConnection CreateConnection()
    {
        return new MySqlConnection(_connectionString);
    }
    
    public static async Task<MySqlConnection> CreateOpenConnectionAsync(
        CancellationToken ct = default)
    {
        var connection = CreateConnection();
        await connection.OpenAsync(ct);
        return connection;
    }
}

/**
 * Repository avec pool
 */
public class UserRepository
{
    public async Task<User?> GetByIdAsync(long id, CancellationToken ct = default)
    {
        // Connexion du pool (using = retour automatique au pool)
        await using var connection = DatabaseConfig.CreateConnection();
        await connection.OpenAsync(ct);
        
        await using var command = new MySqlCommand(
            "SELECT id, username, email FROM users WHERE id = @Id",
            connection
        );
        
        command.Parameters.AddWithValue("@Id", id);
        
        await using var reader = await command.ExecuteReaderAsync(ct);
        
        if (!await reader.ReadAsync(ct))
            return null;
        
        return new User
        {
            Id = reader.GetInt64("id"),
            Username = reader.GetString("username"),
            Email = reader.GetString("email")
        };
        
        // Connexion retourne au pool automatiquement (await using)
    }
}

/**
 * Monitoring du pool
 */
public class PoolMonitor
{
    private readonly ILogger<PoolMonitor> _logger;
    
    public PoolMonitor(ILogger<PoolMonitor> logger)
    {
        _logger = logger;
    }
    
    public async Task MonitorPoolAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            try
            {
                // MySqlConnector expose les stats via mÃ©thodes statiques
                var stats = MySqlConnectorLogManager.Provider.GetPoolStatistics();
                
                _logger.LogInformation(
                    "Pool Stats - Total: {Total}, Idle: {Idle}, Active: {Active}",
                    stats.TotalConnections,
                    stats.IdleConnections,
                    stats.ActiveConnections
                );
                
                await Task.Delay(TimeSpan.FromSeconds(30), ct);
            }
            catch (OperationCanceledException)
            {
                break;
            }
        }
    }
}

/**
 * IntÃ©gration ASP.NET Core
 */
// Program.cs
var builder = WebApplication.CreateBuilder(args);

// Initialiser la configuration du pool
DatabaseConfig.Initialize();

// Enregistrer le monitoring comme service hÃ©bergÃ©
builder.Services.AddHostedService<PoolMonitorService>();

var app = builder.Build();
app.Run();
```

---

## Monitoring et diagnostics

### MÃ©triques Ã  surveiller

| MÃ©trique | Seuil normal | Alerte si |
|----------|-------------|-----------|
| **Active connections** | < 80% du max | > 90% |
| **Idle connections** | minSize Ã  maxSize | < minSize |
| **Wait count** | 0 | > 0 frÃ©quemment |
| **Wait duration** | 0ms | > 100ms |
| **Connection errors** | 0 | > 1% des requÃªtes |
| **Acquisition time** | < 5ms | > 50ms |

### Dashboard de monitoring (exemple Prometheus)

```yaml
# MÃ©triques Prometheus pour pool MariaDB

# Connexions actives
db_pool_active_connections{app="myapp"} 8

# Connexions idle
db_pool_idle_connections{app="myapp"} 12

# Temps d'attente
db_pool_wait_duration_seconds{app="myapp"} 0.052

# Pool exhaustion (alerte critique)
rate(db_pool_wait_count[5m]) > 10
```

### Exemple de logging

```python
import logging
from sqlalchemy import event
from sqlalchemy.pool import Pool

logger = logging.getLogger(__name__)

# Logger les Ã©vÃ©nements du pool
@event.listens_for(Pool, "connect")
def receive_connect(dbapi_conn, connection_record):
    logger.info(f"New connection created: {id(dbapi_conn)}")

@event.listens_for(Pool, "checkout")
def receive_checkout(dbapi_conn, connection_record, connection_proxy):
    logger.debug(f"Connection checked out: {id(dbapi_conn)}")

@event.listens_for(Pool, "checkin")
def receive_checkin(dbapi_conn, connection_record):
    logger.debug(f"Connection checked in: {id(dbapi_conn)}")

# Logger le pool exhaustion
def log_pool_exhaustion():
    stats = engine.pool.status()
    if engine.pool.overflow() >= engine.pool.max_overflow:
        logger.error(
            f"POOL EXHAUSTED! Stats: {stats}. "
            "Consider increasing max_overflow or investigating slow queries."
        )
```

---

## Bonnes pratiques

### âœ… Ã€ FAIRE

1. **Toujours utiliser un pool en production**
   ```python
   # âœ… BON
   engine = create_engine(..., pool_size=10)
   
   # âŒ MAUVAIS (nouvelle connexion Ã  chaque fois)
   engine = create_engine(..., poolclass=NullPool)
   ```

2. **Fermer/relÃ¢cher les connexions explicitement**
   ```javascript
   // âœ… BON
   const conn = await pool.getConnection();
   try {
       await conn.query(...);
   } finally {
       conn.release(); // IMPORTANT !
   }
   
   // âŒ MAUVAIS (connection leak)
   const conn = await pool.getConnection();
   await conn.query(...);
   // Oubli de release() !
   ```

3. **Configurer pool_pre_ping / testOnBorrow**
   ```python
   # âœ… BON : test avant utilisation
   engine = create_engine(..., pool_pre_ping=True)
   
   # âŒ MAUVAIS : risque "MySQL server has gone away"
   engine = create_engine(..., pool_pre_ping=False)
   ```

4. **Dimensionner selon la charge**
   ```java
   // âœ… BON : dimensionnement rÃ©aliste
   config.setMinimumIdle(5);
   config.setMaximumPoolSize(20);
   
   // âŒ MAUVAIS : pool trop grand
   config.setMaximumPoolSize(1000); // Gaspillage ressources !
   ```

5. **Monitorer les mÃ©triques**
   ```go
   // âœ… BON : monitoring continu
   go db.MonitorPool(10 * time.Second)
   
   // âŒ MAUVAIS : aucun monitoring
   // ProblÃ¨mes invisibles jusqu'au crash
   ```

### âŒ Anti-patterns Ã  Ã©viter

1. **Connection leak (ne pas relÃ¢cher)**
   ```javascript
   // âŒ DANGER : fuite de connexion
   async function badExample() {
       const conn = await pool.getConnection();
       const rows = await conn.query('SELECT ...');
       return rows;
       // OUBLI : conn.release() !
   }
   ```

2. **Pool trop petit (saturation)**
   ```python
   # âŒ DANGER : pool saturÃ© sous charge
   engine = create_engine(..., pool_size=1, max_overflow=0)
   # Toutes les requÃªtes concurrentes attendront !
   ```

3. **Pool trop grand (gaspillage)**
   ```java
   // âŒ DANGER : gaspillage mÃ©moire/ressources
   config.setMaximumPoolSize(500);
   // MariaDB : max_connections = 151 par dÃ©faut !
   ```

4. **Pas de timeout**
   ```csharp
   // âŒ DANGER : attente infinie
   builder.ConnectionTimeout = 0; // Pas de timeout !
   // Thread bloquÃ© indÃ©finiment si pool exhausted
   ```

5. **Ignorer les erreurs de pool**
   ```python
   # âŒ DANGER : masquer les problÃ¨mes
   try:
       conn = pool.get_connection()
   except PoolTimeout:
       pass  # Ignorer l'erreur !
   ```

---

## Comparaison pool applicatif vs ProxySQL

| CritÃ¨re | Pool Application | ProxySQL |
|---------|------------------|----------|
| **Localisation** | Dans chaque instance app | Serveur dÃ©diÃ© |
| **Partage** | âŒ Non (isolÃ© par instance) | âœ… Oui (centralisÃ©) |
| **ComplexitÃ©** | Simple | Moyenne-Ã©levÃ©e |
| **Performance** | TrÃ¨s Ã©levÃ©e | Ã‰levÃ©e (hop rÃ©seau) |
| **ScalabilitÃ©** | LinÃ©aire avec instances | Meilleure (pool partagÃ©) |
| **Monitoring** | Par instance | CentralisÃ© |
| **Query routing** | âŒ Non | âœ… Oui (read/write split) |
| **Query cache** | âŒ Non | âœ… Oui |
| **CoÃ»t infra** | Inclus dans app | Serveur additionnel |

**Recommandation** :
- **Pool applicatif** : Applications simples, monolithes, faible nombre d'instances
- **ProxySQL** : Microservices (10+ instances), haute disponibilitÃ©, query routing nÃ©cessaire

---

## âœ… Points clÃ©s Ã  retenir

1. **Pool = rÃ©utilisation** : 10-100x plus rapide qu'ouvrir/fermer Ã  chaque fois
2. **Dimensionnement** : `maxSize â‰ˆ (cores Ã— 2) + disks`
3. **Toujours relÃ¢cher** : Connection leak = pool exhaustion
4. **Pre-ping/validation** : Ã‰viter "server has gone away"
5. **Monitoring** : Surveiller active, idle, wait count, wait duration
6. **Timeouts** : Configurer connectionTimeout et commandTimeout
7. **MaxLifetime** : Recycler rÃ©guliÃ¨rement (30-60min)
8. **Production** : Pool applicatif OU ProxySQL, jamais les deux sur la mÃªme connexion

---

## ğŸ”— Ressources

### Documentation
- [HikariCP GitHub](https://github.com/brettwooldridge/HikariCP)
- [SQLAlchemy Pooling](https://docs.sqlalchemy.org/en/20/core/pooling.html)
- [mysql2 Pool Options](https://github.com/sidorares/node-mysql2#pool-options)
- [Go database/sql](https://pkg.go.dev/database/sql)

### Articles
- [About Pool Sizing (HikariCP wiki)](https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing)
- [Connection Pool Best Practices](https://use-the-index-luke.com/sql/where-clause/the-where-clause)

---

## â¡ï¸ Section suivante

**17.2.2 ProxySQL comme pooler centralisÃ©** : Configuration avancÃ©e de ProxySQL pour connection pooling partagÃ©, query routing, et haute disponibilitÃ© multi-instances.

â­ï¸ [ProxySQL comme pooler](/17-integration-developpement/02.2-proxysql-pooler.md)
