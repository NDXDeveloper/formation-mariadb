üîù Retour au [Sommaire](/SOMMAIRE.md)

# 17.3.2 SQLAlchemy (Python)

> **Niveau** : Interm√©diaire √† Avanc√©  
> **Dur√©e estim√©e** : 4-5 heures  
> **Pr√©requis** : Python 3.8+, bases SQL, concepts POO

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre l'architecture SQLAlchemy (Core vs ORM)
- Configurer SQLAlchemy 2.0 avec MariaDB
- Ma√Ætriser le mapping d√©claratif et les relations
- Utiliser efficacement l'API Session et Query
- G√©rer les migrations avec Alembic
- Optimiser les performances (lazy/eager loading, N+1)
- Int√©grer SQLAlchemy avec FastAPI et Flask
- Appliquer les bonnes pratiques SQLAlchemy-MariaDB

---

## Introduction √† SQLAlchemy

### Qu'est-ce que SQLAlchemy ?

**SQLAlchemy** est l'ORM Python le plus populaire et le plus complet. Il offre deux niveaux d'abstraction :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Architecture SQLAlchemy                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Application Python             ‚îÇ
‚îÇ  (Models - Python Classes)         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     SQLAlchemy ORM                 ‚îÇ
‚îÇ  ‚Ä¢ Declarative models              ‚îÇ
‚îÇ  ‚Ä¢ Session management              ‚îÇ
‚îÇ  ‚Ä¢ Relationship loading            ‚îÇ
‚îÇ  ‚Ä¢ Query API                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     SQLAlchemy Core                ‚îÇ
‚îÇ  ‚Ä¢ SQL Expression Language         ‚îÇ
‚îÇ  ‚Ä¢ Connection pooling              ‚îÇ
‚îÇ  ‚Ä¢ Schema definition               ‚îÇ
‚îÇ  ‚Ä¢ Type system                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     DBAPI (PyMySQL/mysqlclient)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        MariaDB Server              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### SQLAlchemy Core vs ORM

| Aspect | Core | ORM |
|--------|------|-----|
| **Abstraction** | SQL expression language | Object-Relational Mapping |
| **Paradigme** | SQL-centric | Python-centric |
| **Performance** | Maximale | L√©g√®rement inf√©rieure |
| **Flexibilit√©** | Total contr√¥le SQL | Abstraction objets |
| **Complexit√©** | Plus verbeux | Plus concis |
| **Use case** | Requ√™tes complexes, bulk ops | CRUD, relations complexes |

üí° **Conseil** : Utilisez l'**ORM** pour 90% des besoins (CRUD, relations), et le **Core** pour les requ√™tes complexes ou les op√©rations de masse.

---

## Installation et configuration

### Installation

```bash
# SQLAlchemy 2.0+
pip install sqlalchemy>=2.0.0

# Drivers MariaDB/MySQL
pip install pymysql        # Pure Python (recommand√© pour dev)
# OU
pip install mysqlclient    # C bindings (plus rapide, prod)

# Optionnel : Alembic pour migrations
pip install alembic

# Optionnel : Validation
pip install pydantic

# Optionnel : Async support
pip install asyncio
pip install aiomysql       # Async PyMySQL
```

### Requirements.txt

```txt
# requirements.txt
sqlalchemy>=2.0.25
pymysql>=1.1.0
cryptography>=41.0.0  # Pour SSL
alembic>=1.13.0
pydantic>=2.5.0
python-dotenv>=1.0.0
```

### Configuration de base

```python
# database.py
from sqlalchemy import create_engine, event
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy.pool import QueuePool
import logging

# Logging SQL (d√©veloppement)
logging.basicConfig()
logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)

# Base pour les mod√®les
Base = declarative_base()

# Configuration de l'engine
DATABASE_URL = (
    "mysql+pymysql://app_user:SecureP@ssw0rd!@localhost:3306/production_db"
    "?charset=utf8mb4"
)

engine = create_engine(
    DATABASE_URL,
    
    # Connection pooling (QueuePool par d√©faut)
    poolclass=QueuePool,
    pool_size=10,              # Connexions permanentes
    max_overflow=20,           # Connexions suppl√©mentaires
    pool_timeout=30,           # Timeout pour obtenir connexion
    pool_recycle=3600,         # Recycler apr√®s 1h
    pool_pre_ping=True,        # Test avant utilisation
    
    # Options d'ex√©cution
    echo=False,                # Log SQL (False en prod)
    echo_pool=False,           # Log pool events
    future=True,               # SQLAlchemy 2.0 style
    
    # Options MariaDB sp√©cifiques
    connect_args={
        "charset": "utf8mb4",
        "ssl": {"ssl_mode": "PREFERRED"},
        "connect_timeout": 10,
    }
)

# Session factory
SessionLocal = sessionmaker(
    bind=engine,
    autocommit=False,
    autoflush=False,
    expire_on_commit=False
)

# Event listeners pour monitoring
@event.listens_for(engine, "connect")
def receive_connect(dbapi_conn, connection_record):
    print(f"New connection: {id(dbapi_conn)}")

@event.listens_for(engine, "checkout")
def receive_checkout(dbapi_conn, connection_record, connection_proxy):
    print(f"Connection checked out: {id(dbapi_conn)}")

# Context manager pour sessions
from contextlib import contextmanager

@contextmanager
def get_db():
    """Context manager pour session database"""
    db = SessionLocal()
    try:
        yield db
        db.commit()
    except Exception:
        db.rollback()
        raise
    finally:
        db.close()
```

### Configuration avec variables d'environnement

```python
# config.py
from pydantic_settings import BaseSettings
from functools import lru_cache

class Settings(BaseSettings):
    # Database
    DB_HOST: str = "localhost"
    DB_PORT: int = 3306
    DB_USER: str = "app_user"
    DB_PASSWORD: str
    DB_NAME: str = "production_db"
    DB_CHARSET: str = "utf8mb4"
    
    # Pool
    DB_POOL_SIZE: int = 10
    DB_MAX_OVERFLOW: int = 20
    DB_POOL_TIMEOUT: int = 30
    DB_POOL_RECYCLE: int = 3600
    
    # Application
    DEBUG: bool = False
    
    class Config:
        env_file = ".env"
    
    @property
    def database_url(self) -> str:
        return (
            f"mysql+pymysql://{self.DB_USER}:{self.DB_PASSWORD}"
            f"@{self.DB_HOST}:{self.DB_PORT}/{self.DB_NAME}"
            f"?charset={self.DB_CHARSET}"
        )

@lru_cache()
def get_settings() -> Settings:
    return Settings()

# Utilisation
from sqlalchemy import create_engine

settings = get_settings()
engine = create_engine(
    settings.database_url,
    pool_size=settings.DB_POOL_SIZE,
    max_overflow=settings.DB_MAX_OVERFLOW,
    echo=settings.DEBUG
)
```

---

## Mapping d√©claratif

### Mod√®le de base

```python
# models/user.py
from sqlalchemy import (
    Column, Integer, String, Boolean, DateTime, Text,
    Index, UniqueConstraint
)
from sqlalchemy.sql import func
from datetime import datetime
from typing import Optional

from database import Base

class User(Base):
    __tablename__ = "users"
    
    # Colonnes
    id = Column(Integer, primary_key=True, autoincrement=True)
    username = Column(String(50), unique=True, nullable=False, index=True)
    email = Column(String(255), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    first_name = Column(String(100), nullable=True)
    last_name = Column(String(100), nullable=True)
    is_active = Column(Boolean, default=True, nullable=False)
    is_admin = Column(Boolean, default=False, nullable=False)
    
    # Timestamps automatiques
    created_at = Column(
        DateTime, 
        nullable=False, 
        server_default=func.now()
    )
    updated_at = Column(
        DateTime, 
        nullable=True,
        onupdate=func.now()
    )
    last_login = Column(DateTime, nullable=True)
    
    # Index composites
    __table_args__ = (
        Index('idx_active_created', 'is_active', 'created_at'),
        {'mysql_engine': 'InnoDB', 'mysql_charset': 'utf8mb4'}
    )
    
    def __repr__(self):
        return f"<User(id={self.id}, username='{self.username}')>"
    
    def __str__(self):
        return self.username
    
    # M√©thodes helper
    def to_dict(self):
        """Convertir en dictionnaire"""
        return {
            'id': self.id,
            'username': self.username,
            'email': self.email,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'is_active': self.is_active,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }
```

### Types de donn√©es MariaDB

```python
from sqlalchemy import (
    Column, Integer, BigInteger, SmallInteger,
    String, Text, DECIMAL, Float,
    Boolean, Date, Time, DateTime, Enum,
    LargeBinary, JSON
)
from sqlalchemy.dialects.mysql import (
    TINYINT, MEDIUMINT, LONGTEXT,
    DOUBLE, TIMESTAMP
)
import enum

class DataTypesExample(Base):
    __tablename__ = "data_types_example"
    
    id = Column(Integer, primary_key=True)
    
    # Texte
    short_text = Column(String(50))
    long_text = Column(Text)
    medium_text = Column(LONGTEXT)
    
    # Nombres
    tiny_int = Column(TINYINT)
    small_int = Column(SmallInteger)
    int_value = Column(Integer)
    big_int = Column(BigInteger)
    
    # D√©cimaux
    price = Column(DECIMAL(10, 2))  # Pr√©cision exacte
    float_value = Column(Float)
    double_value = Column(DOUBLE)
    
    # Dates et temps
    date_only = Column(Date)
    time_only = Column(Time)
    date_time = Column(DateTime)
    timestamp = Column(TIMESTAMP, server_default=func.now())
    
    # Boolean (TINYINT(1) en MariaDB)
    flag = Column(Boolean, default=False)
    
    # JSON (MariaDB 10.2+)
    metadata = Column(JSON)
    
    # Enum
    class StatusEnum(enum.Enum):
        PENDING = "pending"
        CONFIRMED = "confirmed"
        CANCELLED = "cancelled"
    
    status = Column(Enum(StatusEnum), default=StatusEnum.PENDING)
    
    # Binary
    file_data = Column(LargeBinary)
```

### SQLAlchemy 2.0 style (Mapped)

```python
# models/user_v2.py - Style SQLAlchemy 2.0
from sqlalchemy.orm import Mapped, mapped_column
from datetime import datetime
from typing import Optional

class User(Base):
    __tablename__ = "users"
    
    # Type hints avec Mapped
    id: Mapped[int] = mapped_column(primary_key=True)
    username: Mapped[str] = mapped_column(String(50), unique=True)
    email: Mapped[str] = mapped_column(String(255), unique=True)
    password_hash: Mapped[str] = mapped_column(String(255))
    
    # Nullable avec Optional
    first_name: Mapped[Optional[str]] = mapped_column(String(100))
    last_name: Mapped[Optional[str]] = mapped_column(String(100))
    
    # Boolean avec default
    is_active: Mapped[bool] = mapped_column(default=True)
    is_admin: Mapped[bool] = mapped_column(default=False)
    
    # Timestamps
    created_at: Mapped[datetime] = mapped_column(server_default=func.now())
    updated_at: Mapped[Optional[datetime]] = mapped_column(onupdate=func.now())
```

---

## Relations entre mod√®les

### OneToMany / ManyToOne

```python
# models/order.py
from sqlalchemy import Column, Integer, String, DECIMAL, DateTime, ForeignKey
from sqlalchemy.orm import relationship, Mapped, mapped_column
from typing import List
from datetime import datetime

class Order(Base):
    __tablename__ = "orders"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    
    # Foreign Key vers User
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"))
    
    total_amount: Mapped[float] = mapped_column(DECIMAL(10, 2), default=0)
    status: Mapped[str] = mapped_column(String(20), default="pending")
    created_at: Mapped[datetime] = mapped_column(server_default=func.now())
    updated_at: Mapped[datetime | None] = mapped_column(onupdate=func.now())
    
    # Relations
    # Many orders -> One user
    user: Mapped["User"] = relationship(
        "User", 
        back_populates="orders"
    )
    
    # One order -> Many items
    items: Mapped[List["OrderItem"]] = relationship(
        "OrderItem",
        back_populates="order",
        cascade="all, delete-orphan",  # Cascade delete
        lazy="select"                   # Lazy loading par d√©faut
    )
    
    def __repr__(self):
        return f"<Order(id={self.id}, user_id={self.user_id})>"
    
    def recalculate_total(self):
        """Recalculer le total de la commande"""
        self.total_amount = sum(item.subtotal for item in self.items)

# Ajouter dans User
from sqlalchemy.orm import relationship

class User(Base):
    # ... autres colonnes ...
    
    # One user -> Many orders
    orders: Mapped[List["Order"]] = relationship(
        "Order",
        back_populates="user",
        cascade="all, delete-orphan",
        lazy="select"
    )

# models/order_item.py
class OrderItem(Base):
    __tablename__ = "order_items"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    order_id: Mapped[int] = mapped_column(ForeignKey("orders.id"))
    product_id: Mapped[int] = mapped_column(ForeignKey("products.id"))
    quantity: Mapped[int]
    price: Mapped[float] = mapped_column(DECIMAL(10, 2))
    
    # Relations
    order: Mapped["Order"] = relationship("Order", back_populates="items")
    product: Mapped["Product"] = relationship("Product")
    
    @property
    def subtotal(self):
        """Calculer le sous-total"""
        return self.price * self.quantity
```

### ManyToMany

```python
# models/association.py
from sqlalchemy import Table, Column, Integer, ForeignKey

# Table d'association
user_roles = Table(
    'user_roles',
    Base.metadata,
    Column('user_id', Integer, ForeignKey('users.id'), primary_key=True),
    Column('role_id', Integer, ForeignKey('roles.id'), primary_key=True),
    mysql_engine='InnoDB'
)

# models/role.py
class Role(Base):
    __tablename__ = "roles"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(50), unique=True)
    description: Mapped[str | None] = mapped_column(Text)
    
    # Many roles <-> Many users
    users: Mapped[List["User"]] = relationship(
        "User",
        secondary=user_roles,
        back_populates="roles"
    )

# Dans User
class User(Base):
    # ... autres colonnes ...
    
    # Many users <-> Many roles
    roles: Mapped[List["Role"]] = relationship(
        "Role",
        secondary=user_roles,
        back_populates="users",
        lazy="selectin"  # Eager loading pour √©viter N+1
    )
```

### ManyToMany avec attributs suppl√©mentaires

```python
# models/enrollment.py
from sqlalchemy.orm import Mapped, mapped_column, relationship

class Enrollment(Base):
    __tablename__ = "enrollments"
    
    # Cl√© composite
    student_id: Mapped[int] = mapped_column(
        ForeignKey("students.id"), 
        primary_key=True
    )
    course_id: Mapped[int] = mapped_column(
        ForeignKey("courses.id"), 
        primary_key=True
    )
    
    # Attributs suppl√©mentaires
    enrolled_at: Mapped[datetime] = mapped_column(server_default=func.now())
    grade: Mapped[float | None] = mapped_column(DECIMAL(5, 2))
    completed: Mapped[bool] = mapped_column(default=False)
    
    # Relations
    student: Mapped["Student"] = relationship("Student", back_populates="enrollments")
    course: Mapped["Course"] = relationship("Course", back_populates="enrollments")

class Student(Base):
    __tablename__ = "students"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(100))
    
    enrollments: Mapped[List["Enrollment"]] = relationship(
        "Enrollment",
        back_populates="student",
        cascade="all, delete-orphan"
    )
    
    # Property helper pour acc√©der aux cours
    @property
    def courses(self):
        return [enrollment.course for enrollment in self.enrollments]

class Course(Base):
    __tablename__ = "courses"
    
    id: Mapped[int] = mapped_column(primary_key=True)
    title: Mapped[str] = mapped_column(String(200))
    
    enrollments: Mapped[List["Enrollment"]] = relationship(
        "Enrollment",
        back_populates="course",
        cascade="all, delete-orphan"
    )
```

---

## Requ√™tes avec Session

### CRUD de base

```python
# repositories/user_repository.py
from sqlalchemy.orm import Session
from sqlalchemy import select, and_, or_, func
from models.user import User
from typing import Optional, List

class UserRepository:
    
    def __init__(self, db: Session):
        self.db = db
    
    def get_by_id(self, user_id: int) -> Optional[User]:
        """R√©cup√©rer par ID"""
        return self.db.get(User, user_id)
    
    def get_by_email(self, email: str) -> Optional[User]:
        """R√©cup√©rer par email"""
        stmt = select(User).where(User.email == email)
        return self.db.scalars(stmt).first()
    
    def get_all(self, skip: int = 0, limit: int = 100) -> List[User]:
        """Liste avec pagination"""
        stmt = (
            select(User)
            .where(User.is_active == True)
            .order_by(User.created_at.desc())
            .offset(skip)
            .limit(limit)
        )
        return list(self.db.scalars(stmt))
    
    def search(self, term: str, limit: int = 20) -> List[User]:
        """Recherche par terme"""
        search_term = f"%{term}%"
        stmt = (
            select(User)
            .where(
                and_(
                    User.is_active == True,
                    or_(
                        User.username.ilike(search_term),
                        User.email.ilike(search_term)
                    )
                )
            )
            .limit(limit)
        )
        return list(self.db.scalars(stmt))
    
    def create(self, user: User) -> User:
        """Cr√©er un utilisateur"""
        self.db.add(user)
        self.db.flush()  # Obtenir l'ID sans commit
        return user
    
    def update(self, user: User) -> User:
        """Mettre √† jour"""
        self.db.add(user)  # merge si d√©tach√©
        self.db.flush()
        return user
    
    def delete(self, user_id: int) -> bool:
        """Supprimer (soft delete)"""
        user = self.get_by_id(user_id)
        if user:
            user.is_active = False
            self.db.flush()
            return True
        return False
    
    def count_active(self) -> int:
        """Compter les utilisateurs actifs"""
        stmt = select(func.count(User.id)).where(User.is_active == True)
        return self.db.scalar(stmt)

# Utilisation
with get_db() as db:
    repo = UserRepository(db)
    
    # Create
    user = User(username="john", email="john@example.com")
    user = repo.create(user)
    
    # Read
    user = repo.get_by_id(1)
    users = repo.get_all(skip=0, limit=10)
    
    # Update
    user.email = "newemail@example.com"
    repo.update(user)
    
    # Delete
    repo.delete(1)
```

### Requ√™tes avanc√©es

```python
from sqlalchemy import select, func, and_, or_, case, cast, String
from sqlalchemy.orm import joinedload, selectinload, contains_eager

class UserRepository:
    
    def get_with_orders(self, user_id: int) -> Optional[User]:
        """Charger avec orders (eager loading)"""
        stmt = (
            select(User)
            .options(selectinload(User.orders))  # Eager load
            .where(User.id == user_id)
        )
        return self.db.scalars(stmt).first()
    
    def get_with_orders_and_items(self, user_id: int) -> Optional[User]:
        """Charger avec orders et items (nested eager loading)"""
        stmt = (
            select(User)
            .options(
                selectinload(User.orders).selectinload(Order.items)
            )
            .where(User.id == user_id)
        )
        return self.db.scalars(stmt).first()
    
    def search_advanced(
        self, 
        username: Optional[str] = None,
        email: Optional[str] = None,
        is_active: Optional[bool] = None,
        created_after: Optional[datetime] = None
    ) -> List[User]:
        """Recherche avec filtres dynamiques"""
        stmt = select(User)
        
        # Construire les filtres dynamiquement
        filters = []
        
        if username:
            filters.append(User.username.ilike(f"%{username}%"))
        
        if email:
            filters.append(User.email.ilike(f"%{email}%"))
        
        if is_active is not None:
            filters.append(User.is_active == is_active)
        
        if created_after:
            filters.append(User.created_at >= created_after)
        
        if filters:
            stmt = stmt.where(and_(*filters))
        
        stmt = stmt.order_by(User.created_at.desc())
        
        return list(self.db.scalars(stmt))
    
    def get_user_stats(self):
        """Statistiques avec agr√©gations"""
        stmt = (
            select(
                User.id,
                User.username,
                func.count(Order.id).label('order_count'),
                func.coalesce(func.sum(Order.total_amount), 0).label('total_spent')
            )
            .outerjoin(User.orders)
            .group_by(User.id, User.username)
            .having(func.count(Order.id) > 0)
            .order_by(func.sum(Order.total_amount).desc())
            .limit(10)
        )
        
        return self.db.execute(stmt).all()
    
    def bulk_update_status(self, user_ids: List[int], is_active: bool) -> int:
        """Mise √† jour en masse"""
        from sqlalchemy import update
        
        stmt = (
            update(User)
            .where(User.id.in_(user_ids))
            .values(is_active=is_active, updated_at=func.now())
        )
        
        result = self.db.execute(stmt)
        self.db.flush()
        return result.rowcount
```

### Transactions

```python
# repositories/order_repository.py
from sqlalchemy.orm import Session
from sqlalchemy import select
from models.order import Order, OrderItem
from models.product import Product

class OrderRepository:
    
    def __init__(self, db: Session):
        self.db = db
    
    def create_order_with_items(
        self, 
        user_id: int, 
        items: List[dict]
    ) -> Order:
        """
        Cr√©er une commande avec items (transaction atomique)
        items = [{"product_id": 1, "quantity": 2}, ...]
        """
        # 1. Cr√©er la commande
        order = Order(user_id=user_id, status="pending")
        self.db.add(order)
        self.db.flush()  # Obtenir l'ID
        
        total_amount = 0
        
        # 2. Traiter chaque item
        for item_data in items:
            # R√©cup√©rer le produit avec lock
            stmt = (
                select(Product)
                .where(Product.id == item_data["product_id"])
                .with_for_update()  # SELECT ... FOR UPDATE
            )
            product = self.db.scalars(stmt).first()
            
            if not product:
                raise ValueError(f"Product {item_data['product_id']} not found")
            
            if product.stock < item_data["quantity"]:
                raise ValueError(
                    f"Insufficient stock for product {product.id}"
                )
            
            # Cr√©er l'item
            order_item = OrderItem(
                order_id=order.id,
                product_id=product.id,
                quantity=item_data["quantity"],
                price=product.price
            )
            self.db.add(order_item)
            
            # D√©cr√©menter le stock
            product.stock -= item_data["quantity"]
            
            # Calculer sous-total
            total_amount += product.price * item_data["quantity"]
        
        # 3. Mettre √† jour le total
        order.total_amount = total_amount
        
        # Flush pour valider
        self.db.flush()
        
        # Refresh pour charger les relations
        self.db.refresh(order)
        
        return order

# Utilisation avec transaction
from contextlib import contextmanager

@contextmanager
def get_db_transaction():
    """Context manager avec transaction explicite"""
    db = SessionLocal()
    try:
        yield db
        db.commit()
    except Exception as e:
        db.rollback()
        raise e
    finally:
        db.close()

# Utilisation
try:
    with get_db_transaction() as db:
        repo = OrderRepository(db)
        order = repo.create_order_with_items(
            user_id=1,
            items=[
                {"product_id": 1, "quantity": 2},
                {"product_id": 2, "quantity": 1}
            ]
        )
        print(f"Order created: {order.id}")
except ValueError as e:
    print(f"Error: {e}")
```

---

## Optimisations de performance

### Probl√®me N+1 et solutions

```python
# ‚ùå MAUVAIS : Probl√®me N+1
with get_db() as db:
    # 1 requ√™te pour les commandes
    orders = db.scalars(select(Order)).all()
    
    # N requ√™tes pour charger chaque user !
    for order in orders:
        print(order.user.username)  # Lazy load

# ‚úÖ BON : selectinload (2 requ√™tes total)
with get_db() as db:
    stmt = select(Order).options(selectinload(Order.user))
    orders = db.scalars(stmt).all()
    
    for order in orders:
        print(order.user.username)  # D√©j√† charg√©

# ‚úÖ BON : joinedload (1 requ√™te avec JOIN)
with get_db() as db:
    stmt = select(Order).options(joinedload(Order.user))
    orders = db.scalars(stmt).unique().all()  # unique() n√©cessaire avec joinedload
    
    for order in orders:
        print(order.user.username)

# ‚úÖ BON : Nested eager loading
with get_db() as db:
    stmt = (
        select(Order)
        .options(
            selectinload(Order.user),
            selectinload(Order.items).selectinload(OrderItem.product)
        )
    )
    orders = db.scalars(stmt).all()
    
    for order in orders:
        print(f"User: {order.user.username}")
        for item in order.items:
            print(f"  Product: {item.product.name}")
```

### Strat√©gies de chargement

```python
from sqlalchemy.orm import (
    selectinload,  # SELECT IN (id1, id2, ...) - bon pour OneToMany
    joinedload,    # LEFT OUTER JOIN - bon pour ManyToOne
    subqueryload,  # Subquery - alternatif √† selectinload
    lazyload,      # Lazy (d√©faut)
    noload         # Ne pas charger du tout
)

# selectinload : bon pour collections (OneToMany)
stmt = select(User).options(selectinload(User.orders))

# joinedload : bon pour single objects (ManyToOne)
stmt = select(Order).options(joinedload(Order.user))

# Combinaison
stmt = (
    select(User)
    .options(
        selectinload(User.orders)
        .joinedload(Order.items)
        .joinedload(OrderItem.product)
    )
)

# noload : ne pas charger une relation
stmt = select(User).options(noload(User.orders))
```

### Batch operations

```python
from sqlalchemy import insert, update, delete

class UserRepository:
    
    def bulk_insert_users(self, users_data: List[dict]) -> int:
        """Insertion en masse"""
        stmt = insert(User).values(users_data)
        result = self.db.execute(stmt)
        self.db.flush()
        return result.rowcount
    
    def bulk_update_users(self, updates: List[dict]) -> int:
        """Mise √† jour en masse avec donn√©es diff√©rentes"""
        # updates = [{"id": 1, "email": "new1@example.com"}, ...]
        
        from sqlalchemy.dialects.mysql import insert
        
        stmt = insert(User).values(updates)
        stmt = stmt.on_duplicate_key_update(
            email=stmt.inserted.email,
            updated_at=func.now()
        )
        
        result = self.db.execute(stmt)
        self.db.flush()
        return result.rowcount
    
    def bulk_delete_inactive(self, days: int) -> int:
        """Suppression en masse"""
        from datetime import timedelta
        
        threshold = datetime.utcnow() - timedelta(days=days)
        
        stmt = (
            delete(User)
            .where(
                and_(
                    User.is_active == False,
                    User.updated_at < threshold
                )
            )
        )
        
        result = self.db.execute(stmt)
        self.db.flush()
        return result.rowcount
```

---

## Migrations avec Alembic

### Installation et initialisation

```bash
# Installer Alembic
pip install alembic

# Initialiser
alembic init alembic

# Structure cr√©√©e :
# alembic/
#   ‚îú‚îÄ‚îÄ env.py           # Configuration
#   ‚îú‚îÄ‚îÄ script.py.mako   # Template
#   ‚îî‚îÄ‚îÄ versions/        # Migrations
# alembic.ini            # Config Alembic
```

### Configuration Alembic

```python
# alembic/env.py
from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool
from alembic import context

# Import des mod√®les
from database import Base
from models.user import User
from models.order import Order
from models.order_item import OrderItem
from models.product import Product

# Configuration
config = context.config

# Surcharger sqlalchemy.url depuis .env
from config import get_settings
settings = get_settings()
config.set_main_option("sqlalchemy.url", settings.database_url)

# Metadata des mod√®les
target_metadata = Base.metadata

def run_migrations_offline():
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online():
    """Run migrations in 'online' mode."""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
```

### Cr√©er et appliquer des migrations

```bash
# G√©n√©rer une migration automatique
alembic revision --autogenerate -m "Create users table"

# Appliquer les migrations
alembic upgrade head

# Revenir en arri√®re
alembic downgrade -1

# Voir l'historique
alembic history

# Voir le statut actuel
alembic current
```

### Exemple de migration

```python
# alembic/versions/001_create_users.py
"""Create users table

Revision ID: 001
Revises: 
Create Date: 2024-01-15 10:00:00.000000
"""
from alembic import op
import sqlalchemy as sa

# revision identifiers
revision = '001'
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    op.create_table(
        'users',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('username', sa.String(length=50), nullable=False),
        sa.Column('email', sa.String(length=255), nullable=False),
        sa.Column('password_hash', sa.String(length=255), nullable=False),
        sa.Column('first_name', sa.String(length=100), nullable=True),
        sa.Column('last_name', sa.String(length=100), nullable=True),
        sa.Column('is_active', sa.Boolean(), nullable=False),
        sa.Column('is_admin', sa.Boolean(), nullable=False),
        sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.DateTime(), nullable=True),
        sa.Column('last_login', sa.DateTime(), nullable=True),
        sa.PrimaryKeyConstraint('id'),
        mysql_engine='InnoDB',
        mysql_charset='utf8mb4'
    )
    
    op.create_index('idx_email', 'users', ['email'], unique=True)
    op.create_index('idx_username', 'users', ['username'], unique=True)
    op.create_index('idx_active_created', 'users', ['is_active', 'created_at'])

def downgrade():
    op.drop_index('idx_active_created', table_name='users')
    op.drop_index('idx_username', table_name='users')
    op.drop_index('idx_email', table_name='users')
    op.drop_table('users')
```

---

## Int√©gration avec FastAPI

### Configuration FastAPI

```python
# main.py
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from typing import List

from database import engine, Base, get_db
from models.user import User
from schemas.user import UserCreate, UserRead, UserUpdate
from repositories.user_repository import UserRepository

# Cr√©er les tables
Base.metadata.create_all(bind=engine)

app = FastAPI(title="MariaDB API", version="1.0.0")

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Dependency
def get_user_repo(db: Session = Depends(get_db)):
    return UserRepository(db)

# Routes
@app.get("/users", response_model=List[UserRead])
def list_users(
    skip: int = 0,
    limit: int = 100,
    repo: UserRepository = Depends(get_user_repo)
):
    """Liste des utilisateurs"""
    return repo.get_all(skip=skip, limit=limit)

@app.get("/users/{user_id}", response_model=UserRead)
def get_user(
    user_id: int,
    repo: UserRepository = Depends(get_user_repo)
):
    """R√©cup√©rer un utilisateur"""
    user = repo.get_by_id(user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    return user

@app.post("/users", response_model=UserRead, status_code=status.HTTP_201_CREATED)
def create_user(
    user_data: UserCreate,
    repo: UserRepository = Depends(get_user_repo),
    db: Session = Depends(get_db)
):
    """Cr√©er un utilisateur"""
    # V√©rifier si l'email existe
    existing = repo.get_by_email(user_data.email)
    if existing:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    
    # Cr√©er l'utilisateur
    user = User(**user_data.model_dump())
    user = repo.create(user)
    db.commit()
    db.refresh(user)
    
    return user

@app.put("/users/{user_id}", response_model=UserRead)
def update_user(
    user_id: int,
    user_data: UserUpdate,
    repo: UserRepository = Depends(get_user_repo),
    db: Session = Depends(get_db)
):
    """Mettre √† jour un utilisateur"""
    user = repo.get_by_id(user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    # Mettre √† jour les champs
    for field, value in user_data.model_dump(exclude_unset=True).items():
        setattr(user, field, value)
    
    repo.update(user)
    db.commit()
    db.refresh(user)
    
    return user

@app.delete("/users/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_user(
    user_id: int,
    repo: UserRepository = Depends(get_user_repo),
    db: Session = Depends(get_db)
):
    """Supprimer un utilisateur"""
    success = repo.delete(user_id)
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    db.commit()
    return None
```

### Sch√©mas Pydantic

```python
# schemas/user.py
from pydantic import BaseModel, EmailStr, ConfigDict
from datetime import datetime
from typing import Optional

class UserBase(BaseModel):
    username: str
    email: EmailStr
    first_name: Optional[str] = None
    last_name: Optional[str] = None

class UserCreate(UserBase):
    password: str

class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    is_active: Optional[bool] = None

class UserRead(UserBase):
    id: int
    is_active: bool
    is_admin: bool
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    model_config = ConfigDict(from_attributes=True)
```

---

## ‚úÖ Points cl√©s √† retenir

1. **SQLAlchemy 2.0** : Utiliser le style moderne avec `Mapped` et `select()`
2. **Pool de connexions** : Configur√© automatiquement (QueuePool)
3. **Lazy loading** : Par d√©faut, utiliser eager loading pour √©viter N+1
4. **selectinload vs joinedload** : selectinload pour OneToMany, joinedload pour ManyToOne
5. **Transactions** : Context manager avec commit/rollback automatique
6. **Alembic** : Migrations versionn√©es pour sch√©ma database
7. **Repository pattern** : S√©parer logique data access
8. **Bulk operations** : insert/update/delete pour op√©rations de masse
9. **Type hints** : Utiliser Mapped[Type] pour typage fort
10. **FastAPI** : Dependency injection avec `Depends(get_db)`

---

## üîó Ressources

### Documentation officielle
- [üìñ SQLAlchemy 2.0](https://docs.sqlalchemy.org/en/20/)
- [üìñ SQLAlchemy ORM](https://docs.sqlalchemy.org/en/20/orm/)
- [üìñ Alembic](https://alembic.sqlalchemy.org/)

### Guides et tutoriels
- [SQLAlchemy 2.0 Tutorial](https://docs.sqlalchemy.org/en/20/tutorial/)
- [FastAPI + SQLAlchemy](https://fastapi.tiangolo.com/tutorial/sql-databases/)

---

## ‚û°Ô∏è Section suivante

**17.3.3 Sequelize et Prisma (Node.js)** : ORMs modernes JavaScript/TypeScript avec mapping, migrations, et optimisations pour MariaDB.

‚è≠Ô∏è [Sequelize (Node.js)](/17-integration-developpement/03.3-sequelize.md)
