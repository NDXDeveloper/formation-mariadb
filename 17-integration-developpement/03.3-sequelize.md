üîù Retour au [Sommaire](/SOMMAIRE.md)

# 17.3.3 Sequelize (Node.js)

> **Niveau** : Interm√©diaire √† Avanc√©  
> **Dur√©e estim√©e** : 4-5 heures  
> **Pr√©requis** : Node.js 18+, JavaScript ES6+/TypeScript, async/await, concepts ORM

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Configurer Sequelize 6.x avec MariaDB
- Ma√Ætriser la d√©finition des mod√®les et associations
- G√©rer les migrations et seeders
- Utiliser les hooks et validations
- Optimiser les performances (lazy/eager loading, transactions)
- Impl√©menter les bonnes pratiques Sequelize-MariaDB
- Int√©grer Sequelize avec Express.js et TypeScript
- G√©rer les requ√™tes complexes et agr√©gations

---

## Introduction √† Sequelize

### Qu'est-ce que Sequelize ?

**Sequelize** est l'ORM le plus populaire de l'√©cosyst√®me Node.js. Il offre une abstraction compl√®te pour les bases de donn√©es relationnelles avec support natif de MariaDB, MySQL, PostgreSQL, SQLite et MSSQL.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Architecture Sequelize                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Application Node.js            ‚îÇ
‚îÇ  (Express, Fastify, Koa...)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Sequelize ORM                  ‚îÇ
‚îÇ  ‚Ä¢ Model definitions               ‚îÇ
‚îÇ  ‚Ä¢ Associations                    ‚îÇ
‚îÇ  ‚Ä¢ Query interface                 ‚îÇ
‚îÇ  ‚Ä¢ Hooks & Validations             ‚îÇ
‚îÇ  ‚Ä¢ Migrations & Seeds              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Database Drivers               ‚îÇ
‚îÇ  ‚Ä¢ mysql2 (recommand√©)             ‚îÇ
‚îÇ  ‚Ä¢ mariadb                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        MariaDB Server              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Avantages de Sequelize

| Avantage | Description |
|----------|-------------|
| **Promise-based** | API enti√®rement asynchrone avec async/await |
| **TypeScript** | Support TypeScript de premi√®re classe |
| **Migrations** | Gestion versionn√©e du sch√©ma |
| **Associations** | Relations complexes (1:1, 1:N, N:M) |
| **Hooks** | Lifecycle events pour logique m√©tier |
| **Transactions** | Support ACID complet |
| **Validation** | Validations int√©gr√©es |
| **Raw queries** | √âchappatoire SQL natif si n√©cessaire |

---

## Installation et configuration

### Installation

```bash
# Package.json avec ES modules
npm init -y

# Sequelize et CLI
npm install sequelize sequelize-cli

# Driver MariaDB (mysql2 recommand√©)
npm install mysql2

# TypeScript (optionnel mais recommand√©)
npm install --save-dev typescript @types/node @types/validator
npm install --save-dev ts-node

# Validation
npm install validator

# Dotenv pour configuration
npm install dotenv
```

### package.json

```json
{
  "name": "sequelize-mariadb-app",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "migrate": "sequelize-cli db:migrate",
    "migrate:undo": "sequelize-cli db:migrate:undo",
    "seed": "sequelize-cli db:seed:all"
  },
  "dependencies": {
    "sequelize": "^6.35.2",
    "mysql2": "^3.6.5",
    "dotenv": "^16.3.1",
    "validator": "^13.11.0"
  },
  "devDependencies": {
    "sequelize-cli": "^6.6.2",
    "nodemon": "^3.0.2"
  }
}
```

### Configuration de base

```javascript
// config/database.js
import { Sequelize } from 'sequelize';
import dotenv from 'dotenv';

dotenv.config();

const sequelize = new Sequelize({
  // Database
  database: process.env.DB_NAME || 'production_db',
  username: process.env.DB_USER || 'app_user',
  password: process.env.DB_PASSWORD,
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 3306,
  
  // Dialect
  dialect: 'mysql',
  dialectOptions: {
    charset: 'utf8mb4',
    collate: 'utf8mb4_unicode_ci',
    connectTimeout: 10000,
    // SSL si n√©cessaire
    // ssl: {
    //   require: true,
    //   rejectUnauthorized: false
    // }
  },
  
  // Connection pool
  pool: {
    max: 10,              // Max connexions
    min: 2,               // Min connexions
    acquire: 30000,       // Timeout acquisition (ms)
    idle: 10000,          // Temps idle avant fermeture
    evict: 10000          // Intervalle de v√©rification
  },
  
  // Logging
  logging: process.env.NODE_ENV === 'development' ? console.log : false,
  
  // Options globales
  define: {
    timestamps: true,           // createdAt, updatedAt
    underscored: true,          // snake_case pour colonnes
    freezeTableName: true,      // Pas de pluralisation
    charset: 'utf8mb4',
    collate: 'utf8mb4_unicode_ci'
  },
  
  // Timezone
  timezone: '+00:00'
});

// Test de connexion
export async function testConnection() {
  try {
    await sequelize.authenticate();
    console.log('‚úì Database connection established');
  } catch (error) {
    console.error('‚úó Database connection failed:', error);
    process.exit(1);
  }
}

export default sequelize;
```

### Configuration avec .sequelizerc

```javascript
// .sequelizerc
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export default {
  'config': path.resolve(__dirname, 'config', 'config.json'),
  'models-path': path.resolve(__dirname, 'src', 'models'),
  'seeders-path': path.resolve(__dirname, 'src', 'seeders'),
  'migrations-path': path.resolve(__dirname, 'src', 'migrations')
};
```

---

## D√©finition des mod√®les

### Mod√®le de base

```javascript
// src/models/User.js
import { DataTypes, Model } from 'sequelize';
import sequelize from '../../config/database.js';
import bcrypt from 'bcrypt';

class User extends Model {
  // M√©thodes d'instance
  async validatePassword(password) {
    return bcrypt.compare(password, this.password_hash);
  }
  
  toJSON() {
    const values = { ...this.get() };
    delete values.password_hash;
    return values;
  }
  
  // M√©thodes de classe
  static async findByEmail(email) {
    return this.findOne({ where: { email } });
  }
}

User.init({
  // Colonnes
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  
  username: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: {
      name: 'unique_username',
      msg: 'Username already exists'
    },
    validate: {
      len: {
        args: [3, 50],
        msg: 'Username must be between 3 and 50 characters'
      },
      isAlphanumeric: {
        msg: 'Username must contain only letters and numbers'
      }
    }
  },
  
  email: {
    type: DataTypes.STRING(255),
    allowNull: false,
    unique: {
      name: 'unique_email',
      msg: 'Email already exists'
    },
    validate: {
      isEmail: {
        msg: 'Must be a valid email address'
      }
    }
  },
  
  password_hash: {
    type: DataTypes.STRING(255),
    allowNull: false,
    field: 'password_hash'
  },
  
  first_name: {
    type: DataTypes.STRING(100),
    allowNull: true
  },
  
  last_name: {
    type: DataTypes.STRING(100),
    allowNull: true
  },
  
  is_active: {
    type: DataTypes.BOOLEAN,
    defaultValue: true,
    allowNull: false
  },
  
  is_admin: {
    type: DataTypes.BOOLEAN,
    defaultValue: false,
    allowNull: false
  },
  
  last_login: {
    type: DataTypes.DATE,
    allowNull: true
  }
}, {
  sequelize,
  modelName: 'User',
  tableName: 'users',
  timestamps: true,
  underscored: true,
  
  // Index
  indexes: [
    {
      unique: true,
      fields: ['email']
    },
    {
      unique: true,
      fields: ['username']
    },
    {
      name: 'idx_active_created',
      fields: ['is_active', 'created_at']
    }
  ],
  
  // Hooks
  hooks: {
    beforeCreate: async (user) => {
      if (user.email) {
        user.email = user.email.toLowerCase();
      }
    },
    
    beforeUpdate: async (user) => {
      if (user.changed('email')) {
        user.email = user.email.toLowerCase();
      }
    }
  }
});

export default User;
```

### Types de donn√©es MariaDB

```javascript
// src/models/DataTypesExample.js
import { DataTypes, Model } from 'sequelize';
import sequelize from '../../config/database.js';

class DataTypesExample extends Model {}

DataTypesExample.init({
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  
  // Texte
  short_text: DataTypes.STRING(50),           // VARCHAR(50)
  long_text: DataTypes.TEXT,                  // TEXT
  medium_text: DataTypes.TEXT('medium'),      // MEDIUMTEXT
  tiny_text: DataTypes.TEXT('tiny'),          // TINYTEXT
  
  // Nombres
  tiny_int: DataTypes.TINYINT,
  small_int: DataTypes.SMALLINT,
  int_value: DataTypes.INTEGER,
  big_int: DataTypes.BIGINT,
  
  // D√©cimaux
  price: DataTypes.DECIMAL(10, 2),
  float_value: DataTypes.FLOAT,
  double_value: DataTypes.DOUBLE,
  
  // Dates et temps
  date_only: DataTypes.DATEONLY,              // DATE
  time_only: DataTypes.TIME,                  // TIME
  date_time: DataTypes.DATE,                  // DATETIME
  
  // Boolean (TINYINT(1))
  flag: DataTypes.BOOLEAN,
  
  // JSON (MariaDB 10.2+)
  metadata: DataTypes.JSON,
  
  // Enum
  status: {
    type: DataTypes.ENUM('pending', 'confirmed', 'cancelled'),
    defaultValue: 'pending'
  },
  
  // UUID
  uuid: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4
  },
  
  // Binary
  file_data: DataTypes.BLOB
}, {
  sequelize,
  modelName: 'DataTypesExample',
  tableName: 'data_types_example',
  timestamps: false
});

export default DataTypesExample;
```

---

## Associations (Relations)

### OneToMany / BelongsTo

```javascript
// src/models/Order.js
import { DataTypes, Model } from 'sequelize';
import sequelize from '../../config/database.js';

class Order extends Model {
  async recalculateTotal() {
    const items = await this.getOrderItems();
    const total = items.reduce((sum, item) => {
      return sum + (parseFloat(item.price) * item.quantity);
    }, 0);
    
    this.total_amount = total;
    await this.save();
    
    return this;
  }
}

Order.init({
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  
  user_id: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: 'users',
      key: 'id'
    }
  },
  
  total_amount: {
    type: DataTypes.DECIMAL(10, 2),
    defaultValue: 0,
    allowNull: false
  },
  
  status: {
    type: DataTypes.ENUM('pending', 'confirmed', 'shipped', 'delivered', 'cancelled'),
    defaultValue: 'pending',
    allowNull: false
  }
}, {
  sequelize,
  modelName: 'Order',
  tableName: 'orders',
  timestamps: true,
  underscored: true,
  
  indexes: [
    {
      fields: ['user_id', 'status']
    }
  ]
});

// src/models/OrderItem.js
class OrderItem extends Model {}

OrderItem.init({
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  
  order_id: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: 'orders',
      key: 'id'
    }
  },
  
  product_id: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: 'products',
      key: 'id'
    }
  },
  
  quantity: {
    type: DataTypes.INTEGER,
    allowNull: false,
    validate: {
      min: 1
    }
  },
  
  price: {
    type: DataTypes.DECIMAL(10, 2),
    allowNull: false
  }
}, {
  sequelize,
  modelName: 'OrderItem',
  tableName: 'order_items',
  timestamps: false,
  underscored: true
});

// src/models/index.js - D√©finir les associations
import User from './User.js';
import Order from './Order.js';
import OrderItem from './OrderItem.js';
import Product from './Product.js';

// User <-> Orders (One-to-Many)
User.hasMany(Order, {
  foreignKey: 'user_id',
  as: 'orders',
  onDelete: 'CASCADE'
});

Order.belongsTo(User, {
  foreignKey: 'user_id',
  as: 'user'
});

// Order <-> OrderItems (One-to-Many)
Order.hasMany(OrderItem, {
  foreignKey: 'order_id',
  as: 'items',
  onDelete: 'CASCADE'
});

OrderItem.belongsTo(Order, {
  foreignKey: 'order_id',
  as: 'order'
});

// OrderItem <-> Product (Many-to-One)
OrderItem.belongsTo(Product, {
  foreignKey: 'product_id',
  as: 'product'
});

Product.hasMany(OrderItem, {
  foreignKey: 'product_id',
  as: 'orderItems'
});

export { User, Order, OrderItem, Product };
```

### BelongsToMany (Many-to-Many)

```javascript
// src/models/Role.js
import { DataTypes, Model } from 'sequelize';
import sequelize from '../../config/database.js';

class Role extends Model {}

Role.init({
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  
  name: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: true
  },
  
  description: {
    type: DataTypes.TEXT,
    allowNull: true
  }
}, {
  sequelize,
  modelName: 'Role',
  tableName: 'roles',
  timestamps: true,
  underscored: true
});

// src/models/UserRole.js (table de jonction)
class UserRole extends Model {}

UserRole.init({
  user_id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    references: {
      model: 'users',
      key: 'id'
    }
  },
  
  role_id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    references: {
      model: 'roles',
      key: 'id'
    }
  },
  
  assigned_at: {
    type: DataTypes.DATE,
    defaultValue: DataTypes.NOW
  }
}, {
  sequelize,
  modelName: 'UserRole',
  tableName: 'user_roles',
  timestamps: false,
  underscored: true
});

// Associations Many-to-Many
import User from './User.js';

User.belongsToMany(Role, {
  through: UserRole,
  foreignKey: 'user_id',
  otherKey: 'role_id',
  as: 'roles'
});

Role.belongsToMany(User, {
  through: UserRole,
  foreignKey: 'role_id',
  otherKey: 'user_id',
  as: 'users'
});

export { Role, UserRole };
```

---

## Requ√™tes et CRUD

### Op√©rations de base

```javascript
// src/repositories/UserRepository.js
import { Op } from 'sequelize';
import { User, Order } from '../models/index.js';

class UserRepository {
  
  // CREATE
  async create(userData) {
    return User.create(userData);
  }
  
  // READ - Par ID
  async findById(id) {
    return User.findByPk(id);
  }
  
  // READ - Par email
  async findByEmail(email) {
    return User.findOne({
      where: { email }
    });
  }
  
  // READ - Liste avec pagination
  async findAll({ page = 1, limit = 20, isActive = true } = {}) {
    const offset = (page - 1) * limit;
    
    const { count, rows } = await User.findAndCountAll({
      where: { is_active: isActive },
      limit,
      offset,
      order: [['created_at', 'DESC']],
      attributes: { exclude: ['password_hash'] }
    });
    
    return {
      users: rows,
      total: count,
      page,
      pages: Math.ceil(count / limit)
    };
  }
  
  // READ - Recherche
  async search(term, limit = 20) {
    return User.findAll({
      where: {
        is_active: true,
        [Op.or]: [
          { username: { [Op.like]: `%${term}%` } },
          { email: { [Op.like]: `%${term}%` } }
        ]
      },
      limit,
      order: [['username', 'ASC']],
      attributes: { exclude: ['password_hash'] }
    });
  }
  
  // UPDATE
  async update(id, updates) {
    const user = await User.findByPk(id);
    if (!user) {
      throw new Error('User not found');
    }
    
    return user.update(updates);
  }
  
  // DELETE (soft delete)
  async delete(id) {
    const user = await User.findByPk(id);
    if (!user) {
      throw new Error('User not found');
    }
    
    return user.update({ is_active: false });
  }
  
  // DELETE (hard delete)
  async destroy(id) {
    const user = await User.findByPk(id);
    if (!user) {
      throw new Error('User not found');
    }
    
    return user.destroy();
  }
  
  // COUNT
  async count(isActive = true) {
    return User.count({
      where: { is_active: isActive }
    });
  }
}

export default new UserRepository();
```

### Requ√™tes avanc√©es

```javascript
class UserRepository {
  
  // Eager loading avec includes
  async findByIdWithOrders(id) {
    return User.findByPk(id, {
      include: [
        {
          model: Order,
          as: 'orders',
          attributes: ['id', 'total_amount', 'status', 'created_at'],
          order: [['created_at', 'DESC']],
          limit: 10
        }
      ],
      attributes: { exclude: ['password_hash'] }
    });
  }
  
  // Nested includes
  async findByIdWithOrdersAndItems(id) {
    return User.findByPk(id, {
      include: [
        {
          model: Order,
          as: 'orders',
          include: [
            {
              model: OrderItem,
              as: 'items',
              include: [
                {
                  model: Product,
                  as: 'product',
                  attributes: ['id', 'name', 'price']
                }
              ]
            }
          ]
        }
      ]
    });
  }
  
  // Recherche avanc√©e avec op√©rateurs
  async advancedSearch({
    username,
    email,
    isActive,
    createdAfter,
    createdBefore
  }) {
    const where = {};
    
    if (username) {
      where.username = { [Op.like]: `%${username}%` };
    }
    
    if (email) {
      where.email = { [Op.like]: `%${email}%` };
    }
    
    if (isActive !== undefined) {
      where.is_active = isActive;
    }
    
    if (createdAfter || createdBefore) {
      where.created_at = {};
      if (createdAfter) {
        where.created_at[Op.gte] = createdAfter;
      }
      if (createdBefore) {
        where.created_at[Op.lte] = createdBefore;
      }
    }
    
    return User.findAll({
      where,
      order: [['created_at', 'DESC']],
      attributes: { exclude: ['password_hash'] }
    });
  }
  
  // Agr√©gations
  async getUserStats() {
    return User.findAll({
      attributes: [
        'id',
        'username',
        [sequelize.fn('COUNT', sequelize.col('orders.id')), 'order_count'],
        [sequelize.fn('COALESCE', 
          sequelize.fn('SUM', sequelize.col('orders.total_amount')), 
          0
        ), 'total_spent']
      ],
      include: [
        {
          model: Order,
          as: 'orders',
          attributes: [],
          required: false
        }
      ],
      group: ['User.id', 'User.username'],
      having: sequelize.literal('COUNT(orders.id) > 0'),
      order: [[sequelize.literal('total_spent'), 'DESC']],
      limit: 10,
      raw: true
    });
  }
  
  // Bulk operations
  async bulkUpdateStatus(userIds, isActive) {
    return User.update(
      { is_active: isActive },
      {
        where: {
          id: { [Op.in]: userIds }
        }
      }
    );
  }
  
  async bulkCreate(usersData) {
    return User.bulkCreate(usersData, {
      validate: true,
      individualHooks: true  // Trigger hooks pour chaque ligne
    });
  }
}
```

### Transactions

```javascript
// src/repositories/OrderRepository.js
import sequelize from '../../config/database.js';
import { Order, OrderItem, Product } from '../models/index.js';

class OrderRepository {
  
  async createOrderWithItems(userId, items) {
    // Transaction managed
    const transaction = await sequelize.transaction();
    
    try {
      // 1. Cr√©er la commande
      const order = await Order.create(
        {
          user_id: userId,
          status: 'pending',
          total_amount: 0
        },
        { transaction }
      );
      
      let totalAmount = 0;
      
      // 2. Traiter chaque item
      for (const item of items) {
        // R√©cup√©rer le produit avec lock
        const product = await Product.findByPk(item.product_id, {
          lock: transaction.LOCK.UPDATE,
          transaction
        });
        
        if (!product) {
          throw new Error(`Product ${item.product_id} not found`);
        }
        
        if (product.stock < item.quantity) {
          throw new Error(`Insufficient stock for product ${product.id}`);
        }
        
        // Cr√©er l'item
        await OrderItem.create(
          {
            order_id: order.id,
            product_id: product.id,
            quantity: item.quantity,
            price: product.price
          },
          { transaction }
        );
        
        // D√©cr√©menter le stock
        await product.decrement('stock', {
          by: item.quantity,
          transaction
        });
        
        totalAmount += parseFloat(product.price) * item.quantity;
      }
      
      // 3. Mettre √† jour le total
      await order.update(
        { total_amount: totalAmount },
        { transaction }
      );
      
      // 4. Commit
      await transaction.commit();
      
      // Recharger avec includes
      return Order.findByPk(order.id, {
        include: [
          {
            model: OrderItem,
            as: 'items',
            include: [{ model: Product, as: 'product' }]
          }
        ]
      });
      
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  }
  
  // Transaction automatique avec callback
  async cancelOrder(orderId) {
    return sequelize.transaction(async (t) => {
      // R√©cup√©rer la commande
      const order = await Order.findByPk(orderId, {
        include: [{ model: OrderItem, as: 'items' }],
        transaction: t
      });
      
      if (!order) {
        throw new Error('Order not found');
      }
      
      if (order.status === 'cancelled') {
        throw new Error('Order already cancelled');
      }
      
      // Remettre le stock pour chaque item
      for (const item of order.items) {
        await Product.increment('stock', {
          by: item.quantity,
          where: { id: item.product_id },
          transaction: t
        });
      }
      
      // Mettre √† jour le statut
      await order.update(
        { status: 'cancelled' },
        { transaction: t }
      );
      
      return order;
    });
  }
}

export default new OrderRepository();
```

---

## Hooks et Validations

### Hooks (Lifecycle events)

```javascript
// src/models/User.js
import bcrypt from 'bcrypt';

User.addHook('beforeCreate', async (user) => {
  // Normaliser l'email
  if (user.email) {
    user.email = user.email.toLowerCase().trim();
  }
  
  // Hasher le mot de passe
  if (user.password) {
    const salt = await bcrypt.genSalt(12);
    user.password_hash = await bcrypt.hash(user.password, salt);
    delete user.password;
  }
});

User.addHook('beforeUpdate', async (user) => {
  // Si l'email change
  if (user.changed('email')) {
    user.email = user.email.toLowerCase().trim();
  }
  
  // Si le password change
  if (user.password) {
    const salt = await bcrypt.genSalt(12);
    user.password_hash = await bcrypt.hash(user.password, salt);
    delete user.password;
  }
});

User.addHook('afterCreate', async (user) => {
  console.log(`New user created: ${user.username}`);
  
  // Envoyer un email de bienvenue (async)
  // await sendWelcomeEmail(user.email);
});

User.addHook('afterUpdate', async (user) => {
  if (user.changed('email')) {
    console.log(`Email updated for user ${user.id}`);
    // await sendEmailChangeNotification(user.email);
  }
});

User.addHook('beforeDestroy', async (user) => {
  console.log(`User ${user.id} will be deleted`);
  // Cleanup: supprimer donn√©es associ√©es
});
```

### Validations

```javascript
// src/models/User.js
User.init({
  username: {
    type: DataTypes.STRING(50),
    allowNull: false,
    unique: true,
    validate: {
      // Validations int√©gr√©es
      len: {
        args: [3, 50],
        msg: 'Username must be between 3 and 50 characters'
      },
      isAlphanumeric: {
        msg: 'Username can only contain letters and numbers'
      },
      
      // Validation personnalis√©e
      async isUnique(value) {
        const user = await User.findOne({ where: { username: value } });
        if (user && user.id !== this.id) {
          throw new Error('Username already taken');
        }
      }
    }
  },
  
  email: {
    type: DataTypes.STRING(255),
    allowNull: false,
    unique: true,
    validate: {
      isEmail: {
        msg: 'Must be a valid email address'
      },
      
      // Validation avec fonction
      isValidDomain(value) {
        const allowedDomains = ['example.com', 'company.com'];
        const domain = value.split('@')[1];
        if (!allowedDomains.includes(domain)) {
          throw new Error(`Email must be from: ${allowedDomains.join(', ')}`);
        }
      }
    }
  },
  
  password: {
    type: DataTypes.VIRTUAL,  // N'existe pas en DB
    allowNull: false,
    validate: {
      len: {
        args: [12, 100],
        msg: 'Password must be at least 12 characters'
      },
      
      isStrongPassword(value) {
        const hasUpperCase = /[A-Z]/.test(value);
        const hasLowerCase = /[a-z]/.test(value);
        const hasNumber = /[0-9]/.test(value);
        const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(value);
        
        if (!hasUpperCase || !hasLowerCase || !hasNumber || !hasSpecial) {
          throw new Error(
            'Password must contain uppercase, lowercase, number and special character'
          );
        }
      }
    }
  }
}, {
  sequelize,
  
  // Validations au niveau du mod√®le
  validate: {
    bothNamesOrNone() {
      if ((this.first_name === null) !== (this.last_name === null)) {
        throw new Error('Provide both first name and last name, or neither');
      }
    }
  }
});
```

---

## Migrations et Seeders

### Cr√©er une migration

```bash
# G√©n√©rer une migration
npx sequelize-cli migration:generate --name create-users-table

# Appliquer les migrations
npx sequelize-cli db:migrate

# Annuler la derni√®re migration
npx sequelize-cli db:migrate:undo

# Annuler toutes les migrations
npx sequelize-cli db:migrate:undo:all
```

### Exemple de migration

```javascript
// src/migrations/20240115000001-create-users-table.js
export async function up(queryInterface, Sequelize) {
  await queryInterface.createTable('users', {
    id: {
      type: Sequelize.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    username: {
      type: Sequelize.STRING(50),
      allowNull: false,
      unique: true
    },
    email: {
      type: Sequelize.STRING(255),
      allowNull: false,
      unique: true
    },
    password_hash: {
      type: Sequelize.STRING(255),
      allowNull: false
    },
    first_name: {
      type: Sequelize.STRING(100),
      allowNull: true
    },
    last_name: {
      type: Sequelize.STRING(100),
      allowNull: true
    },
    is_active: {
      type: Sequelize.BOOLEAN,
      defaultValue: true,
      allowNull: false
    },
    is_admin: {
      type: Sequelize.BOOLEAN,
      defaultValue: false,
      allowNull: false
    },
    created_at: {
      type: Sequelize.DATE,
      allowNull: false,
      defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')
    },
    updated_at: {
      type: Sequelize.DATE,
      allowNull: true
    },
    last_login: {
      type: Sequelize.DATE,
      allowNull: true
    }
  }, {
    charset: 'utf8mb4',
    collate: 'utf8mb4_unicode_ci',
    engine: 'InnoDB'
  });
  
  // Ajouter les index
  await queryInterface.addIndex('users', ['email'], {
    unique: true,
    name: 'unique_email'
  });
  
  await queryInterface.addIndex('users', ['username'], {
    unique: true,
    name: 'unique_username'
  });
  
  await queryInterface.addIndex('users', ['is_active', 'created_at'], {
    name: 'idx_active_created'
  });
}

export async function down(queryInterface, Sequelize) {
  await queryInterface.dropTable('users');
}
```

### Seeders

```javascript
// src/seeders/20240115000001-demo-users.js
import bcrypt from 'bcrypt';

export async function up(queryInterface, Sequelize) {
  const salt = await bcrypt.genSalt(12);
  const hashedPassword = await bcrypt.hash('DemoPassword123!', salt);
  
  await queryInterface.bulkInsert('users', [
    {
      username: 'admin',
      email: 'admin@example.com',
      password_hash: hashedPassword,
      first_name: 'Admin',
      last_name: 'User',
      is_active: true,
      is_admin: true,
      created_at: new Date(),
      updated_at: new Date()
    },
    {
      username: 'john_doe',
      email: 'john@example.com',
      password_hash: hashedPassword,
      first_name: 'John',
      last_name: 'Doe',
      is_active: true,
      is_admin: false,
      created_at: new Date(),
      updated_at: new Date()
    }
  ]);
}

export async function down(queryInterface, Sequelize) {
  await queryInterface.bulkDelete('users', null, {});
}
```

---

## Optimisations de performance

### Probl√®me N+1

```javascript
// ‚ùå MAUVAIS : N+1 queries
const orders = await Order.findAll();

for (const order of orders) {
  console.log(order.user.username);  // 1 query par order !
}

// ‚úÖ BON : Eager loading avec include
const orders = await Order.findAll({
  include: [
    {
      model: User,
      as: 'user',
      attributes: ['id', 'username', 'email']
    }
  ]
});

for (const order of orders) {
  console.log(order.user.username);  // D√©j√† charg√©
}

// ‚úÖ BON : Nested includes
const users = await User.findAll({
  include: [
    {
      model: Order,
      as: 'orders',
      include: [
        {
          model: OrderItem,
          as: 'items',
          include: [
            {
              model: Product,
              as: 'product'
            }
          ]
        }
      ]
    }
  ]
});
```

### Attributs s√©lectifs

```javascript
// ‚ùå MAUVAIS : Charger toutes les colonnes
const users = await User.findAll();

// ‚úÖ BON : S√©lectionner uniquement les colonnes n√©cessaires
const users = await User.findAll({
  attributes: ['id', 'username', 'email']
});

// Exclure certaines colonnes
const users = await User.findAll({
  attributes: { exclude: ['password_hash', 'updated_at'] }
});

// Ajouter des fonctions d'agr√©gation
const users = await User.findAll({
  attributes: [
    'id',
    'username',
    [sequelize.fn('COUNT', sequelize.col('orders.id')), 'order_count']
  ],
  include: [
    {
      model: Order,
      as: 'orders',
      attributes: []
    }
  ],
  group: ['User.id']
});
```

### Indexes et requ√™tes optimis√©es

```javascript
// Utiliser les index existants
const users = await User.findAll({
  where: {
    is_active: true,  // Index composite idx_active_created
    created_at: {
      [Op.gte]: new Date('2024-01-01')
    }
  },
  order: [['created_at', 'DESC']]
});

// Limiter les r√©sultats
const recentUsers = await User.findAll({
  limit: 10,
  order: [['created_at', 'DESC']]
});

// Pagination efficace
async function getUsersPaginated(page = 1, limit = 20) {
  const offset = (page - 1) * limit;
  
  return User.findAndCountAll({
    limit,
    offset,
    order: [['created_at', 'DESC']],
    distinct: true  // Pour COUNT correct avec includes
  });
}
```

---

## Int√©gration avec Express.js

### Configuration Express

```javascript
// src/app.js
import express from 'express';
import sequelize, { testConnection } from './config/database.js';
import userRoutes from './routes/userRoutes.js';
import orderRoutes from './routes/orderRoutes.js';

const app = express();

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Routes
app.use('/api/users', userRoutes);
app.use('/api/orders', orderRoutes);

// Health check
app.get('/health', async (req, res) => {
  try {
    await sequelize.authenticate();
    res.json({ status: 'ok', database: 'connected' });
  } catch (error) {
    res.status(500).json({ status: 'error', database: 'disconnected' });
  }
});

// Error handling
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    error: 'Internal Server Error',
    message: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});

// D√©marrage
const PORT = process.env.PORT || 3000;

async function start() {
  try {
    await testConnection();
    
    // Sync des mod√®les (d√©veloppement uniquement)
    if (process.env.NODE_ENV === 'development') {
      await sequelize.sync({ alter: true });
    }
    
    app.listen(PORT, () => {
      console.log(`‚úì Server running on port ${PORT}`);
    });
  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
}

start();

export default app;
```

### Routes et Controllers

```javascript
// src/routes/userRoutes.js
import express from 'express';
import UserController from '../controllers/UserController.js';

const router = express.Router();

router.get('/', UserController.list);
router.get('/:id', UserController.getById);
router.post('/', UserController.create);
router.put('/:id', UserController.update);
router.delete('/:id', UserController.delete);
router.get('/search/:term', UserController.search);

export default router;

// src/controllers/UserController.js
import UserRepository from '../repositories/UserRepository.js';

class UserController {
  
  async list(req, res) {
    try {
      const { page = 1, limit = 20, isActive = 'true' } = req.query;
      
      const result = await UserRepository.findAll({
        page: parseInt(page),
        limit: parseInt(limit),
        isActive: isActive === 'true'
      });
      
      res.json(result);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
  
  async getById(req, res) {
    try {
      const user = await UserRepository.findById(req.params.id);
      
      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      res.json(user);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
  
  async create(req, res) {
    try {
      const user = await UserRepository.create(req.body);
      res.status(201).json(user);
    } catch (error) {
      if (error.name === 'SequelizeValidationError') {
        return res.status(400).json({
          error: 'Validation failed',
          details: error.errors.map(e => ({
            field: e.path,
            message: e.message
          }))
        });
      }
      
      if (error.name === 'SequelizeUniqueConstraintError') {
        return res.status(409).json({
          error: 'Duplicate entry',
          details: error.errors.map(e => e.message)
        });
      }
      
      res.status(500).json({ error: error.message });
    }
  }
  
  async update(req, res) {
    try {
      const user = await UserRepository.update(req.params.id, req.body);
      res.json(user);
    } catch (error) {
      if (error.message === 'User not found') {
        return res.status(404).json({ error: error.message });
      }
      res.status(500).json({ error: error.message });
    }
  }
  
  async delete(req, res) {
    try {
      await UserRepository.delete(req.params.id);
      res.status(204).send();
    } catch (error) {
      if (error.message === 'User not found') {
        return res.status(404).json({ error: error.message });
      }
      res.status(500).json({ error: error.message });
    }
  }
  
  async search(req, res) {
    try {
      const users = await UserRepository.search(req.params.term);
      res.json(users);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
}

export default new UserController();
```

---

## ‚úÖ Points cl√©s √† retenir

1. **mysql2** : Driver recommand√© (plus performant que mariadb)
2. **Pool de connexions** : Configur√© automatiquement via options `pool`
3. **Associations** : hasMany, belongsTo, belongsToMany avec `as` aliases
4. **Eager loading** : Toujours utiliser `include` pour √©viter N+1
5. **Transactions** : Managed ou unmanaged selon le besoin
6. **Hooks** : Lifecycle events pour logique m√©tier automatique
7. **Validations** : Int√©gr√©es (isEmail, len) et personnalis√©es
8. **Migrations** : Versionnement du sch√©ma avec sequelize-cli
9. **Attributs** : S√©lectionner uniquement les colonnes n√©cessaires
10. **TypeScript** : Support natif pour type-safety

---

## üîó Ressources

### Documentation officielle
- [üìñ Sequelize v6](https://sequelize.org/docs/v6/)
- [üìñ Sequelize CLI](https://github.com/sequelize/cli)
- [üìñ mysql2](https://github.com/sidorares/node-mysql2)

### Guides
- [Sequelize Associations](https://sequelize.org/docs/v6/core-concepts/assocs/)
- [Query Interface](https://sequelize.org/docs/v6/other-topics/query-interface/)

---

## ‚û°Ô∏è Section suivante

**17.3.4 Prisma (Node.js)** : ORM moderne type-safe avec schema-first approach, migrations automatiques, et excellent support TypeScript pour MariaDB.

‚è≠Ô∏è [Prisma](/17-integration-developpement/03.4-prisma.md)
