ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 17.3.1 Hibernate (Java)

> **Niveau** : IntermÃ©diaire Ã  AvancÃ©  
> **DurÃ©e estimÃ©e** : 4-5 heures  
> **PrÃ©requis** : Java 11+, bases JPA, Maven/Gradle, JDBC

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Configurer Hibernate 6.x avec MariaDB
- MaÃ®triser le mapping JPA et les annotations avancÃ©es
- GÃ©rer les relations complexes (OneToMany, ManyToMany, inheritance)
- Optimiser les performances (N+1, lazy loading, caching)
- Utiliser JPQL et Criteria API efficacement
- ImplÃ©menter le pattern Repository avec Spring Data JPA
- GÃ©rer les transactions et le versioning optimiste
- RÃ©soudre les problÃ¨mes courants Hibernate-MariaDB

---

## Introduction Ã  Hibernate

### Qu'est-ce que Hibernate ?

**Hibernate** est l'ORM (Object-Relational Mapping) le plus populaire de l'Ã©cosystÃ¨me Java. Il implÃ©mente la spÃ©cification **JPA (Jakarta Persistence API)** et ajoute de nombreuses fonctionnalitÃ©s propriÃ©taires.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Architecture Hibernate               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Application Java               â”‚
â”‚  (Domain Model - POJOs)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     JPA / Hibernate API            â”‚
â”‚  â€¢ EntityManager                   â”‚
â”‚  â€¢ Session                         â”‚
â”‚  â€¢ Criteria API                    â”‚
â”‚  â€¢ JPQL                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Hibernate Core                 â”‚
â”‚  â€¢ Object mapping                  â”‚
â”‚  â€¢ Session management              â”‚
â”‚  â€¢ Transaction management          â”‚
â”‚  â€¢ 1st/2nd level cache             â”‚
â”‚  â€¢ Query optimization              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     JDBC Driver                    â”‚
â”‚  (MariaDB Connector/J)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        MariaDB Server              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### JPA vs Hibernate

| Aspect | JPA | Hibernate |
|--------|-----|-----------|
| **Type** | SpÃ©cification (API) | ImplÃ©mentation |
| **Standard** | Jakarta EE | PropriÃ©taire (avec extensions) |
| **PortabilitÃ©** | Multi-providers | SpÃ©cifique Hibernate |
| **FonctionnalitÃ©s** | Core features | Extended features |
| **Annotations** | `@Entity`, `@Table` | `@Formula`, `@NaturalId` |

ğŸ’¡ **Conseil** : Utilisez les annotations **JPA standard** autant que possible pour la portabilitÃ©, et les extensions Hibernate seulement quand nÃ©cessaire.

---

## Configuration Maven/Gradle

### pom.xml (Maven)

```xml
<project>
    <properties>
        <java.version>17</java.version>
        <hibernate.version>6.4.1.Final</hibernate.version>
        <mariadb.version>3.3.2</mariadb.version>
    </properties>

    <dependencies>
        <!-- Hibernate Core -->
        <dependency>
            <groupId>org.hibernate.orm</groupId>
            <artifactId>hibernate-core</artifactId>
            <version>${hibernate.version}</version>
        </dependency>

        <!-- MariaDB Connector/J -->
        <dependency>
            <groupId>org.mariadb.jdbc</groupId>
            <artifactId>mariadb-java-client</artifactId>
            <version>${mariadb.version}</version>
        </dependency>

        <!-- HikariCP (Connection Pool) -->
        <dependency>
            <groupId>com.zaxxer</groupId>
            <artifactId>HikariCP</artifactId>
            <version>5.1.0</version>
        </dependency>

        <!-- Jakarta Persistence API -->
        <dependency>
            <groupId>jakarta.persistence</groupId>
            <artifactId>jakarta.persistence-api</artifactId>
            <version>3.1.0</version>
        </dependency>

        <!-- Bean Validation -->
        <dependency>
            <groupId>jakarta.validation</groupId>
            <artifactId>jakarta.validation-api</artifactId>
            <version>3.0.2</version>
        </dependency>
        
        <dependency>
            <groupId>org.hibernate.validator</groupId>
            <artifactId>hibernate-validator</artifactId>
            <version>8.0.1.Final</version>
        </dependency>

        <!-- Logging (SLF4J + Logback) -->
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.4.14</version>
        </dependency>
    </dependencies>
</project>
```

### build.gradle (Gradle)

```gradle
plugins {
    id 'java'
}

java {
    sourceCompatibility = '17'
    targetCompatibility = '17'
}

dependencies {
    // Hibernate
    implementation 'org.hibernate.orm:hibernate-core:6.4.1.Final'
    
    // MariaDB
    implementation 'org.mariadb.jdbc:mariadb-java-client:3.3.2'
    
    // Connection Pool
    implementation 'com.zaxxer:HikariCP:5.1.0'
    
    // JPA
    implementation 'jakarta.persistence:jakarta.persistence-api:3.1.0'
    
    // Validation
    implementation 'jakarta.validation:jakarta.validation-api:3.0.2'
    implementation 'org.hibernate.validator:hibernate-validator:8.0.1.Final'
    
    // Logging
    implementation 'ch.qos.logback:logback-classic:1.4.14'
}
```

---

## Configuration Hibernate

### persistence.xml (JPA standard)

```xml
<!-- src/main/resources/META-INF/persistence.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="https://jakarta.ee/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="https://jakarta.ee/xml/ns/persistence
             https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd"
             version="3.0">

    <persistence-unit name="MariaDB-PU" transaction-type="RESOURCE_LOCAL">
        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
        
        <!-- Classes d'entitÃ©s (optionnel si auto-scan) -->
        <class>com.example.model.User</class>
        <class>com.example.model.Order</class>
        <class>com.example.model.OrderItem</class>
        <class>com.example.model.Product</class>
        
        <exclude-unlisted-classes>false</exclude-unlisted-classes>
        
        <properties>
            <!-- Database connection -->
            <property name="jakarta.persistence.jdbc.driver" 
                      value="org.mariadb.jdbc.Driver"/>
            <property name="jakarta.persistence.jdbc.url" 
                      value="jdbc:mariadb://localhost:3306/production_db?useSSL=false&amp;serverTimezone=UTC"/>
            <property name="jakarta.persistence.jdbc.user" 
                      value="app_user"/>
            <property name="jakarta.persistence.jdbc.password" 
                      value="SecureP@ssw0rd!"/>

            <!-- Hibernate settings -->
            <property name="hibernate.dialect" 
                      value="org.hibernate.dialect.MariaDBDialect"/>
            
            <!-- SQL logging -->
            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.format_sql" value="true"/>
            <property name="hibernate.use_sql_comments" value="true"/>
            
            <!-- Schema management -->
            <property name="hibernate.hbm2ddl.auto" value="validate"/>
            
            <!-- Performance -->
            <property name="hibernate.jdbc.batch_size" value="20"/>
            <property name="hibernate.order_inserts" value="true"/>
            <property name="hibernate.order_updates" value="true"/>
            <property name="hibernate.jdbc.batch_versioned_data" value="true"/>
            
            <!-- Statistics -->
            <property name="hibernate.generate_statistics" value="true"/>
            
            <!-- Connection pool (HikariCP) -->
            <property name="hibernate.hikari.minimumIdle" value="5"/>
            <property name="hibernate.hikari.maximumPoolSize" value="20"/>
            <property name="hibernate.hikari.connectionTimeout" value="30000"/>
            <property name="hibernate.hikari.idleTimeout" value="600000"/>
            <property name="hibernate.hikari.maxLifetime" value="1800000"/>
            
            <!-- 2nd level cache (optionnel) -->
            <property name="hibernate.cache.use_second_level_cache" value="true"/>
            <property name="hibernate.cache.region.factory_class" 
                      value="org.hibernate.cache.jcache.JCacheRegionFactory"/>
        </properties>
    </persistence-unit>
</persistence>
```

### Configuration programmatique (alternative)

```java
// HibernateUtil.java
package com.example.util;

import org.hibernate.SessionFactory;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;

public class HibernateUtil {
    
    private static SessionFactory sessionFactory;
    
    static {
        try {
            // Configuration programmatique
            Configuration configuration = new Configuration();
            
            // Database connection
            configuration.setProperty("hibernate.connection.driver_class", 
                "org.mariadb.jdbc.Driver");
            configuration.setProperty("hibernate.connection.url", 
                "jdbc:mariadb://localhost:3306/production_db");
            configuration.setProperty("hibernate.connection.username", "app_user");
            configuration.setProperty("hibernate.connection.password", "SecureP@ssw0rd!");
            
            // Hibernate settings
            configuration.setProperty("hibernate.dialect", 
                "org.hibernate.dialect.MariaDBDialect");
            configuration.setProperty("hibernate.show_sql", "true");
            configuration.setProperty("hibernate.format_sql", "true");
            
            // Connection pool (HikariCP)
            configuration.setProperty("hibernate.connection.provider_class",
                "org.hibernate.hikaricp.internal.HikariCPConnectionProvider");
            configuration.setProperty("hibernate.hikari.minimumIdle", "5");
            configuration.setProperty("hibernate.hikari.maximumPoolSize", "20");
            
            // Performance
            configuration.setProperty("hibernate.jdbc.batch_size", "20");
            configuration.setProperty("hibernate.order_inserts", "true");
            configuration.setProperty("hibernate.order_updates", "true");
            
            // Ajouter les classes annotÃ©es
            configuration.addAnnotatedClass(com.example.model.User.class);
            configuration.addAnnotatedClass(com.example.model.Order.class);
            
            // Build SessionFactory
            StandardServiceRegistry serviceRegistry = 
                new StandardServiceRegistryBuilder()
                    .applySettings(configuration.getProperties())
                    .build();
            
            sessionFactory = configuration.buildSessionFactory(serviceRegistry);
            
        } catch (Exception e) {
            throw new ExceptionInInitializerError(e);
        }
    }
    
    public static SessionFactory getSessionFactory() {
        return sessionFactory;
    }
    
    public static void shutdown() {
        if (sessionFactory != null) {
            sessionFactory.close();
        }
    }
}
```

---

## Mapping des entitÃ©s

### EntitÃ© de base

```java
package com.example.model;

import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.Objects;

@Entity
@Table(
    name = "users",
    indexes = {
        @Index(name = "idx_email", columnList = "email", unique = true),
        @Index(name = "idx_username", columnList = "username", unique = true),
        @Index(name = "idx_active_created", columnList = "is_active, created_at")
    }
)
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;
    
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    @Column(name = "username", nullable = false, unique = true, length = 50)
    private String username;
    
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    @Column(name = "email", nullable = false, unique = true, length = 255)
    private String email;
    
    @NotBlank(message = "Password is required")
    @Column(name = "password_hash", nullable = false, length = 255)
    private String passwordHash;
    
    @Column(name = "first_name", length = 100)
    private String firstName;
    
    @Column(name = "last_name", length = 100)
    private String lastName;
    
    @Column(name = "is_active", nullable = false, columnDefinition = "BOOLEAN DEFAULT true")
    private Boolean isActive = true;
    
    @Column(name = "is_admin", nullable = false, columnDefinition = "BOOLEAN DEFAULT false")
    private Boolean isAdmin = false;
    
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @Column(name = "last_login")
    private LocalDateTime lastLogin;
    
    // Constructeurs
    public User() {}
    
    public User(String username, String email, String passwordHash) {
        this.username = username;
        this.email = email;
        this.passwordHash = passwordHash;
    }
    
    // Getters et Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public String getPasswordHash() { return passwordHash; }
    public void setPasswordHash(String passwordHash) { this.passwordHash = passwordHash; }
    
    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }
    
    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
    
    public Boolean getIsActive() { return isActive; }
    public void setIsActive(Boolean active) { isActive = active; }
    
    public Boolean getIsAdmin() { return isAdmin; }
    public void setIsAdmin(Boolean admin) { isAdmin = admin; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
    
    public LocalDateTime getLastLogin() { return lastLogin; }
    public void setLastLogin(LocalDateTime lastLogin) { this.lastLogin = lastLogin; }
    
    // equals et hashCode (important pour les collections)
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return Objects.equals(id, user.id);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
    
    // toString pour debugging
    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", email='" + email + '\'' +
                ", isActive=" + isActive +
                '}';
    }
}
```

### Types de donnÃ©es MariaDB

```java
@Entity
@Table(name = "data_types_example")
public class DataTypesExample {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // Texte
    @Column(columnDefinition = "VARCHAR(50)")
    private String shortText;
    
    @Column(columnDefinition = "TEXT")
    private String longText;
    
    @Lob  // Large Object (TEXT, BLOB)
    @Column(columnDefinition = "MEDIUMTEXT")
    private String mediumText;
    
    // Nombres
    @Column(columnDefinition = "TINYINT")
    private Byte tinyInt;
    
    @Column(columnDefinition = "SMALLINT")
    private Short smallInt;
    
    @Column(columnDefinition = "INT")
    private Integer intValue;
    
    @Column(columnDefinition = "BIGINT")
    private Long bigInt;
    
    // DÃ©cimaux
    @Column(columnDefinition = "DECIMAL(10,2)")
    private java.math.BigDecimal price;
    
    @Column(columnDefinition = "FLOAT")
    private Float floatValue;
    
    @Column(columnDefinition = "DOUBLE")
    private Double doubleValue;
    
    // Dates et temps
    @Column(columnDefinition = "DATE")
    private java.time.LocalDate dateOnly;
    
    @Column(columnDefinition = "TIME")
    private java.time.LocalTime timeOnly;
    
    @Column(columnDefinition = "DATETIME")
    private java.time.LocalDateTime dateTime;
    
    @Column(columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    private java.time.LocalDateTime timestamp;
    
    // Boolean (MariaDB TINYINT(1))
    @Column(columnDefinition = "BOOLEAN")
    private Boolean flag;
    
    // JSON (MariaDB 10.2+)
    @Column(columnDefinition = "JSON")
    private String jsonData;
    
    // Enum
    @Enumerated(EnumType.STRING)
    @Column(columnDefinition = "ENUM('PENDING', 'CONFIRMED', 'CANCELLED')")
    private OrderStatus status;
    
    // UUID
    @Column(columnDefinition = "BINARY(16)")
    private java.util.UUID uuid;
    
    // Getters/Setters...
}

enum OrderStatus {
    PENDING, CONFIRMED, CANCELLED
}
```

---

## Relations entre entitÃ©s

### OneToMany / ManyToOne

```java
// Order.java
@Entity
@Table(name = "orders")
public class Order {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // Many orders -> One user (cÃ´tÃ© Many)
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false, 
                foreignKey = @ForeignKey(name = "fk_order_user"))
    private User user;
    
    // One order -> Many items (cÃ´tÃ© One)
    @OneToMany(
        mappedBy = "order",           // Champ dans OrderItem
        cascade = CascadeType.ALL,    // Propager toutes les opÃ©rations
        orphanRemoval = true,         // Supprimer les items orphelins
        fetch = FetchType.LAZY        // Lazy par dÃ©faut pour OneToMany
    )
    private List<OrderItem> items = new ArrayList<>();
    
    @Column(name = "total_amount", nullable = false, 
            columnDefinition = "DECIMAL(10,2)")
    private BigDecimal totalAmount = BigDecimal.ZERO;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private OrderStatus status = OrderStatus.PENDING;
    
    @CreationTimestamp
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // Helper methods pour gÃ©rer la relation bidirectionnelle
    public void addItem(OrderItem item) {
        items.add(item);
        item.setOrder(this);
        recalculateTotal();
    }
    
    public void removeItem(OrderItem item) {
        items.remove(item);
        item.setOrder(null);
        recalculateTotal();
    }
    
    private void recalculateTotal() {
        totalAmount = items.stream()
            .map(OrderItem::getSubtotal)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
    
    // Getters/Setters...
}

// OrderItem.java
@Entity
@Table(name = "order_items")
public class OrderItem {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // Many items -> One order
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false,
                foreignKey = @ForeignKey(name = "fk_item_order"))
    private Order order;
    
    // Many items -> One product
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false,
                foreignKey = @ForeignKey(name = "fk_item_product"))
    private Product product;
    
    @Column(name = "quantity", nullable = false)
    private Integer quantity;
    
    @Column(name = "price", nullable = false, columnDefinition = "DECIMAL(10,2)")
    private BigDecimal price;
    
    // Calculated field (not stored)
    @Transient
    public BigDecimal getSubtotal() {
        return price.multiply(BigDecimal.valueOf(quantity));
    }
    
    // Getters/Setters...
}
```

### ManyToMany

```java
// User.java - partie relation
@Entity
@Table(name = "users")
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // Many users <-> Many roles
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "user_roles",                      // Table de jointure
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id"),
        uniqueConstraints = @UniqueConstraint(
            name = "uk_user_role",
            columnNames = {"user_id", "role_id"}
        )
    )
    private Set<Role> roles = new HashSet<>();
    
    // Helper methods
    public void addRole(Role role) {
        roles.add(role);
        role.getUsers().add(this);
    }
    
    public void removeRole(Role role) {
        roles.remove(role);
        role.getUsers().remove(this);
    }
    
    // Getters/Setters...
}

// Role.java
@Entity
@Table(name = "roles")
public class Role {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, unique = true, length = 50)
    private String name;
    
    @Column(name = "description")
    private String description;
    
    // CÃ´tÃ© inverse de la relation (mappedBy)
    @ManyToMany(mappedBy = "roles", fetch = FetchType.LAZY)
    private Set<User> users = new HashSet<>();
    
    // Getters/Setters...
}
```

### ManyToMany avec attributs supplÃ©mentaires

```java
// Enrollment.java - Table de jointure avec attributs
@Entity
@Table(name = "enrollments")
public class Enrollment {
    
    @EmbeddedId
    private EnrollmentId id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("studentId")  // LiÃ© Ã  EnrollmentId.studentId
    @JoinColumn(name = "student_id")
    private Student student;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("courseId")   // LiÃ© Ã  EnrollmentId.courseId
    @JoinColumn(name = "course_id")
    private Course course;
    
    @Column(name = "enrolled_at", nullable = false)
    private LocalDateTime enrolledAt;
    
    @Column(name = "grade")
    private Double grade;
    
    @Column(name = "completed", columnDefinition = "BOOLEAN DEFAULT false")
    private Boolean completed = false;
    
    // Constructeurs, Getters/Setters...
}

// EnrollmentId.java - ClÃ© composite
@Embeddable
public class EnrollmentId implements Serializable {
    
    @Column(name = "student_id")
    private Long studentId;
    
    @Column(name = "course_id")
    private Long courseId;
    
    // Constructeurs
    public EnrollmentId() {}
    
    public EnrollmentId(Long studentId, Long courseId) {
        this.studentId = studentId;
        this.courseId = courseId;
    }
    
    // equals et hashCode obligatoires
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EnrollmentId that = (EnrollmentId) o;
        return Objects.equals(studentId, that.studentId) &&
               Objects.equals(courseId, that.courseId);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(studentId, courseId);
    }
    
    // Getters/Setters...
}
```

---

## RequÃªtes avec JPQL

### JPQL de base

```java
// UserRepository.java
package com.example.repository;

import jakarta.persistence.*;
import com.example.model.User;
import java.util.List;
import java.util.Optional;

public class UserRepository {
    
    private final EntityManagerFactory emf;
    
    public UserRepository(EntityManagerFactory emf) {
        this.emf = emf;
    }
    
    /**
     * Trouver un utilisateur par ID
     */
    public Optional<User> findById(Long id) {
        EntityManager em = emf.createEntityManager();
        try {
            User user = em.find(User.class, id);
            return Optional.ofNullable(user);
        } finally {
            em.close();
        }
    }
    
    /**
     * Trouver par email
     */
    public Optional<User> findByEmail(String email) {
        EntityManager em = emf.createEntityManager();
        try {
            TypedQuery<User> query = em.createQuery(
                "SELECT u FROM User u WHERE u.email = :email", 
                User.class
            );
            query.setParameter("email", email);
            
            try {
                return Optional.of(query.getSingleResult());
            } catch (NoResultException e) {
                return Optional.empty();
            }
        } finally {
            em.close();
        }
    }
    
    /**
     * Liste avec pagination
     */
    public List<User> findAll(int page, int pageSize) {
        EntityManager em = emf.createEntityManager();
        try {
            return em.createQuery(
                "SELECT u FROM User u WHERE u.isActive = true ORDER BY u.createdAt DESC",
                User.class
            )
            .setFirstResult((page - 1) * pageSize)
            .setMaxResults(pageSize)
            .getResultList();
        } finally {
            em.close();
        }
    }
    
    /**
     * Recherche par terme
     */
    public List<User> search(String term, int limit) {
        EntityManager em = emf.createEntityManager();
        try {
            return em.createQuery(
                "SELECT u FROM User u " +
                "WHERE u.isActive = true " +
                "  AND (LOWER(u.username) LIKE LOWER(:term) " +
                "       OR LOWER(u.email) LIKE LOWER(:term)) " +
                "ORDER BY u.username",
                User.class
            )
            .setParameter("term", "%" + term + "%")
            .setMaxResults(limit)
            .getResultList();
        } finally {
            em.close();
        }
    }
    
    /**
     * Compter les utilisateurs actifs
     */
    public long countActive() {
        EntityManager em = emf.createEntityManager();
        try {
            return em.createQuery(
                "SELECT COUNT(u) FROM User u WHERE u.isActive = true",
                Long.class
            )
            .getSingleResult();
        } finally {
            em.close();
        }
    }
    
    /**
     * CrÃ©er un utilisateur
     */
    public User save(User user) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        
        try {
            tx.begin();
            
            if (user.getId() == null) {
                em.persist(user);
            } else {
                user = em.merge(user);
            }
            
            tx.commit();
            return user;
        } catch (Exception e) {
            if (tx.isActive()) {
                tx.rollback();
            }
            throw e;
        } finally {
            em.close();
        }
    }
    
    /**
     * Supprimer (soft delete)
     */
    public void delete(Long id) {
        EntityManager em = emf.createEntityManager();
        EntityTransaction tx = em.getTransaction();
        
        try {
            tx.begin();
            
            em.createQuery(
                "UPDATE User u SET u.isActive = false, u.updatedAt = CURRENT_TIMESTAMP " +
                "WHERE u.id = :id"
            )
            .setParameter("id", id)
            .executeUpdate();
            
            tx.commit();
        } catch (Exception e) {
            if (tx.isActive()) {
                tx.rollback();
            }
            throw e;
        } finally {
            em.close();
        }
    }
}
```

### RequÃªtes avec JOIN

```java
/**
 * Charger un utilisateur avec ses commandes (JOIN FETCH)
 */
public Optional<User> findByIdWithOrders(Long id) {
    EntityManager em = emf.createEntityManager();
    try {
        TypedQuery<User> query = em.createQuery(
            "SELECT u FROM User u " +
            "LEFT JOIN FETCH u.orders o " +
            "WHERE u.id = :id",
            User.class
        );
        query.setParameter("id", id);
        
        try {
            return Optional.of(query.getSingleResult());
        } catch (NoResultException e) {
            return Optional.empty();
        }
    } finally {
        em.close();
    }
}

/**
 * RequÃªte avec plusieurs JOINs
 */
public List<Order> findOrdersWithDetails(Long userId) {
    EntityManager em = emf.createEntityManager();
    try {
        return em.createQuery(
            "SELECT DISTINCT o FROM Order o " +
            "JOIN FETCH o.user u " +
            "JOIN FETCH o.items i " +
            "JOIN FETCH i.product p " +
            "WHERE u.id = :userId " +
            "ORDER BY o.createdAt DESC",
            Order.class
        )
        .setParameter("userId", userId)
        .setHint("hibernate.query.passDistinctThrough", false)
        .getResultList();
    } finally {
        em.close();
    }
}

/**
 * Projection avec DTO
 */
public List<UserStatsDTO> getUserStats() {
    EntityManager em = emf.createEntityManager();
    try {
        return em.createQuery(
            "SELECT new com.example.dto.UserStatsDTO(" +
            "  u.id, u.username, COUNT(o), SUM(o.totalAmount)" +
            ") " +
            "FROM User u " +
            "LEFT JOIN u.orders o " +
            "GROUP BY u.id, u.username " +
            "HAVING COUNT(o) > 0 " +
            "ORDER BY SUM(o.totalAmount) DESC",
            UserStatsDTO.class
        )
        .setMaxResults(10)
        .getResultList();
    } finally {
        em.close();
    }
}

// UserStatsDTO.java
public class UserStatsDTO {
    private Long userId;
    private String username;
    private Long orderCount;
    private BigDecimal totalSpent;
    
    public UserStatsDTO(Long userId, String username, 
                        Long orderCount, BigDecimal totalSpent) {
        this.userId = userId;
        this.username = username;
        this.orderCount = orderCount;
        this.totalSpent = totalSpent != null ? totalSpent : BigDecimal.ZERO;
    }
    
    // Getters...
}
```

---

## Criteria API

### RequÃªtes type-safe

```java
package com.example.repository;

import jakarta.persistence.*;
import jakarta.persistence.criteria.*;
import com.example.model.User;
import java.util.ArrayList;
import java.util.List;

public class UserCriteriaRepository {
    
    private final EntityManagerFactory emf;
    
    public UserCriteriaRepository(EntityManagerFactory emf) {
        this.emf = emf;
    }
    
    /**
     * Recherche dynamique avec Criteria API
     */
    public List<User> searchUsers(String username, String email, 
                                   Boolean isActive, int page, int pageSize) {
        EntityManager em = emf.createEntityManager();
        try {
            CriteriaBuilder cb = em.getCriteriaBuilder();
            CriteriaQuery<User> cq = cb.createQuery(User.class);
            Root<User> user = cq.from(User.class);
            
            // Construire les prÃ©dicats dynamiquement
            List<Predicate> predicates = new ArrayList<>();
            
            if (username != null && !username.isEmpty()) {
                predicates.add(
                    cb.like(cb.lower(user.get("username")), 
                           "%" + username.toLowerCase() + "%")
                );
            }
            
            if (email != null && !email.isEmpty()) {
                predicates.add(
                    cb.like(cb.lower(user.get("email")), 
                           "%" + email.toLowerCase() + "%")
                );
            }
            
            if (isActive != null) {
                predicates.add(cb.equal(user.get("isActive"), isActive));
            }
            
            // Combiner les prÃ©dicats avec AND
            if (!predicates.isEmpty()) {
                cq.where(cb.and(predicates.toArray(new Predicate[0])));
            }
            
            // Tri
            cq.orderBy(cb.desc(user.get("createdAt")));
            
            // ExÃ©cuter avec pagination
            TypedQuery<User> query = em.createQuery(cq);
            query.setFirstResult((page - 1) * pageSize);
            query.setMaxResults(pageSize);
            
            return query.getResultList();
        } finally {
            em.close();
        }
    }
    
    /**
     * Compter avec Criteria
     */
    public long count(String username, String email, Boolean isActive) {
        EntityManager em = emf.createEntityManager();
        try {
            CriteriaBuilder cb = em.getCriteriaBuilder();
            CriteriaQuery<Long> cq = cb.createQuery(Long.class);
            Root<User> user = cq.from(User.class);
            
            cq.select(cb.count(user));
            
            // MÃªme logique de filtres
            List<Predicate> predicates = new ArrayList<>();
            
            if (username != null && !username.isEmpty()) {
                predicates.add(cb.like(cb.lower(user.get("username")), 
                    "%" + username.toLowerCase() + "%"));
            }
            
            if (email != null && !email.isEmpty()) {
                predicates.add(cb.like(cb.lower(user.get("email")), 
                    "%" + email.toLowerCase() + "%"));
            }
            
            if (isActive != null) {
                predicates.add(cb.equal(user.get("isActive"), isActive));
            }
            
            if (!predicates.isEmpty()) {
                cq.where(cb.and(predicates.toArray(new Predicate[0])));
            }
            
            return em.createQuery(cq).getSingleResult();
        } finally {
            em.close();
        }
    }
    
    /**
     * RequÃªte avec JOIN
     */
    public List<Order> findOrdersByUserAndStatus(Long userId, OrderStatus status) {
        EntityManager em = emf.createEntityManager();
        try {
            CriteriaBuilder cb = em.getCriteriaBuilder();
            CriteriaQuery<Order> cq = cb.createQuery(Order.class);
            Root<Order> order = cq.from(Order.class);
            
            // JOIN avec User
            Join<Order, User> user = order.join("user");
            
            // PrÃ©dicats
            Predicate userPredicate = cb.equal(user.get("id"), userId);
            Predicate statusPredicate = cb.equal(order.get("status"), status);
            
            cq.where(cb.and(userPredicate, statusPredicate));
            cq.orderBy(cb.desc(order.get("createdAt")));
            
            return em.createQuery(cq).getResultList();
        } finally {
            em.close();
        }
    }
}
```

---

## Performance et optimisations

### ProblÃ¨me N+1 et solutions

```java
// âŒ MAUVAIS : ProblÃ¨me N+1
public void badExample() {
    EntityManager em = emf.createEntityManager();
    
    // 1 requÃªte pour charger les commandes
    List<Order> orders = em.createQuery(
        "SELECT o FROM Order o", Order.class
    ).getResultList();
    
    // N requÃªtes supplÃ©mentaires pour charger chaque utilisateur !
    for (Order order : orders) {
        System.out.println(order.getUser().getUsername());  // LAZY load
    }
    
    em.close();
}

// âœ… BON : JOIN FETCH pour charger en une seule requÃªte
public void goodExample() {
    EntityManager em = emf.createEntityManager();
    
    // 1 seule requÃªte avec JOIN
    List<Order> orders = em.createQuery(
        "SELECT o FROM Order o JOIN FETCH o.user", 
        Order.class
    ).getResultList();
    
    for (Order order : orders) {
        System.out.println(order.getUser().getUsername());  // DÃ©jÃ  chargÃ©
    }
    
    em.close();
}

// âœ… BON : @EntityGraph (alternative)
public List<Order> findAllWithUser() {
    EntityManager em = emf.createEntityManager();
    try {
        return em.createQuery("SELECT o FROM Order o", Order.class)
            .setHint("jakarta.persistence.loadgraph", 
                    em.getEntityGraph("Order.withUser"))
            .getResultList();
    } finally {
        em.close();
    }
}

// Dans Order.java
@Entity
@NamedEntityGraph(
    name = "Order.withUser",
    attributeNodes = @NamedAttributeNode("user")
)
public class Order {
    // ...
}
```

### Batch processing

```java
/**
 * Insertion par lots (batch insert)
 */
public void batchInsertUsers(List<User> users) {
    EntityManager em = emf.createEntityManager();
    EntityTransaction tx = em.getTransaction();
    
    try {
        tx.begin();
        
        int batchSize = 20;
        for (int i = 0; i < users.size(); i++) {
            em.persist(users.get(i));
            
            // Flush tous les 20 Ã©lÃ©ments
            if (i > 0 && i % batchSize == 0) {
                em.flush();
                em.clear();
            }
        }
        
        tx.commit();
    } catch (Exception e) {
        if (tx.isActive()) {
            tx.rollback();
        }
        throw e;
    } finally {
        em.close();
    }
}

/**
 * Mise Ã  jour en masse (bulk update)
 */
public int deactivateInactiveUsers(int daysSinceLastLogin) {
    EntityManager em = emf.createEntityManager();
    EntityTransaction tx = em.getTransaction();
    
    try {
        tx.begin();
        
        int updated = em.createQuery(
            "UPDATE User u " +
            "SET u.isActive = false, u.updatedAt = CURRENT_TIMESTAMP " +
            "WHERE u.lastLogin < :threshold"
        )
        .setParameter("threshold", 
            LocalDateTime.now().minusDays(daysSinceLastLogin))
        .executeUpdate();
        
        tx.commit();
        return updated;
    } catch (Exception e) {
        if (tx.isActive()) {
            tx.rollback();
        }
        throw e;
    } finally {
        em.close();
    }
}
```

### Second level cache

```java
// Dans persistence.xml
<property name="hibernate.cache.use_second_level_cache" value="true"/>
<property name="hibernate.cache.region.factory_class" 
          value="org.hibernate.cache.jcache.JCacheRegionFactory"/>
<property name="hibernate.cache.use_query_cache" value="true"/>

// Ajouter EhCache dans pom.xml
<dependency>
    <groupId>org.ehcache</groupId>
    <artifactId>ehcache</artifactId>
    <version>3.10.8</version>
</dependency>

// Marquer les entitÃ©s comme cacheable
@Entity
@Cacheable
@org.hibernate.annotations.Cache(
    usage = CacheConcurrencyStrategy.READ_WRITE,
    region = "users"
)
public class User {
    // ...
}

// Utiliser le cache de requÃªtes
public List<User> findActiveUsersCached() {
    EntityManager em = emf.createEntityManager();
    try {
        return em.createQuery(
            "SELECT u FROM User u WHERE u.isActive = true",
            User.class
        )
        .setHint("org.hibernate.cacheable", true)
        .getResultList();
    } finally {
        em.close();
    }
}
```

---

## Spring Data JPA

### Configuration Spring Boot

```yaml
# application.yml
spring:
  datasource:
    url: jdbc:mariadb://localhost:3306/production_db
    username: app_user
    password: SecureP@ssw0rd!
    driver-class-name: org.mariadb.jdbc.Driver
    
    hikari:
      minimum-idle: 5
      maximum-pool-size: 20
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      
  jpa:
    database-platform: org.hibernate.dialect.MariaDBDialect
    hibernate:
      ddl-auto: validate
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
    properties:
      hibernate:
        show_sql: false
        format_sql: true
        use_sql_comments: true
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true
        generate_statistics: false
    open-in-view: false
```

### Repository Spring Data

```java
package com.example.repository;

import com.example.model.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.*;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Query Methods (gÃ©nÃ©ration automatique)
    Optional<User> findByEmail(String email);
    
    Optional<User> findByUsername(String username);
    
    List<User> findByIsActiveTrue();
    
    List<User> findByIsActiveTrueOrderByCreatedAtDesc();
    
    Page<User> findByIsActiveTrue(Pageable pageable);
    
    long countByIsActiveTrue();
    
    boolean existsByEmail(String email);
    
    // @Query JPQL
    @Query("SELECT u FROM User u WHERE u.isActive = true " +
           "AND (LOWER(u.username) LIKE LOWER(CONCAT('%', :term, '%')) " +
           "     OR LOWER(u.email) LIKE LOWER(CONCAT('%', :term, '%')))")
    List<User> searchByTerm(@Param("term") String term);
    
    // @Query avec JOIN FETCH
    @Query("SELECT u FROM User u LEFT JOIN FETCH u.orders WHERE u.id = :id")
    Optional<User> findByIdWithOrders(@Param("id") Long id);
    
    // @Query native SQL
    @Query(value = "SELECT * FROM users WHERE created_at > :since", 
           nativeQuery = true)
    List<User> findRecentUsers(@Param("since") LocalDateTime since);
    
    // Bulk update
    @Modifying
    @Query("UPDATE User u SET u.isActive = false WHERE u.lastLogin < :threshold")
    int deactivateInactiveUsers(@Param("threshold") LocalDateTime threshold);
    
    // Projection DTO
    @Query("SELECT new com.example.dto.UserSummary(u.id, u.username, u.email) " +
           "FROM User u WHERE u.isActive = true")
    List<UserSummary> findAllSummaries();
    
    // @EntityGraph pour Ã©viter N+1
    @EntityGraph(attributePaths = {"orders"})
    @Query("SELECT u FROM User u WHERE u.id = :id")
    Optional<User> findByIdWithOrdersGraph(@Param("id") Long id);
}
```

### Service Layer

```java
package com.example.service;

import com.example.model.User;
import com.example.repository.UserRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@Transactional(readOnly = true)  // Par dÃ©faut lecture seule
public class UserService {
    
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public Optional<User> findById(Long id) {
        return userRepository.findById(id);
    }
    
    public Optional<User> findByEmail(String email) {
        return userRepository.findByEmail(email);
    }
    
    public List<User> findActiveUsers() {
        return userRepository.findByIsActiveTrue();
    }
    
    public List<User> search(String term) {
        return userRepository.searchByTerm(term);
    }
    
    @Transactional  // Override : Ã©criture
    public User createUser(User user) {
        // Valider que l'email n'existe pas
        if (userRepository.existsByEmail(user.getEmail())) {
            throw new IllegalArgumentException("Email already exists");
        }
        
        return userRepository.save(user);
    }
    
    @Transactional
    public User updateUser(Long id, User updates) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("User not found"));
        
        // Mise Ã  jour des champs
        if (updates.getEmail() != null) {
            user.setEmail(updates.getEmail());
        }
        if (updates.getFirstName() != null) {
            user.setFirstName(updates.getFirstName());
        }
        if (updates.getLastName() != null) {
            user.setLastName(updates.getLastName());
        }
        
        return userRepository.save(user);
    }
    
    @Transactional
    public void deleteUser(Long id) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("User not found"));
        
        user.setIsActive(false);
        userRepository.save(user);
    }
    
    @Transactional
    public int deactivateInactiveUsers(int days) {
        LocalDateTime threshold = LocalDateTime.now().minusDays(days);
        return userRepository.deactivateInactiveUsers(threshold);
    }
}
```

---

## âœ… Points clÃ©s Ã  retenir

1. **JPA standard** : PrivilÃ©gier les annotations JPA pour la portabilitÃ©
2. **Lazy loading** : Par dÃ©faut pour @ManyToOne, @OneToMany, @ManyToMany
3. **N+1 problem** : Toujours utiliser JOIN FETCH ou @EntityGraph
4. **Batch processing** : Flush/clear tous les 20-50 Ã©lÃ©ments
5. **Second level cache** : Pour entitÃ©s read-only ou read-mostly
6. **JPQL vs native** : JPQL type-safe, native pour optimisations spÃ©cifiques
7. **Criteria API** : Pour requÃªtes dynamiques complexes
8. **Transactions** : @Transactional au niveau service, pas repository
9. **Versioning** : @Version pour optimistic locking
10. **Spring Data** : Query Methods pour 80% des cas, @Query pour le reste

---

## ğŸ”— Ressources

### Documentation officielle
- [ğŸ“– Hibernate ORM](https://hibernate.org/orm/documentation/)
- [ğŸ“– Jakarta Persistence (JPA)](https://jakarta.ee/specifications/persistence/)
- [ğŸ“– Spring Data JPA](https://spring.io/projects/spring-data-jpa)

### Guides
- [Hibernate Performance Tuning](https://vladmihalcea.com/tutorials/hibernate/)
- [JPA Best Practices](https://thorben-janssen.com/jpa-best-practices/)

---

## â¡ï¸ Section suivante

**17.3.2 SQLAlchemy (Python)** : ORM Python avec mapping, relations, query API, et optimisations pour MariaDB.

â­ï¸ [SQLAlchemy (Python)](/17-integration-developpement/03.2-sqlalchemy.md)
