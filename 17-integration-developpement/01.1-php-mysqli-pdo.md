üîù Retour au [Sommaire](/SOMMAIRE.md)

# 17.1.1 PHP : mysqli et PDO

> **Niveau** : Interm√©diaire √† Avanc√©  
> **Dur√©e estim√©e** : 2-3 heures  
> **Pr√©requis** : Connaissances de base en PHP, compr√©hension des bases de donn√©es relationnelles

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre les diff√©rences entre mysqli et PDO et choisir l'extension appropri√©e
- √âtablir des connexions s√©curis√©es √† MariaDB depuis PHP
- Utiliser les prepared statements pour pr√©venir les injections SQL
- G√©rer efficacement les erreurs et les transactions
- Impl√©menter les bonnes pratiques de s√©curit√© et de performance
- Optimiser la gestion des connexions avec le pooling

---

## Introduction

PHP offre deux extensions principales pour interagir avec MariaDB : **mysqli** (MySQL Improved) et **PDO** (PHP Data Objects). Chacune pr√©sente des avantages sp√©cifiques et r√©pond √† des besoins diff√©rents en termes de portabilit√©, de fonctionnalit√©s et de performance.

### Pourquoi deux extensions ?

- **mysqli** : Extension sp√©cialis√©e pour MySQL/MariaDB, offrant un acc√®s complet aux fonctionnalit√©s sp√©cifiques
- **PDO** : Abstraction multi-base de donn√©es, favorisant la portabilit√© du code

üí° **Conseil** : Pour les nouveaux projets MariaDB-only, mysqli offre des performances l√©g√®rement meilleures et un acc√®s direct aux fonctionnalit√©s avanc√©es. Pour des projets multi-SGBD, PDO est pr√©f√©rable.

---

## mysqli vs PDO : Comparaison d√©taill√©e

### Tableau comparatif

| Crit√®re | mysqli | PDO |
|---------|--------|-----|
| **Bases support√©es** | MySQL/MariaDB uniquement | 12+ SGBD (MySQL, PostgreSQL, SQLite, etc.) |
| **API** | Proc√©durale et Orient√©e Objet | Orient√©e Objet uniquement |
| **Prepared Statements** | ‚úÖ Oui (natifs) | ‚úÖ Oui (natifs ou √©mul√©s) |
| **Named Parameters** | ‚ùå Non (seulement `?`) | ‚úÖ Oui (`:param` et `?`) |
| **Transactions** | ‚úÖ Support complet | ‚úÖ Support complet |
| **Fonctions MariaDB sp√©cifiques** | ‚úÖ Acc√®s direct | ‚ö†Ô∏è Limit√© |
| **Performance** | L√©g√®rement sup√©rieure | Tr√®s proche |
| **Portabilit√©** | Faible | √âlev√©e |
| **Courbe d'apprentissage** | Moyenne | Facile |

### Quand utiliser mysqli ?

- Application d√©di√©e √† MariaDB/MySQL
- Besoin d'acc√©der aux fonctionnalit√©s sp√©cifiques (stored procedures complexes, multi-queries)
- Performance critique sur des requ√™tes simples
- √âquipe d√©j√† famili√®re avec l'extension

### Quand utiliser PDO ?

- Possibilit√© de migration vers un autre SGBD
- Code plus lisible avec named parameters
- Standardisation entre plusieurs projets
- Pr√©f√©rence pour une API moderne et coh√©rente

---

## Connexion √† MariaDB avec mysqli

### Style orient√© objet (recommand√©)

```php
<?php
/**
 * Connexion MariaDB avec mysqli - Style OO
 * Recommand√© pour les applications modernes
 */

// Configuration de connexion
$host = 'localhost';
$username = 'app_user';
$password = 'SecureP@ssw0rd!';
$database = 'production_db';
$port = 3306;
$charset = 'utf8mb4'; // üÜï utf8mb4 par d√©faut depuis MariaDB 11.8

// Cr√©ation de la connexion
$mysqli = new mysqli($host, $username, $password, $database, $port);

// V√©rification de la connexion
if ($mysqli->connect_errno) {
    error_log("√âchec de connexion MariaDB : " . $mysqli->connect_error);
    die("Erreur de connexion √† la base de donn√©es");
}

// Configuration du charset (IMPORTANT pour la s√©curit√©)
if (!$mysqli->set_charset($charset)) {
    error_log("Erreur charset : " . $mysqli->error);
    exit();
}

echo "Connexion r√©ussie √† MariaDB " . $mysqli->server_info . "\n";

// Toujours fermer la connexion
$mysqli->close();
```

### Style proc√©dural

```php
<?php
/**
 * Connexion MariaDB avec mysqli - Style proc√©dural
 * Compatible avec du code legacy
 */

$mysqli = mysqli_connect(
    'localhost',
    'app_user',
    'SecureP@ssw0rd!',
    'production_db',
    3306
);

if (!$mysqli) {
    die("Erreur : " . mysqli_connect_error());
}

mysqli_set_charset($mysqli, 'utf8mb4');

// Utilisation
$result = mysqli_query($mysqli, "SELECT VERSION()");
$row = mysqli_fetch_assoc($result);
echo "MariaDB version : " . $row['VERSION()'] . "\n";

mysqli_close($mysqli);
```

üí° **Conseil** : Privil√©giez toujours le style orient√© objet pour les nouveaux projets. Il est plus lisible et maintenable.

---

## Connexion √† MariaDB avec PDO

### Connexion de base

```php
<?php
/**
 * Connexion MariaDB avec PDO
 * Approche moderne et portable
 */

$host = 'localhost';
$dbname = 'production_db';
$username = 'app_user';
$password = 'SecureP@ssw0rd!';
$charset = 'utf8mb4';
$port = 3306;

// Construction du DSN (Data Source Name)
$dsn = "mysql:host=$host;port=$port;dbname=$dbname;charset=$charset";

// Options PDO recommand√©es
$options = [
    // Mode d'erreur : exceptions (CRUCIAL)
    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
    
    // Mode de r√©cup√©ration par d√©faut : tableau associatif
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    
    // D√©sactiver l'√©mulation de prepared statements (s√©curit√©)
    PDO::ATTR_EMULATE_PREPARES => false,
    
    // Connexions persistantes (voir section pooling)
    // PDO::ATTR_PERSISTENT => true,
];

try {
    $pdo = new PDO($dsn, $username, $password, $options);
    echo "Connexion PDO r√©ussie\n";
    
    // V√©rification de la version
    $version = $pdo->query('SELECT VERSION()')->fetchColumn();
    echo "MariaDB version : $version\n";
    
} catch (PDOException $e) {
    error_log("Erreur PDO : " . $e->getMessage());
    die("Connexion impossible");
}

// PDO se ferme automatiquement en fin de script
// ou avec : $pdo = null;
```

‚ö†Ô∏è **Attention** : Ne jamais afficher les messages d'erreur SQL en production. Toujours les logger c√¥t√© serveur.

---

## Prepared Statements : La pierre angulaire de la s√©curit√©

### Pourquoi utiliser les prepared statements ?

1. **S√©curit√©** : Protection contre les injections SQL
2. **Performance** : Optimisation pour les requ√™tes r√©p√©t√©es
3. **Lisibilit√©** : Code plus clair et maintenable
4. **Typage** : Validation automatique des types de donn√©es

### Prepared Statements avec mysqli

```php
<?php
/**
 * Exemples de prepared statements avec mysqli
 */

// Connexion (voir exemple pr√©c√©dent)
$mysqli = new mysqli('localhost', 'app_user', 'password', 'production_db');
$mysqli->set_charset('utf8mb4');

// ========================================
// Exemple 1 : SELECT avec param√®tres
// ========================================

$email = $_POST['email'] ?? 'user@example.com';

// Pr√©paration de la requ√™te
$stmt = $mysqli->prepare("SELECT id, username, email FROM users WHERE email = ?");

if (!$stmt) {
    die("Erreur de pr√©paration : " . $mysqli->error);
}

// Liaison des param√®tres (bind)
// "s" = string, "i" = integer, "d" = double, "b" = blob
$stmt->bind_param("s", $email);

// Ex√©cution
$stmt->execute();

// R√©cup√©ration des r√©sultats
$result = $stmt->get_result();

while ($row = $result->fetch_assoc()) {
    echo "User : " . htmlspecialchars($row['username']) . "\n";
}

$stmt->close();

// ========================================
// Exemple 2 : INSERT avec multiple param√®tres
// ========================================

$username = "john_doe";
$email = "john@example.com";
$age = 30;
$is_active = true;

$sql = "INSERT INTO users (username, email, age, is_active, created_at) 
        VALUES (?, ?, ?, ?, NOW())";

$stmt = $mysqli->prepare($sql);

// Types : s=string, i=integer
$stmt->bind_param("ssii", $username, $email, $age, $is_active);

if ($stmt->execute()) {
    echo "Nouvel utilisateur cr√©√© avec l'ID : " . $mysqli->insert_id . "\n";
} else {
    echo "Erreur : " . $stmt->error . "\n";
}

$stmt->close();

// ========================================
// Exemple 3 : UPDATE avec v√©rification
// ========================================

$new_email = "newemail@example.com";
$user_id = 42;

$stmt = $mysqli->prepare("UPDATE users SET email = ?, updated_at = NOW() WHERE id = ?");
$stmt->bind_param("si", $new_email, $user_id);
$stmt->execute();

// V√©rifier le nombre de lignes affect√©es
if ($stmt->affected_rows > 0) {
    echo "Utilisateur mis √† jour\n";
} else {
    echo "Aucun utilisateur trouv√© avec cet ID\n";
}

$stmt->close();

$mysqli->close();
```

### Prepared Statements avec PDO

```php
<?php
/**
 * Exemples de prepared statements avec PDO
 * Avantage : Named parameters plus lisibles
 */

$pdo = new PDO(
    'mysql:host=localhost;dbname=production_db;charset=utf8mb4',
    'app_user',
    'password',
    [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
        PDO::ATTR_EMULATE_PREPARES => false,
    ]
);

// ========================================
// Exemple 1 : Named parameters (recommand√©)
// ========================================

$email = $_POST['email'] ?? 'user@example.com';

$sql = "SELECT id, username, email, created_at 
        FROM users 
        WHERE email = :email AND is_active = :active";

$stmt = $pdo->prepare($sql);

// Liaison et ex√©cution en une seule √©tape
$stmt->execute([
    ':email' => $email,
    ':active' => 1
]);

// R√©cup√©ration
$users = $stmt->fetchAll();

foreach ($users as $user) {
    echo "User : " . htmlspecialchars($user['username']) . "\n";
}

// ========================================
// Exemple 2 : Positional parameters
// ========================================

$sql = "SELECT * FROM products WHERE category_id = ? AND price > ?";
$stmt = $pdo->prepare($sql);
$stmt->execute([5, 99.99]);

$products = $stmt->fetchAll();

// ========================================
// Exemple 3 : INSERT avec r√©cup√©ration de l'ID
// ========================================

$sql = "INSERT INTO orders (user_id, total_amount, status, created_at) 
        VALUES (:user_id, :amount, :status, NOW())";

$stmt = $pdo->prepare($sql);

$stmt->execute([
    ':user_id' => 42,
    ':amount' => 149.99,
    ':status' => 'pending'
]);

$order_id = $pdo->lastInsertId();
echo "Nouvelle commande cr√©√©e avec l'ID : $order_id\n";

// ========================================
// Exemple 4 : UPDATE avec bindValue vs bindParam
// ========================================

$sql = "UPDATE products SET stock = stock - :quantity WHERE id = :product_id";
$stmt = $pdo->prepare($sql);

// bindValue : valeur pass√©e imm√©diatement
$stmt->bindValue(':quantity', 5, PDO::PARAM_INT);

// bindParam : r√©f√©rence √† la variable (√©valu√©e √† l'ex√©cution)
$product_id = 123;
$stmt->bindParam(':product_id', $product_id, PDO::PARAM_INT);

$stmt->execute();

echo "Lignes affect√©es : " . $stmt->rowCount() . "\n";
```

üí° **Conseil** : Avec PDO, pr√©f√©rez les named parameters (`:param`) pour une meilleure lisibilit√©. Utilisez `bindValue()` par d√©faut, et `bindParam()` seulement si vous devez modifier la variable entre la liaison et l'ex√©cution.

---

## Gestion des erreurs et exceptions

### Strat√©gie robuste avec mysqli

```php
<?php
/**
 * Gestion d'erreurs robuste avec mysqli
 */

// Activer le mode exceptions (PHP 8.1+)
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);

try {
    $mysqli = new mysqli('localhost', 'app_user', 'password', 'production_db');
    $mysqli->set_charset('utf8mb4');
    
    // Requ√™te avec gestion d'erreur
    $stmt = $mysqli->prepare("SELECT * FROM users WHERE id = ?");
    $user_id = 42;
    $stmt->bind_param("i", $user_id);
    $stmt->execute();
    
    $result = $stmt->get_result();
    $user = $result->fetch_assoc();
    
    if (!$user) {
        throw new Exception("Utilisateur non trouv√©");
    }
    
    echo "Utilisateur : " . $user['username'] . "\n";
    
} catch (mysqli_sql_exception $e) {
    // Erreur SQL sp√©cifique
    error_log("Erreur SQL : " . $e->getMessage());
    
    // G√©rer les erreurs sp√©cifiques
    switch ($e->getCode()) {
        case 1062: // Duplicate entry
            echo "Cet enregistrement existe d√©j√†\n";
            break;
        case 1452: // Foreign key constraint fails
            echo "Violation de contrainte de cl√© √©trang√®re\n";
            break;
        default:
            echo "Une erreur est survenue\n";
    }
    
} catch (Exception $e) {
    // Autres erreurs
    error_log("Erreur : " . $e->getMessage());
    echo "Une erreur est survenue\n";
    
} finally {
    // Nettoyage (m√™me en cas d'erreur)
    if (isset($stmt)) {
        $stmt->close();
    }
    if (isset($mysqli)) {
        $mysqli->close();
    }
}
```

### Strat√©gie avec PDO (recommand√©)

```php
<?php
/**
 * Gestion d'erreurs avec PDO
 * Mode exception activ√© par d√©faut dans les options
 */

try {
    $pdo = new PDO(
        'mysql:host=localhost;dbname=production_db;charset=utf8mb4',
        'app_user',
        'password',
        [
            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
        ]
    );
    
    // Tentative d'insertion avec contrainte unique
    $sql = "INSERT INTO users (username, email) VALUES (:username, :email)";
    $stmt = $pdo->prepare($sql);
    
    $stmt->execute([
        ':username' => 'john_doe',
        ':email' => 'john@example.com'
    ]);
    
    echo "Utilisateur cr√©√© avec succ√®s\n";
    
} catch (PDOException $e) {
    // R√©cup√©rer le code d'erreur SQL
    $errorCode = $e->getCode();
    $errorInfo = $pdo->errorInfo();
    
    // Logger l'erreur compl√®te
    error_log("Erreur PDO [{$errorInfo[1]}] : " . $e->getMessage());
    
    // Gestion par code d'erreur
    if ($errorInfo[1] == 1062) {
        echo "Ce nom d'utilisateur ou email existe d√©j√†\n";
    } elseif ($errorInfo[1] == 1452) {
        echo "R√©f√©rence invalide (cl√© √©trang√®re)\n";
    } else {
        // Message g√©n√©rique pour l'utilisateur
        echo "Impossible de cr√©er l'utilisateur\n";
    }
}
```

‚ö†Ô∏è **Attention** : Ne jamais exposer les d√©tails techniques des erreurs SQL √† l'utilisateur final. Toujours logger les erreurs c√¥t√© serveur et afficher des messages g√©n√©riques.

---

## Gestion des transactions

### Transactions avec mysqli

```php
<?php
/**
 * Gestion de transactions avec mysqli
 * Exemple : Transfert bancaire atomique
 */

$mysqli = new mysqli('localhost', 'app_user', 'password', 'banking_db');
$mysqli->set_charset('utf8mb4');

// D√©sactiver l'autocommit
$mysqli->autocommit(false);

try {
    // D√©but de la transaction
    $mysqli->begin_transaction(MYSQLI_TRANS_START_READ_WRITE);
    
    $from_account = 101;
    $to_account = 102;
    $amount = 500.00;
    
    // √âtape 1 : D√©biter le compte source
    $stmt = $mysqli->prepare(
        "UPDATE accounts SET balance = balance - ? WHERE id = ? AND balance >= ?"
    );
    $stmt->bind_param("did", $amount, $from_account, $amount);
    $stmt->execute();
    
    if ($stmt->affected_rows === 0) {
        throw new Exception("Solde insuffisant ou compte introuvable");
    }
    $stmt->close();
    
    // √âtape 2 : Cr√©diter le compte destination
    $stmt = $mysqli->prepare(
        "UPDATE accounts SET balance = balance + ? WHERE id = ?"
    );
    $stmt->bind_param("di", $amount, $to_account);
    $stmt->execute();
    
    if ($stmt->affected_rows === 0) {
        throw new Exception("Compte destination introuvable");
    }
    $stmt->close();
    
    // √âtape 3 : Enregistrer la transaction
    $stmt = $mysqli->prepare(
        "INSERT INTO transactions (from_account, to_account, amount, created_at) 
         VALUES (?, ?, ?, NOW())"
    );
    $stmt->bind_param("iid", $from_account, $to_account, $amount);
    $stmt->execute();
    $stmt->close();
    
    // Valider la transaction
    $mysqli->commit();
    echo "Transfert de $amount effectu√© avec succ√®s\n";
    
} catch (Exception $e) {
    // Annuler en cas d'erreur
    $mysqli->rollback();
    error_log("Erreur transaction : " . $e->getMessage());
    echo "Le transfert a √©chou√©\n";
    
} finally {
    // R√©activer l'autocommit
    $mysqli->autocommit(true);
    $mysqli->close();
}
```

### Transactions avec PDO

```php
<?php
/**
 * Gestion de transactions avec PDO
 * Syntaxe plus simple et √©l√©gante
 */

$pdo = new PDO(
    'mysql:host=localhost;dbname=banking_db;charset=utf8mb4',
    'app_user',
    'password',
    [PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION]
);

try {
    // D√©but de la transaction
    $pdo->beginTransaction();
    
    $from_account = 101;
    $to_account = 102;
    $amount = 500.00;
    
    // D√©biter
    $sql = "UPDATE accounts SET balance = balance - :amount 
            WHERE id = :account AND balance >= :amount";
    $stmt = $pdo->prepare($sql);
    $stmt->execute([
        ':amount' => $amount,
        ':account' => $from_account
    ]);
    
    if ($stmt->rowCount() === 0) {
        throw new Exception("Solde insuffisant");
    }
    
    // Cr√©diter
    $sql = "UPDATE accounts SET balance = balance + :amount WHERE id = :account";
    $stmt = $pdo->prepare($sql);
    $stmt->execute([
        ':amount' => $amount,
        ':account' => $to_account
    ]);
    
    if ($stmt->rowCount() === 0) {
        throw new Exception("Compte destination introuvable");
    }
    
    // Logger la transaction
    $sql = "INSERT INTO transactions (from_account, to_account, amount) 
            VALUES (:from, :to, :amount)";
    $stmt = $pdo->prepare($sql);
    $stmt->execute([
        ':from' => $from_account,
        ':to' => $to_account,
        ':amount' => $amount
    ]);
    
    // Valider
    $pdo->commit();
    echo "Transfert r√©ussi\n";
    
} catch (Exception $e) {
    // Annuler
    if ($pdo->inTransaction()) {
        $pdo->rollBack();
    }
    error_log("Erreur : " . $e->getMessage());
    echo "Transfert √©chou√©\n";
}
```

üí° **Conseil** : Toujours utiliser des transactions pour les op√©rations multi-√©tapes critiques. Pensez au principe ACID : Atomicit√©, Coh√©rence, Isolation, Durabilit√©.

---

## Connection Pooling en PHP

### Connexions persistantes avec mysqli

```php
<?php
/**
 * Connexions persistantes avec mysqli
 * Utile pour les scripts CLI long-running
 */

// Utiliser le pr√©fixe "p:" pour une connexion persistante
$mysqli = new mysqli(
    'p:localhost',  // "p:" active la persistance
    'app_user',
    'password',
    'production_db'
);

// V√©rifier si la connexion est r√©utilis√©e
if ($mysqli->thread_id) {
    echo "Thread ID : " . $mysqli->thread_id . "\n";
}

// La connexion reste ouverte apr√®s la fermeture du script
$mysqli->close();
```

‚ö†Ô∏è **Attention** : Les connexions persistantes peuvent poser probl√®me avec Apache/PHP-FPM car elles sont li√©es au processus PHP. √Ä utiliser avec prudence.

### Connexions persistantes avec PDO

```php
<?php
/**
 * Connexions persistantes avec PDO
 */

$options = [
    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    PDO::ATTR_EMULATE_PREPARES => false,
    PDO::ATTR_PERSISTENT => true,  // Activer la persistance
];

$pdo = new PDO(
    'mysql:host=localhost;dbname=production_db;charset=utf8mb4',
    'app_user',
    'password',
    $options
);

// La connexion persiste entre les requ√™tes HTTP
```

### Classe de gestion de connexion singleton

```php
<?php
/**
 * Pattern Singleton pour g√©rer une connexion unique
 * Recommand√© pour √©viter les connexions multiples
 */

class Database
{
    private static ?PDO $instance = null;
    
    // Configuration
    private const HOST = 'localhost';
    private const DBNAME = 'production_db';
    private const USERNAME = 'app_user';
    private const PASSWORD = 'SecureP@ssw0rd!';
    private const CHARSET = 'utf8mb4';
    
    // Emp√™cher l'instanciation directe
    private function __construct() {}
    
    // Emp√™cher le clonage
    private function __clone() {}
    
    // Emp√™cher la d√©s√©rialisation
    public function __wakeup()
    {
        throw new Exception("Cannot unserialize singleton");
    }
    
    /**
     * Obtenir l'instance unique de connexion
     */
    public static function getInstance(): PDO
    {
        if (self::$instance === null) {
            $dsn = sprintf(
                "mysql:host=%s;dbname=%s;charset=%s",
                self::HOST,
                self::DBNAME,
                self::CHARSET
            );
            
            $options = [
                PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                PDO::ATTR_EMULATE_PREPARES => false,
            ];
            
            try {
                self::$instance = new PDO($dsn, self::USERNAME, self::PASSWORD, $options);
            } catch (PDOException $e) {
                error_log("Erreur de connexion : " . $e->getMessage());
                throw new Exception("Connexion impossible");
            }
        }
        
        return self::$instance;
    }
}

// Utilisation
try {
    $pdo = Database::getInstance();
    $stmt = $pdo->query("SELECT VERSION()");
    echo "MariaDB : " . $stmt->fetchColumn() . "\n";
} catch (Exception $e) {
    die("Erreur : " . $e->getMessage());
}
```

---

## ProxySQL comme Connection Pooler

### Configuration PHP avec ProxySQL

```php
<?php
/**
 * Connexion via ProxySQL pour le pooling avanc√©
 * ProxySQL g√®re le pooling c√¥t√© serveur
 */

// ProxySQL √©coute g√©n√©ralement sur le port 6033
$pdo = new PDO(
    'mysql:host=127.0.0.1;port=6033;dbname=production_db;charset=utf8mb4',
    'proxysql_user',
    'proxysql_password',
    [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
        PDO::ATTR_EMULATE_PREPARES => false,
        
        // Pas besoin de ATTR_PERSISTENT avec ProxySQL
        // Le pooling est g√©r√© c√¥t√© ProxySQL
        PDO::ATTR_PERSISTENT => false,
    ]
);

// ProxySQL route automatiquement vers le bon serveur
// (master pour √©criture, replica pour lecture)

// Requ√™te de lecture (rout√©e vers replica)
$stmt = $pdo->query("SELECT * FROM products LIMIT 10");
$products = $stmt->fetchAll();

// Requ√™te d'√©criture (rout√©e vers master)
$pdo->beginTransaction();
$stmt = $pdo->prepare("INSERT INTO orders (user_id, total) VALUES (?, ?)");
$stmt->execute([42, 199.99]);
$pdo->commit();
```

üí° **Conseil** : ProxySQL est la solution recommand√©e pour le pooling en production. Il offre :
- Pooling de connexions c√¥t√© serveur
- Routing automatique read/write
- Query caching
- Load balancing
- Monitoring d√©taill√©

---

## Bonnes pratiques de s√©curit√©

### 1. Toujours utiliser des prepared statements

```php
<?php
// ‚ùå DANGER : Injection SQL possible
$user_id = $_GET['id'];
$sql = "SELECT * FROM users WHERE id = $user_id";
$result = $mysqli->query($sql);

// ‚úÖ S√âCURIS√â : Prepared statement
$user_id = $_GET['id'];
$stmt = $mysqli->prepare("SELECT * FROM users WHERE id = ?");
$stmt->bind_param("i", $user_id);
$stmt->execute();
$result = $stmt->get_result();
```

### 2. Valider et filtrer les entr√©es

```php
<?php
/**
 * Validation stricte des entr√©es utilisateur
 */

// Validation d'un ID
$user_id = filter_input(INPUT_GET, 'id', FILTER_VALIDATE_INT);
if ($user_id === false || $user_id < 1) {
    die("ID invalide");
}

// Validation d'un email
$email = filter_input(INPUT_POST, 'email', FILTER_VALIDATE_EMAIL);
if ($email === false) {
    die("Email invalide");
}

// Utilisation s√©curis√©e
$stmt = $pdo->prepare("SELECT * FROM users WHERE id = :id AND email = :email");
$stmt->execute([':id' => $user_id, ':email' => $email]);
```

### 3. √âchapper les sorties (pas les entr√©es)

```php
<?php
// R√©cup√©ration depuis la base
$stmt = $pdo->query("SELECT username, bio FROM users WHERE id = 1");
$user = $stmt->fetch();

// ‚úÖ √âchapper lors de l'affichage HTML
echo "<h1>Profil de " . htmlspecialchars($user['username'], ENT_QUOTES, 'UTF-8') . "</h1>";
echo "<p>" . nl2br(htmlspecialchars($user['bio'], ENT_QUOTES, 'UTF-8')) . "</p>";

// Pour JSON
header('Content-Type: application/json');
echo json_encode($user, JSON_HEX_TAG | JSON_HEX_AMP | JSON_HEX_QUOT);
```

### 4. Utiliser des mots de passe hash√©s

```php
<?php
/**
 * Gestion s√©curis√©e des mots de passe
 */

// ========================================
// INSCRIPTION : Hashing du mot de passe
// ========================================

$password = $_POST['password'];

// Validation (longueur minimale, complexit√©, etc.)
if (strlen($password) < 12) {
    die("Mot de passe trop court (minimum 12 caract√®res)");
}

// Hashing avec bcrypt (recommand√©)
$hashed_password = password_hash($password, PASSWORD_BCRYPT, ['cost' => 12]);

// Stockage en base
$stmt = $pdo->prepare(
    "INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)"
);
$stmt->execute([$username, $email, $hashed_password]);

// ========================================
// CONNEXION : V√©rification du mot de passe
// ========================================

$email = $_POST['email'];
$password = $_POST['password'];

$stmt = $pdo->prepare("SELECT id, password_hash FROM users WHERE email = ?");
$stmt->execute([$email]);
$user = $stmt->fetch();

if ($user && password_verify($password, $user['password_hash'])) {
    // V√©rifier si le hash doit √™tre mis √† jour
    if (password_needs_rehash($user['password_hash'], PASSWORD_BCRYPT, ['cost' => 12])) {
        $new_hash = password_hash($password, PASSWORD_BCRYPT, ['cost' => 12]);
        $stmt = $pdo->prepare("UPDATE users SET password_hash = ? WHERE id = ?");
        $stmt->execute([$new_hash, $user['id']]);
    }
    
    echo "Connexion r√©ussie\n";
    $_SESSION['user_id'] = $user['id'];
} else {
    echo "Identifiants invalides\n";
}
```

### 5. Configuration s√©curis√©e

```php
<?php
/**
 * Fichier de configuration s√©curis√©
 * √Ä placer HORS du document root (ex: /var/www/config/database.php)
 */

return [
    'database' => [
        'host' => getenv('DB_HOST') ?: 'localhost',
        'port' => getenv('DB_PORT') ?: 3306,
        'name' => getenv('DB_NAME') ?: 'production_db',
        'username' => getenv('DB_USER') ?: 'app_user',
        'password' => getenv('DB_PASSWORD') ?: '',
        'charset' => 'utf8mb4',
    ],
    'pdo_options' => [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
        PDO::ATTR_EMULATE_PREPARES => false,
        PDO::ATTR_PERSISTENT => false,
    ],
];

// Utilisation
$config = require __DIR__ . '/../config/database.php';

$dsn = sprintf(
    "mysql:host=%s;port=%d;dbname=%s;charset=%s",
    $config['database']['host'],
    $config['database']['port'],
    $config['database']['name'],
    $config['database']['charset']
);

$pdo = new PDO(
    $dsn,
    $config['database']['username'],
    $config['database']['password'],
    $config['pdo_options']
);
```

### 6. Limiter les privil√®ges de la base de donn√©es

```sql
-- Cr√©er un utilisateur avec privil√®ges limit√©s
CREATE USER 'app_user'@'localhost' IDENTIFIED BY 'SecureP@ssw0rd!';

-- Accorder seulement les privil√®ges n√©cessaires
GRANT SELECT, INSERT, UPDATE, DELETE ON production_db.* TO 'app_user'@'localhost';

-- Ne JAMAIS donner :
-- - DROP, CREATE, ALTER (sauf pour les migrations)
-- - GRANT OPTION
-- - SUPER
-- - FILE (permet LOAD DATA INFILE)

FLUSH PRIVILEGES;
```

---

## Exemples pratiques complets

### Exemple 1 : CRUD complet avec PDO

```php
<?php
/**
 * Classe de gestion des utilisateurs (CRUD complet)
 */

class UserRepository
{
    private PDO $pdo;
    
    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }
    
    /**
     * Cr√©er un utilisateur
     */
    public function create(string $username, string $email, string $password): int
    {
        // Validation
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            throw new InvalidArgumentException("Email invalide");
        }
        
        if (strlen($password) < 12) {
            throw new InvalidArgumentException("Mot de passe trop court");
        }
        
        // Hash du mot de passe
        $password_hash = password_hash($password, PASSWORD_BCRYPT, ['cost' => 12]);
        
        // Insertion
        $sql = "INSERT INTO users (username, email, password_hash, created_at) 
                VALUES (:username, :email, :password_hash, NOW())";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':username' => $username,
            ':email' => $email,
            ':password_hash' => $password_hash
        ]);
        
        return (int) $this->pdo->lastInsertId();
    }
    
    /**
     * Lire un utilisateur par ID
     */
    public function findById(int $id): ?array
    {
        $sql = "SELECT id, username, email, created_at, updated_at 
                FROM users WHERE id = :id";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':id' => $id]);
        
        $user = $stmt->fetch();
        return $user ?: null;
    }
    
    /**
     * Lire un utilisateur par email
     */
    public function findByEmail(string $email): ?array
    {
        $sql = "SELECT id, username, email, password_hash, created_at 
                FROM users WHERE email = :email";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':email' => $email]);
        
        $user = $stmt->fetch();
        return $user ?: null;
    }
    
    /**
     * Lister tous les utilisateurs avec pagination
     */
    public function findAll(int $limit = 20, int $offset = 0): array
    {
        $sql = "SELECT id, username, email, created_at 
                FROM users 
                ORDER BY created_at DESC 
                LIMIT :limit OFFSET :offset";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->bindValue(':limit', $limit, PDO::PARAM_INT);
        $stmt->bindValue(':offset', $offset, PDO::PARAM_INT);
        $stmt->execute();
        
        return $stmt->fetchAll();
    }
    
    /**
     * Mettre √† jour un utilisateur
     */
    public function update(int $id, array $data): bool
    {
        $allowed_fields = ['username', 'email'];
        $fields = [];
        $params = [':id' => $id];
        
        foreach ($data as $key => $value) {
            if (in_array($key, $allowed_fields)) {
                $fields[] = "$key = :$key";
                $params[":$key"] = $value;
            }
        }
        
        if (empty($fields)) {
            return false;
        }
        
        $sql = "UPDATE users SET " . implode(', ', $fields) . ", updated_at = NOW() 
                WHERE id = :id";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute($params);
        
        return $stmt->rowCount() > 0;
    }
    
    /**
     * Supprimer un utilisateur
     */
    public function delete(int $id): bool
    {
        $sql = "DELETE FROM users WHERE id = :id";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':id' => $id]);
        
        return $stmt->rowCount() > 0;
    }
    
    /**
     * Compter le nombre total d'utilisateurs
     */
    public function count(): int
    {
        $sql = "SELECT COUNT(*) FROM users";
        return (int) $this->pdo->query($sql)->fetchColumn();
    }
}

// Utilisation
try {
    $pdo = new PDO(
        'mysql:host=localhost;dbname=production_db;charset=utf8mb4',
        'app_user',
        'password',
        [
            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
        ]
    );
    
    $userRepo = new UserRepository($pdo);
    
    // Cr√©er
    $user_id = $userRepo->create('john_doe', 'john@example.com', 'SecureP@ss123!');
    echo "Utilisateur cr√©√© : ID $user_id\n";
    
    // Lire
    $user = $userRepo->findById($user_id);
    echo "Utilisateur : " . $user['username'] . "\n";
    
    // Mettre √† jour
    $userRepo->update($user_id, ['username' => 'john_doe_updated']);
    
    // Lister
    $users = $userRepo->findAll(10, 0);
    echo "Nombre d'utilisateurs : " . count($users) . "\n";
    
    // Compter
    $total = $userRepo->count();
    echo "Total utilisateurs : $total\n";
    
} catch (Exception $e) {
    error_log("Erreur : " . $e->getMessage());
    die("Une erreur est survenue");
}
```

### Exemple 2 : Gestion des fichiers upload√©s

```php
<?php
/**
 * Upload de fichier avec stockage des m√©tadonn√©es en base
 */

class FileUploadHandler
{
    private PDO $pdo;
    private string $upload_dir;
    private const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5 MB
    private const ALLOWED_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf'];
    
    public function __construct(PDO $pdo, string $upload_dir)
    {
        $this->pdo = $pdo;
        $this->upload_dir = rtrim($upload_dir, '/');
        
        if (!is_dir($this->upload_dir)) {
            mkdir($this->upload_dir, 0755, true);
        }
    }
    
    /**
     * Traiter l'upload d'un fichier
     */
    public function handleUpload(array $file, int $user_id): array
    {
        // Validation
        if ($file['error'] !== UPLOAD_ERR_OK) {
            throw new Exception("Erreur lors de l'upload");
        }
        
        if ($file['size'] > self::MAX_FILE_SIZE) {
            throw new Exception("Fichier trop volumineux");
        }
        
        if (!in_array($file['type'], self::ALLOWED_TYPES)) {
            throw new Exception("Type de fichier non autoris√©");
        }
        
        // G√©n√©rer un nom unique et s√©curis√©
        $extension = pathinfo($file['name'], PATHINFO_EXTENSION);
        $filename = bin2hex(random_bytes(16)) . '.' . $extension;
        $filepath = $this->upload_dir . '/' . $filename;
        
        // D√©placer le fichier
        if (!move_uploaded_file($file['tmp_name'], $filepath)) {
            throw new Exception("Impossible de sauvegarder le fichier");
        }
        
        // Calculer le hash pour d√©duplication
        $file_hash = hash_file('sha256', $filepath);
        
        // V√©rifier si le fichier existe d√©j√†
        $sql = "SELECT id FROM files WHERE file_hash = :hash";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':hash' => $file_hash]);
        $existing = $stmt->fetch();
        
        if ($existing) {
            // Supprimer le doublon
            unlink($filepath);
            return $this->getFileInfo($existing['id']);
        }
        
        // Ins√©rer les m√©tadonn√©es
        $sql = "INSERT INTO files 
                (user_id, original_name, stored_name, file_path, mime_type, file_size, file_hash, created_at) 
                VALUES (:user_id, :original, :stored, :path, :mime, :size, :hash, NOW())";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':user_id' => $user_id,
            ':original' => $file['name'],
            ':stored' => $filename,
            ':path' => $filepath,
            ':mime' => $file['type'],
            ':size' => $file['size'],
            ':hash' => $file_hash
        ]);
        
        $file_id = (int) $this->pdo->lastInsertId();
        
        return $this->getFileInfo($file_id);
    }
    
    /**
     * R√©cup√©rer les informations d'un fichier
     */
    public function getFileInfo(int $file_id): array
    {
        $sql = "SELECT id, original_name, stored_name, file_path, mime_type, file_size, created_at 
                FROM files WHERE id = :id";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':id' => $file_id]);
        
        $file = $stmt->fetch();
        if (!$file) {
            throw new Exception("Fichier non trouv√©");
        }
        
        return $file;
    }
}

// Utilisation
if ($_SERVER['REQUEST_METHOD'] === 'POST' && isset($_FILES['document'])) {
    try {
        $pdo = new PDO(
            'mysql:host=localhost;dbname=production_db;charset=utf8mb4',
            'app_user',
            'password',
            [PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION]
        );
        
        $uploader = new FileUploadHandler($pdo, '/var/www/uploads');
        $file_info = $uploader->handleUpload($_FILES['document'], $user_id);
        
        echo "Fichier upload√© : " . $file_info['original_name'] . "\n";
        echo "ID : " . $file_info['id'] . "\n";
        
    } catch (Exception $e) {
        error_log("Erreur upload : " . $e->getMessage());
        echo "Erreur lors de l'upload\n";
    }
}
```

---

## Performance et optimisation

### Utiliser les requ√™tes en lot (batch)

```php
<?php
/**
 * Insertion en lot pour meilleures performances
 */

$pdo = new PDO(
    'mysql:host=localhost;dbname=production_db;charset=utf8mb4',
    'app_user',
    'password',
    [PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION]
);

// ‚ùå LENT : Insertion ligne par ligne
$start = microtime(true);
for ($i = 0; $i < 1000; $i++) {
    $stmt = $pdo->prepare("INSERT INTO logs (message, created_at) VALUES (?, NOW())");
    $stmt->execute(["Message $i"]);
}
$slow_time = microtime(true) - $start;
echo "Insertion ligne par ligne : {$slow_time}s\n";

// ‚úÖ RAPIDE : Insertion en lot avec transaction
$start = microtime(true);
$pdo->beginTransaction();

$stmt = $pdo->prepare("INSERT INTO logs (message, created_at) VALUES (?, NOW())");

for ($i = 0; $i < 1000; $i++) {
    $stmt->execute(["Message $i"]);
}

$pdo->commit();
$fast_time = microtime(true) - $start;
echo "Insertion en lot : {$fast_time}s\n";
echo "Gain de performance : " . round(($slow_time / $fast_time), 2) . "x\n";

// ‚úÖ ENCORE PLUS RAPIDE : Requ√™te multi-valeurs
$start = microtime(true);

$values = [];
$params = [];
for ($i = 0; $i < 1000; $i++) {
    $values[] = "(?)";
    $params[] = "Message $i";
}

$sql = "INSERT INTO logs (message) VALUES " . implode(',', $values);
$stmt = $pdo->prepare($sql);
$stmt->execute($params);

$fastest_time = microtime(true) - $start;
echo "Insertion multi-valeurs : {$fastest_time}s\n";
```

### Utiliser le buffering des r√©sultats

```php
<?php
/**
 * Gestion de la m√©moire avec les gros r√©sultats
 */

// ‚ùå Charge tout en m√©moire (risque de d√©passement)
$stmt = $pdo->query("SELECT * FROM big_table");
$all_rows = $stmt->fetchAll(); // Peut consommer plusieurs Go de RAM

// ‚úÖ Parcourir ligne par ligne (m√©moire constante)
$stmt = $pdo->query("SELECT * FROM big_table");
while ($row = $stmt->fetch()) {
    // Traiter chaque ligne individuellement
    processRow($row);
}

// ‚úÖ Avec mysqli : unbuffered query pour tr√®s gros r√©sultats
$mysqli->real_query("SELECT * FROM big_table");
$result = $mysqli->use_result(); // Mode unbuffered

while ($row = $result->fetch_assoc()) {
    processRow($row);
}

$result->free();
```

---

## ‚úÖ Points cl√©s √† retenir

1. **mysqli vs PDO** : mysqli pour MariaDB-only, PDO pour la portabilit√©
2. **Prepared statements** : TOUJOURS utiliser pour √©viter les injections SQL
3. **Gestion d'erreurs** : Mode exception activ√©, logging c√¥t√© serveur, messages g√©n√©riques c√¥t√© client
4. **Transactions** : Utiliser pour garantir l'atomicit√© des op√©rations critiques
5. **Connection pooling** : ProxySQL recommand√© en production, singleton pour les scripts
6. **S√©curit√©** : Validation des entr√©es, √©chappement des sorties, mots de passe hash√©s, privil√®ges limit√©s
7. **Performance** : Requ√™tes en lot, transactions pour les insertions multiples, parcours ligne par ligne pour les gros r√©sultats
8. **Configuration** : Charset utf8mb4, mode strict, variables d'environnement pour les credentials

---

## üîó Ressources et r√©f√©rences

### Documentation officielle
- [üìñ PHP mysqli](https://www.php.net/manual/fr/book.mysqli.php)
- [üìñ PHP PDO](https://www.php.net/manual/fr/book.pdo.php)
- [üìñ MariaDB Connector/C](https://mariadb.com/kb/en/mariadb-connector-c/)
- [üìñ PHP Security Best Practices](https://www.php.net/manual/fr/security.php)

### Outils et biblioth√®ques
- [ProxySQL](https://proxysql.com/) - Connection pooling et routing
- [PHP-FIG PSR-7](https://www.php-fig.org/psr/psr-7/) - HTTP message interfaces
- [Composer](https://getcomposer.org/) - Gestionnaire de d√©pendances PHP

### Guides de s√©curit√©
- [OWASP PHP Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/PHP_Configuration_Cheat_Sheet.html)
- [OWASP SQL Injection Prevention](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)

---

## ‚û°Ô∏è Section suivante

**17.1.2 Python : mysql-connector, PyMySQL, SQLAlchemy** : D√©couvrez comment connecter Python √† MariaDB avec diff√©rentes biblioth√®ques, de l'utilisation basique aux ORM avanc√©s avec SQLAlchemy.

‚è≠Ô∏è [Python : mysql-connector, PyMySQL, SQLAlchemy](/17-integration-developpement/01.2-python-connectors.md)
