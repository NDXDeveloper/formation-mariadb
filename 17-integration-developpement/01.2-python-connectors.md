üîù Retour au [Sommaire](/SOMMAIRE.md)

# 17.1.2 Python : mysql-connector, PyMySQL, SQLAlchemy

> **Niveau** : Interm√©diaire √† Avanc√©  
> **Dur√©e estim√©e** : 3-4 heures  
> **Pr√©requis** : Connaissances Python 3.8+, bases de donn√©es relationnelles, gestion d'environnements virtuels

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre les diff√©rences entre mysql-connector, PyMySQL et SQLAlchemy
- √âtablir des connexions s√©curis√©es √† MariaDB depuis Python
- Utiliser les parameterized queries pour pr√©venir les injections SQL
- Impl√©menter des context managers pour une gestion robuste des connexions
- Ma√Ætriser SQLAlchemy ORM pour le d√©veloppement rapide et maintenable
- Configurer le connection pooling pour optimiser les performances
- Appliquer les bonnes pratiques de s√©curit√© et d'architecture

---

## Introduction

Python offre plusieurs biblioth√®ques pour interagir avec MariaDB, chacune avec des philosophies diff√©rentes :

- **mysql-connector-python** : Connecteur officiel MySQL/MariaDB, pur Python
- **PyMySQL** : Connecteur pur Python, compatible DB-API 2.0
- **mysqlclient** : Wrapper Python du client C, haute performance
- **SQLAlchemy** : ORM puissant avec support de multiples SGBD

### √âcosyst√®me Python-MariaDB

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          Application Python                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ORM Layer (optionnel)                      ‚îÇ
‚îÇ  ‚îú‚îÄ SQLAlchemy (recommand√©)                 ‚îÇ
‚îÇ  ‚îú‚îÄ Django ORM                              ‚îÇ
‚îÇ  ‚îî‚îÄ Tortoise ORM                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  DB-API 2.0 Drivers                         ‚îÇ
‚îÇ  ‚îú‚îÄ mysql-connector-python (officiel)       ‚îÇ
‚îÇ  ‚îú‚îÄ PyMySQL (pur Python, async capable)     ‚îÇ
‚îÇ  ‚îî‚îÄ mysqlclient (C-based, + rapide)         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ          MariaDB Server                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

üí° **Conseil** : Pour les nouveaux projets, utilisez **SQLAlchemy** avec **PyMySQL** ou **mysqlclient** comme driver. Cette combinaison offre le meilleur √©quilibre entre performance, flexibilit√© et maintenabilit√©.

---

## Comparaison des connecteurs Python

### Tableau comparatif d√©taill√©

| Crit√®re | mysql-connector | PyMySQL | mysqlclient | SQLAlchemy |
|---------|----------------|---------|-------------|------------|
| **Type** | Connecteur | Connecteur | Connecteur | ORM + Core |
| **Impl√©mentation** | Pur Python | Pur Python | C (libmysqlclient) | Abstraction |
| **Performance** | Moyenne | Moyenne | √âlev√©e | Variable |
| **Async support** | ‚ùå Non | ‚úÖ Oui (aiomysql) | ‚ùå Non | ‚úÖ Oui (async) |
| **Installation** | Facile | Facile | N√©cessite compilateur | Facile |
| **DB-API 2.0** | ‚úÖ Compatible | ‚úÖ Compatible | ‚úÖ Compatible | ‚úÖ Compatible |
| **Connection pooling** | ‚úÖ Int√©gr√© | ‚ö†Ô∏è Manuel | ‚ö†Ô∏è Manuel | ‚úÖ Puissant |
| **Transactions** | ‚úÖ Support | ‚úÖ Support | ‚úÖ Support | ‚úÖ Avanc√© |
| **Maintenance** | Oracle | Active | Active | Tr√®s active |
| **Courbe apprentissage** | Facile | Facile | Facile | Moyenne-√âlev√©e |

### Quand utiliser chaque option ?

#### mysql-connector-python
```bash
pip install mysql-connector-python
```
**Utiliser quand :**
- Connecteur officiel souhait√©
- Portabilit√© maximale (pur Python)
- Pas de d√©pendances syst√®me
- Scripts simples ou prototypes

**√âviter si :**
- Performance critique
- Besoin d'async/await
- D√©ploiement sur environnements contraints

#### PyMySQL
```bash
pip install PyMySQL
# Pour async
pip install aiomysql
```
**Utiliser quand :**
- Pur Python requis
- Support async n√©cessaire (avec aiomysql)
- Remplacement drop-in de mysqlclient
- Compatibilit√© maximale

**√âviter si :**
- Performance absolue requise

#### mysqlclient
```bash
# N√©cessite libmysqlclient-dev sur Debian/Ubuntu
sudo apt-get install python3-dev default-libmysqlclient-dev build-essential
pip install mysqlclient
```
**Utiliser quand :**
- Performance maximale
- Production avec charge √©lev√©e
- Legacy Django projects

**√âviter si :**
- Environnement sans compilateur
- Support async requis

#### SQLAlchemy
```bash
pip install sqlalchemy pymysql
# ou
pip install sqlalchemy mysqlclient
```
**Utiliser quand :**
- Application complexe
- Besoin d'ORM
- Migrations de sch√©ma
- Multi-SGBD (portabilit√©)

**√âviter si :**
- Scripts ultra-simples
- Performance critique (utiliser Core, pas ORM)

---

## Installation et configuration

### Setup d'environnement recommand√©

```bash
# Cr√©er un environnement virtuel
python -m venv venv
source venv/bin/activate  # Linux/Mac
# venv\Scripts\activate  # Windows

# Installation compl√®te pour d√©veloppement
pip install sqlalchemy pymysql cryptography python-dotenv

# Alternative haute performance
pip install sqlalchemy mysqlclient

# Pour async
pip install sqlalchemy[asyncio] aiomysql

# Outils de d√©veloppement
pip install ipython pytest pytest-cov
```

### Configuration avec variables d'environnement

```python
# config.py
"""
Configuration centralis√©e avec support .env
"""
import os
from dotenv import load_dotenv

# Charger les variables d'environnement
load_dotenv()

class DatabaseConfig:
    """Configuration de la base de donn√©es"""
    
    HOST = os.getenv('DB_HOST', 'localhost')
    PORT = int(os.getenv('DB_PORT', 3306))
    DATABASE = os.getenv('DB_NAME', 'production_db')
    USER = os.getenv('DB_USER', 'app_user')
    PASSWORD = os.getenv('DB_PASSWORD', '')
    CHARSET = os.getenv('DB_CHARSET', 'utf8mb4')
    
    # Connection pooling
    POOL_SIZE = int(os.getenv('DB_POOL_SIZE', 5))
    MAX_OVERFLOW = int(os.getenv('DB_MAX_OVERFLOW', 10))
    POOL_TIMEOUT = int(os.getenv('DB_POOL_TIMEOUT', 30))
    POOL_RECYCLE = int(os.getenv('DB_POOL_RECYCLE', 3600))
    
    @classmethod
    def get_connection_string(cls) -> str:
        """Construire la cha√Æne de connexion SQLAlchemy"""
        return (
            f"mysql+pymysql://{cls.USER}:{cls.PASSWORD}@"
            f"{cls.HOST}:{cls.PORT}/{cls.DATABASE}"
            f"?charset={cls.CHARSET}"
        )
    
    @classmethod
    def get_connection_params(cls) -> dict:
        """Param√®tres de connexion pour drivers natifs"""
        return {
            'host': cls.HOST,
            'port': cls.PORT,
            'database': cls.DATABASE,
            'user': cls.USER,
            'password': cls.PASSWORD,
            'charset': cls.CHARSET,
        }
```

```env
# .env (√† ne JAMAIS commiter)
DB_HOST=localhost
DB_PORT=3306
DB_NAME=production_db
DB_USER=app_user
DB_PASSWORD=SecureP@ssw0rd!
DB_CHARSET=utf8mb4
DB_POOL_SIZE=5
DB_MAX_OVERFLOW=10
```

---

## Connexion avec mysql-connector-python

### Connexion de base avec context manager

```python
"""
Connexion MariaDB avec mysql-connector-python
Context manager pour gestion automatique
"""
import mysql.connector
from mysql.connector import Error
from contextlib import contextmanager

@contextmanager
def get_db_connection():
    """
    Context manager pour connexion MariaDB
    Fermeture automatique m√™me en cas d'erreur
    """
    connection = None
    try:
        connection = mysql.connector.connect(
            host='localhost',
            port=3306,
            database='production_db',
            user='app_user',
            password='SecureP@ssw0rd!',
            charset='utf8mb4',
            collation='utf8mb4_unicode_ci',
            autocommit=False,  # Transactions explicites
            connection_timeout=10,  # Timeout apr√®s 10 secondes
        )
        
        if connection.is_connected():
            print(f"‚úì Connect√© √† MariaDB {connection.get_server_info()}")
            yield connection
        else:
            raise Error("Connexion impossible")
            
    except Error as e:
        print(f"‚úó Erreur de connexion : {e}")
        raise
    finally:
        if connection and connection.is_connected():
            connection.close()
            print("‚úì Connexion ferm√©e")

# Utilisation
try:
    with get_db_connection() as conn:
        cursor = conn.cursor(dictionary=True)  # R√©sultats en dict
        cursor.execute("SELECT VERSION() as version")
        result = cursor.fetchone()
        print(f"MariaDB version : {result['version']}")
        cursor.close()
        
except Error as e:
    print(f"Erreur : {e}")
```

### Prepared statements et parameterized queries

```python
"""
Exemples de requ√™tes param√©tr√©es avec mysql-connector
ESSENTIEL pour la s√©curit√©
"""
import mysql.connector
from mysql.connector import Error
from datetime import datetime

def example_prepared_statements():
    """D√©monstration des prepared statements"""
    
    try:
        connection = mysql.connector.connect(
            host='localhost',
            database='production_db',
            user='app_user',
            password='SecureP@ssw0rd!',
            charset='utf8mb4'
        )
        
        cursor = connection.cursor(dictionary=True)
        
        # ========================================
        # Exemple 1 : SELECT avec param√®tres
        # ========================================
        
        email = "user@example.com"  # Peut venir de l'utilisateur
        
        # ‚úÖ S√âCURIS√â : Parameterized query
        query = "SELECT id, username, email FROM users WHERE email = %s"
        cursor.execute(query, (email,))
        
        user = cursor.fetchone()
        if user:
            print(f"Utilisateur trouv√© : {user['username']}")
        else:
            print("Utilisateur non trouv√©")
        
        # ========================================
        # Exemple 2 : INSERT avec multiple param√®tres
        # ========================================
        
        insert_query = """
            INSERT INTO users (username, email, password_hash, created_at)
            VALUES (%s, %s, %s, %s)
        """
        
        # Pr√©parer les donn√©es
        import hashlib
        password_hash = hashlib.sha256("password123".encode()).hexdigest()
        
        user_data = (
            "john_doe",
            "john@example.com",
            password_hash,
            datetime.now()
        )
        
        cursor.execute(insert_query, user_data)
        connection.commit()
        
        user_id = cursor.lastrowid
        print(f"Utilisateur cr√©√© avec l'ID : {user_id}")
        
        # ========================================
        # Exemple 3 : UPDATE avec v√©rification
        # ========================================
        
        update_query = """
            UPDATE users 
            SET email = %s, updated_at = %s 
            WHERE id = %s
        """
        
        cursor.execute(update_query, (
            "newemail@example.com",
            datetime.now(),
            user_id
        ))
        connection.commit()
        
        print(f"Lignes modifi√©es : {cursor.rowcount}")
        
        # ========================================
        # Exemple 4 : DELETE avec condition
        # ========================================
        
        # Supprimer les utilisateurs inactifs
        delete_query = """
            DELETE FROM users 
            WHERE last_login < %s AND is_active = %s
        """
        
        # Date il y a 1 an
        from datetime import timedelta
        one_year_ago = datetime.now() - timedelta(days=365)
        
        cursor.execute(delete_query, (one_year_ago, False))
        connection.commit()
        
        print(f"Utilisateurs supprim√©s : {cursor.rowcount}")
        
        cursor.close()
        
    except Error as e:
        print(f"Erreur : {e}")
        if connection:
            connection.rollback()
    finally:
        if connection and connection.is_connected():
            connection.close()

# Ex√©cution
example_prepared_statements()
```

‚ö†Ô∏è **Attention** : Toujours utiliser `%s` comme placeholder avec mysql-connector, jamais de f-strings ou de concat√©nation pour les requ√™tes SQL !

### Gestion des transactions

```python
"""
Transactions avec mysql-connector-python
Exemple : Syst√®me de commande e-commerce
"""
import mysql.connector
from mysql.connector import Error
from decimal import Decimal

def process_order(user_id: int, items: list, total_amount: Decimal):
    """
    Traiter une commande de mani√®re atomique
    
    Args:
        user_id: ID de l'utilisateur
        items: Liste de (product_id, quantity, price)
        total_amount: Montant total
    """
    connection = None
    
    try:
        connection = mysql.connector.connect(
            host='localhost',
            database='ecommerce_db',
            user='app_user',
            password='SecureP@ssw0rd!',
            autocommit=False  # Transactions manuelles
        )
        
        cursor = connection.cursor()
        
        # D√©marrer la transaction (implicite avec autocommit=False)
        
        # √âtape 1 : Cr√©er la commande
        order_query = """
            INSERT INTO orders (user_id, total_amount, status, created_at)
            VALUES (%s, %s, %s, NOW())
        """
        cursor.execute(order_query, (user_id, total_amount, 'pending'))
        order_id = cursor.lastrowid
        
        print(f"Commande cr√©√©e : ID {order_id}")
        
        # √âtape 2 : Ajouter les items et v√©rifier le stock
        item_query = """
            INSERT INTO order_items (order_id, product_id, quantity, price)
            VALUES (%s, %s, %s, %s)
        """
        
        stock_query = """
            UPDATE products 
            SET stock = stock - %s 
            WHERE id = %s AND stock >= %s
        """
        
        for product_id, quantity, price in items:
            # Ins√©rer l'item
            cursor.execute(item_query, (order_id, product_id, quantity, price))
            
            # D√©cr√©menter le stock
            cursor.execute(stock_query, (quantity, product_id, quantity))
            
            if cursor.rowcount == 0:
                raise Exception(f"Stock insuffisant pour le produit {product_id}")
        
        # √âtape 3 : Mettre √† jour le statut
        cursor.execute(
            "UPDATE orders SET status = %s WHERE id = %s",
            ('confirmed', order_id)
        )
        
        # Tout s'est bien pass√© : valider la transaction
        connection.commit()
        print(f"‚úì Commande {order_id} trait√©e avec succ√®s")
        
        return order_id
        
    except Exception as e:
        # Erreur : annuler toutes les modifications
        if connection:
            connection.rollback()
            print(f"‚úó Transaction annul√©e : {e}")
        raise
        
    finally:
        if cursor:
            cursor.close()
        if connection and connection.is_connected():
            connection.close()

# Utilisation
try:
    items = [
        (101, 2, Decimal('29.99')),  # product_id, quantity, price
        (102, 1, Decimal('49.99')),
    ]
    total = Decimal('109.97')
    
    order_id = process_order(user_id=42, items=items, total_amount=total)
    print(f"Commande r√©ussie : #{order_id}")
    
except Exception as e:
    print(f"√âchec de la commande : {e}")
```

---

## Connexion avec PyMySQL

### Connexion de base

```python
"""
Connexion MariaDB avec PyMySQL
Alternative pure Python √† mysqlclient
"""
import pymysql
from pymysql.cursors import DictCursor
from contextlib import contextmanager

@contextmanager
def get_pymysql_connection():
    """Context manager pour connexion PyMySQL"""
    connection = None
    try:
        connection = pymysql.connect(
            host='localhost',
            port=3306,
            user='app_user',
            password='SecureP@ssw0rd!',
            database='production_db',
            charset='utf8mb4',
            cursorclass=DictCursor,  # R√©sultats en dict par d√©faut
            autocommit=False,
            connect_timeout=10,
        )
        yield connection
    except pymysql.Error as e:
        print(f"Erreur PyMySQL : {e}")
        raise
    finally:
        if connection:
            connection.close()

# Utilisation
with get_pymysql_connection() as conn:
    with conn.cursor() as cursor:
        # Requ√™te simple
        cursor.execute("SELECT DATABASE() as db, VERSION() as version")
        info = cursor.fetchone()
        print(f"Base : {info['db']}, Version : {info['version']}")
```

### PyMySQL avec prepared statements

```python
"""
Exemples de requ√™tes s√©curis√©es avec PyMySQL
"""
import pymysql
from pymysql.cursors import DictCursor

def user_crud_operations():
    """Op√©rations CRUD avec PyMySQL"""
    
    connection = pymysql.connect(
        host='localhost',
        user='app_user',
        password='SecureP@ssw0rd!',
        database='production_db',
        charset='utf8mb4',
        cursorclass=DictCursor
    )
    
    try:
        with connection.cursor() as cursor:
            
            # CREATE
            insert_sql = """
                INSERT INTO users (username, email, password_hash)
                VALUES (%s, %s, %s)
            """
            cursor.execute(insert_sql, ('alice', 'alice@example.com', 'hash123'))
            connection.commit()
            user_id = cursor.lastrowid
            print(f"Utilisateur cr√©√© : ID {user_id}")
            
            # READ
            select_sql = "SELECT * FROM users WHERE id = %s"
            cursor.execute(select_sql, (user_id,))
            user = cursor.fetchone()
            print(f"Utilisateur : {user}")
            
            # UPDATE
            update_sql = "UPDATE users SET email = %s WHERE id = %s"
            cursor.execute(update_sql, ('newemail@example.com', user_id))
            connection.commit()
            print(f"Lignes modifi√©es : {cursor.rowcount}")
            
            # READ ALL with pagination
            select_all_sql = """
                SELECT id, username, email 
                FROM users 
                ORDER BY created_at DESC 
                LIMIT %s OFFSET %s
            """
            cursor.execute(select_all_sql, (10, 0))  # 10 premiers r√©sultats
            users = cursor.fetchall()
            print(f"Utilisateurs trouv√©s : {len(users)}")
            
            # DELETE
            delete_sql = "DELETE FROM users WHERE id = %s"
            cursor.execute(delete_sql, (user_id,))
            connection.commit()
            print(f"Utilisateur supprim√© : {cursor.rowcount} ligne(s)")
            
    except pymysql.Error as e:
        connection.rollback()
        print(f"Erreur : {e}")
        raise
    finally:
        connection.close()
```

### PyMySQL async avec aiomysql

```python
"""
Connexion asynchrone avec aiomysql
Id√©al pour FastAPI, aiohttp, etc.
"""
import asyncio
import aiomysql

async def async_database_operations():
    """Op√©rations asynchrones avec aiomysql"""
    
    # Cr√©er un pool de connexions
    pool = await aiomysql.create_pool(
        host='localhost',
        port=3306,
        user='app_user',
        password='SecureP@ssw0rd!',
        db='production_db',
        charset='utf8mb4',
        minsize=1,
        maxsize=10,
        autocommit=False,
    )
    
    try:
        # Acqu√©rir une connexion du pool
        async with pool.acquire() as conn:
            async with conn.cursor(aiomysql.DictCursor) as cursor:
                
                # SELECT
                await cursor.execute(
                    "SELECT id, username FROM users WHERE email = %s",
                    ('user@example.com',)
                )
                user = await cursor.fetchone()
                print(f"User: {user}")
                
                # INSERT
                await cursor.execute(
                    "INSERT INTO logs (message, created_at) VALUES (%s, NOW())",
                    ('Async operation',)
                )
                await conn.commit()
                
                # Fetch multiple
                await cursor.execute("SELECT * FROM products LIMIT 10")
                products = await cursor.fetchall()
                print(f"Products: {len(products)}")
                
    finally:
        pool.close()
        await pool.wait_closed()

# Ex√©cution
asyncio.run(async_database_operations())
```

üí° **Conseil** : Pour les applications web modernes (FastAPI, Quart), utilisez **aiomysql** pour b√©n√©ficier de l'async/await et maximiser la concurrence.

---

## SQLAlchemy : L'ORM de r√©f√©rence

### SQLAlchemy Core vs ORM

SQLAlchemy offre deux approches :

1. **Core** : API SQL bas niveau, haute performance
2. **ORM** : Mapping objet-relationnel, productivit√© accrue

### Configuration SQLAlchemy

```python
"""
Configuration SQLAlchemy avec best practices
"""
from sqlalchemy import create_engine, event
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy.pool import QueuePool

# Base pour les mod√®les ORM
Base = declarative_base()

class DatabaseManager:
    """Gestionnaire centralis√© de la base de donn√©es"""
    
    def __init__(self, connection_string: str):
        """
        Initialiser le moteur SQLAlchemy
        
        Args:
            connection_string: URL de connexion SQLAlchemy
                Format: mysql+pymysql://user:pass@host:port/db
        """
        self.engine = create_engine(
            connection_string,
            
            # Connection pooling
            poolclass=QueuePool,
            pool_size=5,              # Connexions permanentes
            max_overflow=10,          # Connexions additionnelles
            pool_timeout=30,          # Timeout acquisition connexion
            pool_recycle=3600,        # Recycler apr√®s 1h
            pool_pre_ping=True,       # V√©rifier connexion avant usage
            
            # Logging (d√©sactiver en production)
            echo=False,               # Mettre True pour debug SQL
            echo_pool=False,          # Logs du pool
            
            # Performances
            isolation_level="READ COMMITTED",
        )
        
        # Configurer les √©v√©nements
        self._setup_engine_events()
        
        # Session factory
        self.SessionLocal = sessionmaker(
            bind=self.engine,
            autocommit=False,
            autoflush=False,
            expire_on_commit=False,  # Garder les objets apr√®s commit
        )
    
    def _setup_engine_events(self):
        """Configurer les √©v√©nements du moteur"""
        
        @event.listens_for(self.engine, "connect")
        def receive_connect(dbapi_conn, connection_record):
            """√âv√©nement √† la connexion"""
            # Configurer le charset
            cursor = dbapi_conn.cursor()
            cursor.execute("SET NAMES utf8mb4 COLLATE utf8mb4_unicode_ci")
            cursor.execute("SET time_zone = '+00:00'")  # UTC
            cursor.close()
    
    def get_session(self):
        """Obtenir une nouvelle session"""
        return self.SessionLocal()
    
    def create_all_tables(self):
        """Cr√©er toutes les tables (d√©veloppement uniquement)"""
        Base.metadata.create_all(bind=self.engine)
    
    def drop_all_tables(self):
        """Supprimer toutes les tables (d√©veloppement uniquement)"""
        Base.metadata.drop_all(bind=self.engine)

# Initialisation globale
from config import DatabaseConfig

db_manager = DatabaseManager(DatabaseConfig.get_connection_string())
```

### D√©finition de mod√®les ORM

```python
"""
Mod√®les SQLAlchemy avec relations et validations
"""
from sqlalchemy import (
    Column, Integer, String, Text, Boolean, DateTime, 
    Numeric, ForeignKey, Index, UniqueConstraint, CheckConstraint
)
from sqlalchemy.orm import relationship, validates
from sqlalchemy.sql import func
from datetime import datetime
import re

from database import Base

class User(Base):
    """Mod√®le Utilisateur"""
    __tablename__ = 'users'
    
    # Colonnes
    id = Column(Integer, primary_key=True, autoincrement=True)
    username = Column(String(50), unique=True, nullable=False, index=True)
    email = Column(String(255), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    first_name = Column(String(100))
    last_name = Column(String(100))
    is_active = Column(Boolean, default=True, nullable=False)
    is_admin = Column(Boolean, default=False, nullable=False)
    
    # Timestamps automatiques
    created_at = Column(DateTime, server_default=func.now(), nullable=False)
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    last_login = Column(DateTime)
    
    # Relations (lazy loading par d√©faut)
    orders = relationship("Order", back_populates="user", lazy='dynamic')
    addresses = relationship("Address", back_populates="user", cascade="all, delete-orphan")
    
    # Index composites
    __table_args__ = (
        Index('idx_user_name', 'first_name', 'last_name'),
        Index('idx_user_active_created', 'is_active', 'created_at'),
    )
    
    # Validations
    @validates('email')
    def validate_email(self, key, email):
        """Valider le format de l'email"""
        if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', email):
            raise ValueError("Format d'email invalide")
        return email.lower()
    
    @validates('username')
    def validate_username(self, key, username):
        """Valider le nom d'utilisateur"""
        if len(username) < 3:
            raise ValueError("Username trop court (min 3 caract√®res)")
        if not re.match(r'^[a-zA-Z0-9_]+$', username):
            raise ValueError("Username invalide (alphanumerique et _ uniquement)")
        return username
    
    def __repr__(self):
        return f"<User(id={self.id}, username='{self.username}', email='{self.email}')>"
    
    def to_dict(self):
        """Convertir en dictionnaire (pour API)"""
        return {
            'id': self.id,
            'username': self.username,
            'email': self.email,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'is_active': self.is_active,
            'created_at': self.created_at.isoformat() if self.created_at else None,
        }


class Address(Base):
    """Mod√®le Adresse"""
    __tablename__ = 'addresses'
    
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    address_type = Column(String(20))  # billing, shipping
    street = Column(String(255), nullable=False)
    city = Column(String(100), nullable=False)
    postal_code = Column(String(20), nullable=False)
    country = Column(String(2), nullable=False)  # Code ISO
    
    created_at = Column(DateTime, server_default=func.now())
    
    # Relation
    user = relationship("User", back_populates="addresses")
    
    __table_args__ = (
        CheckConstraint("address_type IN ('billing', 'shipping')", name='check_address_type'),
        Index('idx_address_user', 'user_id', 'address_type'),
    )


class Product(Base):
    """Mod√®le Produit"""
    __tablename__ = 'products'
    
    id = Column(Integer, primary_key=True)
    name = Column(String(255), nullable=False)
    description = Column(Text)
    price = Column(Numeric(10, 2), nullable=False)
    stock = Column(Integer, default=0, nullable=False)
    is_active = Column(Boolean, default=True)
    
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, onupdate=func.now())
    
    # Relation
    order_items = relationship("OrderItem", back_populates="product")
    
    __table_args__ = (
        CheckConstraint('price >= 0', name='check_price_positive'),
        CheckConstraint('stock >= 0', name='check_stock_positive'),
        Index('idx_product_active_price', 'is_active', 'price'),
    )


class Order(Base):
    """Mod√®le Commande"""
    __tablename__ = 'orders'
    
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)
    total_amount = Column(Numeric(10, 2), nullable=False)
    status = Column(String(20), default='pending')
    
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, onupdate=func.now())
    
    # Relations
    user = relationship("User", back_populates="orders")
    items = relationship("OrderItem", back_populates="order", cascade="all, delete-orphan")
    
    __table_args__ = (
        CheckConstraint(
            "status IN ('pending', 'confirmed', 'shipped', 'delivered', 'cancelled')",
            name='check_order_status'
        ),
        Index('idx_order_user_status', 'user_id', 'status'),
    )


class OrderItem(Base):
    """Mod√®le Item de commande"""
    __tablename__ = 'order_items'
    
    id = Column(Integer, primary_key=True)
    order_id = Column(Integer, ForeignKey('orders.id', ondelete='CASCADE'), nullable=False)
    product_id = Column(Integer, ForeignKey('products.id'), nullable=False)
    quantity = Column(Integer, nullable=False)
    price = Column(Numeric(10, 2), nullable=False)  # Prix au moment de la commande
    
    # Relations
    order = relationship("Order", back_populates="items")
    product = relationship("Product", back_populates="order_items")
    
    __table_args__ = (
        CheckConstraint('quantity > 0', name='check_quantity_positive'),
        UniqueConstraint('order_id', 'product_id', name='uq_order_product'),
        Index('idx_orderitem_order', 'order_id'),
    )
```

### Op√©rations CRUD avec SQLAlchemy ORM

```python
"""
Op√©rations CRUD avec SQLAlchemy ORM
"""
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from database import db_manager
from models import User, Product, Order, OrderItem
from decimal import Decimal
import bcrypt

class UserRepository:
    """Repository pour les op√©rations utilisateur"""
    
    def __init__(self, session: Session):
        self.session = session
    
    def create_user(self, username: str, email: str, password: str, **kwargs) -> User:
        """Cr√©er un utilisateur"""
        
        # Hasher le mot de passe
        password_hash = bcrypt.hashpw(
            password.encode('utf-8'),
            bcrypt.gensalt()
        ).decode('utf-8')
        
        user = User(
            username=username,
            email=email,
            password_hash=password_hash,
            **kwargs
        )
        
        try:
            self.session.add(user)
            self.session.commit()
            self.session.refresh(user)  # Rafra√Æchir pour avoir l'ID
            return user
        except IntegrityError as e:
            self.session.rollback()
            if 'username' in str(e):
                raise ValueError("Ce nom d'utilisateur existe d√©j√†")
            elif 'email' in str(e):
                raise ValueError("Cet email existe d√©j√†")
            raise
    
    def get_user_by_id(self, user_id: int) -> User | None:
        """R√©cup√©rer un utilisateur par ID"""
        return self.session.query(User).filter(User.id == user_id).first()
    
    def get_user_by_email(self, email: str) -> User | None:
        """R√©cup√©rer un utilisateur par email"""
        return self.session.query(User).filter(User.email == email).first()
    
    def get_all_users(self, skip: int = 0, limit: int = 100) -> list[User]:
        """R√©cup√©rer tous les utilisateurs avec pagination"""
        return (
            self.session.query(User)
            .filter(User.is_active == True)
            .order_by(User.created_at.desc())
            .offset(skip)
            .limit(limit)
            .all()
        )
    
    def update_user(self, user_id: int, **kwargs) -> User:
        """Mettre √† jour un utilisateur"""
        user = self.get_user_by_id(user_id)
        if not user:
            raise ValueError("Utilisateur non trouv√©")
        
        # Filtrer les champs autoris√©s
        allowed_fields = {'first_name', 'last_name', 'email', 'is_active'}
        for key, value in kwargs.items():
            if key in allowed_fields:
                setattr(user, key, value)
        
        try:
            self.session.commit()
            self.session.refresh(user)
            return user
        except IntegrityError:
            self.session.rollback()
            raise ValueError("Email d√©j√† utilis√©")
    
    def delete_user(self, user_id: int) -> bool:
        """Supprimer un utilisateur"""
        user = self.get_user_by_id(user_id)
        if not user:
            return False
        
        self.session.delete(user)
        self.session.commit()
        return True
    
    def authenticate(self, email: str, password: str) -> User | None:
        """Authentifier un utilisateur"""
        user = self.get_user_by_email(email)
        if not user:
            return None
        
        # V√©rifier le mot de passe
        if bcrypt.checkpw(password.encode('utf-8'), user.password_hash.encode('utf-8')):
            # Mettre √† jour last_login
            user.last_login = datetime.now()
            self.session.commit()
            return user
        
        return None


class OrderRepository:
    """Repository pour les commandes"""
    
    def __init__(self, session: Session):
        self.session = session
    
    def create_order(self, user_id: int, items: list[dict]) -> Order:
        """
        Cr√©er une commande avec items
        
        Args:
            user_id: ID de l'utilisateur
            items: Liste de {'product_id': int, 'quantity': int}
        """
        
        # Calculer le total et v√©rifier le stock
        total_amount = Decimal('0.00')
        order_items = []
        
        for item_data in items:
            product = self.session.query(Product).filter(
                Product.id == item_data['product_id']
            ).first()
            
            if not product:
                raise ValueError(f"Produit {item_data['product_id']} non trouv√©")
            
            if product.stock < item_data['quantity']:
                raise ValueError(f"Stock insuffisant pour {product.name}")
            
            item_total = product.price * item_data['quantity']
            total_amount += item_total
            
            order_items.append({
                'product': product,
                'quantity': item_data['quantity'],
                'price': product.price,
                'total': item_total
            })
        
        # Cr√©er la commande (transaction)
        try:
            order = Order(
                user_id=user_id,
                total_amount=total_amount,
                status='pending'
            )
            self.session.add(order)
            self.session.flush()  # Obtenir l'ID sans commit
            
            # Ajouter les items et d√©cr√©menter le stock
            for item_info in order_items:
                order_item = OrderItem(
                    order_id=order.id,
                    product_id=item_info['product'].id,
                    quantity=item_info['quantity'],
                    price=item_info['price']
                )
                self.session.add(order_item)
                
                # D√©cr√©menter le stock
                item_info['product'].stock -= item_info['quantity']
            
            self.session.commit()
            self.session.refresh(order)
            
            return order
            
        except Exception as e:
            self.session.rollback()
            raise
    
    def get_order_with_items(self, order_id: int) -> Order | None:
        """R√©cup√©rer une commande avec ses items (eager loading)"""
        from sqlalchemy.orm import joinedload
        
        return (
            self.session.query(Order)
            .options(joinedload(Order.items).joinedload(OrderItem.product))
            .filter(Order.id == order_id)
            .first()
        )
    
    def get_user_orders(self, user_id: int) -> list[Order]:
        """R√©cup√©rer toutes les commandes d'un utilisateur"""
        return (
            self.session.query(Order)
            .filter(Order.user_id == user_id)
            .order_by(Order.created_at.desc())
            .all()
        )


# ========================================
# Utilisation des repositories
# ========================================

def example_usage():
    """Exemple d'utilisation compl√®te"""
    
    # Cr√©er les tables (dev only)
    db_manager.create_all_tables()
    
    # Obtenir une session
    session = db_manager.get_session()
    
    try:
        # Repositories
        user_repo = UserRepository(session)
        order_repo = OrderRepository(session)
        
        # Cr√©er un utilisateur
        user = user_repo.create_user(
            username='alice_dev',
            email='alice@example.com',
            password='SecureP@ss123!',
            first_name='Alice',
            last_name='Dupont'
        )
        print(f"‚úì Utilisateur cr√©√© : {user.username} (ID: {user.id})")
        
        # Cr√©er des produits
        products = [
            Product(name='Laptop', price=Decimal('999.99'), stock=10),
            Product(name='Mouse', price=Decimal('29.99'), stock=50),
            Product(name='Keyboard', price=Decimal('79.99'), stock=30),
        ]
        session.add_all(products)
        session.commit()
        print(f"‚úì {len(products)} produits cr√©√©s")
        
        # Cr√©er une commande
        order = order_repo.create_order(
            user_id=user.id,
            items=[
                {'product_id': products[0].id, 'quantity': 1},
                {'product_id': products[1].id, 'quantity': 2},
            ]
        )
        print(f"‚úì Commande cr√©√©e : #{order.id}, Total: {order.total_amount}‚Ç¨")
        
        # R√©cup√©rer la commande avec items
        order_full = order_repo.get_order_with_items(order.id)
        print(f"‚úì Commande #{order_full.id} avec {len(order_full.items)} items")
        for item in order_full.items:
            print(f"  - {item.product.name}: {item.quantity}x {item.price}‚Ç¨")
        
        # Lister les utilisateurs
        users = user_repo.get_all_users()
        print(f"‚úì {len(users)} utilisateurs actifs")
        
    except Exception as e:
        print(f"‚úó Erreur : {e}")
        session.rollback()
    finally:
        session.close()

if __name__ == '__main__':
    example_usage()
```

### Requ√™tes avanc√©es avec SQLAlchemy

```python
"""
Requ√™tes avanc√©es et optimisations SQLAlchemy
"""
from sqlalchemy import func, and_, or_, desc, case, text
from sqlalchemy.orm import joinedload, selectinload, subqueryload
from models import User, Order, Product, OrderItem
from database import db_manager

def advanced_queries():
    """Exemples de requ√™tes avanc√©es"""
    
    session = db_manager.get_session()
    
    try:
        # ========================================
        # Agr√©gations et groupements
        # ========================================
        
        # Nombre de commandes par utilisateur
        user_order_counts = (
            session.query(
                User.username,
                func.count(Order.id).label('order_count'),
                func.sum(Order.total_amount).label('total_spent')
            )
            .join(Order)
            .group_by(User.id, User.username)
            .having(func.count(Order.id) > 0)
            .all()
        )
        
        for username, count, total in user_order_counts:
            print(f"{username}: {count} commandes, {total}‚Ç¨")
        
        # ========================================
        # Sous-requ√™tes
        # ========================================
        
        # Utilisateurs avec des commandes r√©centes
        from datetime import datetime, timedelta
        recent_date = datetime.now() - timedelta(days=30)
        
        recent_orders_subq = (
            session.query(Order.user_id)
            .filter(Order.created_at >= recent_date)
            .distinct()
            .subquery()
        )
        
        active_users = (
            session.query(User)
            .filter(User.id.in_(recent_orders_subq))
            .all()
        )
        print(f"{len(active_users)} utilisateurs actifs (30 derniers jours)")
        
        # ========================================
        # Jointures complexes
        # ========================================
        
        # Produits les plus vendus
        top_products = (
            session.query(
                Product.name,
                func.sum(OrderItem.quantity).label('total_sold'),
                func.count(OrderItem.id).label('times_ordered')
            )
            .join(OrderItem)
            .group_by(Product.id, Product.name)
            .order_by(desc('total_sold'))
            .limit(10)
            .all()
        )
        
        print("\nTop 10 produits :")
        for name, total_sold, times in top_products:
            print(f"  {name}: {total_sold} unit√©s ({times} commandes)")
        
        # ========================================
        # Expressions CASE
        # ========================================
        
        # Cat√©goriser les utilisateurs par activit√©
        user_categories = (
            session.query(
                User.username,
                func.count(Order.id).label('order_count'),
                case(
                    (func.count(Order.id) == 0, 'Inactif'),
                    (func.count(Order.id).between(1, 5), 'Occasionnel'),
                    (func.count(Order.id).between(6, 20), 'R√©gulier'),
                    else_='VIP'
                ).label('category')
            )
            .outerjoin(Order)
            .group_by(User.id, User.username)
            .all()
        )
        
        print("\nCat√©gories utilisateurs :")
        for username, count, category in user_categories:
            print(f"  {username}: {category} ({count} commandes)")
        
        # ========================================
        # Eager Loading pour √©viter N+1
        # ========================================
        
        # ‚ùå MAUVAIS : N+1 queries
        users_bad = session.query(User).all()
        for user in users_bad:
            print(f"{user.username}: {len(user.orders.all())} commandes")  # N queries !
        
        # ‚úÖ BON : Jointure (1 query)
        users_good = (
            session.query(User)
            .options(joinedload(User.orders))  # LEFT JOIN
            .all()
        )
        for user in users_good:
            print(f"{user.username}: {len(user.orders)} commandes")  # Pas de query !
        
        # ‚úÖ Alternative : selectinload (2 queries au lieu de N+1)
        users_select = (
            session.query(User)
            .options(selectinload(User.orders))  # SELECT s√©par√© optimis√©
            .all()
        )
        
        # ========================================
        # Filtres dynamiques
        # ========================================
        
        def get_filtered_users(
            is_active: bool = None,
            search: str = None,
            min_orders: int = None
        ):
            """Filtrage dynamique"""
            query = session.query(User)
            
            if is_active is not None:
                query = query.filter(User.is_active == is_active)
            
            if search:
                query = query.filter(
                    or_(
                        User.username.like(f'%{search}%'),
                        User.email.like(f'%{search}%'),
                        User.first_name.like(f'%{search}%')
                    )
                )
            
            if min_orders:
                query = (
                    query.join(Order)
                    .group_by(User.id)
                    .having(func.count(Order.id) >= min_orders)
                )
            
            return query.all()
        
        # Utilisation
        results = get_filtered_users(is_active=True, search='alice', min_orders=1)
        print(f"\nUtilisateurs filtr√©s : {len(results)}")
        
        # ========================================
        # Raw SQL quand n√©cessaire
        # ========================================
        
        # Pour des requ√™tes tr√®s sp√©cifiques
        raw_results = session.execute(
            text("""
                SELECT 
                    u.username,
                    COUNT(o.id) as order_count,
                    COALESCE(SUM(o.total_amount), 0) as total_spent
                FROM users u
                LEFT JOIN orders o ON u.id = o.user_id
                WHERE u.is_active = :is_active
                GROUP BY u.id, u.username
                HAVING total_spent > :min_spent
                ORDER BY total_spent DESC
            """),
            {'is_active': True, 'min_spent': 100}
        ).fetchall()
        
        print("\nGros acheteurs (Raw SQL) :")
        for username, count, total in raw_results:
            print(f"  {username}: {count} commandes, {total}‚Ç¨")
        
    finally:
        session.close()

if __name__ == '__main__':
    advanced_queries()
```

üí° **Conseil** : Utilisez `joinedload` pour les relations one-to-one/many-to-one, `selectinload` pour one-to-many/many-to-many avec beaucoup de donn√©es.

---

## Connection Pooling avanc√©

### Configuration du pool SQLAlchemy

```python
"""
Configuration avanc√©e du connection pooling
"""
from sqlalchemy import create_engine, event, pool
from sqlalchemy.pool import QueuePool, NullPool, StaticPool

def create_production_engine():
    """Configuration production avec pool optimis√©"""
    
    engine = create_engine(
        'mysql+pymysql://user:pass@localhost/db',
        
        # QueuePool (par d√©faut, recommand√©)
        poolclass=QueuePool,
        
        # Taille du pool
        pool_size=10,              # Connexions permanentes
        max_overflow=20,           # Connexions temporaires suppl√©mentaires
        
        # Timeouts
        pool_timeout=30,           # Timeout pour obtenir une connexion
        pool_recycle=3600,         # Recycler les connexions apr√®s 1h
        pool_pre_ping=True,        # V√©rifier avant utilisation (MariaDB peut timeout)
        
        # Strat√©gie de recyclage
        pool_use_lifo=True,        # Last-In-First-Out (garde connexions chaudes)
        
        # √âv√©nements pour monitoring
        echo_pool='debug',         # Logs du pool (dev only)
    )
    
    # √âv√©nements personnalis√©s
    @event.listens_for(engine, "connect")
    def receive_connect(dbapi_conn, connection_record):
        """Configuration √† chaque nouvelle connexion"""
        cursor = dbapi_conn.cursor()
        
        # Charset et collation
        cursor.execute("SET NAMES utf8mb4 COLLATE utf8mb4_unicode_ci")
        
        # Timezone UTC
        cursor.execute("SET time_zone = '+00:00'")
        
        # Mode SQL strict
        cursor.execute("""
            SET SESSION sql_mode = 
            'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION'
        """)
        
        # Timeout pour les requ√™tes longues
        cursor.execute("SET SESSION max_execution_time = 30000")  # 30 secondes
        
        cursor.close()
    
    @event.listens_for(engine, "checkout")
    def receive_checkout(dbapi_conn, connection_record, connection_proxy):
        """Quand une connexion est emprunt√©e du pool"""
        # Compter les checkouts (monitoring)
        connection_record.info.setdefault('checkout_count', 0)
        connection_record.info['checkout_count'] += 1
    
    @event.listens_for(engine, "checkin")
    def receive_checkin(dbapi_conn, connection_record):
        """Quand une connexion retourne au pool"""
        # Nettoyer les variables de session si n√©cessaire
        pass
    
    return engine


def create_testing_engine():
    """Configuration pour les tests (pool minimal)"""
    
    return create_engine(
        'mysql+pymysql://test:test@localhost/test_db',
        poolclass=StaticPool,  # Pool statique (1 connexion partag√©e)
        echo=True,             # Logs SQL pour debug
    )


def create_no_pool_engine():
    """Sans pooling (cas sp√©cifiques)"""
    
    return create_engine(
        'mysql+pymysql://user:pass@localhost/db',
        poolclass=NullPool,  # Pas de pool, nouvelle connexion √† chaque fois
    )
```

### Monitoring du pool

```python
"""
Monitoring et diagnostics du connection pool
"""
from sqlalchemy import create_engine
import time

def monitor_pool(engine):
    """Afficher les statistiques du pool"""
    
    pool = engine.pool
    
    print(f"""
    === Pool Statistics ===
    Pool size (permanent): {pool.size()}
    Connections in use: {pool.checkedin()}
    Available connections: {pool.size() - pool.checkedin()}
    Overflow connections: {pool.overflow()}
    Timeout: {pool.timeout()}
    """)


def pool_stress_test():
    """Test de charge du pool"""
    
    engine = create_engine(
        'mysql+pymysql://user:pass@localhost/db',
        pool_size=5,
        max_overflow=10,
        pool_timeout=5,
    )
    
    from concurrent.futures import ThreadPoolExecutor
    import random
    
    def worker(worker_id):
        """Simule une t√¢che utilisant la base"""
        try:
            with engine.connect() as conn:
                # Simuler une requ√™te
                result = conn.execute(text("SELECT SLEEP(0.1), :id"), {'id': worker_id})
                result.fetchall()
                return f"Worker {worker_id}: OK"
        except Exception as e:
            return f"Worker {worker_id}: ERROR - {e}"
    
    # Lancer 50 workers en parall√®le (pool = 5 + 10 overflow)
    with ThreadPoolExecutor(max_workers=50) as executor:
        start = time.time()
        results = list(executor.map(worker, range(50)))
        duration = time.time() - start
    
    print(f"\nTest termin√© en {duration:.2f}s")
    print(f"Succ√®s : {sum(1 for r in results if 'OK' in r)}/50")
    
    monitor_pool(engine)
```

---

## Bonnes pratiques de s√©curit√©

### 1. Pr√©vention des injections SQL

```python
"""
Exemples d'injections SQL et pr√©vention
"""

# ‚ùå DANGER : Injection SQL possible
def vulnerable_login(username, password):
    """NE JAMAIS FAIRE CELA !"""
    query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
    # Si username = "admin' OR '1'='1" ‚Üí bypass authentification !

# ‚úÖ S√âCURIS√â : Parameterized query
def safe_login_pymysql(username, password):
    """Version s√©curis√©e avec PyMySQL"""
    import pymysql
    
    conn = pymysql.connect(...)
    cursor = conn.cursor()
    
    # Les param√®tres sont √©chapp√©s automatiquement
    cursor.execute(
        "SELECT * FROM users WHERE username = %s AND password_hash = %s",
        (username, hash_password(password))
    )
    return cursor.fetchone()

# ‚úÖ S√âCURIS√â : SQLAlchemy ORM
def safe_login_sqlalchemy(session, username, password):
    """Version s√©curis√©e avec SQLAlchemy"""
    from sqlalchemy import and_
    
    user = (
        session.query(User)
        .filter(and_(
            User.username == username,  # Automatiquement param√©tris√©
            User.is_active == True
        ))
        .first()
    )
    
    if user and verify_password(password, user.password_hash):
        return user
    return None
```

### 2. Hashing s√©curis√© des mots de passe

```python
"""
Gestion s√©curis√©e des mots de passe avec bcrypt
"""
import bcrypt

def hash_password(password: str) -> str:
    """Hasher un mot de passe avec bcrypt"""
    
    # G√©n√©rer un salt (facteur de co√ªt = 12)
    salt = bcrypt.gensalt(rounds=12)
    
    # Hasher
    password_hash = bcrypt.hashpw(password.encode('utf-8'), salt)
    
    return password_hash.decode('utf-8')


def verify_password(password: str, password_hash: str) -> bool:
    """V√©rifier un mot de passe"""
    
    return bcrypt.checkpw(
        password.encode('utf-8'),
        password_hash.encode('utf-8')
    )


# Alternative avec passlib (plus de flexibilit√©)
from passlib.context import CryptContext

pwd_context = CryptContext(
    schemes=["bcrypt"],
    deprecated="auto",
    bcrypt__rounds=12,
)

def hash_password_passlib(password: str) -> str:
    """Hasher avec passlib"""
    return pwd_context.hash(password)


def verify_password_passlib(password: str, hash: str) -> bool:
    """V√©rifier avec passlib"""
    return pwd_context.verify(password, hash)
```

### 3. Protection contre les attaques temporelles

```python
"""
Pr√©vention timing attacks lors de l'authentification
"""
import hmac

def constant_time_compare(a: str, b: str) -> bool:
    """Comparaison en temps constant"""
    return hmac.compare_digest(a, b)

def authenticate_user_secure(session, email: str, password: str):
    """Authentification r√©sistante aux timing attacks"""
    
    # Toujours hasher le mot de passe, m√™me si l'utilisateur n'existe pas
    # √âvite de r√©v√©ler l'existence d'un compte par le temps de r√©ponse
    
    user = session.query(User).filter(User.email == email).first()
    
    if user is None:
        # Hasher quand m√™me pour avoir le m√™me temps de r√©ponse
        bcrypt.hashpw(b"dummy", bcrypt.gensalt())
        return None
    
    # V√©rification du mot de passe
    if bcrypt.checkpw(password.encode(), user.password_hash.encode()):
        return user
    
    return None
```

### 4. Validation et sanitization

```python
"""
Validation robuste des entr√©es utilisateur
"""
from pydantic import BaseModel, EmailStr, Field, validator
import re

class UserCreate(BaseModel):
    """Mod√®le de validation pour cr√©ation utilisateur"""
    
    username: str = Field(..., min_length=3, max_length=50)
    email: EmailStr
    password: str = Field(..., min_length=12)
    first_name: str | None = Field(None, max_length=100)
    last_name: str | None = Field(None, max_length=100)
    
    @validator('username')
    def validate_username(cls, v):
        """Valider le format du username"""
        if not re.match(r'^[a-zA-Z0-9_]+$', v):
            raise ValueError('Username invalide (alphanum√©rique et _ uniquement)')
        return v.lower()
    
    @validator('password')
    def validate_password_strength(cls, v):
        """V√©rifier la force du mot de passe"""
        if not re.search(r'[A-Z]', v):
            raise ValueError('Le mot de passe doit contenir une majuscule')
        if not re.search(r'[a-z]', v):
            raise ValueError('Le mot de passe doit contenir une minuscule')
        if not re.search(r'[0-9]', v):
            raise ValueError('Le mot de passe doit contenir un chiffre')
        if not re.search(r'[!@#$%^&*(),.?":{}|<>]', v):
            raise ValueError('Le mot de passe doit contenir un caract√®re sp√©cial')
        return v


# Utilisation
def create_user_validated(session, user_data: dict):
    """Cr√©er un utilisateur avec validation"""
    try:
        # Valider les donn√©es
        validated = UserCreate(**user_data)
        
        # Cr√©er l'utilisateur
        user = User(
            username=validated.username,
            email=validated.email,
            password_hash=hash_password(validated.password),
            first_name=validated.first_name,
            last_name=validated.last_name,
        )
        
        session.add(user)
        session.commit()
        
        return user
        
    except ValueError as e:
        print(f"Validation error: {e}")
        raise
```

### 5. Limitation des privil√®ges database

```sql
-- Cr√©er un utilisateur avec privil√®ges minimaux
CREATE USER 'app_user'@'localhost' IDENTIFIED BY 'SecureP@ssw0rd!';

-- Accorder seulement les privil√®ges n√©cessaires
GRANT SELECT, INSERT, UPDATE, DELETE ON production_db.* TO 'app_user'@'localhost';

-- Ne PAS donner :
-- - DROP, CREATE, ALTER (sauf pour les migrations)
-- - GRANT OPTION
-- - SUPER, PROCESS
-- - FILE (permet LOAD DATA LOCAL INFILE)

FLUSH PRIVILEGES;
```

---

## ‚úÖ Points cl√©s √† retenir

1. **Choix du connecteur** : SQLAlchemy + PyMySQL pour la plupart des projets, mysqlclient pour la performance
2. **ORM vs Raw SQL** : ORM pour la productivit√©, Raw SQL pour les requ√™tes complexes
3. **S√©curit√©** : TOUJOURS utiliser parameterized queries, jamais de string formatting
4. **Connection pooling** : pool_size=5-10 pour la plupart des apps, pool_pre_ping=True obligatoire
5. **Transactions** : Utiliser context managers et g√©rer explicitement commit/rollback
6. **Mots de passe** : bcrypt avec rounds=12 minimum, v√©rification en temps constant
7. **Validation** : Pydantic pour valider toutes les entr√©es utilisateur
8. **Performance** : Eager loading (joinedload/selectinload) pour √©viter N+1, batch operations
9. **Async** : aiomysql pour FastAPI/async frameworks
10. **Monitoring** : Surveiller les stats du pool, logs SQL en d√©veloppement uniquement

---

## üîó Ressources et r√©f√©rences

### Documentation officielle
- [üìñ SQLAlchemy Documentation](https://docs.sqlalchemy.org/)
- [üìñ PyMySQL Documentation](https://pymysql.readthedocs.io/)
- [üìñ mysql-connector-python](https://dev.mysql.com/doc/connector-python/en/)
- [üìñ aiomysql](https://aiomysql.readthedocs.io/)

### Guides et tutoriels
- [SQLAlchemy Tutorial](https://docs.sqlalchemy.org/en/20/tutorial/)
- [Real Python - SQLAlchemy](https://realpython.com/python-sqlite-sqlalchemy/)
- [FastAPI + SQLAlchemy](https://fastapi.tiangolo.com/tutorial/sql-databases/)

### S√©curit√©
- [OWASP SQL Injection Prevention](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [Python Security Best Practices](https://python.readthedocs.io/en/stable/library/security_warnings.html)

### Outils
- [Alembic](https://alembic.sqlalchemy.org/) - Migrations de sch√©ma
- [Pydantic](https://docs.pydantic.dev/) - Validation de donn√©es
- [SQLAlchemy-Utils](https://sqlalchemy-utils.readthedocs.io/) - Extensions utilitaires

---

## ‚û°Ô∏è Section suivante

**17.1.3 Java : JDBC, MariaDB Connector/J** : D√©couvrez comment int√©grer MariaDB dans vos applications Java avec JDBC, connection pooling (HikariCP), et frameworks (Spring Boot, Hibernate JPA).

‚è≠Ô∏è [Java : JDBC, MariaDB Connector/J](/17-integration-developpement/01.3-java-jdbc.md)
