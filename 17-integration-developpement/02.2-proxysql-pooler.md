ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 17.2.2 ProxySQL comme pooler

> **Niveau** : AvancÃ©  
> **DurÃ©e estimÃ©e** : 3-4 heures  
> **PrÃ©requis** : ComprÃ©hension du pooling applicatif, bases de l'administration systÃ¨me, SQL

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre l'architecture et le rÃ´le de ProxySQL
- Installer et configurer ProxySQL pour MariaDB
- ImplÃ©menter un pooling centralisÃ© pour plusieurs applications
- Configurer le query routing (read/write split)
- Utiliser le query cache et les query rules
- Monitorer et optimiser les performances de ProxySQL
- IntÃ©grer ProxySQL dans une architecture microservices
- Diagnostiquer et rÃ©soudre les problÃ¨mes courants

---

## Introduction Ã  ProxySQL

### Qu'est-ce que ProxySQL ?

**ProxySQL** est un proxy SQL haute performance qui se place entre vos applications et vos serveurs de base de donnÃ©es. Il agit comme un **pooler centralisÃ©** et offre des fonctionnalitÃ©s avancÃ©es de routage et de cache.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Architecture avec ProxySQL            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  App 1  â”‚  â”‚  App 2  â”‚  â”‚  App 3  â”‚  â”‚  App N  â”‚
â”‚ (Node)  â”‚  â”‚ (Java)  â”‚  â”‚ (Python)â”‚  â”‚  (Go)   â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚            â”‚            â”‚            â”‚
     â”‚  Connexions simples (pool app lÃ©ger) â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚            â”‚
            â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
            â”‚                        â”‚
            â”‚      ProxySQL          â”‚
            â”‚   (Port 6033)          â”‚
            â”‚                        â”‚
            â”‚  â€¢ Connection Pool     â”‚
            â”‚  â€¢ Query Routing       â”‚
            â”‚  â€¢ Query Cache         â”‚
            â”‚  â€¢ Load Balancing      â”‚
            â”‚  â€¢ Query Rewriting     â”‚
            â”‚                        â”‚
            â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                  â”‚            â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                                      â”‚
â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”                          â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚ MariaDB   â”‚                          â”‚ MariaDB   â”‚
â”‚ Primary   â”‚                          â”‚ Replica   â”‚
â”‚(Port 3306)                           â”‚(Port 3306)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Avantages de ProxySQL

| Avantage | Description |
|----------|-------------|
| **Pooling centralisÃ©** | Un pool partagÃ© entre toutes les applications |
| **Query routing** | Redirection automatique read/write selon la requÃªte |
| **Query cache** | Cache des rÃ©sultats pour requÃªtes identiques |
| **Load balancing** | Distribution de charge entre rÃ©plicas |
| **Query rewriting** | Modification des requÃªtes Ã  la volÃ©e |
| **Multiplexing** | RÃ©utilisation optimale des connexions backend |
| **Monitoring** | Statistiques dÃ©taillÃ©es et mÃ©triques en temps rÃ©el |
| **Zero downtime** | Reconfiguration sans interruption de service |

---

## Installation de ProxySQL

### Installation sur Ubuntu/Debian

```bash
# Ajouter le repository officiel
wget -O - 'https://repo.proxysql.com/ProxySQL/proxysql-2.5.x/repo_pub_key' | apt-key add -

echo "deb https://repo.proxysql.com/ProxySQL/proxysql-2.5.x/$(lsb_release -sc)/ ./" \
  | tee /etc/apt/sources.list.d/proxysql.list

# Installer ProxySQL
apt-get update
apt-get install -y proxysql

# DÃ©marrer le service
systemctl start proxysql
systemctl enable proxysql
systemctl status proxysql
```

### Installation sur CentOS/RHEL

```bash
# Ajouter le repository
cat <<EOF > /etc/yum.repos.d/proxysql.repo
[proxysql]
name=ProxySQL YUM repository
baseurl=https://repo.proxysql.com/ProxySQL/proxysql-2.5.x/centos/\$releasever
gpgcheck=1
gpgkey=https://repo.proxysql.com/ProxySQL/proxysql-2.5.x/repo_pub_key
EOF

# Installer
yum install -y proxysql

# DÃ©marrer
systemctl start proxysql
systemctl enable proxysql
```

### VÃ©rification de l'installation

```bash
# VÃ©rifier que ProxySQL Ã©coute sur les bons ports
netstat -tlnp | grep proxysql

# Ports par dÃ©faut :
# 6033 : port SQL (applications se connectent ici)
# 6032 : port admin (configuration)
# 6080 : port stats (monitoring web)

# Se connecter Ã  l'interface admin
mysql -u admin -padmin -h 127.0.0.1 -P6032 --prompt='ProxySQL Admin> '
```

---

## Configuration de base

### Architecture de configuration ProxySQL

ProxySQL utilise une architecture Ã  3 couches :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         MEMORY (Runtime Config)            â”‚
â”‚  Configuration active en mÃ©moire           â”‚
â”‚  UtilisÃ©e pour le routing en temps rÃ©el    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â”‚ LOAD TO RUNTIME
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         DISK (Persistent Config)           â”‚
â”‚  Configuration sauvegardÃ©e sur disque      â”‚
â”‚  ChargÃ©e au dÃ©marrage de ProxySQL          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â”‚ SAVE TO DISK
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         CONFIG (Config File)               â”‚
â”‚  /etc/proxysql.cnf                         â”‚
â”‚  UtilisÃ© uniquement au premier dÃ©marrage   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Workflow typique :
1. Modifier les tables : main.*
2. Charger en runtime : LOAD ... TO RUNTIME
3. Sauver sur disque : SAVE ... TO DISK
```

### Configuration des serveurs backend

```sql
-- Se connecter Ã  l'interface admin
-- mysql -u admin -padmin -h 127.0.0.1 -P6032

-- 1. Ajouter les serveurs MariaDB
INSERT INTO mysql_servers (
    hostgroup_id,
    hostname,
    port,
    status,
    weight,
    compression,
    max_connections,
    max_replication_lag,
    comment
) VALUES
-- Primary (Write hostgroup = 0)
(0, '192.168.1.10', 3306, 'ONLINE', 1000, 0, 1000, 0, 'Primary MariaDB'),

-- Replica 1 (Read hostgroup = 1)
(1, '192.168.1.11', 3306, 'ONLINE', 1000, 0, 1000, 10, 'Replica 1'),

-- Replica 2 (Read hostgroup = 1)
(1, '192.168.1.12', 3306, 'ONLINE', 1000, 0, 1000, 10, 'Replica 2');

-- 2. Charger la configuration en runtime
LOAD MYSQL SERVERS TO RUNTIME;

-- 3. Sauvegarder sur disque
SAVE MYSQL SERVERS TO DISK;

-- 4. VÃ©rifier
SELECT 
    hostgroup_id,
    hostname,
    port,
    status,
    weight,
    max_connections,
    comment
FROM mysql_servers
ORDER BY hostgroup_id, hostname;
```

### Configuration des utilisateurs

```sql
-- 1. CrÃ©er l'utilisateur dans MariaDB (sur tous les serveurs)
-- Sur Primary et Replicas :
CREATE USER 'app_user'@'%' IDENTIFIED BY 'SecureP@ssw0rd!';
GRANT SELECT, INSERT, UPDATE, DELETE ON production_db.* TO 'app_user'@'%';
FLUSH PRIVILEGES;

-- 2. Ajouter l'utilisateur dans ProxySQL
INSERT INTO mysql_users (
    username,
    password,
    active,
    default_hostgroup,
    max_connections,
    comment
) VALUES (
    'app_user',
    'SecureP@ssw0rd!',
    1,              -- active
    0,              -- default hostgroup (write)
    1000,           -- max connexions
    'Application user'
);

-- 3. Charger et sauvegarder
LOAD MYSQL USERS TO RUNTIME;
SAVE MYSQL USERS TO DISK;

-- 4. VÃ©rifier
SELECT username, active, default_hostgroup, max_connections 
FROM mysql_users;
```

---

## Configuration du Query Routing

### Read/Write Split automatique

```sql
-- Configuration des query rules pour split read/write

-- 1. RÃ¨gle pour les SELECT (READ) vers les replicas
INSERT INTO mysql_query_rules (
    rule_id,
    active,
    match_pattern,
    destination_hostgroup,
    apply,
    comment
) VALUES (
    10,                         -- rule_id
    1,                          -- active
    '^SELECT.*FOR UPDATE$',     -- Pattern pour SELECT FOR UPDATE
    0,                          -- Vers hostgroup 0 (write)
    1,                          -- apply
    'SELECT FOR UPDATE to write hostgroup'
);

-- 2. RÃ¨gle pour tous les autres SELECT (READ)
INSERT INTO mysql_query_rules (
    rule_id,
    active,
    match_pattern,
    destination_hostgroup,
    apply,
    cache_ttl,
    comment
) VALUES (
    20,
    1,
    '^SELECT',                  -- Tous les SELECT
    1,                          -- Vers hostgroup 1 (read replicas)
    1,
    5000,                       -- Cache 5 secondes
    'SELECT to read hostgroup'
);

-- 3. RÃ¨gle pour les Ã©critures (INSERT, UPDATE, DELETE)
INSERT INTO mysql_query_rules (
    rule_id,
    active,
    match_pattern,
    destination_hostgroup,
    apply,
    comment
) VALUES (
    30,
    1,
    '^(INSERT|UPDATE|DELETE)',
    0,                          -- Vers hostgroup 0 (write)
    1,
    'Write queries to primary'
);

-- 4. Charger et sauvegarder
LOAD MYSQL QUERY RULES TO RUNTIME;
SAVE MYSQL QUERY RULES TO DISK;

-- 5. VÃ©rifier les rÃ¨gles
SELECT 
    rule_id,
    active,
    match_pattern,
    destination_hostgroup,
    cache_ttl,
    apply,
    comment
FROM mysql_query_rules
ORDER BY rule_id;
```

### Query Rewriting (exemples avancÃ©s)

```sql
-- RÃ©Ã©criture pour forcer l'utilisation d'index
INSERT INTO mysql_query_rules (
    rule_id,
    active,
    match_pattern,
    replace_pattern,
    destination_hostgroup,
    apply,
    comment
) VALUES (
    100,
    1,
    '^SELECT \* FROM users WHERE username',
    'SELECT id, username, email FROM users USE INDEX(idx_username) WHERE username',
    1,
    1,
    'Force index usage on users table'
);

-- Bloquer les requÃªtes dangereuses
INSERT INTO mysql_query_rules (
    rule_id,
    active,
    match_pattern,
    error_msg,
    comment
) VALUES (
    200,
    1,
    '.*DROP TABLE.*',
    'DROP TABLE is not allowed',
    'Block DROP TABLE statements'
);

-- Charger les rÃ¨gles
LOAD MYSQL QUERY RULES TO RUNTIME;
SAVE MYSQL QUERY RULES TO DISK;
```

---

## Configuration du Connection Pooling

### ParamÃ¨tres de pool par hostgroup

```sql
-- Configuration du pooling dans ProxySQL

-- 1. Configuration globale des variables
UPDATE global_variables 
SET variable_value = '200' 
WHERE variable_name = 'mysql-max_connections';

UPDATE global_variables 
SET variable_value = '10000' 
WHERE variable_name = 'mysql-default_query_timeout';

UPDATE global_variables 
SET variable_value = '3600000' 
WHERE variable_name = 'mysql-connection_max_age_ms';

UPDATE global_variables 
SET variable_value = '1' 
WHERE variable_name = 'mysql-multiplexing';

-- 2. Charger les variables
LOAD MYSQL VARIABLES TO RUNTIME;
SAVE MYSQL VARIABLES TO DISK;

-- 3. Afficher les variables importantes
SELECT 
    variable_name, 
    variable_value 
FROM global_variables 
WHERE variable_name LIKE 'mysql-%connection%'
   OR variable_name LIKE 'mysql-multiplex%'
   OR variable_name LIKE 'mysql-%timeout%'
ORDER BY variable_name;
```

### Variables de pooling importantes

```sql
-- Configuration dÃ©taillÃ©e du pooling

-- Connection pooling
SET mysql-max_connections = 2000;           -- Max connexions vers clients
SET mysql-default_max_latency_ms = 1000;    -- Latence max acceptable

-- Multiplexing (rÃ©utilisation des connexions)
SET mysql-multiplexing = 1;                 -- Activer le multiplexing
SET mysql-connection_max_age_ms = 3600000;  -- Max age 1h

-- Backend connections
SET mysql-free_connections_pct = 10;        -- % connexions libres Ã  maintenir
SET mysql-connect_timeout_server_max = 10000; -- 10s timeout connexion backend

-- Ping keepalive
SET mysql-ping_interval_server_msec = 10000;  -- Ping toutes les 10s
SET mysql-ping_timeout_server = 200;          -- Timeout ping 200ms

-- Session persistance
SET mysql-session_idle_ms = 10000;          -- Idle 10s avant multiplexing

LOAD MYSQL VARIABLES TO RUNTIME;
SAVE MYSQL VARIABLES TO DISK;
```

---

## Query Cache Configuration

### Activer et configurer le cache

```sql
-- 1. Activer le query cache
UPDATE global_variables 
SET variable_value = '256' 
WHERE variable_name = 'mysql-query_cache_size_MB';

-- 2. Configuration du cache
UPDATE global_variables 
SET variable_value = '5000' 
WHERE variable_name = 'mysql-query_cache_default_timeout';

LOAD MYSQL VARIABLES TO RUNTIME;
SAVE MYSQL VARIABLES TO DISK;

-- 3. Ajouter des rÃ¨gles avec cache
INSERT INTO mysql_query_rules (
    rule_id,
    active,
    match_pattern,
    destination_hostgroup,
    cache_ttl,          -- Time To Live en millisecondes
    apply,
    comment
) VALUES
-- Cache pour les statistiques (30 secondes)
(1000, 1, '^SELECT COUNT.*FROM users', 1, 30000, 1, 'Cache user count'),

-- Cache pour les catÃ©gories (5 minutes)
(1001, 1, '^SELECT.*FROM categories', 1, 300000, 1, 'Cache categories'),

-- Cache pour les configs (10 minutes)
(1002, 1, '^SELECT.*FROM config', 1, 600000, 1, 'Cache config');

LOAD MYSQL QUERY RULES TO RUNTIME;
SAVE MYSQL QUERY RULES TO DISK;
```

### Monitorer le cache

```sql
-- Statistiques du query cache
SELECT * FROM stats_mysql_query_cache;

-- DÃ©tail par requÃªte
SELECT 
    digest_text,
    count_hit,
    count_miss,
    count_hit / (count_hit + count_miss) * 100 AS hit_ratio
FROM stats_mysql_query_digest
WHERE cache_ttl > 0
ORDER BY count_hit DESC
LIMIT 20;
```

---

## Monitoring et diagnostics

### Connexions actives

```sql
-- Vue d'ensemble des connexions
SELECT 
    srv_host,
    srv_port,
    ConnUsed,
    ConnFree,
    ConnOK,
    ConnERR,
    Queries,
    Bytes_data_sent,
    Bytes_data_recv
FROM stats_mysql_connection_pool
ORDER BY srv_host, srv_port;

-- Connexions par hostgroup
SELECT 
    hostgroup,
    SUM(ConnUsed) AS total_used,
    SUM(ConnFree) AS total_free,
    SUM(ConnOK) AS total_ok,
    SUM(ConnERR) AS total_errors
FROM stats_mysql_connection_pool
GROUP BY hostgroup;
```

### Performance des requÃªtes

```sql
-- Top requÃªtes par temps d'exÃ©cution
SELECT 
    hostgroup,
    schemaname,
    digest_text,
    count_star AS exec_count,
    sum_time / 1000000 AS total_time_sec,
    sum_time / count_star / 1000 AS avg_time_ms,
    min_time / 1000 AS min_time_ms,
    max_time / 1000 AS max_time_ms
FROM stats_mysql_query_digest
ORDER BY sum_time DESC
LIMIT 20;

-- RequÃªtes les plus frÃ©quentes
SELECT 
    digest_text,
    count_star AS exec_count,
    sum_time / 1000000 AS total_time_sec,
    sum_time / count_star / 1000 AS avg_time_ms
FROM stats_mysql_query_digest
ORDER BY count_star DESC
LIMIT 20;
```

### Statistiques globales

```sql
-- Statistiques des commandes
SELECT * FROM stats_mysql_commands_counters 
ORDER BY Total_cnt DESC;

-- Statistiques globales
SELECT * FROM stats_mysql_global;

-- Ã‰tat des serveurs
SELECT 
    hostgroup_id,
    hostname,
    port,
    status,
    Queries,
    Bytes_data_sent / 1024 / 1024 AS MB_sent,
    Bytes_data_recv / 1024 / 1024 AS MB_recv,
    Latency_us / 1000 AS latency_ms
FROM stats_mysql_connection_pool
ORDER BY hostgroup_id, hostname;
```

### Dashboard de monitoring

```sql
-- Script de monitoring complet
SELECT '=== CONNECTION POOL STATUS ===' AS section;

SELECT 
    hostgroup,
    srv_host,
    srv_port,
    status,
    ConnUsed,
    ConnFree,
    Queries,
    Latency_us / 1000 AS latency_ms
FROM stats_mysql_connection_pool
ORDER BY hostgroup, srv_host;

SELECT '=== TOP 10 SLOW QUERIES ===' AS section;

SELECT 
    SUBSTR(digest_text, 1, 80) AS query,
    count_star AS count,
    sum_time / count_star / 1000 AS avg_ms,
    max_time / 1000 AS max_ms
FROM stats_mysql_query_digest
ORDER BY sum_time DESC
LIMIT 10;

SELECT '=== QUERY CACHE EFFICIENCY ===' AS section;

SELECT 
    SUM(count_hit) AS total_hits,
    SUM(count_miss) AS total_misses,
    ROUND(SUM(count_hit) / (SUM(count_hit) + SUM(count_miss)) * 100, 2) AS hit_ratio_pct
FROM stats_mysql_query_cache;

SELECT '=== COMMANDS COUNTERS ===' AS section;

SELECT 
    Command,
    Total_cnt,
    Total_Time_us / 1000000 AS total_time_sec
FROM stats_mysql_commands_counters
WHERE Total_cnt > 0
ORDER BY Total_cnt DESC
LIMIT 10;
```

---

## IntÃ©gration avec les applications

### Configuration cÃ´tÃ© application

Avec ProxySQL, les applications se connectent au **port 6033** au lieu de 3306 :

#### PHP (PDO)

```php
<?php
// Connexion via ProxySQL (port 6033)
$pdo = new PDO(
    'mysql:host=proxysql-server;port=6033;dbname=production_db;charset=utf8mb4',
    'app_user',
    'SecureP@ssw0rd!',
    [
        // Pool applicatif minimal car ProxySQL gÃ¨re le pooling
        PDO::ATTR_PERSISTENT => false,
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
    ]
);

// Les requÃªtes sont routÃ©es automatiquement
$stmt = $pdo->query("SELECT * FROM users LIMIT 10");  // â†’ Replica
$rows = $stmt->fetchAll();

$stmt = $pdo->prepare("INSERT INTO users (username) VALUES (?)");
$stmt->execute(['newuser']);  // â†’ Primary
```

#### Python (SQLAlchemy)

```python
from sqlalchemy import create_engine

# Connexion via ProxySQL
engine = create_engine(
    'mysql+pymysql://app_user:SecureP@ssw0rd!@proxysql-server:6033/production_db',
    
    # Pool applicatif rÃ©duit (ProxySQL gÃ¨re le vrai pool)
    pool_size=5,            # RÃ©duit de 10
    max_overflow=10,        # RÃ©duit de 20
    pool_pre_ping=False,    # ProxySQL gÃ¨re la validation
    pool_recycle=3600,
)

# Les requÃªtes sont automatiquement routÃ©es
with engine.connect() as conn:
    # SELECT â†’ Replica
    result = conn.execute("SELECT * FROM users")
    
    # INSERT â†’ Primary
    conn.execute("INSERT INTO users (username) VALUES ('newuser')")
```

#### Java (HikariCP)

```java
// Configuration HikariCP avec ProxySQL
HikariConfig config = new HikariConfig();

// Connexion ProxySQL (port 6033)
config.setJdbcUrl("jdbc:mariadb://proxysql-server:6033/production_db");
config.setUsername("app_user");
config.setPassword("SecureP@ssw0rd!");

// Pool rÃ©duit (ProxySQL gÃ¨re le pooling)
config.setMinimumIdle(2);
config.setMaximumPoolSize(10);  // RÃ©duit de 20

// Pas de validation nÃ©cessaire (ProxySQL gÃ¨re)
config.setConnectionTestQuery(null);

HikariDataSource dataSource = new HikariDataSource(config);
```

#### Node.js (mysql2)

```javascript
import mysql from 'mysql2/promise';

// Pool rÃ©duit car ProxySQL gÃ¨re le pooling
const pool = mysql.createPool({
  host: 'proxysql-server',
  port: 6033,              // Port ProxySQL
  user: 'app_user',
  password: 'SecureP@ssw0rd!',
  database: 'production_db',
  connectionLimit: 10,     // RÃ©duit de 50
  waitForConnections: true
});

// Les requÃªtes sont routÃ©es automatiquement
const [users] = await pool.execute('SELECT * FROM users');  // â†’ Replica
await pool.execute('INSERT INTO users (username) VALUES (?)', ['new']); // â†’ Primary
```

#### Go (database/sql)

```go
import (
    "database/sql"
    _ "github.com/go-sql-driver/mysql"
)

// DSN vers ProxySQL (port 6033)
dsn := "app_user:SecureP@ssw0rd!@tcp(proxysql-server:6033)/production_db"

db, err := sql.Open("mysql", dsn)
if err != nil {
    log.Fatal(err)
}

// Pool rÃ©duit
db.SetMaxOpenConns(10)   // RÃ©duit de 25
db.SetMaxIdleConns(2)    // RÃ©duit de 5

// RequÃªtes automatiquement routÃ©es
rows, _ := db.Query("SELECT * FROM users")  // â†’ Replica
db.Exec("INSERT INTO users (username) VALUES (?)", "new")  // â†’ Primary
```

#### .NET (MySqlConnector)

```csharp
var builder = new MySqlConnectionStringBuilder
{
    Server = "proxysql-server",
    Port = 6033,            // Port ProxySQL
    UserID = "app_user",
    Password = "SecureP@ssw0rd!",
    Database = "production_db",
    
    // Pool rÃ©duit (ProxySQL gÃ¨re)
    Pooling = true,
    MinimumPoolSize = 2,
    MaximumPoolSize = 10    // RÃ©duit de 25
};

var connectionString = builder.ConnectionString;
```

ğŸ’¡ **Principe clÃ©** : Avec ProxySQL, le pool applicatif doit Ãªtre **rÃ©duit** car ProxySQL gÃ¨re le vrai pooling. L'application n'a besoin que de connexions vers ProxySQL, pas vers les serveurs MariaDB.

---

## Configuration avancÃ©e

### Load Balancing avec pondÃ©ration

```sql
-- Configuration du load balancing entre replicas

-- Replica 1 : serveur puissant (weight = 2000)
UPDATE mysql_servers 
SET weight = 2000 
WHERE hostgroup_id = 1 AND hostname = '192.168.1.11';

-- Replica 2 : serveur standard (weight = 1000)
UPDATE mysql_servers 
SET weight = 1000 
WHERE hostgroup_id = 1 AND hostname = '192.168.1.12';

-- Replica 3 : serveur lÃ©ger (weight = 500)
INSERT INTO mysql_servers (hostgroup_id, hostname, port, weight)
VALUES (1, '192.168.1.13', 3306, 500);

LOAD MYSQL SERVERS TO RUNTIME;
SAVE MYSQL SERVERS TO DISK;

-- La distribution sera approximativement :
-- Replica 1 : 57% des requÃªtes (2000 / 3500)
-- Replica 2 : 29% des requÃªtes (1000 / 3500)
-- Replica 3 : 14% des requÃªtes (500 / 3500)
```

### Gestion du replication lag

```sql
-- Configuration du replication lag acceptable

-- Replicas avec max 10 secondes de lag
UPDATE mysql_servers 
SET max_replication_lag = 10 
WHERE hostgroup_id = 1;

-- VÃ©rifier le lag en temps rÃ©el
SELECT 
    hostgroup_id,
    hostname,
    status,
    replication_lag
FROM runtime_mysql_servers
WHERE hostgroup_id = 1;

-- Si lag > max_replication_lag, le serveur passe en SHUNNED
-- et ne reÃ§oit plus de requÃªtes jusqu'Ã  rattrapage
```

### Scheduler pour maintenance

```sql
-- Planifier des tÃ¢ches automatiques

-- 1. VÃ©rification de santÃ© toutes les 5 secondes
INSERT INTO scheduler (
    id,
    active,
    interval_ms,
    filename,
    comment
) VALUES (
    1,
    1,
    5000,
    '/usr/share/proxysql/check_backends.sh',
    'Health check backend servers'
);

-- 2. Rotation des stats toutes les heures
INSERT INTO scheduler (
    id,
    active,
    interval_ms,
    filename,
    comment
) VALUES (
    2,
    1,
    3600000,
    '/usr/share/proxysql/rotate_stats.sh',
    'Rotate statistics'
);

LOAD SCHEDULER TO RUNTIME;
SAVE SCHEDULER TO DISK;
```

---

## Haute disponibilitÃ©

### ProxySQL en cluster

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Architecture HA avec ProxySQL        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  App 1  â”‚       â”‚  App 2  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚                 â”‚
     â”‚  VIP: 10.0.0.100
     â”‚                 â”‚
â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
â”‚      Load Balancer         â”‚
â”‚    (HAProxy / Keepalived)  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚                 â”‚
â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚ProxySQL â”‚â—„â”€â”€â”€â”€â”€â–ºâ”‚ProxySQL â”‚
â”‚  Node 1 â”‚ Sync  â”‚  Node 2 â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚                 â”‚
     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
          â”‚     â”‚
     â”Œâ”€â”€â”€â”€â–¼â”€â” â”Œâ”€â–¼â”€â”€â”€â”€â”
     â”‚ P-DB â”‚ â”‚ R-DB â”‚
     â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜
```

### Configuration du cluster ProxySQL

```sql
-- Sur ProxySQL Node 1
-- Configuration du cluster
UPDATE global_variables 
SET variable_value = '192.168.1.20:6032,192.168.1.21:6032' 
WHERE variable_name = 'admin-cluster_proxysql_servers';

UPDATE global_variables 
SET variable_value = 'cluster_user' 
WHERE variable_name = 'admin-cluster_username';

UPDATE global_variables 
SET variable_value = 'cluster_password' 
WHERE variable_name = 'admin-cluster_password';

UPDATE global_variables 
SET variable_value = '1000' 
WHERE variable_name = 'admin-cluster_check_interval_ms';

UPDATE global_variables 
SET variable_value = '200' 
WHERE variable_name = 'admin-cluster_check_status_frequency';

LOAD ADMIN VARIABLES TO RUNTIME;
SAVE ADMIN VARIABLES TO DISK;

-- Ajouter les nÅ“uds du cluster
INSERT INTO proxysql_servers (hostname, port, weight, comment)
VALUES 
('192.168.1.20', 6032, 100, 'ProxySQL Node 1'),
('192.168.1.21', 6032, 100, 'ProxySQL Node 2');

LOAD PROXYSQL SERVERS TO RUNTIME;
SAVE PROXYSQL SERVERS TO DISK;
```

---

## SÃ©curitÃ©

### SSL/TLS vers MariaDB

```sql
-- Configuration SSL pour les connexions backend

UPDATE mysql_servers 
SET use_ssl = 1 
WHERE hostgroup_id IN (0, 1);

-- Variables SSL globales
UPDATE global_variables 
SET variable_value = '/etc/proxysql/ssl/ca.pem' 
WHERE variable_name = 'mysql-ssl_p2s_ca';

UPDATE global_variables 
SET variable_value = '/etc/proxysql/ssl/client-cert.pem' 
WHERE variable_name = 'mysql-ssl_p2s_cert';

UPDATE global_variables 
SET variable_value = '/etc/proxysql/ssl/client-key.pem' 
WHERE variable_name = 'mysql-ssl_p2s_key';

LOAD MYSQL VARIABLES TO RUNTIME;
SAVE MYSQL VARIABLES TO DISK;
```

### Firewall rules

```sql
-- Bloquer les adresses IP suspectes
INSERT INTO mysql_firewall_whitelist_rules (
    active,
    username,
    client_address,
    comment
) VALUES (
    1,
    'app_user',
    '192.168.1.0/24',
    'Allow from app subnet only'
);

-- Bloquer certains patterns dangereux (dÃ©jÃ  vu avec query rules)
INSERT INTO mysql_query_rules (
    rule_id,
    active,
    match_pattern,
    error_msg,
    comment
) VALUES
(9000, 1, '.*LOAD DATA.*', 'LOAD DATA not allowed', 'Block LOAD DATA'),
(9001, 1, '.*INTO OUTFILE.*', 'INTO OUTFILE not allowed', 'Block file export');

LOAD MYSQL QUERY RULES TO RUNTIME;
SAVE MYSQL QUERY RULES TO DISK;
```

---

## Troubleshooting

### ProblÃ¨mes courants

#### 1. Pool exhaustion (trop de connexions)

```sql
-- SymptÃ´me : "Max connections reached"

-- Diagnostic
SELECT * FROM stats_mysql_connection_pool;

-- Solution 1 : Augmenter max_connections
UPDATE global_variables 
SET variable_value = '4000' 
WHERE variable_name = 'mysql-max_connections';

-- Solution 2 : Augmenter max_connections par serveur
UPDATE mysql_servers 
SET max_connections = 2000 
WHERE hostgroup_id IN (0, 1);

LOAD MYSQL SERVERS TO RUNTIME;
LOAD MYSQL VARIABLES TO RUNTIME;
```

#### 2. Replication lag Ã©levÃ©

```sql
-- Diagnostic
SELECT 
    hostname,
    status,
    replication_lag
FROM runtime_mysql_servers
WHERE hostgroup_id = 1;

-- Solution : Augmenter le lag acceptable temporairement
UPDATE mysql_servers 
SET max_replication_lag = 30 
WHERE hostgroup_id = 1;

LOAD MYSQL SERVERS TO RUNTIME;
```

#### 3. RequÃªtes lentes via ProxySQL

```sql
-- Identifier les requÃªtes lentes
SELECT 
    digest_text,
    count_star,
    sum_time / 1000000 AS total_sec,
    sum_time / count_star / 1000 AS avg_ms,
    max_time / 1000 AS max_ms
FROM stats_mysql_query_digest
WHERE sum_time / count_star > 1000000  -- Moyenne > 1s
ORDER BY sum_time DESC;

-- VÃ©rifier si le cache aide
SELECT * FROM stats_mysql_query_cache
WHERE count_miss > count_hit;
```

#### 4. Multiplexing dÃ©sactivÃ©

```sql
-- VÃ©rifier le multiplexing
SHOW VARIABLES LIKE 'mysql-multiplexing';

-- Si dÃ©sactivÃ©, activer
SET mysql-multiplexing = 1;
LOAD MYSQL VARIABLES TO RUNTIME;

-- VÃ©rifier les variables qui cassent le multiplexing
SELECT * FROM mysql_variables 
WHERE variable_name LIKE '%multiplexing%';
```

### Logs de dÃ©bogage

```bash
# Activer les logs dÃ©taillÃ©s
mysql -u admin -padmin -h 127.0.0.1 -P6032 -e "
SET mysql-eventslog_filename='/var/lib/proxysql/queries.log';
SET mysql-eventslog_default_log=1;
SET mysql-eventslog_format=2;
LOAD MYSQL VARIABLES TO RUNTIME;
"

# Surveiller les logs
tail -f /var/lib/proxysql/queries.log

# Logs systÃ¨me
journalctl -u proxysql -f
```

---

## Benchmarks et optimisations

### Comparaison Performance

Test : 1000 requÃªtes/seconde pendant 60 secondes

| Configuration | Latence P50 | Latence P99 | Throughput |
|--------------|-------------|-------------|------------|
| **Direct MariaDB** | 2ms | 15ms | 950 req/s |
| **App pool â†’ MariaDB** | 2.5ms | 18ms | 920 req/s |
| **ProxySQL â†’ MariaDB** | 3ms | 20ms | 980 req/s |
| **ProxySQL + Cache** | 0.5ms | 8ms | 1200 req/s |

ğŸ’¡ **Conclusion** : ProxySQL ajoute ~1ms de latence mais amÃ©liore le throughput et le cache rÃ©duit drastiquement la latence.

### Optimisations recommandÃ©es

```sql
-- 1. Multiplexing agressif
SET mysql-multiplexing = 1;
SET mysql-session_idle_ms = 1000;  -- Multiplexer aprÃ¨s 1s idle

-- 2. Connection pooling optimal
SET mysql-free_connections_pct = 20;
SET mysql-connect_timeout_server_max = 5000;

-- 3. Query cache pour lectures rÃ©pÃ©tÃ©es
SET mysql-query_cache_size_MB = 512;

-- 4. Compression pour WAN (si nÃ©cessaire)
UPDATE mysql_servers SET compression = 1 WHERE hostname LIKE 'remote%';

-- 5. Timeouts raisonnables
SET mysql-default_query_timeout = 10000;  -- 10s

LOAD MYSQL VARIABLES TO RUNTIME;
SAVE MYSQL VARIABLES TO DISK;
```

---

## âœ… Points clÃ©s Ã  retenir

1. **ProxySQL = pooler centralisÃ©** : Un pool partagÃ© entre toutes les applications
2. **Query routing** : Split read/write automatique selon les patterns
3. **Query cache** : Cache transparent pour requÃªtes identiques
4. **Pool applicatif rÃ©duit** : Avec ProxySQL, rÃ©duire le pool cÃ´tÃ© app
5. **Architecture 3 couches** : MEMORY â†’ DISK â†’ CONFIG
6. **Monitoring essentiel** : stats_mysql_* pour diagnostics
7. **LOAD TO RUNTIME** : Toujours charger aprÃ¨s modification
8. **SAVE TO DISK** : Persister la config aprÃ¨s validation
9. **HA avec cluster** : ProxySQL nodes en cluster pour haute disponibilitÃ©
10. **Performance** : +1ms latence mais meilleur throughput global

---

## ğŸ”— Ressources

### Documentation officielle
- [ğŸ“– ProxySQL Documentation](https://proxysql.com/documentation/)
- [ğŸ“– ProxySQL GitHub](https://github.com/sysown/proxysql)
- [ğŸ“– ProxySQL Wiki](https://github.com/sysown/proxysql/wiki)

### Guides et tutoriels
- [ProxySQL Configuration Guide](https://proxysql.com/documentation/ProxySQL-Configuration/)
- [Query Rules Tutorial](https://proxysql.com/documentation/query-rules/)

### Outils
- [ProxySQL Admin](https://github.com/sysown/proxysql-admin-tool)
- [ProxySQL Exporter (Prometheus)](https://github.com/percona/proxysql_exporter)

---

## â¡ï¸ Section suivante

**17.3 ORM et frameworks** : Utilisation des ORM populaires (Hibernate, SQLAlchemy, Sequelize, Prisma, Entity Framework Core) avec MariaDB, patterns avancÃ©s et optimisations.

â­ï¸ [ORM et frameworks](/17-integration-developpement/03-orm-frameworks.md)
