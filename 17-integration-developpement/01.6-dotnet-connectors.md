üîù Retour au [Sommaire](/SOMMAIRE.md)

# 17.1.6 .NET : MySqlConnector, MariaDB.Data, ADO.NET

> **Niveau** : Interm√©diaire √† Avanc√©  
> **Dur√©e estim√©e** : 3-4 heures  
> **Pr√©requis** : .NET 6+, C# 10+, async/await, LINQ, Entity Framework basics

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Choisir entre MySqlConnector, MariaDB.Data et MySQL.Data
- Utiliser ADO.NET de mani√®re moderne avec async/await
- Configurer Entity Framework Core pour MariaDB
- Impl√©menter le pattern Repository avec EF Core
- Utiliser Dapper pour des requ√™tes haute performance
- G√©rer les transactions et le connection pooling
- Appliquer les bonnes pratiques de s√©curit√© .NET
- Int√©grer MariaDB dans ASP.NET Core

---

## Introduction

.NET offre un √©cosyst√®me riche pour travailler avec MariaDB, du bas niveau ADO.NET aux ORMs modernes. Avec .NET 6+ et C# 10+, le d√©veloppement est type-safe, performant et b√©n√©ficie d'un excellent support async/await.

### √âcosyst√®me .NET-MariaDB

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        Application .NET                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Framework Layer                            ‚îÇ
‚îÇ  ‚îú‚îÄ ASP.NET Core (Web API, MVC, Blazor)     ‚îÇ
‚îÇ  ‚îú‚îÄ Minimal APIs (.NET 6+)                  ‚îÇ
‚îÇ  ‚îî‚îÄ Worker Services (Background tasks)      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ORM / Micro-ORM                            ‚îÇ
‚îÇ  ‚îú‚îÄ Entity Framework Core (ORM complet)     ‚îÇ
‚îÇ  ‚îú‚îÄ Dapper (micro-ORM performant)           ‚îÇ
‚îÇ  ‚îú‚îÄ RepoDb (hybrid ORM)                     ‚îÇ
‚îÇ  ‚îî‚îÄ NHibernate (legacy ORM)                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ADO.NET (Data Provider)                    ‚îÇ
‚îÇ  ‚îú‚îÄ MySqlConnector (recommand√©)             ‚îÇ
‚îÇ  ‚îú‚îÄ MariaDB.Data (officiel MariaDB)         ‚îÇ
‚îÇ  ‚îî‚îÄ MySql.Data (Oracle, legacy)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ          MariaDB Server                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

üí° **Conseil** : Pour les nouveaux projets .NET 6+, utilisez **MySqlConnector** avec **Entity Framework Core** pour la productivit√©, ou **Dapper** pour la performance maximale. ASP.NET Core + EF Core + MySqlConnector est la stack recommand√©e.

---

## Comparaison des connecteurs .NET

### Tableau comparatif d√©taill√©

| Crit√®re | MySqlConnector | MariaDB.Data | MySql.Data (Oracle) |
|---------|----------------|--------------|---------------------|
| **Performance** | Tr√®s √©lev√©e | √âlev√©e | Moyenne |
| **Async/Await** | ‚úÖ Natif optimal | ‚úÖ Natif | ‚ö†Ô∏è Wrapper sync |
| **EF Core** | ‚úÖ Excellent | ‚úÖ Support | ‚úÖ Support |
| **Maintenance** | Tr√®s active | Active | Oracle (lent) |
| **Open Source** | ‚úÖ MIT | ‚úÖ LGPL 2.1 | ‚ö†Ô∏è GPL (dual) |
| **Compatibilit√©** | MySQL 5.7+, MariaDB 10.2+ | MariaDB optimis√© | MySQL focus |
| **Connection Pool** | ‚úÖ Int√©gr√© | ‚úÖ Int√©gr√© | ‚úÖ Int√©gr√© |
| **NuGet downloads** | ~15M/mois | ~100K/mois | ~30M/mois (legacy) |
| **.NET Support** | .NET 6+ optimis√© | .NET Standard 2.0+ | .NET Framework+ |

### Recommandations par cas d'usage

#### MySqlConnector ‚≠ê (Recommand√©)
```bash
dotnet add package MySqlConnector
dotnet add package Pomelo.EntityFrameworkCore.MySql
```

**Utiliser quand :**
- Nouveau projet .NET 6+
- Performance critique
- Async/await essentiel
- EF Core avec Pomelo provider
- Licence MIT requise

**Avantages :**
- ‚úÖ Le plus performant (benchmarks)
- ‚úÖ Async natif sans overhead
- ‚úÖ Excellent support EF Core (Pomelo)
- ‚úÖ Licence MIT (permissive)
- ‚úÖ Maintenance active
- ‚úÖ Best practices .NET

**Inconv√©nients :**
- ‚ö†Ô∏è Pas officiel Oracle/MariaDB

#### MariaDB.Data (Officiel MariaDB)
```bash
dotnet add package MariaDB.Data
```

**Utiliser quand :**
- Support officiel prioritaire
- Features MariaDB sp√©cifiques
- LGPL acceptable

**Avantages :**
- ‚úÖ Connecteur officiel MariaDB Foundation
- ‚úÖ Optimis√© pour MariaDB
- ‚úÖ Async natif
- ‚úÖ Support MariaDB features

**Inconv√©nients :**
- ‚ö†Ô∏è Moins populaire (√©cosyst√®me)
- ‚ö†Ô∏è Licence LGPL 2.1

#### MySql.Data (Legacy - √©viter)
```bash
# NE PAS utiliser pour nouveaux projets
dotnet add package MySql.Data
```

**√âviter car :**
- ‚ùå Performance inf√©rieure
- ‚ùå Async wrapper over sync
- ‚ùå Licence GPL probl√©matique
- ‚ùå Maintenance Oracle lente
- ‚ùå Probl√®mes de compatibilit√©

üí° **Verdict** : Utilisez **MySqlConnector** sauf si vous avez absolument besoin du support officiel MariaDB.

---

## Configuration et installation

### Fichier projet (.csproj)

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <!-- Connecteur MariaDB/MySQL -->
    <PackageReference Include="MySqlConnector" Version="2.3.5" />
    
    <!-- Entity Framework Core -->
    <PackageReference Include="Pomelo.EntityFrameworkCore.MySql" Version="8.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.0">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    
    <!-- Micro-ORM Dapper (optionnel, pour performance) -->
    <PackageReference Include="Dapper" Version="2.1.28" />
    
    <!-- Configuration -->
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="8.0.0" />
    
    <!-- Validation -->
    <PackageReference Include="FluentValidation.AspNetCore" Version="11.3.0" />
    
    <!-- Logging -->
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
  </ItemGroup>

</Project>
```

### Configuration (appsettings.json)

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost;Port=3306;Database=production_db;User=app_user;Password=SecureP@ssw0rd!;CharSet=utf8mb4;SslMode=Preferred;ConnectionTimeout=10;DefaultCommandTimeout=30;Pooling=true;MinimumPoolSize=5;MaximumPoolSize=25;ConnectionLifeTime=600;ConnectionIdleTimeout=300;AllowUserVariables=true;UseAffectedRows=false"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.EntityFrameworkCore.Database.Command": "Information"
    }
  }
}
```

### Classe de configuration

```csharp
// Configuration/DatabaseSettings.cs
namespace MariaDbApp.Configuration;

public class DatabaseSettings
{
    public string Server { get; set; } = "localhost";
    public int Port { get; set; } = 3306;
    public string Database { get; set; } = "production_db";
    public string User { get; set; } = "app_user";
    public string Password { get; set; } = string.Empty;
    public string CharSet { get; set; } = "utf8mb4";
    public string SslMode { get; set; } = "Preferred";
    
    // Connection pooling
    public bool Pooling { get; set; } = true;
    public int MinimumPoolSize { get; set; } = 5;
    public int MaximumPoolSize { get; set; } = 25;
    public int ConnectionLifeTime { get; set; } = 600;  // 10 minutes
    public int ConnectionIdleTimeout { get; set; } = 300; // 5 minutes
    
    // Timeouts
    public int ConnectionTimeout { get; set; } = 10;     // secondes
    public int DefaultCommandTimeout { get; set; } = 30; // secondes
    
    public string GetConnectionString()
    {
        return $"Server={Server};Port={Port};Database={Database};" +
               $"User={User};Password={Password};CharSet={CharSet};" +
               $"SslMode={SslMode};ConnectionTimeout={ConnectionTimeout};" +
               $"DefaultCommandTimeout={DefaultCommandTimeout};" +
               $"Pooling={Pooling};MinimumPoolSize={MinimumPoolSize};" +
               $"MaximumPoolSize={MaximumPoolSize};" +
               $"ConnectionLifeTime={ConnectionLifeTime};" +
               $"ConnectionIdleTimeout={ConnectionIdleTimeout};" +
               $"AllowUserVariables=true;UseAffectedRows=false";
    }
}
```

---

## ADO.NET avec MySqlConnector

### Connexion et requ√™tes basiques

```csharp
// Data/MariaDbConnection.cs
using MySqlConnector;

namespace MariaDbApp.Data;

public class MariaDbConnectionFactory
{
    private readonly string _connectionString;
    
    public MariaDbConnectionFactory(string connectionString)
    {
        _connectionString = connectionString;
    }
    
    public MySqlConnection CreateConnection()
    {
        return new MySqlConnection(_connectionString);
    }
    
    public async Task<MySqlConnection> CreateOpenConnectionAsync(
        CancellationToken cancellationToken = default)
    {
        var connection = CreateConnection();
        await connection.OpenAsync(cancellationToken);
        return connection;
    }
    
    public async Task<bool> TestConnectionAsync(
        CancellationToken cancellationToken = default)
    {
        try
        {
            await using var connection = CreateConnection();
            await connection.OpenAsync(cancellationToken);
            
            await using var command = connection.CreateCommand();
            command.CommandText = "SELECT VERSION()";
            
            var version = await command.ExecuteScalarAsync(cancellationToken);
            Console.WriteLine($"‚úì Connected to MariaDB {version}");
            
            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚úó Connection failed: {ex.Message}");
            return false;
        }
    }
}
```

### Mod√®les de donn√©es

```csharp
// Models/User.cs
namespace MariaDbApp.Models;

public class User
{
    public long Id { get; set; }
    public string Username { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public string PasswordHash { get; set; } = string.Empty;
    public string? FirstName { get; set; }
    public string? LastName { get; set; }
    public bool IsActive { get; set; } = true;
    public bool IsAdmin { get; set; } = false;
    public DateTime CreatedAt { get; set; }
    public DateTime? UpdatedAt { get; set; }
    public DateTime? LastLogin { get; set; }
}

public record UserCreateDto(
    string Username,
    string Email,
    string Password,
    string? FirstName,
    string? LastName
);

public record UserUpdateDto(
    string? Email,
    string? FirstName,
    string? LastName,
    bool? IsActive
);
```

### Repository avec ADO.NET

```csharp
// Repositories/UserRepository.cs
using MySqlConnector;
using MariaDbApp.Models;

namespace MariaDbApp.Repositories;

public interface IUserRepository
{
    Task<User?> GetByIdAsync(long id, CancellationToken ct = default);
    Task<User?> GetByEmailAsync(string email, CancellationToken ct = default);
    Task<IEnumerable<User>> ListAsync(int limit, int offset, CancellationToken ct = default);
    Task<long> CreateAsync(UserCreateDto user, CancellationToken ct = default);
    Task<bool> UpdateAsync(long id, UserUpdateDto user, CancellationToken ct = default);
    Task<bool> DeleteAsync(long id, CancellationToken ct = default);
    Task<long> CountAsync(CancellationToken ct = default);
}

public class UserRepository : IUserRepository
{
    private readonly MariaDbConnectionFactory _connectionFactory;
    
    public UserRepository(MariaDbConnectionFactory connectionFactory)
    {
        _connectionFactory = connectionFactory;
    }
    
    public async Task<User?> GetByIdAsync(long id, CancellationToken ct = default)
    {
        const string sql = @"
            SELECT id, username, email, password_hash, first_name, last_name,
                   is_active, is_admin, created_at, updated_at, last_login
            FROM users
            WHERE id = @Id";
        
        await using var connection = await _connectionFactory.CreateOpenConnectionAsync(ct);
        await using var command = new MySqlCommand(sql, connection);
        
        command.Parameters.AddWithValue("@Id", id);
        
        await using var reader = await command.ExecuteReaderAsync(ct);
        
        if (!await reader.ReadAsync(ct))
            return null;
        
        return MapUser(reader);
    }
    
    public async Task<User?> GetByEmailAsync(string email, CancellationToken ct = default)
    {
        const string sql = @"
            SELECT id, username, email, password_hash, first_name, last_name,
                   is_active, is_admin, created_at, updated_at, last_login
            FROM users
            WHERE email = @Email";
        
        await using var connection = await _connectionFactory.CreateOpenConnectionAsync(ct);
        await using var command = new MySqlCommand(sql, connection);
        
        command.Parameters.AddWithValue("@Email", email);
        
        await using var reader = await command.ExecuteReaderAsync(ct);
        
        if (!await reader.ReadAsync(ct))
            return null;
        
        return MapUser(reader);
    }
    
    public async Task<IEnumerable<User>> ListAsync(
        int limit, int offset, CancellationToken ct = default)
    {
        const string sql = @"
            SELECT id, username, email, first_name, last_name,
                   is_active, created_at
            FROM users
            WHERE is_active = true
            ORDER BY created_at DESC
            LIMIT @Limit OFFSET @Offset";
        
        await using var connection = await _connectionFactory.CreateOpenConnectionAsync(ct);
        await using var command = new MySqlCommand(sql, connection);
        
        command.Parameters.AddWithValue("@Limit", limit);
        command.Parameters.AddWithValue("@Offset", offset);
        
        var users = new List<User>();
        
        await using var reader = await command.ExecuteReaderAsync(ct);
        while (await reader.ReadAsync(ct))
        {
            users.Add(MapUserPartial(reader));
        }
        
        return users;
    }
    
    public async Task<long> CreateAsync(UserCreateDto dto, CancellationToken ct = default)
    {
        const string sql = @"
            INSERT INTO users (username, email, password_hash, first_name, last_name, created_at)
            VALUES (@Username, @Email, @PasswordHash, @FirstName, @LastName, NOW());
            SELECT LAST_INSERT_ID();";
        
        await using var connection = await _connectionFactory.CreateOpenConnectionAsync(ct);
        await using var command = new MySqlCommand(sql, connection);
        
        command.Parameters.AddWithValue("@Username", dto.Username);
        command.Parameters.AddWithValue("@Email", dto.Email);
        command.Parameters.AddWithValue("@PasswordHash", HashPassword(dto.Password));
        command.Parameters.AddWithValue("@FirstName", dto.FirstName ?? (object)DBNull.Value);
        command.Parameters.AddWithValue("@LastName", dto.LastName ?? (object)DBNull.Value);
        
        var result = await command.ExecuteScalarAsync(ct);
        return Convert.ToInt64(result);
    }
    
    public async Task<bool> UpdateAsync(long id, UserUpdateDto dto, CancellationToken ct = default)
    {
        var updates = new List<string>();
        var parameters = new List<MySqlParameter>();
        
        if (dto.Email is not null)
        {
            updates.Add("email = @Email");
            parameters.Add(new MySqlParameter("@Email", dto.Email));
        }
        
        if (dto.FirstName is not null)
        {
            updates.Add("first_name = @FirstName");
            parameters.Add(new MySqlParameter("@FirstName", dto.FirstName));
        }
        
        if (dto.LastName is not null)
        {
            updates.Add("last_name = @LastName");
            parameters.Add(new MySqlParameter("@LastName", dto.LastName));
        }
        
        if (dto.IsActive.HasValue)
        {
            updates.Add("is_active = @IsActive");
            parameters.Add(new MySqlParameter("@IsActive", dto.IsActive.Value));
        }
        
        if (updates.Count == 0)
            return false;
        
        updates.Add("updated_at = NOW()");
        
        var sql = $@"
            UPDATE users 
            SET {string.Join(", ", updates)}
            WHERE id = @Id";
        
        await using var connection = await _connectionFactory.CreateOpenConnectionAsync(ct);
        await using var command = new MySqlCommand(sql, connection);
        
        parameters.Add(new MySqlParameter("@Id", id));
        command.Parameters.AddRange(parameters.ToArray());
        
        var affected = await command.ExecuteNonQueryAsync(ct);
        return affected > 0;
    }
    
    public async Task<bool> DeleteAsync(long id, CancellationToken ct = default)
    {
        const string sql = @"
            UPDATE users 
            SET is_active = false, updated_at = NOW()
            WHERE id = @Id";
        
        await using var connection = await _connectionFactory.CreateOpenConnectionAsync(ct);
        await using var command = new MySqlCommand(sql, connection);
        
        command.Parameters.AddWithValue("@Id", id);
        
        var affected = await command.ExecuteNonQueryAsync(ct);
        return affected > 0;
    }
    
    public async Task<long> CountAsync(CancellationToken ct = default)
    {
        const string sql = "SELECT COUNT(*) FROM users WHERE is_active = true";
        
        await using var connection = await _connectionFactory.CreateOpenConnectionAsync(ct);
        await using var command = new MySqlCommand(sql, connection);
        
        var result = await command.ExecuteScalarAsync(ct);
        return Convert.ToInt64(result);
    }
    
    // Helper methods
    private static User MapUser(MySqlDataReader reader)
    {
        return new User
        {
            Id = reader.GetInt64("id"),
            Username = reader.GetString("username"),
            Email = reader.GetString("email"),
            PasswordHash = reader.GetString("password_hash"),
            FirstName = reader.IsDBNull("first_name") ? null : reader.GetString("first_name"),
            LastName = reader.IsDBNull("last_name") ? null : reader.GetString("last_name"),
            IsActive = reader.GetBoolean("is_active"),
            IsAdmin = reader.GetBoolean("is_admin"),
            CreatedAt = reader.GetDateTime("created_at"),
            UpdatedAt = reader.IsDBNull("updated_at") ? null : reader.GetDateTime("updated_at"),
            LastLogin = reader.IsDBNull("last_login") ? null : reader.GetDateTime("last_login")
        };
    }
    
    private static User MapUserPartial(MySqlDataReader reader)
    {
        return new User
        {
            Id = reader.GetInt64("id"),
            Username = reader.GetString("username"),
            Email = reader.GetString("email"),
            FirstName = reader.IsDBNull("first_name") ? null : reader.GetString("first_name"),
            LastName = reader.IsDBNull("last_name") ? null : reader.GetString("last_name"),
            IsActive = reader.GetBoolean("is_active"),
            CreatedAt = reader.GetDateTime("created_at")
        };
    }
    
    private static string HashPassword(string password)
    {
        // Utiliser BCrypt ou Identity PasswordHasher en production
        return BCrypt.Net.BCrypt.HashPassword(password, 12);
    }
}
```

‚ö†Ô∏è **Attention** : TOUJOURS utiliser des param√®tres (`@Name`) et JAMAIS de concat√©nation de cha√Ænes pour les requ√™tes SQL !

```csharp
// ‚ùå DANGEREUX - Injection SQL possible
string username = "admin' OR '1'='1";
string sql = $"SELECT * FROM users WHERE username = '{username}'";

// ‚úÖ S√âCURIS√â - Parameterized query
string sql = "SELECT * FROM users WHERE username = @Username";
command.Parameters.AddWithValue("@Username", username);
```

---

## Gestion des transactions

### Transactions avec MySqlConnector

```csharp
// Repositories/OrderRepository.cs
using MySqlConnector;
using MariaDbApp.Models;

namespace MariaDbApp.Repositories;

public class OrderRepository
{
    private readonly MariaDbConnectionFactory _connectionFactory;
    
    public OrderRepository(MariaDbConnectionFactory connectionFactory)
    {
        _connectionFactory = connectionFactory;
    }
    
    public async Task<long> CreateOrderAsync(
        long userId, 
        List<OrderItemDto> items,
        CancellationToken ct = default)
    {
        await using var connection = await _connectionFactory.CreateOpenConnectionAsync(ct);
        
        // D√©marrer la transaction
        await using var transaction = await connection.BeginTransactionAsync(ct);
        
        try
        {
            // 1. Cr√©er la commande
            const string orderSql = @"
                INSERT INTO orders (user_id, total_amount, status, created_at)
                VALUES (@UserId, 0, 'pending', NOW());
                SELECT LAST_INSERT_ID();";
            
            await using var orderCmd = new MySqlCommand(orderSql, connection, transaction);
            orderCmd.Parameters.AddWithValue("@UserId", userId);
            
            var orderId = Convert.ToInt64(await orderCmd.ExecuteScalarAsync(ct));
            decimal totalAmount = 0;
            
            // 2. Traiter chaque item
            foreach (var item in items)
            {
                // R√©cup√©rer le produit avec lock
                const string productSql = @"
                    SELECT id, price, stock 
                    FROM products 
                    WHERE id = @ProductId 
                    FOR UPDATE";
                
                await using var productCmd = new MySqlCommand(productSql, connection, transaction);
                productCmd.Parameters.AddWithValue("@ProductId", item.ProductId);
                
                await using var reader = await productCmd.ExecuteReaderAsync(ct);
                
                if (!await reader.ReadAsync(ct))
                    throw new InvalidOperationException($"Product {item.ProductId} not found");
                
                var price = reader.GetDecimal("price");
                var stock = reader.GetInt32("stock");
                
                await reader.CloseAsync();
                
                if (stock < item.Quantity)
                    throw new InvalidOperationException($"Insufficient stock for product {item.ProductId}");
                
                var subtotal = price * item.Quantity;
                totalAmount += subtotal;
                
                // Cr√©er l'item
                const string itemSql = @"
                    INSERT INTO order_items (order_id, product_id, quantity, price)
                    VALUES (@OrderId, @ProductId, @Quantity, @Price)";
                
                await using var itemCmd = new MySqlCommand(itemSql, connection, transaction);
                itemCmd.Parameters.AddWithValue("@OrderId", orderId);
                itemCmd.Parameters.AddWithValue("@ProductId", item.ProductId);
                itemCmd.Parameters.AddWithValue("@Quantity", item.Quantity);
                itemCmd.Parameters.AddWithValue("@Price", price);
                
                await itemCmd.ExecuteNonQueryAsync(ct);
                
                // D√©cr√©menter le stock
                const string stockSql = @"
                    UPDATE products 
                    SET stock = stock - @Quantity 
                    WHERE id = @ProductId";
                
                await using var stockCmd = new MySqlCommand(stockSql, connection, transaction);
                stockCmd.Parameters.AddWithValue("@Quantity", item.Quantity);
                stockCmd.Parameters.AddWithValue("@ProductId", item.ProductId);
                
                await stockCmd.ExecuteNonQueryAsync(ct);
            }
            
            // 3. Mettre √† jour le total
            const string updateSql = @"
                UPDATE orders 
                SET total_amount = @Total 
                WHERE id = @OrderId";
            
            await using var updateCmd = new MySqlCommand(updateSql, connection, transaction);
            updateCmd.Parameters.AddWithValue("@Total", totalAmount);
            updateCmd.Parameters.AddWithValue("@OrderId", orderId);
            
            await updateCmd.ExecuteNonQueryAsync(ct);
            
            // 4. Valider la transaction
            await transaction.CommitAsync(ct);
            
            return orderId;
        }
        catch
        {
            // Annuler en cas d'erreur
            await transaction.RollbackAsync(ct);
            throw;
        }
    }
}
```

---

## Entity Framework Core

### Installation

```bash
dotnet add package Pomelo.EntityFrameworkCore.MySql
dotnet add package Microsoft.EntityFrameworkCore.Design
```

### DbContext

```csharp
// Data/ApplicationDbContext.cs
using Microsoft.EntityFrameworkCore;
using MariaDbApp.Models;

namespace MariaDbApp.Data;

public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }
    
    public DbSet<User> Users => Set<User>();
    public DbSet<Order> Orders => Set<Order>();
    public DbSet<OrderItem> OrderItems => Set<OrderItem>();
    public DbSet<Product> Products => Set<Product>();
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        
        // Configuration User
        modelBuilder.Entity<User>(entity =>
        {
            entity.ToTable("users");
            
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Id).HasColumnName("id");
            
            entity.Property(e => e.Username)
                .HasColumnName("username")
                .HasMaxLength(50)
                .IsRequired();
            
            entity.Property(e => e.Email)
                .HasColumnName("email")
                .HasMaxLength(255)
                .IsRequired();
            
            entity.Property(e => e.PasswordHash)
                .HasColumnName("password_hash")
                .HasMaxLength(255)
                .IsRequired();
            
            entity.Property(e => e.FirstName)
                .HasColumnName("first_name")
                .HasMaxLength(100);
            
            entity.Property(e => e.LastName)
                .HasColumnName("last_name")
                .HasMaxLength(100);
            
            entity.Property(e => e.IsActive)
                .HasColumnName("is_active")
                .HasDefaultValue(true);
            
            entity.Property(e => e.IsAdmin)
                .HasColumnName("is_admin")
                .HasDefaultValue(false);
            
            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .HasDefaultValueSql("CURRENT_TIMESTAMP");
            
            entity.Property(e => e.UpdatedAt)
                .HasColumnName("updated_at");
            
            entity.Property(e => e.LastLogin)
                .HasColumnName("last_login");
            
            // Index
            entity.HasIndex(e => e.Email).IsUnique();
            entity.HasIndex(e => e.Username).IsUnique();
            entity.HasIndex(e => new { e.IsActive, e.CreatedAt });
            
            // Relations
            entity.HasMany(e => e.Orders)
                .WithOne(e => e.User)
                .HasForeignKey(e => e.UserId)
                .OnDelete(DeleteBehavior.Cascade);
        });
        
        // Configuration Order
        modelBuilder.Entity<Order>(entity =>
        {
            entity.ToTable("orders");
            
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Id).HasColumnName("id");
            
            entity.Property(e => e.UserId)
                .HasColumnName("user_id")
                .IsRequired();
            
            entity.Property(e => e.TotalAmount)
                .HasColumnName("total_amount")
                .HasColumnType("decimal(10,2)")
                .IsRequired();
            
            entity.Property(e => e.Status)
                .HasColumnName("status")
                .HasMaxLength(20)
                .IsRequired()
                .HasDefaultValue("pending");
            
            entity.Property(e => e.CreatedAt)
                .HasColumnName("created_at")
                .HasDefaultValueSql("CURRENT_TIMESTAMP");
            
            entity.Property(e => e.UpdatedAt)
                .HasColumnName("updated_at");
            
            // Index
            entity.HasIndex(e => new { e.UserId, e.Status });
            
            // Relations
            entity.HasMany(e => e.Items)
                .WithOne(e => e.Order)
                .HasForeignKey(e => e.OrderId)
                .OnDelete(DeleteBehavior.Cascade);
        });
        
        // Configuration OrderItem
        modelBuilder.Entity<OrderItem>(entity =>
        {
            entity.ToTable("order_items");
            
            entity.HasKey(e => e.Id);
            
            entity.Property(e => e.Price)
                .HasColumnType("decimal(10,2)");
            
            entity.HasIndex(e => new { e.OrderId, e.ProductId }).IsUnique();
        });
        
        // Configuration Product
        modelBuilder.Entity<Product>(entity =>
        {
            entity.ToTable("products");
            
            entity.Property(e => e.Price)
                .HasColumnType("decimal(10,2)");
            
            entity.HasIndex(e => new { e.IsActive, e.Price });
        });
    }
}
```

### Mod√®les EF Core

```csharp
// Models/Entities.cs
namespace MariaDbApp.Models;

public class Order
{
    public long Id { get; set; }
    public long UserId { get; set; }
    public decimal TotalAmount { get; set; }
    public string Status { get; set; } = "pending";
    public DateTime CreatedAt { get; set; }
    public DateTime? UpdatedAt { get; set; }
    
    // Navigation properties
    public User User { get; set; } = null!;
    public ICollection<OrderItem> Items { get; set; } = new List<OrderItem>();
}

public class OrderItem
{
    public long Id { get; set; }
    public long OrderId { get; set; }
    public long ProductId { get; set; }
    public int Quantity { get; set; }
    public decimal Price { get; set; }
    
    // Navigation properties
    public Order Order { get; set; } = null!;
    public Product Product { get; set; } = null!;
}

public class Product
{
    public long Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public decimal Price { get; set; }
    public int Stock { get; set; }
    public bool IsActive { get; set; } = true;
    public DateTime CreatedAt { get; set; }
    public DateTime? UpdatedAt { get; set; }
    
    // Navigation properties
    public ICollection<OrderItem> OrderItems { get; set; } = new List<OrderItem>();
}

public record OrderItemDto(long ProductId, int Quantity);
```

### Repository avec EF Core

```csharp
// Repositories/UserRepositoryEF.cs
using Microsoft.EntityFrameworkCore;
using MariaDbApp.Data;
using MariaDbApp.Models;

namespace MariaDbApp.Repositories;

public class UserRepositoryEF
{
    private readonly ApplicationDbContext _context;
    
    public UserRepositoryEF(ApplicationDbContext context)
    {
        _context = context;
    }
    
    public async Task<User?> GetByIdAsync(long id, CancellationToken ct = default)
    {
        return await _context.Users
            .AsNoTracking()
            .FirstOrDefaultAsync(u => u.Id == id, ct);
    }
    
    public async Task<User?> GetByEmailAsync(string email, CancellationToken ct = default)
    {
        return await _context.Users
            .AsNoTracking()
            .FirstOrDefaultAsync(u => u.Email == email, ct);
    }
    
    public async Task<List<User>> ListAsync(
        int page, int pageSize, CancellationToken ct = default)
    {
        return await _context.Users
            .AsNoTracking()
            .Where(u => u.IsActive)
            .OrderByDescending(u => u.CreatedAt)
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync(ct);
    }
    
    public async Task<User> CreateAsync(UserCreateDto dto, CancellationToken ct = default)
    {
        var user = new User
        {
            Username = dto.Username,
            Email = dto.Email,
            PasswordHash = HashPassword(dto.Password),
            FirstName = dto.FirstName,
            LastName = dto.LastName,
            CreatedAt = DateTime.UtcNow
        };
        
        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);
        
        return user;
    }
    
    public async Task<bool> UpdateAsync(
        long id, UserUpdateDto dto, CancellationToken ct = default)
    {
        var user = await _context.Users.FindAsync(new object[] { id }, ct);
        if (user is null)
            return false;
        
        if (dto.Email is not null)
            user.Email = dto.Email;
        
        if (dto.FirstName is not null)
            user.FirstName = dto.FirstName;
        
        if (dto.LastName is not null)
            user.LastName = dto.LastName;
        
        if (dto.IsActive.HasValue)
            user.IsActive = dto.IsActive.Value;
        
        user.UpdatedAt = DateTime.UtcNow;
        
        await _context.SaveChangesAsync(ct);
        return true;
    }
    
    public async Task<bool> DeleteAsync(long id, CancellationToken ct = default)
    {
        var user = await _context.Users.FindAsync(new object[] { id }, ct);
        if (user is null)
            return false;
        
        user.IsActive = false;
        user.UpdatedAt = DateTime.UtcNow;
        
        await _context.SaveChangesAsync(ct);
        return true;
    }
    
    public async Task<User?> GetWithOrdersAsync(long id, CancellationToken ct = default)
    {
        return await _context.Users
            .Include(u => u.Orders.OrderByDescending(o => o.CreatedAt).Take(10))
            .FirstOrDefaultAsync(u => u.Id == id, ct);
    }
    
    public async Task<List<User>> SearchAsync(
        string term, int limit, CancellationToken ct = default)
    {
        return await _context.Users
            .AsNoTracking()
            .Where(u => u.IsActive && 
                       (EF.Functions.Like(u.Username, $"%{term}%") ||
                        EF.Functions.Like(u.Email, $"%{term}%")))
            .Take(limit)
            .ToListAsync(ct);
    }
    
    public async Task<long> CountAsync(CancellationToken ct = default)
    {
        return await _context.Users
            .Where(u => u.IsActive)
            .CountAsync(ct);
    }
    
    private static string HashPassword(string password)
    {
        return BCrypt.Net.BCrypt.HashPassword(password, 12);
    }
}
```

---

## Dapper : Micro-ORM haute performance

### Installation et utilisation

```bash
dotnet add package Dapper
```

```csharp
// Repositories/UserRepositoryDapper.cs
using Dapper;
using MySqlConnector;
using MariaDbApp.Models;

namespace MariaDbApp.Repositories;

public class UserRepositoryDapper
{
    private readonly MariaDbConnectionFactory _connectionFactory;
    
    public UserRepositoryDapper(MariaDbConnectionFactory connectionFactory)
    {
        _connectionFactory = connectionFactory;
    }
    
    public async Task<User?> GetByIdAsync(long id, CancellationToken ct = default)
    {
        const string sql = @"
            SELECT id AS Id, username AS Username, email AS Email,
                   password_hash AS PasswordHash, first_name AS FirstName,
                   last_name AS LastName, is_active AS IsActive,
                   is_admin AS IsAdmin, created_at AS CreatedAt,
                   updated_at AS UpdatedAt, last_login AS LastLogin
            FROM users
            WHERE id = @Id";
        
        await using var connection = await _connectionFactory.CreateOpenConnectionAsync(ct);
        
        return await connection.QuerySingleOrDefaultAsync<User>(
            new CommandDefinition(sql, new { Id = id }, cancellationToken: ct));
    }
    
    public async Task<IEnumerable<User>> ListAsync(
        int limit, int offset, CancellationToken ct = default)
    {
        const string sql = @"
            SELECT id AS Id, username AS Username, email AS Email,
                   first_name AS FirstName, last_name AS LastName,
                   is_active AS IsActive, created_at AS CreatedAt
            FROM users
            WHERE is_active = true
            ORDER BY created_at DESC
            LIMIT @Limit OFFSET @Offset";
        
        await using var connection = await _connectionFactory.CreateOpenConnectionAsync(ct);
        
        return await connection.QueryAsync<User>(
            new CommandDefinition(
                sql, 
                new { Limit = limit, Offset = offset }, 
                cancellationToken: ct));
    }
    
    public async Task<long> CreateAsync(UserCreateDto dto, CancellationToken ct = default)
    {
        const string sql = @"
            INSERT INTO users (username, email, password_hash, first_name, last_name, created_at)
            VALUES (@Username, @Email, @PasswordHash, @FirstName, @LastName, NOW());
            SELECT LAST_INSERT_ID();";
        
        await using var connection = await _connectionFactory.CreateOpenConnectionAsync(ct);
        
        return await connection.ExecuteScalarAsync<long>(
            new CommandDefinition(
                sql,
                new
                {
                    dto.Username,
                    dto.Email,
                    PasswordHash = HashPassword(dto.Password),
                    dto.FirstName,
                    dto.LastName
                },
                cancellationToken: ct));
    }
    
    public async Task<int> BulkInsertAsync(
        IEnumerable<UserCreateDto> users, CancellationToken ct = default)
    {
        const string sql = @"
            INSERT INTO users (username, email, password_hash, first_name, last_name, created_at)
            VALUES (@Username, @Email, @PasswordHash, @FirstName, @LastName, NOW())";
        
        await using var connection = await _connectionFactory.CreateOpenConnectionAsync(ct);
        
        var parameters = users.Select(u => new
        {
            u.Username,
            u.Email,
            PasswordHash = HashPassword(u.Password),
            u.FirstName,
            u.LastName
        });
        
        return await connection.ExecuteAsync(
            new CommandDefinition(sql, parameters, cancellationToken: ct));
    }
    
    public async Task<IEnumerable<dynamic>> GetUserStatsAsync(CancellationToken ct = default)
    {
        const string sql = @"
            SELECT 
                u.username,
                COUNT(o.id) as order_count,
                COALESCE(SUM(o.total_amount), 0) as total_spent
            FROM users u
            LEFT JOIN orders o ON u.id = o.user_id
            WHERE u.is_active = true
            GROUP BY u.id, u.username
            HAVING order_count > 0
            ORDER BY total_spent DESC";
        
        await using var connection = await _connectionFactory.CreateOpenConnectionAsync(ct);
        
        return await connection.QueryAsync(
            new CommandDefinition(sql, cancellationToken: ct));
    }
    
    private static string HashPassword(string password)
    {
        return BCrypt.Net.BCrypt.HashPassword(password, 12);
    }
}
```

üí° **Conseil** : Dapper est excellent pour les requ√™tes read-only et les op√©rations bulk. Pour des entit√©s complexes avec relations, EF Core reste plus pratique.

---

## Configuration ASP.NET Core

### Program.cs (.NET 6+ Minimal API)

```csharp
// Program.cs
using Microsoft.EntityFrameworkCore;
using MariaDbApp.Data;
using MariaDbApp.Repositories;
using MariaDbApp.Services;

var builder = WebApplication.CreateBuilder(args);

// Configuration
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection")
    ?? throw new InvalidOperationException("Connection string not found");

// Services
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Database - Entity Framework Core
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseMySql(
        connectionString,
        ServerVersion.AutoDetect(connectionString),
        mySqlOptions =>
        {
            mySqlOptions.EnableRetryOnFailure(
                maxRetryCount: 3,
                maxRetryDelay: TimeSpan.FromSeconds(5),
                errorNumbersToAdd: null);
            
            mySqlOptions.CommandTimeout(30);
        })
        .EnableSensitiveDataLogging(builder.Environment.IsDevelopment())
        .EnableDetailedErrors(builder.Environment.IsDevelopment()));

// Database - ADO.NET
builder.Services.AddSingleton(new MariaDbConnectionFactory(connectionString));

// Repositories
builder.Services.AddScoped<IUserRepository, UserRepository>();
builder.Services.AddScoped<UserRepositoryEF>();
builder.Services.AddScoped<UserRepositoryDapper>();

// Services
builder.Services.AddScoped<IUserService, UserService>();

// Health checks
builder.Services.AddHealthChecks()
    .AddDbContextCheck<ApplicationDbContext>("database");

var app = builder.Build();

// Middleware pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();
app.MapHealthChecks("/health");

app.Run();
```

### Controller exemple

```csharp
// Controllers/UsersController.cs
using Microsoft.AspNetCore.Mvc;
using MariaDbApp.Models;
using MariaDbApp.Services;

namespace MariaDbApp.Controllers;

[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly IUserService _userService;
    private readonly ILogger<UsersController> _logger;
    
    public UsersController(IUserService userService, ILogger<UsersController> logger)
    {
        _userService = userService;
        _logger = logger;
    }
    
    [HttpGet]
    public async Task<ActionResult<IEnumerable<User>>> GetUsers(
        [FromQuery] int page = 1,
        [FromQuery] int pageSize = 20,
        CancellationToken ct = default)
    {
        try
        {
            var users = await _userService.GetUsersAsync(page, pageSize, ct);
            return Ok(users);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting users");
            return StatusCode(500, "Internal server error");
        }
    }
    
    [HttpGet("{id}")]
    public async Task<ActionResult<User>> GetUser(long id, CancellationToken ct = default)
    {
        var user = await _userService.GetUserByIdAsync(id, ct);
        
        if (user is null)
            return NotFound();
        
        return Ok(user);
    }
    
    [HttpPost]
    public async Task<ActionResult<User>> CreateUser(
        [FromBody] UserCreateDto dto,
        CancellationToken ct = default)
    {
        try
        {
            var userId = await _userService.CreateUserAsync(dto, ct);
            var user = await _userService.GetUserByIdAsync(userId, ct);
            
            return CreatedAtAction(nameof(GetUser), new { id = userId }, user);
        }
        catch (InvalidOperationException ex)
        {
            return BadRequest(ex.Message);
        }
    }
    
    [HttpPut("{id}")]
    public async Task<IActionResult> UpdateUser(
        long id,
        [FromBody] UserUpdateDto dto,
        CancellationToken ct = default)
    {
        var success = await _userService.UpdateUserAsync(id, dto, ct);
        
        if (!success)
            return NotFound();
        
        return NoContent();
    }
    
    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteUser(long id, CancellationToken ct = default)
    {
        var success = await _userService.DeleteUserAsync(id, ct);
        
        if (!success)
            return NotFound();
        
        return NoContent();
    }
}
```

---

## Bonnes pratiques de s√©curit√©

### Validation avec FluentValidation

```csharp
// Validators/UserCreateValidator.cs
using FluentValidation;
using MariaDbApp.Models;

namespace MariaDbApp.Validators;

public class UserCreateValidator : AbstractValidator<UserCreateDto>
{
    public UserCreateValidator()
    {
        RuleFor(x => x.Username)
            .NotEmpty().WithMessage("Username is required")
            .Length(3, 50).WithMessage("Username must be between 3 and 50 characters")
            .Matches("^[a-zA-Z0-9_]+$").WithMessage("Username can only contain letters, numbers and underscore");
        
        RuleFor(x => x.Email)
            .NotEmpty().WithMessage("Email is required")
            .EmailAddress().WithMessage("Invalid email format")
            .MaximumLength(255);
        
        RuleFor(x => x.Password)
            .NotEmpty().WithMessage("Password is required")
            .MinimumLength(12).WithMessage("Password must be at least 12 characters")
            .Matches("[A-Z]").WithMessage("Password must contain uppercase letter")
            .Matches("[a-z]").WithMessage("Password must contain lowercase letter")
            .Matches("[0-9]").WithMessage("Password must contain digit")
            .Matches("[^a-zA-Z0-9]").WithMessage("Password must contain special character");
    }
}
```

### Authentication avec ASP.NET Core Identity

```csharp
// Services/AuthService.cs
using Microsoft.AspNetCore.Identity;
using MariaDbApp.Models;
using MariaDbApp.Repositories;

namespace MariaDbApp.Services;

public interface IAuthService
{
    Task<User?> AuthenticateAsync(string email, string password, CancellationToken ct = default);
    Task<string> GenerateTokenAsync(User user);
}

public class AuthService : IAuthService
{
    private readonly IUserRepository _userRepository;
    private readonly IPasswordHasher<User> _passwordHasher;
    
    public AuthService(
        IUserRepository userRepository,
        IPasswordHasher<User> passwordHasher)
    {
        _userRepository = userRepository;
        _passwordHasher = passwordHasher;
    }
    
    public async Task<User?> AuthenticateAsync(
        string email, 
        string password, 
        CancellationToken ct = default)
    {
        var user = await _userRepository.GetByEmailAsync(email, ct);
        
        if (user is null || !user.IsActive)
            return null;
        
        var result = _passwordHasher.VerifyHashedPassword(
            user, 
            user.PasswordHash, 
            password);
        
        if (result == PasswordVerificationResult.Failed)
            return null;
        
        // Si rehash n√©cessaire (algorithme am√©lior√©)
        if (result == PasswordVerificationResult.SuccessRehashNeeded)
        {
            user.PasswordHash = _passwordHasher.HashPassword(user, password);
            await _userRepository.UpdateAsync(user.Id, new UserUpdateDto(
                Email: null,
                FirstName: null,
                LastName: null,
                IsActive: null
            ), ct);
        }
        
        return user;
    }
    
    public Task<string> GenerateTokenAsync(User user)
    {
        // Impl√©menter JWT ou autre m√©canisme
        throw new NotImplementedException();
    }
}
```

---

## ‚úÖ Points cl√©s √† retenir

1. **Connecteur** : MySqlConnector recommand√© (performance, async natif, MIT)
2. **ORM** : Entity Framework Core pour productivit√©, Dapper pour performance
3. **Async/await** : Toujours utiliser les m√©thodes async (*Async)
4. **Param√®tres** : @Name pour ADO.NET, toujours param√©tr√©
5. **Connection pooling** : G√©r√© automatiquement par le connecteur
6. **Transactions** : using + BeginTransactionAsync + try/catch
7. **Nullable** : Activer `<Nullable>enable</Nullable>` dans .csproj
8. **CancellationToken** : Passer partout pour annulation gracieuse
9. **Validation** : FluentValidation c√¥t√© serveur
10. **Security** : PasswordHasher pour bcrypt, HTTPS obligatoire

---

## üîó Ressources et r√©f√©rences

### Documentation officielle
- [üìñ MySqlConnector](https://mysqlconnector.net/)
- [üìñ Pomelo EF Core Provider](https://github.com/PomeloFoundation/Pomelo.EntityFrameworkCore.MySql)
- [üìñ Entity Framework Core](https://docs.microsoft.com/ef/core/)
- [üìñ Dapper](https://github.com/DapperLib/Dapper)

### Microsoft Docs
- [ASP.NET Core](https://docs.microsoft.com/aspnet/core/)
- [ADO.NET](https://docs.microsoft.com/dotnet/framework/data/adonet/)

### Outils
- [EF Core Tools](https://docs.microsoft.com/ef/core/cli/dotnet) - Migrations CLI
- [FluentValidation](https://fluentvalidation.net/)
- [Serilog](https://serilog.net/) - Structured logging

---

## üéâ Conclusion du chapitre 17.1

Vous avez maintenant une vue compl√®te de l'int√©gration MariaDB dans **6 √©cosyst√®mes majeurs** :

| Langage | Connecteur | ORM | Forces |
|---------|-----------|-----|--------|
| PHP | mysqli/PDO | Doctrine/Eloquent | Web traditionnel |
| Python | PyMySQL/mysqlclient | SQLAlchemy | Data science, ML |
| Java | JDBC | Hibernate/Spring Data | Enterprise |
| Node.js | mysql2 | Prisma/Sequelize | APIs modernes |
| Go | go-sql-driver | GORM | Microservices |
| .NET | MySqlConnector | EF Core | Cross-platform |

### Principes universels

Quel que soit le langage :
1. ‚úÖ **Toujours** utiliser prepared statements/parameterized queries
2. ‚úÖ Connection pooling en production
3. ‚úÖ Transactions pour op√©rations atomiques
4. ‚úÖ Validation stricte des entr√©es
5. ‚úÖ Hashing bcrypt (12+ rounds) pour mots de passe
6. ‚úÖ Logs structur√©s, monitoring
7. ‚úÖ Tests automatis√©s

---

## ‚û°Ô∏è Section suivante

**17.2 Connection Pooling** : Approfondissement du pooling c√¥t√© application vs ProxySQL, dimensionnement, monitoring et optimisations avanc√©es pour tous les langages.

‚è≠Ô∏è [Connection pooling](/17-integration-developpement/02-connection-pooling.md)
