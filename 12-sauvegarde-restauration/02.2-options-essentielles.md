üîù Retour au [Sommaire](/SOMMAIRE.md)

# 12.2.2 Options essentielles (--single-transaction, --routines, etc.)

> **Niveau** : Avanc√©  
> **Dur√©e estim√©e** : 2.5 heures  
> **Pr√©requis** : Section 12.2.1 (mysqldump/mariadb-dump), connaissance des transactions et de la r√©plication

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Ma√Ætriser les options critiques pour garantir la coh√©rence des sauvegardes en production
- Configurer les dumps pour la continuit√© d'activit√© et le disaster recovery
- Optimiser les performances de sauvegarde selon les contraintes de votre environnement
- Pr√©parer les dumps pour le Point-in-Time Recovery (PITR)
- Combiner intelligemment les options selon vos cas d'usage
- √âviter les pi√®ges courants li√©s aux mauvaises configurations

---

## Introduction

Les options de `mariadb-dump` ne sont pas de simples param√®tres techniques : elles d√©terminent la **coh√©rence**, la **compl√©tude**, et l'**utilisabilit√©** de vos sauvegardes en cas de disaster recovery. Une mauvaise combinaison d'options peut rendre vos backups inutilisables lors d'un incident critique.

Cette section approfondit les options essentielles qui font la diff√©rence entre un backup "qui semble fonctionner" et un backup **production-ready** qui vous sauvera en cas de sinistre.

### Cat√©gories d'options

Les options critiques se regroupent en 5 cat√©gories :

1. **Coh√©rence transactionnelle** : Garantir un snapshot coh√©rent
2. **Compl√©tude des objets** : Capturer tous les √©l√©ments de la base
3. **Point-in-Time Recovery** : Pr√©parer la restauration pr√©cise
4. **Performance** : Optimiser vitesse et ressources
5. **S√©curit√© et isolation** : Prot√©ger la production et les donn√©es

---

## Options de coh√©rence transactionnelle

### `--single-transaction` : L'option fondamentale InnoDB

```bash
--single-transaction
```

#### Fonctionnement technique

```bash
# Ce que fait mariadb-dump avec --single-transaction :

# 1. D√©marre une transaction avec isolation REPEATABLE READ
START TRANSACTION WITH CONSISTENT SNAPSHOT;

# 2. Lit toutes les donn√©es dans le contexte de ce snapshot
SELECT * FROM table1;
SELECT * FROM table2;
# ...

# 3. Commit √† la fin (ne modifie rien, juste lib√®re les ressources)
COMMIT;
```

üí° **Avantage majeur** : Les √©critures concurrentes continuent normalement pendant le dump. La base reste 100% disponible.

#### Conditions d'utilisation

‚úÖ **Fonctionne parfaitement si** :
- Toutes vos tables utilisent InnoDB (ou autres moteurs transactionnels)
- Pas de modifications DDL pendant le dump (`ALTER TABLE`, `DROP TABLE`, etc.)
- Configuration m√©moire ad√©quate (voir `innodb_buffer_pool_size`)

‚ùå **Ne fonctionne PAS pour** :
- Tables MyISAM (besoin de `--lock-tables`)
- Tables Memory (perdues au red√©marrage)
- Pendant un `ALTER TABLE` en cours

#### Exemple complet avec logging

```bash
#!/bin/bash
# Backup avec single-transaction et v√©rification de coh√©rence

LOG_FILE="/var/log/mariadb_backup_$(date +%Y%m%d).log"

echo "[$(date)] Starting backup with consistent snapshot" | tee -a "$LOG_FILE"

# V√©rifier que toutes les tables sont InnoDB
NON_INNODB=$(mariadb -u backup_user -p -N -e "
    SELECT CONCAT(table_schema, '.', table_name) 
    FROM information_schema.tables 
    WHERE table_schema NOT IN ('information_schema', 'performance_schema', 'mysql')
    AND engine != 'InnoDB'
")

if [ -n "$NON_INNODB" ]; then
    echo "[WARNING] Non-InnoDB tables detected:" | tee -a "$LOG_FILE"
    echo "$NON_INNODB" | tee -a "$LOG_FILE"
    echo "Consider using --lock-all-tables instead" | tee -a "$LOG_FILE"
fi

# Effectuer le backup
mariadb-dump -u backup_user -p \
  --single-transaction \
  --routines \
  --triggers \
  --events \
  --all-databases 2>> "$LOG_FILE" | \
  zstd -3 > backup_$(date +%Y%m%d_%H%M%S).sql.zst

if [ $? -eq 0 ]; then
    echo "[$(date)] ‚úÖ Backup completed successfully" | tee -a "$LOG_FILE"
else
    echo "[$(date)] ‚ùå Backup FAILED" | tee -a "$LOG_FILE"
    exit 1
fi
```

#### Impact sur les performances

```sql
-- Pendant le dump, surveillance de l'impact :

-- Transactions bloqu√©es par le snapshot
SHOW ENGINE INNODB STATUS\G

-- Taille du undo log (augmente pendant le dump)
SELECT 
    SUM(data_length + index_length) / 1024 / 1024 AS undo_size_mb
FROM information_schema.tables
WHERE table_schema = 'mysql' 
AND table_name LIKE '%undo%';

-- Transactions longues
SELECT * FROM information_schema.processlist 
WHERE time > 3600 
AND command = 'Sleep';
```

‚ö†Ô∏è **Attention** : Un dump tr√®s long avec `--single-transaction` peut faire grossir le undo log et ralentir les purges InnoDB.

---

### `--lock-tables` : Verrous par base de donn√©es

```bash
--lock-tables
# Alias : -l
```

#### Fonctionnement

```bash
# Pour chaque base de donn√©es :

FLUSH TABLES;
LOCK TABLES table1 READ, table2 READ, ...;
# Dump de toutes les tables de la base
UNLOCK TABLES;

# Puis passe √† la base suivante
```

üí° **Comportement** : Les tables sont verrouill√©es **par base**, pas globalement.

#### Quand l'utiliser ?

‚úÖ **Cas d'usage** :
- Bases contenant des tables MyISAM
- Petites bases o√π un lock court est acceptable
- Pas de r√©plication (voir `--master-data` pour ce cas)

‚ùå **Inconv√©nient** : Les √©critures sont bloqu√©es pendant le dump de chaque base.

```bash
# Exemple : Mix InnoDB/MyISAM
mariadb-dump -u backup_user -p \
  --lock-tables \
  --routines \
  --triggers \
  mixed_engine_db > backup.sql
```

---

### `--lock-all-tables` : Verrou global

```bash
--lock-all-tables
# Alias : -x
```

#### Fonctionnement

```bash
# Verrouille TOUTES les tables de TOUTES les bases :

FLUSH TABLES WITH READ LOCK;
# Dump complet
UNLOCK TABLES;
```

üí° **Impact** : **Aucune √©criture** n'est possible pendant toute la dur√©e du dump.

#### Quand l'utiliser ?

‚úÖ **Cas d'usage** :
- Coh√©rence absolue requise entre plusieurs bases
- Sauvegarde avant maintenance majeure
- Fen√™tre de maintenance planifi√©e
- Snapshot pour r√©plication (avec `--master-data`)

‚ùå **√Ä √©viter** :
- Production 24/7 sans fen√™tre de maintenance
- Grandes bases (dump > 30 minutes)

```bash
# Exemple : Backup complet avant migration
mariadb-dump -u root -p \
  --lock-all-tables \
  --all-databases \
  --master-data=2 \
  --routines \
  --triggers \
  --events > pre_migration_backup.sql
```

#### Combinaison avec `--single-transaction`

‚ö†Ô∏è **ATTENTION** : `--lock-all-tables` est **incompatible** avec `--single-transaction`. Mariadb-dump privil√©giera `--lock-all-tables`.

```bash
# ‚ùå MAUVAIS : Les deux options ensemble
mariadb-dump --single-transaction --lock-all-tables db > backup.sql
# R√©sultat : lock-all-tables prend le dessus, single-transaction ignor√©

# ‚úÖ BON : Choisir selon le moteur
# Pour InnoDB :
mariadb-dump --single-transaction db > backup.sql

# Pour MyISAM ou mix :
mariadb-dump --lock-all-tables db > backup.sql
```

---

### `--skip-lock-tables` : Sans verrous

```bash
--skip-lock-tables
```

#### Quand l'utiliser ?

‚úÖ **Cas d'usage sp√©cifiques** :
- Dump d'une r√©plica en lecture seule
- Base de donn√©es en lecture seule (read-only)
- Tests et d√©veloppement

‚ùå **Jamais en production** sur une base en √©criture : risque d'incoh√©rence.

```bash
# Exemple : Dump depuis un replica
mariadb-dump -u backup_user -p \
  --skip-lock-tables \
  --single-transaction \
  --host=replica-server \
  production_db > backup.sql
```

---

## Options de capture des objets

### `--routines` : Proc√©dures et fonctions stock√©es

```bash
--routines
# Alias : -R
```

#### Ce qui est sauvegard√©

```sql
-- Sans --routines, cette proc√©dure NE SERA PAS dans le dump :
DELIMITER $$
CREATE PROCEDURE get_customer_orders(IN customer_id INT)
BEGIN
    SELECT * FROM orders WHERE customer = customer_id;
END$$
DELIMITER ;

-- Cette fonction non plus :
CREATE FUNCTION calculate_tax(amount DECIMAL(10,2)) 
RETURNS DECIMAL(10,2)
DETERMINISTIC
BEGIN
    RETURN amount * 0.20;
END;
```

#### Exemple de dump avec routines

```bash
# Dump avec routines
mariadb-dump -u backup_user -p \
  --single-transaction \
  --routines \
  production_db > backup.sql

# Le fichier contiendra :
# /*!50003 CREATE PROCEDURE `get_customer_orders` (...) */
# /*!50003 CREATE FUNCTION `calculate_tax` (...) */
```

üí° **Format conditionnel** : Le `/*!50003 ... */` indique que la syntaxe est compatible avec MariaDB/MySQL 5.00.03+.

#### V√©rification post-backup

```bash
# V√©rifier que les routines sont pr√©sentes
grep -c "CREATE PROCEDURE" backup.sql
grep -c "CREATE FUNCTION" backup.sql

# Lister les routines sauvegard√©es
grep "CREATE PROCEDURE\|CREATE FUNCTION" backup.sql | \
  sed 's/.*CREATE \(PROCEDURE\|FUNCTION\) `\([^`]*\)`.*/\1: \2/'
```

---

### `--triggers` : D√©clencheurs

```bash
--triggers
```

üí° **Note** : Activ√© par d√©faut, mais recommand√© de le sp√©cifier explicitement.

#### Ce qui est sauvegard√©

```sql
-- Trigger critique pour l'audit
CREATE TRIGGER audit_salary_changes
AFTER UPDATE ON employees
FOR EACH ROW
BEGIN
    IF OLD.salary != NEW.salary THEN
        INSERT INTO salary_audit (employee_id, old_salary, new_salary, changed_at)
        VALUES (NEW.id, OLD.salary, NEW.salary, NOW());
    END IF;
END;
```

Sans `--triggers`, ce d√©clencheur serait perdu lors de la restauration.

#### D√©sactiver les triggers temporairement

```bash
# Si vous voulez le sch√©ma SANS les triggers
mariadb-dump -u backup_user -p \
  --single-transaction \
  --skip-triggers \
  production_db > schema_no_triggers.sql

# Cas d'usage : Migration de donn√©es sans d√©clencher les triggers
```

---

### `--events` : T√¢ches planifi√©es

```bash
--events
```

#### Ce qui est sauvegard√©

```sql
-- √âv√©nement de maintenance automatique
CREATE EVENT cleanup_old_sessions
ON SCHEDULE EVERY 1 DAY
STARTS '2025-01-01 03:00:00'
DO
    DELETE FROM sessions 
    WHERE last_activity < NOW() - INTERVAL 30 DAY;

-- √âv√©nement d'agr√©gation quotidienne
CREATE EVENT daily_stats_aggregation
ON SCHEDULE EVERY 1 DAY
STARTS '2025-01-01 00:30:00'
DO
    CALL aggregate_daily_statistics();
```

‚ö†Ô∏è **Important** : L'Event Scheduler doit √™tre activ√© sur le serveur cible.

```sql
-- V√©rifier l'Event Scheduler
SHOW VARIABLES LIKE 'event_scheduler';

-- Activer si n√©cessaire
SET GLOBAL event_scheduler = ON;
```

#### Dump avec events

```bash
mariadb-dump -u backup_user -p \
  --single-transaction \
  --events \
  production_db > backup.sql

# V√©rification
grep -c "CREATE EVENT" backup.sql
```

---

### Combinaison compl√®te : `--all-databases` avec tous les objets

```bash
#!/bin/bash
# Backup COMPLET d'un serveur MariaDB

mariadb-dump -u backup_user -p \
  --all-databases \
  --single-transaction \
  --routines \
  --triggers \
  --events \
  --flush-privileges \
  --master-data=2 | \
  zstd -3 > full_server_backup_$(date +%Y%m%d).sql.zst
```

üí° **Option `--flush-privileges`** : Inclut un `FLUSH PRIVILEGES` apr√®s la restauration des tables syst√®me `mysql.*` pour garantir que les nouveaux utilisateurs/privil√®ges sont actifs.

---

## Options pour Point-in-Time Recovery (PITR)

### `--master-data` : Position binlog pour PITR

```bash
--master-data[=value]
```

#### Valeurs possibles

- `--master-data=1` : Ajoute `CHANGE MASTER TO` **ex√©cutable**
- `--master-data=2` : Ajoute `CHANGE MASTER TO` en **commentaire**

#### Fonctionnement

```bash
# Avec --master-data=1
mariadb-dump -u backup_user -p \
  --single-transaction \
  --master-data=1 \
  production_db > backup.sql
```

Le fichier contiendra :

```sql
-- Position to start replication or point-in-time recovery from this backup.
CHANGE MASTER TO MASTER_LOG_FILE='mariadb-bin.000042', MASTER_LOG_POS=1234567;
```

Avec `--master-data=2` (recommand√© pour PITR) :

```sql
-- CHANGE MASTER TO MASTER_LOG_FILE='mariadb-bin.000042', MASTER_LOG_POS=1234567;
```

#### Cas d'usage : Pr√©paration PITR

```bash
#!/bin/bash
# Backup quotidien avec position binlog pour PITR

BACKUP_DIR="/var/backups/mariadb/daily"
DATE=$(date +%Y%m%d_%H%M%S)

mariadb-dump -u backup_user -p \
  --single-transaction \
  --master-data=2 \
  --routines \
  --triggers \
  --events \
  --all-databases | \
  zstd -3 > "$BACKUP_DIR/backup_${DATE}.sql.zst"

# Extraire la position binlog pour documentation
zstd -dc "$BACKUP_DIR/backup_${DATE}.sql.zst" | \
  grep "CHANGE MASTER TO" | \
  tee "$BACKUP_DIR/backup_${DATE}_binlog_position.txt"

echo "‚úÖ Backup completed with binlog position recorded"
```

üí° **Pourquoi c'est crucial** : En cas de disaster, vous pourrez restaurer ce backup puis "rejouer" les binlogs depuis cette position jusqu'au moment exact du crash.

---

### `--flush-logs` : Rotation des binlogs

```bash
--flush-logs
```

#### Fonctionnement

```bash
# Avant de commencer le dump :
FLUSH LOGS;
# Cr√©e un nouveau fichier binlog, ferme l'ancien
```

#### Cas d'usage : Sauvegardes incr√©mentales

```bash
#!/bin/bash
# Strat√©gie : Full backup quotidien + binlogs pour incr√©mental

# 1. Full backup avec flush-logs
mariadb-dump -u backup_user -p \
  --single-transaction \
  --master-data=2 \
  --flush-logs \
  --all-databases | \
  zstd > /backups/full_$(date +%Y%m%d).sql.zst

# 2. Archiver les anciens binlogs
# (les nouveaux √©v√©nements iront dans un nouveau fichier)
BINLOG_DIR="/var/lib/mysql"
ARCHIVE_DIR="/backups/binlogs/$(date +%Y%m%d)"
mkdir -p "$ARCHIVE_DIR"

# Copier les binlogs ferm√©s (pas le dernier qui est actif)
find "$BINLOG_DIR" -name "mariadb-bin.[0-9]*" -type f -mmin +5 \
  -exec cp {} "$ARCHIVE_DIR/" \;

echo "‚úÖ Full backup + binlog archive completed"
```

üí° **B√©n√©fice** : Vous avez un point de d√©part clair (le full backup) et tous les changements incr√©mentaux (binlogs) depuis ce point.

---

### `--delete-master-logs` : Purge des binlogs

```bash
--delete-master-logs
```

‚ö†Ô∏è **DANGER** : Cette option **supprime tous les binlogs** apr√®s le dump.

```bash
# √âquivalent de :
FLUSH LOGS;
PURGE BINARY LOGS TO '<nouveau_fichier>';
```

‚ùå **√Ä √©viter** dans la plupart des cas, car :
- Emp√™che le PITR entre deux backups
- Bloque la r√©plication si vous avez des replicas
- Perte de donn√©es en cas d'incident entre deux backups

‚úÖ **Utiliser uniquement** si :
- Pas de r√©plication
- Pas de besoin de PITR
- Espace disque tr√®s limit√©

```bash
# ‚ö†Ô∏è USAGE D√âCONSEILL√â (juste pour exemple)
mariadb-dump -u backup_user -p \
  --single-transaction \
  --delete-master-logs \
  standalone_db > backup.sql
```

üí° **Alternative recommand√©e** : Utilisez une politique de r√©tention des binlogs via `expire_logs_days`.

```sql
-- Configurer la r√©tention √† 7 jours
SET GLOBAL expire_logs_days = 7;

-- Ou dans my.cnf
[mysqld]
expire_logs_days = 7
binlog_expire_logs_seconds = 604800  # 7 jours en secondes (MariaDB 10.6+)
```

---

## Options de performance et optimisation

### `--quick` : Streaming sans buffer

```bash
--quick
# Alias : -q
```

#### Fonctionnement

```bash
# SANS --quick (comportement par d√©faut) :
# 1. mariadb-dump lit TOUTE la table en m√©moire
# 2. Puis √©crit dans le fichier de sortie
# Probl√®me : Tables > RAM = swap ou crash

# AVEC --quick :
# 1. mariadb-dump lit ROW par ROW
# 2. √âcrit imm√©diatement dans le fichier
# Avantage : M√©moire constante, tables illimit√©es
```

üí° **Activ√© par d√©faut** depuis MariaDB 10.3, mais recommand√© de le sp√©cifier explicitement.

#### Benchmark comparatif

| Table | Taille | Sans --quick | Avec --quick | M√©moire peak |
|-------|--------|--------------|--------------|--------------|
| users | 500 MB | 45s | 48s | 520 MB / 15 MB |
| orders | 5 GB | 8min | 8min 15s | 5.2 GB / 18 MB |
| logs | 50 GB | OOM Crash | 85min | N/A / 22 MB |

‚úÖ **Recommandation** : **Toujours utiliser `--quick`** en production pour √©viter les crashs.

```bash
mariadb-dump -u backup_user -p \
  --single-transaction \
  --quick \
  large_database > backup.sql
```

---

### `--extended-insert` : Inserts group√©s

```bash
--extended-insert
# Alias : -e
```

#### Comparaison des formats

```sql
-- SANS --extended-insert (format classique) :
INSERT INTO users (id, name) VALUES (1, 'Alice');
INSERT INTO users (id, name) VALUES (2, 'Bob');
INSERT INTO users (id, name) VALUES (3, 'Charlie');
-- Taille : ~150 bytes, 3 queries

-- AVEC --extended-insert (format optimis√©) :
INSERT INTO users (id, name) VALUES 
(1, 'Alice'),
(2, 'Bob'),
(3, 'Charlie');
-- Taille : ~80 bytes, 1 query
```

üí° **Avantages** :
- **Taille fichier** : R√©duction de 30-50%
- **Vitesse restauration** : 5-10x plus rapide
- **Moins de parsing** : Le serveur traite moins de requ√™tes

#### Contr√¥le de la taille des inserts

```bash
--max-allowed-packet=1G
```

Par d√©faut, `--extended-insert` limite les inserts √† `max_allowed_packet` (16 MB par d√©faut).

```bash
# Augmenter pour de meilleures performances
mariadb-dump -u backup_user -p \
  --single-transaction \
  --extended-insert \
  --max-allowed-packet=1G \
  production_db > backup.sql
```

‚ö†Ô∏è **Attention restauration** : Le serveur MariaDB cible doit aussi avoir `max_allowed_packet` configur√© :

```sql
-- Avant de restaurer un dump avec de gros packets :
SET GLOBAL max_allowed_packet = 1073741824; -- 1 GB
```

---

### `--opt` : Ensemble d'options optimales

```bash
--opt
```

üí° **Activ√© par d√©faut**, √©quivaut √† :

```bash
--add-drop-table
--add-locks
--create-options
--disable-keys
--extended-insert
--lock-tables
--quick
--set-charset
```

#### D√©tail des sous-options

| Option | Description |
|--------|-------------|
| `--add-drop-table` | Ajoute `DROP TABLE IF EXISTS` avant chaque `CREATE TABLE` |
| `--add-locks` | Entoure les inserts de `LOCK TABLES` / `UNLOCK TABLES` |
| `--create-options` | Inclut les options sp√©cifiques (ENGINE, CHARSET, etc.) |
| `--disable-keys` | D√©sactive les index pendant l'import, les reconstruit √† la fin |
| `--extended-insert` | Inserts group√©s |
| `--lock-tables` | Verrous de lecture pendant le dump |
| `--quick` | Streaming row-by-row |
| `--set-charset` | D√©finit le charset |

#### D√©sactiver --opt pour contr√¥le fin

```bash
# D√©sactiver --opt (rare, pour cas sp√©cifiques)
--skip-opt

# Puis r√©activer seulement ce dont vous avez besoin
mariadb-dump -u backup_user -p \
  --skip-opt \
  --single-transaction \
  --quick \
  --extended-insert \
  production_db > backup.sql
```

---

### `--disable-keys` : Optimisation des index

```bash
--disable-keys
# Alias : -K
```

#### Fonctionnement

```sql
-- Dans le fichier dump, pour chaque table MyISAM :

/*!40000 ALTER TABLE `users` DISABLE KEYS */;
-- Tous les INSERTs...
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
```

üí° **Effet** : Les index secondaires sont reconstruits en une seule passe √† la fin, au lieu d'√™tre mis √† jour √† chaque INSERT.

#### Benchmark

| Table | Lignes | Avec index actifs | DISABLE KEYS | Gain |
|-------|--------|-------------------|--------------|------|
| users | 100K | 2min 30s | 45s | 3.3x |
| orders | 1M | 28min | 6min 20s | 4.4x |
| logs | 10M | 4h 15min | 52min | 4.9x |

‚úÖ **Automatique** pour MyISAM avec `--opt` (actif par d√©faut).  
‚ö†Ô∏è **N'affecte pas InnoDB** (les index InnoDB doivent √™tre maintenus en temps r√©el).

---

### `--hex-blob` : Format hexad√©cimal pour BLOB

```bash
--hex-blob
```

#### Probl√®me r√©solu

```sql
-- SANS --hex-blob (donn√©es binaires en texte) :
INSERT INTO images (id, data) VALUES (1, '√ø√ò√ø√†JFIF...');
-- Probl√®me : Caract√®res sp√©ciaux, √©chappement, encodage

-- AVEC --hex-blob (format hexad√©cimal) :
INSERT INTO images (id, data) VALUES (1, 0xFFD8FFE000104A4649460001...);
-- Avantage : Pas d'ambigu√Øt√©, portable, fiable
```

üí° **Recommand√©** si vous avez des colonnes BLOB/BINARY.

```bash
mariadb-dump -u backup_user -p \
  --single-transaction \
  --hex-blob \
  multimedia_db > backup.sql
```

---

## Options de s√©curit√© et isolation

### `--no-tablespaces` : Exclure les tablespaces

```bash
--no-tablespaces
```

üí° **Raison** : La gestion des tablespaces n√©cessite le privil√®ge `PROCESS`, que vous ne voulez peut-√™tre pas donner √† l'utilisateur de backup.

```bash
# Sans cette option, mariadb-dump essaie de dumper les tablespaces :
# /*!50106 CREATE LOGFILE GROUP ... */

# Avec --no-tablespaces :
mariadb-dump -u backup_user -p \
  --single-transaction \
  --no-tablespaces \
  production_db > backup.sql
```

---

### `--skip-add-drop-table` : Pr√©server les tables existantes

```bash
--skip-add-drop-table
```

#### Cas d'usage

```bash
# Par d√©faut, le dump contient :
DROP TABLE IF EXISTS `users`;
CREATE TABLE `users` (...);

# Avec --skip-add-drop-table :
# Pas de DROP TABLE
CREATE TABLE `users` (...);  # √âchouera si la table existe d√©j√†
```

‚úÖ **Utile pour** :
- Merge de donn√©es (restauration additive)
- √âviter suppressions accidentelles

```bash
# Restauration "additive" de donn√©es de test
mariadb-dump -u backup_user -p \
  --skip-add-drop-table \
  --no-create-info \
  test_db > additional_test_data.sql
```

---

### `--set-gtid-purged` : Gestion GTID

```bash
--set-gtid-purged[=value]
```

#### Valeurs possibles

- `AUTO` (d√©faut) : D√©tection automatique
- `ON` : Inclut `SET @@GLOBAL.gtid_purged`
- `OFF` : N'inclut pas GTID
- `COMMENTED` : Inclut GTID en commentaire

#### Pour GTID-enabled servers

```bash
mariadb-dump -u backup_user -p \
  --single-transaction \
  --set-gtid-purged=ON \
  production_db > backup.sql
```

Le dump contiendra :

```sql
SET @MYSQLDUMP_TEMP_LOG_BIN = @@SESSION.SQL_LOG_BIN;
SET @@SESSION.SQL_LOG_BIN= 0;

SET @@GLOBAL.gtid_purged=/*!80000 '+'*/ '0-1-100:0-2-200';

SET @@SESSION.SQL_LOG_BIN = @MYSQLDUMP_TEMP_LOG_BIN;
```

üí° **Essentiel pour** :
- R√©plication GTID
- Clonage de serveurs avec GTID
- Restauration d'un replica

---

## Combinaisons recommand√©es par cas d'usage

### 1. Production OLTP (InnoDB) - Backup standard

```bash
mariadb-dump \
  --single-transaction \
  --quick \
  --routines \
  --triggers \
  --events \
  --master-data=2 \
  --flush-logs \
  --hex-blob \
  --default-character-set=utf8mb4 \
  production_db | zstd -3 > backup_$(date +%Y%m%d).sql.zst
```

**Rationale** :
- ‚úÖ `--single-transaction` : Coh√©rence sans bloquer les √©critures
- ‚úÖ `--quick` : Pas de saturation m√©moire
- ‚úÖ `--routines/triggers/events` : Compl√©tude des objets
- ‚úÖ `--master-data=2` : Pr√©paration PITR
- ‚úÖ `--flush-logs` : Nouveau binlog pour incr√©mental
- ‚úÖ `--hex-blob` : Fiabilit√© des donn√©es binaires
- ‚úÖ `--default-character-set=utf8mb4` : Unicode complet

---

### 2. Serveur complet avec utilisateurs

```bash
mariadb-dump \
  --all-databases \
  --single-transaction \
  --routines \
  --triggers \
  --events \
  --flush-privileges \
  --master-data=2 \
  --flush-logs | zstd -3 > full_server_$(date +%Y%m%d).sql.zst
```

**Nouveaut√©** :
- ‚úÖ `--all-databases` : Toutes les bases, y compris `mysql.*`
- ‚úÖ `--flush-privileges` : Rechargement des privil√®ges apr√®s restore

---

### 3. Mix InnoDB/MyISAM

```bash
mariadb-dump \
  --lock-all-tables \
  --routines \
  --triggers \
  --events \
  --hex-blob \
  mixed_engine_db > backup.sql
```

**Rationale** :
- ‚ö†Ô∏è `--lock-all-tables` : Coh√©rence globale (MyISAM ne supporte pas transactions)
- ‚ùå Pas de `--single-transaction` (incompatible)

---

### 4. R√©plica en lecture seule

```bash
mariadb-dump \
  --single-transaction \
  --skip-lock-tables \
  --routines \
  --triggers \
  --events \
  --host=replica.example.com \
  production_db > backup.sql
```

**Rationale** :
- ‚úÖ `--skip-lock-tables` : Pas de verrous (replica read-only)
- ‚úÖ Aucun impact sur le primary

---

### 5. Dump pour migration cross-platform

```bash
mariadb-dump \
  --single-transaction \
  --skip-extended-insert \
  --complete-insert \
  --compatible=ansi \
  --skip-quote-names \
  --hex-blob \
  --default-character-set=utf8mb4 \
  production_db > portable_backup.sql
```

**Rationale** :
- ‚úÖ `--skip-extended-insert` : Inserts simples (plus compatible)
- ‚úÖ `--complete-insert` : Noms de colonnes explicites
- ‚úÖ `--compatible=ansi` : SQL ANSI standard
- ‚úÖ `--hex-blob` : Format universel pour binaires

---

### 6. Export de sch√©ma seul (documentation)

```bash
mariadb-dump \
  --no-data \
  --routines \
  --triggers \
  --events \
  production_db > schema_only.sql
```

---

### 7. Export de donn√©es seules (migration)

```bash
mariadb-dump \
  --no-create-info \
  --skip-triggers \
  --complete-insert \
  --extended-insert \
  production_db > data_only.sql
```

---

### 8. Backup pour clonage de serveur GTID

```bash
mariadb-dump \
  --all-databases \
  --single-transaction \
  --routines \
  --triggers \
  --events \
  --set-gtid-purged=ON \
  --master-data=2 > gtid_clone.sql
```

---

## Pi√®ges et erreurs courantes

### Pi√®ge 1 : Oublier `--routines`

```bash
# ‚ùå Backup incomplet
mariadb-dump --single-transaction production_db > backup.sql

# ‚úÖ Backup complet
mariadb-dump --single-transaction --routines --triggers --events \
  production_db > backup.sql
```

**Impact** : Perte de toutes les proc√©dures stock√©es, fonctions, et √©v√©nements lors du restore.

---

### Pi√®ge 2 : `--single-transaction` avec MyISAM

```bash
# ‚ùå Incoh√©rent (MyISAM ne supporte pas les transactions)
mariadb-dump --single-transaction mixed_db > backup.sql

# ‚úÖ Solution 1 : Migrer vers InnoDB
ALTER TABLE mytable ENGINE=InnoDB;

# ‚úÖ Solution 2 : Utiliser --lock-all-tables
mariadb-dump --lock-all-tables mixed_db > backup.sql
```

---

### Pi√®ge 3 : Max packet size insuffisant

```bash
# ‚ùå Restauration √©choue : "Packet too large"
mariadb-dump --extended-insert production_db > backup.sql

# ‚úÖ Solution : Augmenter max_allowed_packet
mariadb-dump --extended-insert --max-allowed-packet=512M \
  production_db > backup.sql

# √Ä la restauration :
mariadb --max-allowed-packet=512M production_db < backup.sql
```

---

### Pi√®ge 4 : Backup pendant un ALTER TABLE

```bash
# ‚ö†Ô∏è Risque : --single-transaction ne prot√®ge pas contre les DDL

# Solution : Planifier les backups en dehors des fen√™tres de maintenance
# Ou utiliser --lock-all-tables (avec downtime)
```

---

### Pi√®ge 5 : Charset/collation mismatch

```bash
# ‚ùå Restauration avec mauvais charset
mariadb-dump production_db > backup.sql
mariadb test_db < backup.sql
# Erreur : Incorrect string value

# ‚úÖ Solution : Sp√©cifier le charset explicitement
mariadb-dump --default-character-set=utf8mb4 production_db > backup.sql
mariadb --default-character-set=utf8mb4 test_db < backup.sql
```

---

### Pi√®ge 6 : Binlog position non captur√©e

```bash
# ‚ùå PITR impossible (pas de position binlog)
mariadb-dump --single-transaction production_db > backup.sql

# ‚úÖ PITR possible
mariadb-dump --single-transaction --master-data=2 \
  production_db > backup.sql
```

---

### Pi√®ge 7 : Dump trop verbeux (commentaires inutiles)

```bash
# Fichier avec commentaires MariaDB :
-- MariaDB dump 10.19  Distrib 10.11.6-MariaDB, for Linux (x86_64)
-- Host: localhost    Database: production_db
-- ------------------------------------------------------
-- Server version       10.11.6-MariaDB

# Si espace critique, utiliser --compact
mariadb-dump --compact production_db > backup.sql
# Enl√®ve : commentaires, d√©finitions de charset, commandes SET
```

---

### Pi√®ge 8 : Privil√®ges insuffisants

```bash
# Erreur : Access denied for user 'backup_user'@'localhost'

# Privil√®ges minimaux requis pour backup complet :
GRANT SELECT, SHOW VIEW, TRIGGER, LOCK TABLES, 
      RELOAD, REPLICATION CLIENT 
ON *.* 
TO 'backup_user'@'localhost';
FLUSH PRIVILEGES;

# Pour --master-data :
GRANT REPLICATION CLIENT ON *.* TO 'backup_user'@'localhost';

# Pour --all-databases incluant mysql.* :
GRANT SELECT ON mysql.* TO 'backup_user'@'localhost';
```

---

## Scripts de production avanc√©s

### Script 1 : Backup avec validation automatique

```bash
#!/bin/bash
# /opt/scripts/mariadb_validated_backup.sh

set -euo pipefail

# Configuration
DB="production_db"
BACKUP_DIR="/var/backups/mariadb"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/backup_${DATE}.sql.zst"
LOG_FILE="$BACKUP_DIR/backup_${DATE}.log"

# Fonction de logging
log() {
    echo "[$(date -Iseconds)] $1" | tee -a "$LOG_FILE"
}

# 1. V√©rifier l'espace disque
REQUIRED_SPACE_GB=50
AVAILABLE_SPACE_GB=$(df -BG "$BACKUP_DIR" | tail -1 | awk '{print $4}' | sed 's/G//')

if [ "$AVAILABLE_SPACE_GB" -lt "$REQUIRED_SPACE_GB" ]; then
    log "‚ùå Insufficient disk space: ${AVAILABLE_SPACE_GB}GB < ${REQUIRED_SPACE_GB}GB"
    exit 1
fi

log "‚úÖ Disk space check: ${AVAILABLE_SPACE_GB}GB available"

# 2. V√©rifier que toutes les tables sont InnoDB
NON_INNODB=$(mariadb -u backup_user -N -e "
    SELECT COUNT(*) 
    FROM information_schema.tables 
    WHERE table_schema='$DB' AND engine != 'InnoDB'
")

if [ "$NON_INNODB" -gt 0 ]; then
    log "‚ö†Ô∏è  Warning: $NON_INNODB non-InnoDB tables detected"
fi

# 3. Effectuer le backup
log "üîÑ Starting backup..."

mariadb-dump \
  --single-transaction \
  --quick \
  --routines \
  --triggers \
  --events \
  --master-data=2 \
  --flush-logs \
  --hex-blob \
  --default-character-set=utf8mb4 \
  "$DB" 2>> "$LOG_FILE" | \
  zstd -3 > "$BACKUP_FILE"

BACKUP_STATUS=$?

if [ $BACKUP_STATUS -ne 0 ]; then
    log "‚ùå Backup FAILED with exit code $BACKUP_STATUS"
    exit 1
fi

# 4. Validation du backup
log "üîç Validating backup..."

# Test 1 : Fichier non vide
FILE_SIZE=$(stat -f%z "$BACKUP_FILE" 2>/dev/null || stat -c%s "$BACKUP_FILE")
if [ "$FILE_SIZE" -lt 1000 ]; then
    log "‚ùå Backup file too small: ${FILE_SIZE} bytes"
    exit 1
fi

log "‚úÖ File size: $(numfmt --to=iec-i --suffix=B $FILE_SIZE)"

# Test 2 : Compression int√®gre
if ! zstd -t "$BACKUP_FILE" 2>> "$LOG_FILE"; then
    log "‚ùå Backup file is corrupted (compression test failed)"
    exit 1
fi

log "‚úÖ Compression integrity verified"

# Test 3 : Contenu SQL valide
SAMPLE=$(zstd -dc "$BACKUP_FILE" | head -n 200)
if ! echo "$SAMPLE" | grep -q "CREATE TABLE"; then
    log "‚ùå Backup file doesn't contain valid SQL"
    exit 1
fi

log "‚úÖ SQL content validated"

# Test 4 : Extraction position binlog
BINLOG_POS=$(zstd -dc "$BACKUP_FILE" | grep "CHANGE MASTER TO" | head -n 1)
if [ -z "$BINLOG_POS" ]; then
    log "‚ö†Ô∏è  Warning: No binlog position found (--master-data not working?)"
else
    log "‚úÖ Binlog position: $BINLOG_POS"
    echo "$BINLOG_POS" > "$BACKUP_DIR/backup_${DATE}_binlog_pos.txt"
fi

# 5. Nettoyage des anciens backups (r√©tention 7 jours)
log "üßπ Cleaning old backups..."
find "$BACKUP_DIR" -name "backup_*.sql.zst" -mtime +7 -delete
find "$BACKUP_DIR" -name "backup_*.log" -mtime +7 -delete

log "‚úÖ Backup completed successfully: $BACKUP_FILE"

# 6. Envoyer m√©triques √† Prometheus (optionnel)
if [ -n "${PROMETHEUS_PUSHGATEWAY:-}" ]; then
    cat <<EOF | curl --data-binary @- "$PROMETHEUS_PUSHGATEWAY/metrics/job/mariadb_backup/instance/$(hostname)"
# HELP mariadb_backup_size_bytes Size of the backup file
# TYPE mariadb_backup_size_bytes gauge
mariadb_backup_size_bytes $FILE_SIZE

# HELP mariadb_backup_success Last backup success (1=success, 0=failure)
# TYPE mariadb_backup_success gauge
mariadb_backup_success 1

# HELP mariadb_backup_timestamp_seconds Timestamp of last successful backup
# TYPE mariadb_backup_timestamp_seconds gauge
mariadb_backup_timestamp_seconds $(date +%s)
EOF
fi
```

---

### Script 2 : Backup parall√®le multi-bases

```bash
#!/bin/bash
# Backup parall√®le de plusieurs bases

DATABASES="db1 db2 db3 db4"
BACKUP_DIR="/var/backups/mariadb/$(date +%Y%m%d)"
MAX_PARALLEL=4

mkdir -p "$BACKUP_DIR"

# Fonction de backup d'une base
backup_database() {
    local db=$1
    local output="$BACKUP_DIR/${db}.sql.zst"
    
    echo "[$(date)] Starting backup of $db"
    
    mariadb-dump \
      --single-transaction \
      --quick \
      --routines \
      --triggers \
      --events \
      "$db" | zstd -3 > "$output"
    
    if [ $? -eq 0 ]; then
        echo "[$(date)] ‚úÖ $db backed up successfully ($(du -h $output | cut -f1))"
    else
        echo "[$(date)] ‚ùå $db backup FAILED"
        return 1
    fi
}

export -f backup_database
export BACKUP_DIR

# Ex√©cution parall√®le
echo "$DATABASES" | tr ' ' '\n' | \
  xargs -I {} -P $MAX_PARALLEL bash -c 'backup_database "$@"' _ {}

echo "üéâ All backups completed"
```

---

## ‚úÖ Points cl√©s √† retenir

- **`--single-transaction`** : Option fondamentale pour InnoDB, garantit coh√©rence sans bloquer les √©critures
- **`--routines`, `--triggers`, `--events`** : Toujours les inclure pour backup complet
- **`--master-data=2`** : Essentiel pour Point-in-Time Recovery (PITR), enregistre position binlog
- **`--quick`** : √âvite saturation m√©moire, streaming row-by-row (activ√© par d√©faut)
- **`--extended-insert`** : Inserts group√©s = fichiers 30-50% plus petits, restauration 5-10x plus rapide
- **`--flush-logs`** : Rotation binlogs pour strat√©gie incr√©mentale propre
- **`--hex-blob`** : Format fiable pour donn√©es binaires (BLOB)
- **`--lock-all-tables`** : Seule option pour coh√©rence avec MyISAM (bloque √©critures)
- **Combinaisons types** : Adapter selon moteur (InnoDB vs MyISAM), cas d'usage (PITR, migration, clone)
- **Validation syst√©matique** : Tester int√©grit√© compression, pr√©sence SQL, position binlog

---

## üîó Ressources et r√©f√©rences

- üìñ [mariadb-dump Options (Documentation officielle)](https://mariadb.com/kb/en/mariadb-dump-options/)
- üìñ [Backup and Restore Overview](https://mariadb.com/kb/en/backup-and-restore-overview/)
- üìñ [Binary Log](https://mariadb.com/kb/en/binary-log/)
- üìñ [GTID](https://mariadb.com/kb/en/gtid/)
- üõ†Ô∏è [Percona Toolkit - pt-query-digest](https://docs.percona.com/percona-toolkit/)
- üìä [Benchmarking Backup Strategies](https://mariadb.com/resources/blog/mariadb-backup-best-practices/)

---

## ‚û°Ô∏è Section suivante

**12.2.3 mydumper/myloader : Parall√©lisme** : Alternative moderne √† mysqldump avec dump parall√®le multi-threads, compression native, et restauration granulaire ultra-rapide.

‚è≠Ô∏è [mydumper/myloader : Parall√©lisme](/12-sauvegarde-restauration/02.3-mydumper-myloader.md)
