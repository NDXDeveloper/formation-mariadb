üîù Retour au [Sommaire](/SOMMAIRE.md)

# 12.2.1 mysqldump / mariadb-dump

> **Niveau** : Avanc√©  
> **Dur√©e estim√©e** : 2 heures  
> **Pr√©requis** : Section 12.1 (Strat√©gies de sauvegarde), connaissance des bases de donn√©es et SQL

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre les diff√©rences entre `mysqldump` et `mariadb-dump`
- Ma√Ætriser les options essentielles pour des sauvegardes coh√©rentes en production
- Cr√©er des sauvegardes logiques adapt√©es √† diff√©rents sc√©narios (bases compl√®tes, tables sp√©cifiques, multi-bases)
- Optimiser les performances de sauvegarde et de restauration
- Automatiser les sauvegardes logiques avec gestion de la r√©tention

---

## Introduction

Les sauvegardes logiques constituent une approche fondamentale pour la protection des donn√©es dans MariaDB. Contrairement aux sauvegardes physiques qui copient les fichiers bruts de la base de donn√©es, les sauvegardes logiques exportent les donn√©es sous forme de requ√™tes SQL, offrant ainsi une portabilit√© maximale et une granularit√© fine.

**mysqldump** et **mariadb-dump** sont les outils de r√©f√©rence pour r√©aliser ces sauvegardes logiques. Bien que fonctionnellement identiques, `mariadb-dump` est le nom moderne recommand√© depuis MariaDB 10.5, s'inscrivant dans la strat√©gie de renommage des outils MariaDB pour affirmer son identit√© distincte de MySQL.

### Quand utiliser les sauvegardes logiques ?

‚úÖ **Cas d'usage recommand√©s** :
- Migration entre versions diff√©rentes de MariaDB ou vers d'autres SGBD
- Sauvegarde s√©lective de bases/tables sp√©cifiques
- Environnements de d√©veloppement et test
- Bases de donn√©es de petite √† moyenne taille (< 100 GB)
- Besoin de portabilit√© maximale
- Restauration granulaire (table par table)

‚ùå **Limitations √† consid√©rer** :
- Performance limit√©e sur tr√®s grandes bases (> 500 GB)
- Temps de restauration plus long que les sauvegardes physiques
- Charge CPU/m√©moire importante lors de la restauration
- Ne capture pas l'√©tat exact des fichiers binaires

---

## mysqldump vs mariadb-dump : Quelle diff√©rence ?

### √âvolution historique

```bash
# mysqldump : Outil historique h√©rit√© de MySQL
mysqldump --version
# Output : mysqldump  Ver 10.19 Distrib 10.11.x-MariaDB

# mariadb-dump : Nom moderne depuis MariaDB 10.5
mariadb-dump --version
# Output : mariadb-dump  Ver 10.19 Distrib 10.11.x-MariaDB
```

üí° **Point important** : Sur la plupart des installations MariaDB modernes, `mysqldump` est en r√©alit√© un lien symbolique vers `mariadb-dump`. Les deux commandes sont donc **strictement identiques** en termes de fonctionnalit√©s.

```bash
# V√©rification sur votre syst√®me
ls -la $(which mysqldump)
# Exemple de sortie : mysqldump -> mariadb-dump
```

### Recommandation de nommage

üÜï **Depuis MariaDB 10.5** : Privil√©giez `mariadb-dump` dans vos nouveaux scripts pour :
- **Clart√©** : √âviter toute confusion avec l'outil MySQL
- **P√©rennit√©** : S'aligner sur la strat√©gie de renommage MariaDB
- **Compatibilit√© future** : Anticiper d'√©ventuelles divergences futures

---

## Syntaxe de base

### Structure g√©n√©rale

```bash
mariadb-dump [options] database_name [table_name ...]
mariadb-dump [options] --databases db1 db2 db3 ...
mariadb-dump [options] --all-databases
```

### Exemple minimal

```bash
# Sauvegarde d'une base unique
mariadb-dump -u root -p production_db > production_db_backup.sql

# Sauvegarde de plusieurs bases
mariadb-dump -u backup_user -p --databases db1 db2 db3 > multi_db_backup.sql

# Sauvegarde compl√®te du serveur
mariadb-dump -u root -p --all-databases > full_backup.sql
```

‚ö†Ô∏è **Attention s√©curit√©** : Ne jamais utiliser l'option `-p<password>` directement dans la ligne de commande. Utilisez plut√¥t un fichier de configuration ou laissez l'outil demander le mot de passe de mani√®re interactive.

---

## Options essentielles pour la production

### Options de coh√©rence : Le trio indispensable

Pour garantir une sauvegarde coh√©rente en production, trois options sont **critiques** :

```bash
mariadb-dump -u backup_user -p \
  --single-transaction \
  --routines \
  --triggers \
  --events \
  production_db > backup.sql
```

#### 1. `--single-transaction` : Coh√©rence transactionnelle

```bash
--single-transaction
```

**Fonctionnement** :
- D√©marre une transaction avec isolation `REPEATABLE READ`
- Obtient un snapshot coh√©rent de la base sans bloquer les √©critures
- **Uniquement pour les tables InnoDB** (ne fonctionne pas avec MyISAM)

üí° **Avantage majeur** : Permet de sauvegarder une base en production sans interruption de service.

‚ö†Ô∏è **Limitation** : N'affecte pas les instructions DDL (`ALTER TABLE`, `CREATE TABLE`) pendant le dump. √âvitez les modifications de sch√©ma pendant la sauvegarde.

#### 2. `--routines` : Proc√©dures stock√©es et fonctions

```bash
--routines
```

Sans cette option, les proc√©dures stock√©es (`PROCEDURE`) et fonctions (`FUNCTION`) ne sont **pas sauvegard√©es**.

```sql
-- Exemple de proc√©dure qui serait perdue sans --routines
DELIMITER $$
CREATE PROCEDURE calculate_monthly_revenue(IN month_id INT)
BEGIN
    SELECT SUM(amount) FROM orders WHERE MONTH(order_date) = month_id;
END$$
DELIMITER ;
```

#### 3. `--triggers` : D√©clencheurs

```bash
--triggers
```

Par d√©faut, les triggers **sont inclus**, mais il est recommand√© de le sp√©cifier explicitement pour plus de clart√©.

```sql
-- Exemple de trigger critique pour l'audit
CREATE TRIGGER audit_user_changes
AFTER UPDATE ON users
FOR EACH ROW
    INSERT INTO audit_log (user_id, action, timestamp) 
    VALUES (OLD.id, 'UPDATE', NOW());
```

#### 4. `--events` : T√¢ches planifi√©es

```bash
--events
```

Sans cette option, les √©v√©nements planifi√©s ne sont pas sauvegard√©s.

```sql
-- Exemple d'√©v√©nement de maintenance qui serait perdu
CREATE EVENT cleanup_old_sessions
ON SCHEDULE EVERY 1 DAY
DO
    DELETE FROM sessions WHERE last_activity < NOW() - INTERVAL 30 DAY;
```

---

## Options de performance et optimisation

### Compression √† la vol√©e

```bash
# Compression gzip (ratio ~10:1)
mariadb-dump -u backup_user -p --single-transaction production_db | gzip > backup.sql.gz

# Compression pigz (gzip parall√®le, plus rapide sur multi-core)
mariadb-dump -u backup_user -p --single-transaction production_db | pigz > backup.sql.gz

# Compression zstd (excellent ratio + vitesse)
mariadb-dump -u backup_user -p --single-transaction production_db | zstd -3 > backup.sql.zst
```

üí° **Benchmark indicatif** (base 10 GB) :

| Compresseur | Temps | Taille finale | CPU |
|-------------|-------|---------------|-----|
| Sans compression | 8 min | 10 GB | 1 core |
| gzip (-6) | 12 min | 1.2 GB | 1 core |
| pigz (-6) | 9 min | 1.2 GB | 8 cores |
| zstd (-3) | 8.5 min | 1.4 GB | 1 core |

### Optimisation de la taille du dump

```bash
# Compact : Pas d'espaces inutiles
--compact

# Exclure les commentaires de cr√©ation
--skip-comments

# Extended INSERT : Regrouper plusieurs lignes par INSERT
--extended-insert

# Taille maximale des paquets r√©seau (1 GB)
--max-allowed-packet=1G
```

**Exemple combin√©** :

```bash
mariadb-dump -u backup_user -p \
  --single-transaction \
  --extended-insert \
  --max-allowed-packet=1G \
  --skip-comments \
  production_db | zstd -3 > backup_$(date +%Y%m%d).sql.zst
```

### Contr√¥le du buffer et du flush

```bash
# Augmenter le buffer de sortie (d√©faut : 16 MB)
--net-buffer-length=16M

# Forcer le flush apr√®s chaque table (lib√®re m√©moire)
--quick
```

üí° **Option `--quick`** : √âvite de charger la table enti√®re en m√©moire. Essentiel pour les grandes tables (> 1 GB).

---

## Options de s√©lection et filtrage

### Sauvegarde s√©lective de tables

```bash
# Une seule table
mariadb-dump -u backup_user -p production_db users > users_backup.sql

# Plusieurs tables
mariadb-dump -u backup_user -p production_db users orders payments > critical_tables.sql

# Toutes les tables sauf certaines (via --ignore-table)
mariadb-dump -u backup_user -p \
  --single-transaction \
  --ignore-table=production_db.temp_data \
  --ignore-table=production_db.cache \
  production_db > backup.sql
```

### Sauvegarder uniquement la structure (sans donn√©es)

```bash
# Sch√©ma complet sans donn√©es
mariadb-dump -u backup_user -p --no-data production_db > schema_only.sql

# Utile pour :
# - Documentation de la structure
# - Cr√©ation d'environnements de test
# - Analyse de sch√©ma
```

### Sauvegarder uniquement les donn√©es (sans structure)

```bash
# Donn√©es seules
mariadb-dump -u backup_user -p --no-create-info production_db > data_only.sql

# Cas d'usage : Migration de donn√©es entre bases de structure identique
```

### Filtrage par clause WHERE

```bash
# Sauvegarder uniquement un sous-ensemble de donn√©es
mariadb-dump -u backup_user -p production_db orders \
  --where="order_date >= '2025-01-01'" > recent_orders.sql

# Exemple avanc√© : Export de donn√©es de test anonymis√©es
mariadb-dump -u backup_user -p production_db users \
  --where="created_at < '2025-01-01' LIMIT 1000" > sample_users.sql
```

---

## Options de compatibilit√© et portabilit√©

### Compatibilit√© entre versions

```bash
# D√©sactiver les fonctionnalit√©s sp√©cifiques √† MariaDB
--compatible=mysql

# Rendre compatible avec des versions anciennes
--compatible=mysql323
--compatible=mysql40
```

üí° **Cas d'usage** : Migration de MariaDB vers MySQL ou vers une version plus ancienne.

### Gestion des caract√®res et encodage

```bash
# Sp√©cifier l'encodage
--default-character-set=utf8mb4

# Exemple complet pour migration cross-platform
mariadb-dump -u backup_user -p \
  --single-transaction \
  --default-character-set=utf8mb4 \
  --skip-set-charset \
  production_db > backup.sql
```

üÜï **MariaDB 11.8** : utf8mb4 est d√©sormais le charset par d√©faut avec la collation `uca1400_ai_ci` (UCA 14.0.0).

### Option `--add-drop-database` et `--add-drop-table`

```bash
# Ajouter DROP DATABASE IF EXISTS avant CREATE DATABASE
--add-drop-database

# Ajouter DROP TABLE IF EXISTS avant CREATE TABLE (activ√© par d√©faut)
--add-drop-table

# Exemple : Sauvegarde "propre" pour restauration compl√®te
mariadb-dump -u backup_user -p \
  --single-transaction \
  --add-drop-database \
  --databases production_db staging_db > full_clean_backup.sql
```

---

## Gestion de la s√©curit√©

### Exclusion des privil√®ges syst√®me

```bash
# Exclure les tables syst√®me mysql.*
mariadb-dump -u backup_user -p \
  --all-databases \
  --ignore-database=mysql \
  --ignore-database=information_schema \
  --ignore-database=performance_schema > backup.sql
```

‚ö†Ô∏è **Important** : Si vous sauvegardez la base `mysql`, sauvegardez √©galement les utilisateurs et privil√®ges :

```bash
# Sauvegarde compl√®te incluant utilisateurs
mariadb-dump -u root -p \
  --all-databases \
  --routines \
  --triggers \
  --events \
  --flush-privileges > full_backup_with_users.sql
```

### Protection du fichier de sauvegarde

```bash
# Cr√©er le backup avec permissions restreintes
(umask 077; mariadb-dump -u backup_user -p production_db > backup.sql)

# V√©rifier les permissions
ls -l backup.sql
# Output : -rw------- 1 backup backup 1.2G Dec 13 10:30 backup.sql

# Chiffrement du backup
mariadb-dump -u backup_user -p production_db | \
  gpg --encrypt --recipient backup@company.com > backup.sql.gpg
```

---

## Cas d'usage pratiques en production

### 1. Sauvegarde quotidienne compl√®te

```bash
#!/bin/bash
# /opt/scripts/mariadb_daily_backup.sh

# Configuration
BACKUP_USER="backup_user"
BACKUP_DIR="/var/backups/mariadb"
RETENTION_DAYS=7
DATABASES="production_db analytics_db"
DATE=$(date +%Y%m%d_%H%M%S)

# Cr√©ation du r√©pertoire de backup
mkdir -p "$BACKUP_DIR"

# Sauvegarde avec rotation
mariadb-dump -u "$BACKUP_USER" -p \
  --single-transaction \
  --routines \
  --triggers \
  --events \
  --databases $DATABASES | \
  zstd -3 > "$BACKUP_DIR/backup_${DATE}.sql.zst"

# V√©rification du succ√®s
if [ $? -eq 0 ]; then
    echo "‚úÖ Backup successful: backup_${DATE}.sql.zst"
    
    # Nettoyage des anciens backups
    find "$BACKUP_DIR" -name "backup_*.sql.zst" -mtime +$RETENTION_DAYS -delete
    echo "üßπ Cleaned backups older than $RETENTION_DAYS days"
else
    echo "‚ùå Backup failed!" >&2
    exit 1
fi
```

üí° **Am√©lioration** : Utilisez un fichier `.my.cnf` pour stocker les credentials de mani√®re s√©curis√©e.

```ini
# /home/backup/.my.cnf
[client]
user=backup_user
password=SecurePassword123!
host=localhost
```

```bash
# Script utilisant .my.cnf
mariadb-dump --defaults-file=/home/backup/.my.cnf \
  --single-transaction \
  production_db > backup.sql
```

### 2. Sauvegarde par table pour grandes bases

```bash
#!/bin/bash
# Backup table par table pour bases > 500 GB

DATABASE="large_production_db"
BACKUP_DIR="/var/backups/mariadb/per_table/$DATABASE"
DATE=$(date +%Y%m%d)

mkdir -p "$BACKUP_DIR"

# R√©cup√©rer la liste des tables
TABLES=$(mariadb -u backup_user -p -N -e \
  "SELECT table_name FROM information_schema.tables 
   WHERE table_schema='$DATABASE'")

# Boucle sur chaque table
for TABLE in $TABLES; do
    echo "üì¶ Backing up table: $TABLE"
    
    mariadb-dump -u backup_user -p \
      --single-transaction \
      --quick \
      "$DATABASE" "$TABLE" | \
      zstd -3 > "$BACKUP_DIR/${TABLE}_${DATE}.sql.zst"
    
    if [ $? -eq 0 ]; then
        echo "  ‚úÖ $TABLE backed up successfully"
    else
        echo "  ‚ùå Failed to backup $TABLE" >&2
    fi
done

echo "üéâ Table-by-table backup completed"
```

üí° **Avantage** : 
- Parall√©lisation possible (ex√©cuter plusieurs dumps simultan√©ment)
- Restauration granulaire (table par table)
- Tol√©rance aux erreurs (une table en erreur ne bloque pas les autres)

### 3. Sauvegarde incr√©mentale "pauvre"

```bash
#!/bin/bash
# Sauvegarde uniquement des tables modifi√©es r√©cemment

DATABASE="production_db"
BACKUP_DIR="/var/backups/mariadb/incremental"
DATE=$(date +%Y%m%d)
SINCE_DATE=$(date -d "yesterday" +%Y-%m-%d)

# Identifier les tables modifi√©es
MODIFIED_TABLES=$(mariadb -u backup_user -p -N -e \
  "SELECT table_name FROM information_schema.tables 
   WHERE table_schema='$DATABASE' 
   AND update_time >= '$SINCE_DATE'")

if [ -z "$MODIFIED_TABLES" ]; then
    echo "‚ÑπÔ∏è  No tables modified since $SINCE_DATE"
    exit 0
fi

echo "üìä Modified tables: $MODIFIED_TABLES"

# Backup des tables modifi√©es uniquement
for TABLE in $MODIFIED_TABLES; do
    mariadb-dump -u backup_user -p \
      --single-transaction \
      "$DATABASE" "$TABLE" | \
      zstd -3 > "$BACKUP_DIR/${TABLE}_${DATE}.sql.zst"
done
```

‚ö†Ô∏è **Limitation** : Cette approche ne remplace pas une vraie sauvegarde incr√©mentale avec binary logs. √Ä utiliser uniquement pour optimiser l'espace de stockage sur des bases avec quelques tables actives.

### 4. Export pour migration vers PostgreSQL

```bash
# Dump compatible pour conversion vers PostgreSQL
mariadb-dump -u backup_user -p \
  --compatible=postgresql \
  --no-create-db \
  --skip-extended-insert \
  --complete-insert \
  --skip-quote-names \
  production_db > export_for_postgresql.sql

# Ensuite, utiliser un outil comme pgloader pour la conversion finale
```

---

## Restauration d'une sauvegarde logique

### Restauration simple

```bash
# D√©compression et restauration
zstd -d backup.sql.zst
mariadb -u root -p production_db < backup.sql

# Ou en une seule commande (pipe)
zstd -dc backup.sql.zst | mariadb -u root -p production_db
```

### Restauration avec logs de progression

```bash
# Utiliser pv (pipe viewer) pour suivre la progression
zstd -dc backup.sql.zst | pv | mariadb -u root -p production_db

# Exemple de sortie :
# 1.2GiB 0:03:45 [5.32MiB/s] [============>     ] 65% ETA 0:02:10
```

### Restauration s√©lective

```bash
# Extraire et restaurer une seule table
# M√©thode 1 : Avec sed
zstd -dc backup.sql.zst | \
  sed -n '/CREATE TABLE `users`/,/UNLOCK TABLES/p' | \
  mariadb -u root -p production_db

# M√©thode 2 : Avec grep (structure connue)
zstd -dc backup.sql.zst | \
  grep -A 1000 "Table structure for table \`users\`" | \
  grep -B 1000 "Table structure for table \`orders\`" | \
  head -n -5 | \
  mariadb -u root -p production_db
```

‚ö†Ô∏è **Attention** : Pour des restaurations s√©lectives complexes, privil√©giez `mydumper/myloader` (section 12.2.3) qui g√©n√®re un fichier par table.

### Options utiles lors de la restauration

```bash
# Forcer la continuation malgr√© les erreurs
mariadb -u root -p --force production_db < backup.sql

# Mode verbose pour debug
mariadb -u root -p -vvv production_db < backup.sql

# D√©sactiver les contraintes temporairement (acc√©l√®re la restauration)
mariadb -u root -p production_db <<EOF
SET foreign_key_checks = 0;
SET unique_checks = 0;
SET autocommit = 0;
SOURCE backup.sql;
COMMIT;
SET foreign_key_checks = 1;
SET unique_checks = 1;
EOF
```

---

## Monitoring et validation

### V√©rification de l'int√©grit√© du backup

```bash
# Test 1 : V√©rifier que le fichier n'est pas corrompu
zstd -t backup.sql.zst
# Output : backup.sql.zst OK

# Test 2 : V√©rifier qu'il contient du SQL valide
zstd -dc backup.sql.zst | head -n 100
# Devrait afficher des instructions SQL valides

# Test 3 : Compter les tables sauvegard√©es
zstd -dc backup.sql.zst | grep -c "CREATE TABLE"
# Output : 42

# Test 4 : V√©rifier la pr√©sence de proc√©dures/triggers
zstd -dc backup.sql.zst | grep -c "CREATE PROCEDURE"
zstd -dc backup.sql.zst | grep -c "CREATE TRIGGER"
```

### M√©triques importantes √† logger

```bash
#!/bin/bash
# Script de backup avec m√©triques compl√®tes

START_TIME=$(date +%s)
BACKUP_FILE="backup_$(date +%Y%m%d_%H%M%S).sql.zst"

# Effectuer le backup
mariadb-dump -u backup_user -p \
  --single-transaction \
  --routines \
  --triggers \
  --events \
  production_db | \
  zstd -3 > "$BACKUP_FILE"

BACKUP_STATUS=$?
END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))
FILE_SIZE=$(du -h "$BACKUP_FILE" | cut -f1)

# Logger les m√©triques
cat >> /var/log/mariadb_backups.log <<EOF
Date: $(date -Iseconds)
Database: production_db
Backup file: $BACKUP_FILE
Size: $FILE_SIZE
Duration: ${DURATION}s
Status: $([ $BACKUP_STATUS -eq 0 ] && echo "SUCCESS" || echo "FAILED")
---
EOF

# Envoyer √† un syst√®me de monitoring (exemple : Prometheus Pushgateway)
if [ $BACKUP_STATUS -eq 0 ]; then
    echo "mariadb_backup_duration_seconds $DURATION" | \
      curl --data-binary @- http://pushgateway:9091/metrics/job/mariadb_backup
fi
```

---

## Performance : Comparaison avec les alternatives

### mysqldump vs Mariabackup

| Crit√®re | mysqldump/mariadb-dump | Mariabackup |
|---------|------------------------|-------------|
| **Type** | Logique (SQL) | Physique (fichiers) |
| **Vitesse backup** | 50-200 MB/s | 500-2000 MB/s |
| **Vitesse restauration** | Lent (parsing SQL) | Rapide (copie fichiers) |
| **Taille backup (sans compression)** | ~1x taille base | ~1x taille base |
| **Impact production** | Faible (lecture) | Tr√®s faible |
| **Portabilit√©** | Excellente | Limit√©e (m√™me version/config) |
| **Granularit√©** | Table par table | Base enti√®re |
| **Backup coh√©rent** | Oui (--single-transaction) | Oui (natif) |
| **Cas d'usage id√©al** | < 100 GB, migration | > 100 GB, PITR |

üí° **Recommandation g√©n√©rale** :
- **< 50 GB** : mysqldump/mariadb-dump
- **50-500 GB** : Les deux sont viables, tester selon vos contraintes
- **> 500 GB** : Privil√©gier Mariabackup (voir section 12.3)

---

## Limitations et pi√®ges courants

### 1. Timeout lors de la connexion

```bash
# Erreur : Lost connection to MySQL server during query
# Cause : Tables volumineuses, r√©seau instable

# Solution : Augmenter les timeouts
mariadb-dump -u backup_user -p \
  --max-allowed-packet=1G \
  --net-read-timeout=3600 \
  --net-write-timeout=3600 \
  production_db > backup.sql
```

### 2. Incoh√©rences entre MyISAM et InnoDB

```bash
# ‚ö†Ô∏è PROBL√àME : --single-transaction ne prot√®ge que InnoDB
# Si votre base contient MyISAM et InnoDB, vous risquez des incoh√©rences

# Solution : Utiliser --lock-all-tables (bloque toutes les √©critures)
mariadb-dump -u backup_user -p \
  --lock-all-tables \
  --routines \
  --triggers \
  mixed_engines_db > backup.sql
```

üí° **Meileure pratique** : Migrez vos tables MyISAM vers InnoDB avant d'utiliser `--single-transaction`.

```sql
-- Convertir une table MyISAM vers InnoDB
ALTER TABLE my_table ENGINE=InnoDB;
```

### 3. Oubli des objets de base de donn√©es

```bash
# ‚ùå Backup incomplet (manque proc√©dures, triggers, events)
mariadb-dump -u backup_user -p production_db > incomplete_backup.sql

# ‚úÖ Backup complet
mariadb-dump -u backup_user -p \
  --single-transaction \
  --routines \
  --triggers \
  --events \
  production_db > complete_backup.sql
```

### 4. Probl√®mes d'encodage

```bash
# Erreur fr√©quente lors de la restauration :
# Incorrect string value: '\xF0\x9F...' for column 'content'

# Solution : Sp√©cifier explicitement utf8mb4
mariadb-dump -u backup_user -p \
  --default-character-set=utf8mb4 \
  production_db > backup.sql

# √Ä la restauration :
mariadb -u root -p --default-character-set=utf8mb4 production_db < backup.sql
```

### 5. Saturation m√©moire lors de la restauration

```bash
# Sympt√¥me : Serveur MariaDB lent ou crash lors du restore

# Cause : autocommit=1 cr√©e une transaction par INSERT
# Solution : D√©sactiver autocommit temporairement

mariadb -u root -p production_db <<EOF
SET autocommit=0;
SOURCE backup.sql;
COMMIT;
SET autocommit=1;
EOF
```

### 6. Binary log corruption pendant le backup

```bash
# Si le binary log change pendant le dump, risque d'incoh√©rence pour PITR

# Solution : Enregistrer la position du binlog
mariadb-dump -u backup_user -p \
  --single-transaction \
  --master-data=2 \
  production_db > backup.sql

# Le fichier contiendra :
# -- CHANGE MASTER TO MASTER_LOG_FILE='binlog.000042', MASTER_LOG_POS=12345;
```

üí° Cette position est cruciale pour le Point-in-Time Recovery (voir section 12.5.2).

---

## Automatisation et int√©gration

### Cron job standard

```bash
# /etc/cron.d/mariadb-backup
# Backup quotidien √† 2h du matin

0 2 * * * backup /opt/scripts/mariadb_daily_backup.sh >> /var/log/mariadb_backup.log 2>&1
```

### Int√©gration avec systemd timer

```ini
# /etc/systemd/system/mariadb-backup.service
[Unit]
Description=MariaDB Daily Backup
After=mariadb.service

[Service]
Type=oneshot
User=backup
ExecStart=/opt/scripts/mariadb_daily_backup.sh
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
```

```ini
# /etc/systemd/system/mariadb-backup.timer
[Unit]
Description=MariaDB Daily Backup Timer
Requires=mariadb-backup.service

[Timer]
OnCalendar=daily
OnCalendar=02:00
Persistent=true

[Install]
WantedBy=timers.target
```

```bash
# Activer le timer
sudo systemctl enable mariadb-backup.timer
sudo systemctl start mariadb-backup.timer

# V√©rifier le statut
sudo systemctl list-timers mariadb-backup.timer
```

### Notification en cas d'√©chec

```bash
#!/bin/bash
# Script avec notification Slack/email en cas d'erreur

SLACK_WEBHOOK="https://hooks.slack.com/services/YOUR/WEBHOOK/URL"

mariadb-dump -u backup_user -p \
  --single-transaction \
  production_db > backup.sql

if [ $? -ne 0 ]; then
    # Notification Slack
    curl -X POST -H 'Content-type: application/json' \
      --data "{\"text\":\"‚ùå MariaDB backup failed on $(hostname)\"}" \
      "$SLACK_WEBHOOK"
    
    # Email (si mailutils install√©)
    echo "MariaDB backup failed at $(date)" | \
      mail -s "ALERT: MariaDB Backup Failed" admin@company.com
    
    exit 1
fi
```

### Int√©gration avec des outils de backup enterprise

```bash
# Exemple : Bacula (backup enterprise)
# /etc/bacula/scripts/mariadb-backup.sh

#!/bin/bash
# Script appel√© par Bacula avant le backup de /var/backups/mariadb

mariadb-dump -u backup_user -p \
  --single-transaction \
  --all-databases | \
  zstd -3 > /var/backups/mariadb/latest.sql.zst

# Bacula sauvegardera ensuite /var/backups/mariadb/latest.sql.zst
```

---

## ‚úÖ Points cl√©s √† retenir

- **mariadb-dump** et **mysqldump** sont identiques ; privil√©giez `mariadb-dump` pour la clart√©
- **`--single-transaction`** est essentiel pour des backups coh√©rents en production sans bloquer les √©critures (InnoDB uniquement)
- **Toujours inclure** `--routines`, `--triggers`, et `--events` pour capturer tous les objets de la base
- **Compression recommand√©e** : `zstd` offre le meilleur compromis vitesse/ratio pour les backups
- Les sauvegardes logiques sont **id√©ales pour** : bases < 100 GB, migrations, portabilit√©, restauration granulaire
- **Limitations** : Performance limit√©e sur tr√®s grandes bases, temps de restauration long
- **Automatisation** : Utilisez systemd timers ou cron avec logs, monitoring et alertes
- **S√©curit√©** : Fichier `.my.cnf` pour credentials, chiffrement GPG, permissions restreintes (600)

---

## üîó Ressources et r√©f√©rences

- üìñ [Documentation officielle mariadb-dump](https://mariadb.com/kb/en/mariadb-dump/)
- üìñ [Options mariadb-dump](https://mariadb.com/kb/en/mariadb-dump-options/)
- üìñ [Backup and Restore Overview](https://mariadb.com/kb/en/backup-and-restore-overview/)
- üõ†Ô∏è [Percona Toolkit pour analyse des dumps](https://www.percona.com/software/database-tools/percona-toolkit)
- üìä [Benchmark: mysqldump vs Mariabackup](https://mariadb.com/resources/blog/mariabackup-vs-mysqldump/)

---

## ‚û°Ô∏è Section suivante

**12.2.2 Options essentielles** : Approfondissement des options critiques pour la production (`--master-data`, `--flush-logs`, `--hex-blob`, etc.) et optimisation avanc√©e des performances de dump.

‚è≠Ô∏è [Options essentielles (--single-transaction, --routines, etc.)](/12-sauvegarde-restauration/02.2-options-essentielles.md)
