ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 12.5.2 Point-in-Time Recovery (PITR)

> **Niveau** : AvancÃ©  
> **DurÃ©e estimÃ©e** : 4 heures  
> **PrÃ©requis** : Section 12.5.1 (Restauration complÃ¨te), comprÃ©hension des binary logs, maÃ®trise de mysqlbinlog

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre l'architecture et le fonctionnement du Point-in-Time Recovery
- Configurer les binary logs pour permettre le PITR
- Extraire et rejouer les Ã©vÃ©nements des binary logs avec mysqlbinlog
- Restaurer une base de donnÃ©es Ã  un moment prÃ©cis (timestamp ou position)
- GÃ©rer les scÃ©narios complexes (erreur humaine, corruption ciblÃ©e, suppression accidentelle)
- Calculer le RPO (Recovery Point Objective) optimal avec PITR
- Automatiser les procÃ©dures PITR avec des scripts robustes
- Combiner PITR avec diffÃ©rents types de backups (mysqldump, Mariabackup)
- ImplÃ©menter PITR dans des architectures cloud-native
- Ã‰viter les piÃ¨ges courants et gÃ©rer les cas limites

---

## Introduction

Le **Point-in-Time Recovery (PITR)** est une technique de restauration permettant de ramener une base de donnÃ©es Ã  un **Ã©tat prÃ©cis dans le temps**, gÃ©nÃ©ralement entre deux backups. Cette capacitÃ© est essentielle pour rÃ©cupÃ©rer aprÃ¨s des erreurs humaines, corruptions ciblÃ©es, ou incidents spÃ©cifiques oÃ¹ une restauration complÃ¨te serait excessive.

### DiffÃ©rence restauration complÃ¨te vs PITR

```
RESTAURATION COMPLÃˆTE :
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Restaure la base Ã  l'Ã©tat du dernier backup disponible

Dimanche : [FULL BACKUP] â†â”€â”€â”€ On restaure ici
Lundi    : Modifications perdues âŒ
Mardi    : Modifications perdues âŒ
Mercredi : DROP TABLE users; (erreur) âŒ
Jeudi    : Modifications perdues âŒ

RÃ©sultat : Base au dimanche, pertes lundi-jeudi


POINT-IN-TIME RECOVERY :
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Restaure la base Ã  un instant T prÃ©cis (ex: avant erreur)

Dimanche : [FULL BACKUP]
           â†“ [Binary logs jour par jour]
Lundi    : [Binlog lundi]    âœ… RejouÃ©s
Mardi    : [Binlog mardi]    âœ… RejouÃ©s
Mercredi : 14:29:59 â† STOP ICI (avant DROP TABLE users)
           14:30:00 DROP TABLE users; âŒ Non rejouÃ©
Jeudi    : [Binlog jeudi]    âŒ Non rejouÃ©s (aprÃ¨s incident)

RÃ©sultat : Base au mercredi 14:29:59, juste avant l'erreur âœ…
```

### Cas d'usage du PITR

| ScÃ©nario | Sans PITR | Avec PITR | RPO |
|----------|-----------|-----------|-----|
| DROP TABLE accidentel | Perte 24-168h | RÃ©cupÃ©ration prÃ©cise | < 1 min |
| UPDATE sans WHERE | Perte 24-168h | Restauration avant erreur | < 1 min |
| Ransomware dÃ©tectÃ© | Perte 24-168h | Ã‰tat juste avant infection | < 5 min |
| Corruption ciblÃ©e | Perte 24-168h | Ã‰tat sain prÃ©cis | < 1 min |
| Rollback changement | Impossible | Possible | 0 |

ğŸ’¡ **RPO avec PITR** : Potentiellement **< 1 minute** (limitÃ© uniquement par la frÃ©quence de flush des binary logs).

---

## Architecture du PITR

### Composants nÃ©cessaires

```
PITR = BACKUP COMPLET + BINARY LOGS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. ğŸ“¦ BACKUP COMPLET (point de dÃ©part)
   â”œâ”€ Full backup dimanche 02:00
   â”œâ”€ Position binlog enregistrÃ©e
   â””â”€ File: mariadb-bin.000042, Position: 123456

2. ğŸ“ BINARY LOGS (journal complet des modifications)
   â”œâ”€ mariadb-bin.000042 (dim 02:00 â†’ lun 02:00)
   â”œâ”€ mariadb-bin.000043 (lun 02:00 â†’ mar 02:00)
   â”œâ”€ mariadb-bin.000044 (mar 02:00 â†’ mer 14:30) â† STOP ICI
   â””â”€ mariadb-bin.000045 (mer 14:30 â†’ jeu 02:00)

3. ğŸ¯ POINT CIBLE (timestamp ou position)
   â””â”€ Mercredi 14:29:59 (avant DROP TABLE)

4. â™»ï¸  REPLAY (rejouer les Ã©vÃ©nements)
   â”œâ”€ Restaurer full backup (dimanche)
   â”œâ”€ Rejouer binlog.000042 (complet)
   â”œâ”€ Rejouer binlog.000043 (complet)
   â”œâ”€ Rejouer binlog.000044 (jusqu'Ã  14:29:59)
   â””â”€ STOP â†’ Base restaurÃ©e au mercredi 14:29:59 âœ…
```

---

## Configuration des binary logs

### Activation des binary logs

```ini
# /etc/my.cnf.d/server.cnf

[mysqld]
# Activer les binary logs (obligatoire pour PITR)
log_bin = /var/lib/mysql/mariadb-bin
server_id = 1  # Requis pour rÃ©plication et binlog

# Format binlog (ROW recommandÃ© pour PITR)
binlog_format = ROW
# ROW : Chaque ligne modifiÃ©e est loggÃ©e (prÃ©cis, PITR fiable)
# STATEMENT : SQL brut (moins prÃ©cis, problÃ¨mes avec RAND(), NOW())
# MIXED : Hybride

# RÃ©tention binlog
expire_logs_days = 7
# Ou (MariaDB 10.6+) :
binlog_expire_logs_seconds = 604800  # 7 jours

# Taille maximale par fichier binlog
max_binlog_size = 1G

# Sync binlog (sÃ©curitÃ© vs performance)
sync_binlog = 1
# 1 = Flush Ã  chaque commit (sÃ»r, PITR complet)
# 0 = OS dÃ©cide (plus rapide, risque perte < 1s)
# N = Flush tous les N commits
```

```bash
# RedÃ©marrer MariaDB aprÃ¨s configuration
systemctl restart mariadb

# VÃ©rifier que les binlogs sont actifs
mariadb -e "SHOW VARIABLES LIKE 'log_bin';"
# log_bin | ON

mariadb -e "SHOW MASTER STATUS\G"
# Output :
# File: mariadb-bin.000001
# Position: 328
```

---

### Archivage des binary logs

âš ï¸ **CRITIQUE** : Les binary logs doivent Ãªtre **archivÃ©s** rÃ©guliÃ¨rement pour permettre le PITR.

```bash
#!/bin/bash
# archive_binlogs.sh
# Archivage quotidien des binary logs

set -euo pipefail

BINLOG_DIR="/var/lib/mysql"
ARCHIVE_DIR="/backups/binlogs/$(date +%Y%m%d)"
RETENTION_DAYS=30

mkdir -p "$ARCHIVE_DIR"

echo "ğŸ“¦ Archiving binary logs..."

# Obtenir la liste des binlogs (sauf le dernier actif)
BINLOGS=$(mariadb -N -e "SHOW BINARY LOGS;" | awk '{print $1}' | head -n -1)

# Copier les binlogs vers l'archive
for binlog in $BINLOGS; do
    if [ -f "$BINLOG_DIR/$binlog" ]; then
        cp "$BINLOG_DIR/$binlog" "$ARCHIVE_DIR/"
        echo "  âœ… Archived: $binlog"
    fi
done

# Purger les anciens binlogs du serveur (aprÃ¨s archivage)
LAST_BINLOG=$(echo "$BINLOGS" | tail -1)
if [ -n "$LAST_BINLOG" ]; then
    mariadb -e "PURGE BINARY LOGS TO '$LAST_BINLOG';"
    echo "âœ… Purged binlogs up to $LAST_BINLOG"
fi

# Nettoyage des archives anciennes
find /backups/binlogs -type d -mtime +$RETENTION_DAYS -exec rm -rf {} \;

echo "âœ… Binlog archiving completed"
```

ğŸ’¡ **FrÃ©quence recommandÃ©e** : Quotidien, ou aprÃ¨s chaque full backup.

---

## Extraction des Ã©vÃ©nements avec mysqlbinlog

### Syntaxe de base

```bash
# Lire un binlog complet
mysqlbinlog /var/lib/mysql/mariadb-bin.000042

# Filtrer par timestamp
mysqlbinlog \
  --start-datetime="2025-12-13 00:00:00" \
  --stop-datetime="2025-12-13 14:29:59" \
  mariadb-bin.000042

# Filtrer par position
mysqlbinlog \
  --start-position=123456 \
  --stop-position=789012 \
  mariadb-bin.000042

# Filtrer par base de donnÃ©es
mysqlbinlog \
  --database=production_db \
  mariadb-bin.000042
```

---

### Options importantes

| Option | Description | Recommandation |
|--------|-------------|----------------|
| `--start-datetime` | DÃ©but (YYYY-MM-DD HH:MM:SS) | âœ… PITR par timestamp |
| `--stop-datetime` | Fin (YYYY-MM-DD HH:MM:SS) | âœ… PITR par timestamp |
| `--start-position` | Position de dÃ©but | âœ… PITR prÃ©cis |
| `--stop-position` | Position de fin | âœ… PITR prÃ©cis |
| `--database` | Filtrer par base | âœ… Si multi-bases |
| `--disable-log-bin` | DÃ©sactiver binlog pendant replay | âœ… Ã‰viter boucle |
| `--short-form` | Format court (debug) | ğŸ” Analyse |
| `--base64-output=DECODE-ROWS` | DÃ©code format ROW | ğŸ” Lecture ROW |
| `--verbose` | Afficher requÃªtes SQL (ROWâ†’SQL) | ğŸ” Comprendre ROW |

---

### Exemple : Analyser un binlog

```bash
# Analyser un binlog au format ROW (illisible par dÃ©faut)
mysqlbinlog \
  --base64-output=DECODE-ROWS \
  --verbose \
  mariadb-bin.000042 | less

# Output (exemple) :
### INSERT INTO `production_db`.`users`
### SET
###   @1=12345 /* INT */
###   @2='john.doe@example.com' /* VARCHAR(255) */
###   @3='2025-12-13 14:25:00' /* TIMESTAMP */

### DELETE FROM `production_db`.`users`
### WHERE
###   @1=12345
```

ğŸ’¡ **Format ROW** : Chaque ligne modifiÃ©e est loggÃ©e, idÃ©al pour PITR prÃ©cis.

---

## PITR : ProcÃ©dures complÃ¨tes

### ScÃ©nario 1 : DROP TABLE accidentel

**Contexte** :
- Mercredi 13/12/2025 Ã  14:30:00 â†’ DROP TABLE users; (ERREUR)
- Dernier full backup : Dimanche 10/12/2025 02:00
- Binary logs disponibles : dim 02:00 â†’ mer 15:00

**Objectif** : Restaurer la base au mercredi 14:29:59 (juste avant le DROP).

---

#### Ã‰tape 1 : Identifier le moment exact de l'erreur

```bash
# Rechercher "DROP TABLE users" dans les binlogs
grep -r "DROP TABLE.*users" /backups/binlogs/

# Output :
# /backups/binlogs/20251213/mariadb-bin.000044:DROP TABLE `users`

# Trouver le timestamp exact
mysqlbinlog \
  --base64-output=DECODE-ROWS \
  --verbose \
  /backups/binlogs/20251213/mariadb-bin.000044 | \
  grep -B5 "DROP TABLE.*users"

# Output :
# #251213 14:30:00 server id 1  end_log_pos 987654321
# SET TIMESTAMP=1734095400/*!*/;
# DROP TABLE `users`
```

ğŸ’¡ **Timestamp cible** : 2025-12-13 14:29:59 (1 seconde avant DROP).

---

#### Ã‰tape 2 : Restaurer le full backup

```bash
#!/bin/bash
# Restaurer le full backup du dimanche

FULL_BACKUP="/backups/mariadb/full_20251210"

# ArrÃªter MariaDB
systemctl stop mariadb

# Restaurer (exemple Mariabackup)
rm -rf /var/lib/mysql/*
mariabackup --copy-back --target-dir="$FULL_BACKUP"
chown -R mysql:mysql /var/lib/mysql

# DÃ©marrer MariaDB
systemctl start mariadb

echo "âœ… Full backup restored (Sunday 02:00)"
```

**Ã‰tat actuel** : Base au dimanche 10/12/2025 02:00.

---

#### Ã‰tape 3 : Identifier les binlogs Ã  rejouer

```bash
# Consulter la position binlog du full backup
cat "$FULL_BACKUP/xtrabackup_binlog_info"
# Output :
# mariadb-bin.000042    123456789

# Binlogs Ã  rejouer :
# 1. mariadb-bin.000042 (Ã  partir de position 123456789)
# 2. mariadb-bin.000043 (complet)
# 3. mariadb-bin.000044 (jusqu'Ã  2025-12-13 14:29:59)
```

---

#### Ã‰tape 4 : Extraire et rejouer les binlogs

```bash
#!/bin/bash
# pitr_restore.sh
# PITR jusqu'au mercredi 14:29:59

set -euo pipefail

BINLOG_ARCHIVE="/backups/binlogs"
TARGET_DATETIME="2025-12-13 14:29:59"
TEMP_SQL="/tmp/pitr_replay.sql"

echo "ğŸ”„ PITR: Replaying binlogs up to $TARGET_DATETIME"

# DÃ©sactiver temporairement le binlog (Ã©viter boucle)
mariadb -e "SET sql_log_bin=0;"

# Extraire les Ã©vÃ©nements de TOUS les binlogs nÃ©cessaires
mysqlbinlog \
  --disable-log-bin \
  --start-position=123456789 \
  "$BINLOG_ARCHIVE"/20251210/mariadb-bin.000042 \
  "$BINLOG_ARCHIVE"/20251211/mariadb-bin.000043 \
  "$BINLOG_ARCHIVE"/20251212/mariadb-bin.000043 \
  "$BINLOG_ARCHIVE"/20251213/mariadb-bin.000044 \
  --stop-datetime="$TARGET_DATETIME" \
  > "$TEMP_SQL"

# VÃ©rifier la taille du fichier SQL
FILE_SIZE=$(du -h "$TEMP_SQL" | cut -f1)
echo "ğŸ“Š SQL replay file size: $FILE_SIZE"

# Rejouer les Ã©vÃ©nements
echo "â™»ï¸  Replaying events..."
START_TIME=$(date +%s)

mariadb < "$TEMP_SQL"

END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))

if [ $? -eq 0 ]; then
    echo "âœ… PITR completed in ${DURATION}s"
    echo "ğŸ“… Database restored to: $TARGET_DATETIME"
else
    echo "âŒ PITR FAILED"
    exit 1
fi

# Nettoyage
rm -f "$TEMP_SQL"

# RÃ©activer le binlog
mariadb -e "SET sql_log_bin=1;"

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "âœ… PITR Recovery completed"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""
echo "âš ï¸  Next steps:"
echo "  1. Verify table 'users' is restored"
echo "  2. Check data integrity"
echo "  3. Test application"
```

**Ã‰tat final** : Base au mercredi 13/12/2025 14:29:59 (juste avant DROP TABLE) âœ….

---

### ScÃ©nario 2 : UPDATE sans WHERE (corruption massive)

**Contexte** :
- Mardi 12/12/2025 Ã  10:15:30 â†’ UPDATE users SET email='test@example.com'; (OUBLI du WHERE!)
- RÃ©sultat : Tous les emails Ã©crasÃ©s
- Besoin : Restaurer au mardi 10:15:29 (avant UPDATE)

---

#### Script PITR complet avec validation

```bash
#!/bin/bash
# pitr_update_recovery.sh
# RÃ©cupÃ©ration aprÃ¨s UPDATE sans WHERE

set -euo pipefail

# Configuration
FULL_BACKUP="/backups/mariadb/full_20251210"
BINLOG_ARCHIVE="/backups/binlogs"
TARGET_DATETIME="2025-12-12 10:15:29"
RESTORE_DB="production_db"

echo "ğŸš¨ EMERGENCY PITR: UPDATE without WHERE recovery"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Ã‰tape 1 : Sauvegarder l'Ã©tat actuel (au cas oÃ¹)
echo "ğŸ’¾ Step 1: Backing up current state..."
mysqldump --single-transaction "$RESTORE_DB" > \
  "/tmp/before_pitr_$(date +%s).sql"
echo "âœ… Current state backed up"

# Ã‰tape 2 : CrÃ©er une base temporaire pour PITR
TEMP_DB="${RESTORE_DB}_pitr_$(date +%s)"
echo ""
echo "ğŸ“¦ Step 2: Creating temporary database for PITR..."
mariadb -e "CREATE DATABASE $TEMP_DB;"

# Ã‰tape 3 : Restaurer le full backup dans la base temporaire
echo ""
echo "ğŸ“¥ Step 3: Restoring full backup to temporary database..."

# Si backup logique :
# zcat "$FULL_BACKUP" | mariadb "$TEMP_DB"

# Si Mariabackup (nÃ©cessite restauration complÃ¨te sur serveur secondaire)
# Approche alternative : Export/Import de la base spÃ©cifique
echo "  (Using logical backup approach for single database PITR)"

# Ã‰tape 4 : Identifier la position binlog du backup
BINLOG_FILE=$(cat "$FULL_BACKUP/xtrabackup_binlog_info" | cut -f1)
BINLOG_POS=$(cat "$FULL_BACKUP/xtrabackup_binlog_info" | cut -f2)

echo "  Binlog position: $BINLOG_FILE:$BINLOG_POS"

# Ã‰tape 5 : Rejouer les binlogs jusqu'au point cible
echo ""
echo "â™»ï¸  Step 4: Replaying binlogs up to $TARGET_DATETIME..."

mysqlbinlog \
  --disable-log-bin \
  --database="$RESTORE_DB" \
  --start-position="$BINLOG_POS" \
  "$BINLOG_ARCHIVE"/*/*bin.* \
  --stop-datetime="$TARGET_DATETIME" | \
  mariadb "$TEMP_DB"

if [ $? -ne 0 ]; then
    echo "âŒ Binlog replay FAILED"
    exit 1
fi

echo "âœ… Binlogs replayed successfully"

# Ã‰tape 6 : Validation de la restauration
echo ""
echo "ğŸ” Step 5: Validating PITR restore..."

# Compter les lignes
ORIGINAL_COUNT=$(mariadb -N -e "SELECT COUNT(*) FROM $RESTORE_DB.users;")
RESTORED_COUNT=$(mariadb -N -e "SELECT COUNT(*) FROM $TEMP_DB.users;")

echo "  - Original database: $ORIGINAL_COUNT rows"
echo "  - PITR restored: $RESTORED_COUNT rows"

# VÃ©rifier la diversitÃ© des emails (dÃ©tection UPDATE sans WHERE)
UNIQUE_EMAILS_ORIGINAL=$(mariadb -N -e "SELECT COUNT(DISTINCT email) FROM $RESTORE_DB.users;")
UNIQUE_EMAILS_RESTORED=$(mariadb -N -e "SELECT COUNT(DISTINCT email) FROM $TEMP_DB.users;")

echo "  - Unique emails (original): $UNIQUE_EMAILS_ORIGINAL"
echo "  - Unique emails (restored): $UNIQUE_EMAILS_RESTORED"

if [ "$UNIQUE_EMAILS_RESTORED" -gt "$UNIQUE_EMAILS_ORIGINAL" ]; then
    echo "âœ… PITR validation passed (diversity restored)"
else
    echo "âš ï¸  WARNING: Email diversity not improved"
fi

# Ã‰tape 7 : DÃ©cision de remplacement
echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "âš ï¸  MANUAL DECISION REQUIRED"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""
echo "Temporary database created: $TEMP_DB"
echo ""
echo "To replace production database, run:"
echo "  mariadb -e \"DROP DATABASE $RESTORE_DB;\""
echo "  mariadb -e \"CREATE DATABASE $RESTORE_DB;\""
echo "  mysqldump $TEMP_DB | mariadb $RESTORE_DB"
echo "  mariadb -e \"DROP DATABASE $TEMP_DB;\""
echo ""
echo "Or to cancel and keep current state:"
echo "  mariadb -e \"DROP DATABASE $TEMP_DB;\""
```

ğŸ’¡ **Approche sÃ©curisÃ©e** : Restauration dans une base temporaire pour validation avant remplacement.

---

### ScÃ©nario 3 : Restauration sÃ©lective (une table uniquement)

**Contexte** :
- Table `orders` corrompue
- Autres tables OK, ne doivent pas Ãªtre touchÃ©es
- Besoin : Restaurer uniquement `orders` au dernier Ã©tat sain

---

```bash
#!/bin/bash
# pitr_single_table.sh
# PITR d'une seule table

set -euo pipefail

TABLE_NAME="orders"
DATABASE="production_db"
TARGET_DATETIME="2025-12-13 12:00:00"
TEMP_DB="pitr_temp_$(date +%s)"

echo "ğŸ¯ Single-table PITR: $DATABASE.$TABLE_NAME"

# Ã‰tape 1 : CrÃ©er base temporaire
mariadb -e "CREATE DATABASE $TEMP_DB;"

# Ã‰tape 2 : Restaurer structure de la table
mariadb -e "CREATE TABLE $TEMP_DB.$TABLE_NAME LIKE $DATABASE.$TABLE_NAME;"

# Ã‰tape 3 : Extraire et rejouer UNIQUEMENT les Ã©vÃ©nements de cette table
mysqlbinlog \
  --disable-log-bin \
  --database="$DATABASE" \
  /backups/binlogs/*/*bin.* \
  --stop-datetime="$TARGET_DATETIME" | \
  grep -A100 "$TABLE_NAME" | \
  mariadb "$TEMP_DB"

# Ã‰tape 4 : Remplacer la table corrompue
echo "âš ï¸  Replacing table $TABLE_NAME..."

mariadb "$DATABASE" <<EOF
-- Renommer table corrompue
RENAME TABLE $TABLE_NAME TO ${TABLE_NAME}_corrupted_$(date +%s);

-- Renommer table restaurÃ©e
RENAME TABLE $TEMP_DB.$TABLE_NAME TO $DATABASE.$TABLE_NAME;
EOF

# Ã‰tape 5 : Nettoyage
mariadb -e "DROP DATABASE $TEMP_DB;"

echo "âœ… Table $TABLE_NAME restored to $TARGET_DATETIME"
```

âš ï¸ **Limitation** : Fonctionne uniquement si la table n'a pas de contraintes FK complexes avec d'autres tables.

---

## PITR avec diffÃ©rents types de backup

### PITR depuis mysqldump

```bash
#!/bin/bash
# pitr_from_mysqldump.sh

MYSQLDUMP_BACKUP="/backups/full_20251210.sql.gz"
TARGET_DATETIME="2025-12-13 14:29:59"

# Ã‰tape 1 : Restaurer mysqldump
echo "ğŸ“¥ Restoring mysqldump backup..."
zcat "$MYSQLDUMP_BACKUP" | mariadb

# Ã‰tape 2 : Extraire position binlog du dump
# mysqldump avec --master-data=2 inclut :
# -- CHANGE MASTER TO MASTER_LOG_FILE='binlog.000042', MASTER_LOG_POS=123456;

BINLOG_FILE=$(zcat "$MYSQLDUMP_BACKUP" | grep "CHANGE MASTER TO" | sed -n "s/.*MASTER_LOG_FILE='\([^']*\)'.*/\1/p")
BINLOG_POS=$(zcat "$MYSQLDUMP_BACKUP" | grep "CHANGE MASTER TO" | sed -n "s/.*MASTER_LOG_POS=\([0-9]*\).*/\1/p")

echo "  Binlog: $BINLOG_FILE:$BINLOG_POS"

# Ã‰tape 3 : Rejouer binlogs
mysqlbinlog \
  --disable-log-bin \
  --start-position="$BINLOG_POS" \
  /backups/binlogs/*/$BINLOG_FILE \
  /backups/binlogs/*/*bin.* \
  --stop-datetime="$TARGET_DATETIME" | \
  mariadb

echo "âœ… PITR from mysqldump completed"
```

ğŸ’¡ **Requis** : mysqldump doit avoir Ã©tÃ© crÃ©Ã© avec `--master-data=2`.

---

### PITR depuis Mariabackup

```bash
#!/bin/bash
# pitr_from_mariabackup.sh

MARIABACKUP_DIR="/backups/mariadb/full_20251210"
TARGET_DATETIME="2025-12-13 14:29:59"

# Ã‰tape 1 : Restaurer Mariabackup
echo "ğŸ“¥ Restoring Mariabackup backup..."

systemctl stop mariadb
rm -rf /var/lib/mysql/*

mariabackup --prepare --target-dir="$MARIABACKUP_DIR"
mariabackup --copy-back --target-dir="$MARIABACKUP_DIR"

chown -R mysql:mysql /var/lib/mysql
systemctl start mariadb

sleep 5

# Ã‰tape 2 : Lire position binlog
BINLOG_FILE=$(cat "$MARIABACKUP_DIR/xtrabackup_binlog_info" | cut -f1)
BINLOG_POS=$(cat "$MARIABACKUP_DIR/xtrabackup_binlog_info" | cut -f2)

echo "  Binlog: $BINLOG_FILE:$BINLOG_POS"

# Ã‰tape 3 : Rejouer binlogs
mysqlbinlog \
  --disable-log-bin \
  --start-position="$BINLOG_POS" \
  /backups/binlogs/*/$BINLOG_FILE \
  /backups/binlogs/*/*bin.* \
  --stop-datetime="$TARGET_DATETIME" | \
  mariadb

echo "âœ… PITR from Mariabackup completed"
```

---

## Automatisation du PITR

### Script PITR gÃ©nÃ©rique

```bash
#!/bin/bash
# pitr_generic.sh
# Script PITR gÃ©nÃ©rique et rÃ©utilisable

set -euo pipefail

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Configuration (personnalisable)
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BACKUP_TYPE="${1:-mariabackup}"  # mariabackup | mysqldump
FULL_BACKUP="${2:-/backups/mariadb/latest}"
TARGET_DATETIME="${3:-}"
BINLOG_ARCHIVE="${4:-/backups/binlogs}"
DATABASE="${5:-}"  # Optionnel : filtrer par base

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Validation des paramÃ¨tres
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if [ -z "$TARGET_DATETIME" ]; then
    echo "âŒ Usage: $0 <backup_type> <full_backup> <target_datetime> [binlog_archive] [database]"
    echo ""
    echo "Examples:"
    echo "  $0 mariabackup /backups/full_20251210 '2025-12-13 14:29:59'"
    echo "  $0 mysqldump /backups/dump.sql.gz '2025-12-13 14:29:59' /backups/binlogs production_db"
    exit 1
fi

echo "ğŸ”„ GENERIC PITR SCRIPT"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "  Backup type: $BACKUP_TYPE"
echo "  Full backup: $FULL_BACKUP"
echo "  Target time: $TARGET_DATETIME"
echo "  Database filter: ${DATABASE:-None}"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Ã‰tape 1 : Restaurer le full backup
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

echo "ğŸ“¥ Step 1: Restoring full backup..."

case "$BACKUP_TYPE" in
    mariabackup)
        systemctl stop mariadb
        rm -rf /var/lib/mysql/*
        
        mariabackup --prepare --target-dir="$FULL_BACKUP"
        mariabackup --copy-back --target-dir="$FULL_BACKUP"
        
        chown -R mysql:mysql /var/lib/mysql
        systemctl start mariadb
        
        sleep 5
        
        BINLOG_FILE=$(cat "$FULL_BACKUP/xtrabackup_binlog_info" | cut -f1)
        BINLOG_POS=$(cat "$FULL_BACKUP/xtrabackup_binlog_info" | cut -f2)
        ;;
        
    mysqldump)
        if [[ "$FULL_BACKUP" == *.gz ]]; then
            zcat "$FULL_BACKUP" | mariadb ${DATABASE:+$DATABASE}
        else
            mariadb ${DATABASE:+$DATABASE} < "$FULL_BACKUP"
        fi
        
        # Extraire position binlog du dump
        if [[ "$FULL_BACKUP" == *.gz ]]; then
            BINLOG_FILE=$(zcat "$FULL_BACKUP" | grep "CHANGE MASTER TO" | sed -n "s/.*MASTER_LOG_FILE='\([^']*\)'.*/\1/p")
            BINLOG_POS=$(zcat "$FULL_BACKUP" | grep "CHANGE MASTER TO" | sed -n "s/.*MASTER_LOG_POS=\([0-9]*\).*/\1/p")
        else
            BINLOG_FILE=$(grep "CHANGE MASTER TO" "$FULL_BACKUP" | sed -n "s/.*MASTER_LOG_FILE='\([^']*\)'.*/\1/p")
            BINLOG_POS=$(grep "CHANGE MASTER TO" "$FULL_BACKUP" | sed -n "s/.*MASTER_LOG_POS=\([0-9]*\).*/\1/p")
        fi
        ;;
        
    *)
        echo "âŒ Unknown backup type: $BACKUP_TYPE"
        exit 1
        ;;
esac

echo "âœ… Full backup restored"
echo "  Binlog position: $BINLOG_FILE:$BINLOG_POS"

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Ã‰tape 2 : Rejouer les binlogs
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

echo ""
echo "â™»ï¸  Step 2: Replaying binary logs to $TARGET_DATETIME..."

# Construire la commande mysqlbinlog
MYSQLBINLOG_CMD="mysqlbinlog --disable-log-bin --start-position=$BINLOG_POS"

if [ -n "$DATABASE" ]; then
    MYSQLBINLOG_CMD="$MYSQLBINLOG_CMD --database=$DATABASE"
fi

# Trouver tous les binlogs depuis la position de dÃ©part
BINLOG_FILES=$(find "$BINLOG_ARCHIVE" -name "*.0*" -type f | sort)

# Filtrer pour dÃ©marrer au bon fichier
START_FOUND=0
FILTERED_BINLOGS=""

for binlog in $BINLOG_FILES; do
    BINLOG_NAME=$(basename "$binlog")
    
    if [[ "$BINLOG_NAME" == "$BINLOG_FILE" ]]; then
        START_FOUND=1
    fi
    
    if [ $START_FOUND -eq 1 ]; then
        FILTERED_BINLOGS="$FILTERED_BINLOGS $binlog"
    fi
done

# ExÃ©cuter mysqlbinlog
$MYSQLBINLOG_CMD \
  $FILTERED_BINLOGS \
  --stop-datetime="$TARGET_DATETIME" | \
  mariadb

if [ $? -eq 0 ]; then
    echo "âœ… Binlogs replayed successfully"
else
    echo "âŒ Binlog replay FAILED"
    exit 1
fi

#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Ã‰tape 3 : Validation
#â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

echo ""
echo "ğŸ” Step 3: Validating PITR restore..."

# Test connexion
if mariadb -e "SELECT VERSION();" &>/dev/null; then
    echo "âœ… Database connection OK"
else
    echo "âŒ Database connection FAILED"
    exit 1
fi

# Compter les bases
DB_COUNT=$(mariadb -N -e "SELECT COUNT(*) FROM information_schema.schemata WHERE schema_name NOT IN ('information_schema', 'performance_schema', 'mysql');")
echo "  - User databases: $DB_COUNT"

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "âœ… PITR COMPLETED SUCCESSFULLY"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""
echo "ğŸ“… Database restored to: $TARGET_DATETIME"
echo ""
echo "âš ï¸  Next steps:"
echo "  1. Verify critical data"
echo "  2. Run application smoke tests"
echo "  3. Check data integrity"
echo "  4. Resume normal operations"
```

**Usage** :

```bash
# PITR depuis Mariabackup
./pitr_generic.sh mariabackup /backups/full_20251210 '2025-12-13 14:29:59'

# PITR depuis mysqldump avec filtre base
./pitr_generic.sh mysqldump /backups/dump.sql.gz '2025-12-13 14:29:59' /backups/binlogs production_db
```

---

## Calcul et optimisation du RPO

### Formule du RPO avec PITR

```
RPO effectif = MIN(
    FrÃ©quence flush binlog,
    FrÃ©quence archivage binlog,
    Latence dÃ©tection incident
)

Exemples :
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Configuration 1 : sync_binlog=1, archivage quotidien
RPO = 24 heures (limitÃ© par archivage)

Configuration 2 : sync_binlog=1, archivage horaire
RPO = 1 heure

Configuration 3 : sync_binlog=1, archivage temps rÃ©el (S3)
RPO = < 1 seconde (quasi-instantanÃ©)

Configuration 4 : sync_binlog=0, archivage quotidien
RPO = 24 heures + risque perte < 1s (crash serveur)
```

---

### Optimisation RPO < 1 minute

```bash
#!/bin/bash
# sync_binlogs_realtime.sh
# Synchronisation temps rÃ©el des binlogs vers S3

S3_BUCKET="s3://my-backups/binlogs"
BINLOG_DIR="/var/lib/mysql"
SYNC_INTERVAL=60  # Secondes

while true; do
    # Copier les nouveaux binlogs vers S3
    aws s3 sync "$BINLOG_DIR" "$S3_BUCKET/$(date +%Y%m%d)/" \
      --exclude "*" \
      --include "mariadb-bin.*" \
      --storage-class STANDARD_IA
    
    sleep $SYNC_INTERVAL
done
```

```ini
# /etc/systemd/system/binlog-sync.service
[Unit]
Description=Real-time binlog sync to S3
After=mariadb.service

[Service]
Type=simple
ExecStart=/opt/scripts/sync_binlogs_realtime.sh
Restart=always

[Install]
WantedBy=multi-user.target
```

ğŸ’¡ **RÃ©sultat** : RPO < 1 minute avec archivage S3 temps rÃ©el.

---

## PITR cloud-native

### AWS RDS : Automated Backups avec PITR

```bash
# AWS RDS fournit PITR intÃ©grÃ© (jusqu'Ã  35 jours)
# Restauration via AWS CLI

aws rds restore-db-instance-to-point-in-time \
  --source-db-instance-identifier mydb-prod \
  --target-db-instance-identifier mydb-pitr-20251213 \
  --restore-time 2025-12-13T14:29:59Z \
  --db-instance-class db.r5.large

# RÃ©sultat : Nouvelle instance RDS crÃ©Ã©e Ã  l'Ã©tat PITR
```

---

### Kubernetes : PITR avec PVC snapshots + binlogs

```yaml
# pitr-restore-job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: mariadb-pitr-restore
  namespace: databases
spec:
  template:
    spec:
      restartPolicy: OnFailure
      initContainers:
      # 1. Restaurer depuis VolumeSnapshot
      - name: restore-snapshot
        image: mariadb:11.8
        command:
        - sh
        - -c
        - |
          # La snapshot est montÃ©e automatiquement
          cp -r /snapshot-data/* /var/lib/mysql/
          chown -R mysql:mysql /var/lib/mysql
        volumeMounts:
        - name: snapshot-restore
          mountPath: /snapshot-data
        - name: mariadb-data
          mountPath: /var/lib/mysql
      
      containers:
      # 2. Rejouer les binlogs depuis S3
      - name: replay-binlogs
        image: mariadb:11.8
        env:
        - name: TARGET_DATETIME
          value: "2025-12-13 14:29:59"
        - name: S3_BINLOG_BUCKET
          value: "s3://my-backups/binlogs"
        command:
        - sh
        - -c
        - |
          # TÃ©lÃ©charger binlogs depuis S3
          aws s3 sync $S3_BINLOG_BUCKET /tmp/binlogs/
          
          # DÃ©marrer MariaDB temporairement
          mysqld --skip-networking --datadir=/var/lib/mysql &
          MYSQL_PID=$!
          
          sleep 10
          
          # Rejouer binlogs
          mysqlbinlog --disable-log-bin \
            /tmp/binlogs/*bin.* \
            --stop-datetime="$TARGET_DATETIME" | \
            mariadb
          
          # ArrÃªter proprement
          mysqladmin shutdown
          wait $MYSQL_PID
          
          echo "âœ… PITR completed"
        volumeMounts:
        - name: mariadb-data
          mountPath: /var/lib/mysql
      
      volumes:
      - name: snapshot-restore
        persistentVolumeClaim:
          claimName: mariadb-snapshot-pvc
      - name: mariadb-data
        persistentVolumeClaim:
          claimName: mariadb-data-pvc
```

---

## PiÃ¨ges et limitations

### PiÃ¨ge 1 : Binary log inexistant ou incomplet

**SymptÃ´me** :

```
ERROR: Could not find binary log file 'mariadb-bin.000043'
```

**Cause** : Binlog purgÃ© ou non archivÃ©.

**Solution** :

```bash
# Toujours archiver AVANT de purger
# Automatiser l'archivage avant PURGE BINARY LOGS

# Script sÃ©curisÃ©
archive_binlogs.sh  # Archive vers /backups/binlogs
mariadb -e "PURGE BINARY LOGS BEFORE NOW() - INTERVAL 7 DAY;"
```

ğŸ’¡ **PrÃ©vention** : Archivage automatique quotidien + rÃ©tention longue (30-90 jours).

---

### PiÃ¨ge 2 : Binlog format STATEMENT avec fonctions non-dÃ©terministes

**SymptÃ´me** :

```
# Binlog contient :
UPDATE users SET updated_at = NOW();

# Lors du replay, NOW() = temps actuel (pas temps original)
# RÃ©sultat : Timestamps incorrects
```

**Solution** :

```ini
# /etc/my.cnf.d/server.cnf
[mysqld]
binlog_format = ROW  # Toujours ROW pour PITR fiable
```

---

### PiÃ¨ge 3 : Taille excessive des binlogs

**SymptÃ´me** : Binlogs de plusieurs centaines de GB, replay trÃ¨s long.

**Solution** :

```bash
# Rejouer en parallÃ¨le (si plusieurs bases indÃ©pendantes)
mysqlbinlog --database=db1 binlog.* | mariadb db1 &
mysqlbinlog --database=db2 binlog.* | mariadb db2 &
wait

# Ou : Filtrer uniquement la pÃ©riode nÃ©cessaire
mysqlbinlog \
  --start-datetime="2025-12-13 00:00:00" \
  --stop-datetime="2025-12-13 14:29:59" \
  binlog.* | mariadb
```

---

### PiÃ¨ge 4 : Charset diffÃ©rent entre backup et binlogs

**SymptÃ´me** : CaractÃ¨res spÃ©ciaux corrompus aprÃ¨s PITR.

**Solution** :

```bash
# Forcer le charset lors du replay
mysqlbinlog --set-charset=utf8mb4 binlog.* | \
  mariadb --default-character-set=utf8mb4
```

---

### PiÃ¨ge 5 : Oublier de dÃ©sactiver sql_log_bin pendant replay

**SymptÃ´me** : Les Ã©vÃ©nements rejouÃ©s sont eux-mÃªmes loggÃ©s dans le binlog (boucle).

**Solution** :

```bash
# Toujours utiliser --disable-log-bin
mysqlbinlog --disable-log-bin binlog.* | mariadb

# Ou au niveau session :
mariadb -e "SET sql_log_bin=0;"
# ... replay ...
mariadb -e "SET sql_log_bin=1;"
```

---

## âœ… Points clÃ©s Ã  retenir

- **PITR** = Restauration prÃ©cise Ã  un instant T (entre deux backups)
- **Composants** : Full backup + Binary logs archivÃ©s
- **RPO avec PITR** : < 1 minute (limitÃ© par flush/archivage binlog)
- **sync_binlog=1** : Obligatoire pour PITR complet sans perte
- **binlog_format=ROW** : RecommandÃ© pour PITR fiable (vs STATEMENT)
- **Archivage binlogs** : Automatique quotidien minimum, temps rÃ©el idÃ©al
- **mysqlbinlog options** : `--disable-log-bin`, `--start-position`, `--stop-datetime`
- **3 approches PITR** : Par timestamp, par position, par base de donnÃ©es
- **Validation obligatoire** : Toujours tester dans base temporaire avant production
- **Automatisation** : Script PITR gÃ©nÃ©rique rÃ©utilisable pour DR rapide

---

## ğŸ”— Ressources et rÃ©fÃ©rences

- ğŸ“– [Binary Log Documentation](https://mariadb.com/kb/en/binary-log/)
- ğŸ“– [mysqlbinlog Utility](https://mariadb.com/kb/en/mysqlbinlog/)
- ğŸ“– [Point-in-Time Recovery](https://mariadb.com/kb/en/point-in-time-recovery/)
- ğŸ“– [Binary Log Formats](https://mariadb.com/kb/en/binary-log-formats/)
- ğŸ› ï¸ [PITR Best Practices](https://mariadb.com/resources/blog/point-in-time-recovery-mariadb/)
- ğŸ“Š [RPO Optimization Strategies](https://mariadb.com/kb/en/backup-and-restore-overview/)

---

## â¡ï¸ Section suivante

**12.6 Automatisation des sauvegardes** : Scripts de backup complets, orchestration avec cron/systemd, monitoring Prometheus, alerting Slack/email, et intÃ©gration CI/CD pour tests automatisÃ©s de restauration.

â­ï¸ [Automatisation des sauvegardes](/12-sauvegarde-restauration/06-automatisation-sauvegardes.md)
