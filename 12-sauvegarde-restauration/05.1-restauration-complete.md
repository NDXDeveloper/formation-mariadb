ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 12.5.1 Restauration complÃ¨te

> **Niveau** : AvancÃ©  
> **DurÃ©e estimÃ©e** : 3 heures  
> **PrÃ©requis** : Sections 12.2 et 12.3 (sauvegardes logiques et physiques), comprÃ©hension des procÃ©dures DR

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Restaurer une base de donnÃ©es complÃ¨te depuis diffÃ©rents types de backups (logique, physique)
- Suivre des procÃ©dures de restauration sÃ©curisÃ©es en situation de disaster recovery
- Valider l'intÃ©gritÃ© et la cohÃ©rence des donnÃ©es aprÃ¨s restauration
- Mesurer et optimiser le RTO (Recovery Time Objective)
- GÃ©rer les erreurs courantes lors de la restauration
- Automatiser les procÃ©dures de restauration avec des scripts robustes
- Restaurer dans des environnements cloud-native (Kubernetes, AWS)
- Documenter et tester vos plans de reprise d'activitÃ© (PRA)

---

## Introduction

La **restauration complÃ¨te** est le processus de reconstruction d'une base de donnÃ©es MariaDB Ã  partir d'un backup, ramenant le systÃ¨me Ã  un Ã©tat cohÃ©rent et fonctionnel. Contrairement au Point-in-Time Recovery (PITR) qui restaure Ã  un moment prÃ©cis, la restauration complÃ¨te vise Ã  rÃ©cupÃ©rer l'Ã©tat le plus rÃ©cent disponible dans les backups.

### ScÃ©narios de restauration complÃ¨te

```
SCÃ‰NARIOS NÃ‰CESSITANT UNE RESTAURATION COMPLÃˆTE :
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. ğŸ’¥ DISASTER RECOVERY
   â”œâ”€ Panne matÃ©rielle (disque HS, serveur HS)
   â”œâ”€ Corruption du datadir MariaDB
   â”œâ”€ Incendie, inondation, sinistre datacenter
   â””â”€ RTO : < 1-4 heures

2. ğŸ› CORRUPTION DE DONNÃ‰ES
   â”œâ”€ Bug applicatif ayant corrompu donnÃ©es
   â”œâ”€ Ransomware, malware
   â”œâ”€ Erreur humaine (DROP DATABASE accidentel)
   â””â”€ RTO : < 2-6 heures

3. ğŸ”„ MIGRATION
   â”œâ”€ Migration vers nouveau serveur
   â”œâ”€ Changement de datacenter
   â”œâ”€ Upgrade infrastructure
   â””â”€ RTO : PlanifiÃ© (fenÃªtre maintenance)

4. ğŸ§ª CLONAGE ENVIRONNEMENT
   â”œâ”€ Restauration en dev/test/staging
   â”œâ”€ Analyse post-mortem
   â”œâ”€ Tests de performance
   â””â”€ RTO : Non critique

5. ğŸ” AUDIT/FORENSICS
   â”œâ”€ Investigation sÃ©curitÃ©
   â”œâ”€ RÃ©cupÃ©ration donnÃ©es historiques
   â”œâ”€ Analyse rÃ©glementaire
   â””â”€ RTO : Non critique
```

### Matrice de dÃ©cision : Quel type de restauration ?

| ScÃ©nario | Type backup | MÃ©thode | RTO estimÃ© |
|----------|-------------|---------|------------|
| DR urgent (< 1h) | Mariabackup full | --copy-back | 15-45 min |
| DR standard (< 4h) | Mariabackup full + inc | --prepare + --copy-back | 1-3h |
| Corruption donnÃ©es | mysqldump/mydumper | mysql < backup.sql | 2-6h |
| Migration planifiÃ©e | Au choix | Selon disponibilitÃ© | PlanifiÃ© |
| Clone dev/test | mydumper (sÃ©lectif) | myloader | 30 min - 2h |

---

## Restauration depuis mysqldump / mariadb-dump

### Processus de restauration

```
Ã‰TAPES DE RESTAURATION LOGIQUE :
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. â¸ï¸  ArrÃªter l'application (si nÃ©cessaire)
2. ğŸ—‘ï¸  Vider la base cible (ou crÃ©er nouvelle base)
3. ğŸ“¥ Importer le dump SQL
4. âœ… Valider l'intÃ©gritÃ© des donnÃ©es
5. â–¶ï¸  RedÃ©marrer l'application
```

---

### Exemple 1 : Restauration simple (base unique)

```bash
#!/bin/bash
# restore_from_mysqldump.sh
# Restauration complÃ¨te depuis mysqldump

set -euo pipefail

BACKUP_FILE="/backups/mariadb/production_db_20251213.sql.gz"
DATABASE="production_db"

echo "ğŸ”„ Starting restore from mysqldump"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Ã‰tape 1 : VÃ©rifier que le fichier de backup existe
if [ ! -f "$BACKUP_FILE" ]; then
    echo "âŒ Backup file not found: $BACKUP_FILE"
    exit 1
fi

echo "âœ… Backup file found: $BACKUP_FILE"

# Ã‰tape 2 : CrÃ©er la base de donnÃ©es si elle n'existe pas
echo "ğŸ“¦ Creating database if not exists..."
mariadb -e "CREATE DATABASE IF NOT EXISTS $DATABASE CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"

# Ã‰tape 3 : Importer le backup
echo "ğŸ“¥ Importing backup..."
START_TIME=$(date +%s)

zcat "$BACKUP_FILE" | pv | mariadb "$DATABASE"

END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))

if [ $? -eq 0 ]; then
    echo "âœ… Backup imported successfully in ${DURATION}s"
else
    echo "âŒ Import FAILED"
    exit 1
fi

# Ã‰tape 4 : Validation basique
echo "ğŸ” Validating restore..."

TABLE_COUNT=$(mariadb -N -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='$DATABASE';")
echo "  - Tables restored: $TABLE_COUNT"

if [ "$TABLE_COUNT" -eq 0 ]; then
    echo "âŒ No tables found! Restore may have failed."
    exit 1
fi

# Compter les lignes dans les tables principales (exemple)
USERS_COUNT=$(mariadb -N -e "SELECT COUNT(*) FROM $DATABASE.users;" 2>/dev/null || echo "0")
ORDERS_COUNT=$(mariadb -N -e "SELECT COUNT(*) FROM $DATABASE.orders;" 2>/dev/null || echo "0")

echo "  - users: $USERS_COUNT rows"
echo "  - orders: $ORDERS_COUNT rows"

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "âœ… Restore completed successfully"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""
echo "âš ï¸  Next steps:"
echo "  1. Run application smoke tests"
echo "  2. Verify data integrity"
echo "  3. Check application logs"
```

---

### Exemple 2 : Restauration avec optimisations

```bash
#!/bin/bash
# restore_optimized.sh
# Restauration optimisÃ©e pour grandes bases

BACKUP_FILE="/backups/large_db_backup.sql.gz"
DATABASE="large_db"

echo "ğŸ“¥ Optimized restore starting..."

# DÃ©sactiver temporairement les checks pour performance
mariadb "$DATABASE" <<EOF
SET AUTOCOMMIT=0;
SET UNIQUE_CHECKS=0;
SET FOREIGN_KEY_CHECKS=0;

-- Import du backup
SOURCE <(zcat $BACKUP_FILE);

COMMIT;

-- RÃ©activer les checks
SET UNIQUE_CHECKS=1;
SET FOREIGN_KEY_CHECKS=1;
SET AUTOCOMMIT=1;

-- Reconstruire les statistiques
ANALYZE TABLE \`users\`, \`orders\`, \`products\`;
EOF

echo "âœ… Optimized restore completed"
```

**Gains de performance** :
- `AUTOCOMMIT=0` : Moins de flush disque (1 commit global vs N commits)
- `UNIQUE_CHECKS=0` : Pas de vÃ©rification unicitÃ© Ã  chaque ligne
- `FOREIGN_KEY_CHECKS=0` : Pas de vÃ©rification FK Ã  chaque ligne
- RÃ©sultat : **3-5x plus rapide** sur grandes bases

---

### Exemple 3 : Restauration sur nouveau serveur

```bash
#!/bin/bash
# restore_to_new_server.sh
# Restauration DR sur serveur de secours

set -euo pipefail

# Configuration
NEW_SERVER="dr-server.example.com"
BACKUP_FILE="/backups/production_20251213.sql.gz"
DATABASE="production_db"

echo "ğŸš€ DR restore to new server: $NEW_SERVER"

# Ã‰tape 1 : VÃ©rifier connectivitÃ©
if ! mariadb -h "$NEW_SERVER" -e "SELECT 1;" &>/dev/null; then
    echo "âŒ Cannot connect to $NEW_SERVER"
    exit 1
fi

echo "âœ… Connection to $NEW_SERVER verified"

# Ã‰tape 2 : CrÃ©er la base
mariadb -h "$NEW_SERVER" -e "CREATE DATABASE IF NOT EXISTS $DATABASE;"

# Ã‰tape 3 : Restaurer
echo "ğŸ“¥ Restoring to $NEW_SERVER..."

zcat "$BACKUP_FILE" | \
  pv -pterb | \
  mariadb -h "$NEW_SERVER" "$DATABASE"

if [ $? -eq 0 ]; then
    echo "âœ… Restore to DR server completed"
    
    # Ã‰tape 4 : VÃ©rifier les utilisateurs et privilÃ¨ges
    echo "ğŸ‘¤ Recreating users and privileges..."
    
    # Restaurer les utilisateurs depuis un backup sÃ©parÃ©
    mariadb -h "$NEW_SERVER" mysql < /backups/users_grants.sql
    
    echo "âœ… DR server ready for production"
else
    echo "âŒ Restore FAILED"
    exit 1
fi
```

---

## Restauration depuis mydumper / myloader

### Avantages de myloader pour la restauration

```
myloader vs mariadb < dump.sql :
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… Restauration parallÃ¨le (8-16 threads)
âœ… Restauration sÃ©lective (tables spÃ©cifiques)
âœ… Reconstruction index optimisÃ©e (--innodb-optimize-keys)
âœ… Logs dÃ©taillÃ©s et monitoring
âœ… Gestion erreurs granulaire (par table)

RÃ©sultat : 5-10x plus rapide que mysql CLI
```

---

### Exemple 1 : Restauration complÃ¨te avec myloader

```bash
#!/bin/bash
# restore_with_myloader.sh
# Restauration rapide avec myloader

set -euo pipefail

BACKUP_DIR="/backups/mydumper_20251213"
DATABASE="production_db"
LOG_FILE="/var/log/myloader_restore_$(date +%Y%m%d_%H%M%S).log"

echo "ğŸ”„ Starting restore with myloader"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Validation du backup
if [ ! -d "$BACKUP_DIR" ]; then
    echo "âŒ Backup directory not found: $BACKUP_DIR"
    exit 1
fi

if [ ! -f "$BACKUP_DIR/metadata" ]; then
    echo "âŒ Metadata file missing (invalid backup)"
    exit 1
fi

echo "âœ… Backup directory validated"
echo "ğŸ“Š Backup metadata:"
cat "$BACKUP_DIR/metadata"
echo ""

# CrÃ©er la base cible
echo "ğŸ“¦ Creating target database..."
mariadb -e "CREATE DATABASE IF NOT EXISTS $DATABASE;"

# Restauration avec myloader
echo "ğŸ“¥ Restoring with myloader (parallel mode)..."
START_TIME=$(date +%s)

myloader \
  --directory="$BACKUP_DIR" \
  --database="$DATABASE" \
  --threads=16 \
  --innodb-optimize-keys \
  --max-allowed-packet=1G \
  --queries-per-transaction=1000 \
  --overwrite-tables \
  --verbose=3 \
  --logfile="$LOG_FILE"

RESTORE_STATUS=$?
END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))

if [ $RESTORE_STATUS -ne 0 ]; then
    echo "âŒ Restore FAILED"
    echo "ğŸ“„ Check logs: $LOG_FILE"
    exit 1
fi

echo "âœ… Restore completed in ${DURATION}s"

# Validation
echo "ğŸ” Validating restore..."

TABLE_COUNT=$(mariadb -N -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='$DATABASE';")
echo "  - Tables: $TABLE_COUNT"

# VÃ©rifier l'absence de tables vides critiques
CRITICAL_TABLES=("users" "orders" "products")

for table in "${CRITICAL_TABLES[@]}"; do
    COUNT=$(mariadb -N -e "SELECT COUNT(*) FROM $DATABASE.$table;" 2>/dev/null || echo "ERROR")
    
    if [ "$COUNT" = "ERROR" ]; then
        echo "  âš ï¸  Table $table not found"
    elif [ "$COUNT" -eq 0 ]; then
        echo "  âš ï¸  Table $table is empty!"
    else
        echo "  âœ… Table $table: $COUNT rows"
    fi
done

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "âœ… myloader restore completed"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "ğŸ“„ Detailed logs: $LOG_FILE"
```

---

### Exemple 2 : Restauration sÃ©lective (tables critiques uniquement)

```bash
#!/bin/bash
# restore_selective_tables.sh
# Restauration urgente des tables critiques uniquement

BACKUP_DIR="/backups/mydumper_latest"
DATABASE="production_db"

# Tables critiques Ã  restaurer en prioritÃ©
CRITICAL_TABLES="users|orders|payments|sessions"

echo "âš¡ Fast restore: critical tables only"

myloader \
  --directory="$BACKUP_DIR" \
  --database="$DATABASE" \
  --source-db="production_db" \
  --regex="production_db\\.($CRITICAL_TABLES)" \
  --threads=8 \
  --innodb-optimize-keys \
  --overwrite-tables

if [ $? -eq 0 ]; then
    echo "âœ… Critical tables restored"
    echo "  Application can restart with limited functionality"
    echo ""
    echo "â­ï¸  Restore remaining tables in background:"
    echo "  myloader -d $BACKUP_DIR --database=$DATABASE \\"
    echo "    --regex='production_db\\.(?!$CRITICAL_TABLES)' --threads=16"
fi
```

---

## Restauration depuis Mariabackup

### Architecture de restauration Mariabackup

```
PROCESSUS RESTAURATION MARIABACKUP :
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. ğŸ”§ PRÃ‰PARATION (--prepare)
   â”œâ”€ Applique redo log au backup
   â”œâ”€ Rollback transactions uncommitted
   â””â”€ Ã‰tat : Backup cohÃ©rent

2. â¸ï¸  ARRÃŠT MARIADB
   â””â”€ systemctl stop mariadb

3. ğŸ—‘ï¸  NETTOYAGE DATADIR
   â””â”€ rm -rf /var/lib/mysql/* (ou sauvegarde)

4. ğŸ“‹ COPIE (--copy-back)
   â””â”€ Copie fichiers prÃ©parÃ©s vers datadir

5. ğŸ”’ PERMISSIONS
   â””â”€ chown -R mysql:mysql /var/lib/mysql

6. â–¶ï¸  DÃ‰MARRAGE MARIADB
   â””â”€ systemctl start mariadb

7. âœ… VALIDATION
   â””â”€ Tests connexion et intÃ©gritÃ©
```

---

### Exemple 1 : Restauration full backup (cas simple)

```bash
#!/bin/bash
# restore_mariabackup_full.sh
# Restauration complÃ¨te depuis Mariabackup full backup

set -euo pipefail

BACKUP_DIR="/backups/mariadb/full_20251213"
DATADIR="/var/lib/mysql"
DATADIR_BACKUP="/var/lib/mysql_old_$(date +%s)"

echo "ğŸ”„ Mariabackup Full Restore"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Ã‰TAPE 1 : Validation du backup
echo "ğŸ” Step 1: Validating backup..."

if [ ! -d "$BACKUP_DIR" ]; then
    echo "âŒ Backup directory not found: $BACKUP_DIR"
    exit 1
fi

if [ ! -f "$BACKUP_DIR/xtrabackup_checkpoints" ]; then
    echo "âŒ Invalid backup (xtrabackup_checkpoints missing)"
    exit 1
fi

# VÃ©rifier que le backup est prÃ©parÃ©
if ! grep -q "backup_type = full-prepared" "$BACKUP_DIR/xtrabackup_checkpoints"; then
    echo "âš ï¸  Backup NOT prepared, running --prepare..."
    
    mariabackup --prepare --target-dir="$BACKUP_DIR"
    
    if [ $? -ne 0 ]; then
        echo "âŒ Backup preparation FAILED"
        exit 1
    fi
    
    echo "âœ… Backup prepared successfully"
else
    echo "âœ… Backup is already prepared"
fi

# Afficher les LSN
echo "ğŸ“Š Backup LSN information:"
grep "lsn" "$BACKUP_DIR/xtrabackup_checkpoints"

# Ã‰TAPE 2 : ArrÃªter MariaDB
echo ""
echo "â¸ï¸  Step 2: Stopping MariaDB..."

systemctl stop mariadb

if systemctl is-active --quiet mariadb; then
    echo "âŒ Failed to stop MariaDB"
    exit 1
fi

echo "âœ… MariaDB stopped"

# Ã‰TAPE 3 : Sauvegarder l'ancien datadir
echo ""
echo "ğŸ’¾ Step 3: Backing up old datadir..."

if [ -d "$DATADIR" ] && [ "$(ls -A $DATADIR)" ]; then
    echo "  Moving $DATADIR to $DATADIR_BACKUP"
    mv "$DATADIR" "$DATADIR_BACKUP"
    echo "âœ… Old datadir saved"
else
    echo "  Datadir is empty or doesn't exist, skipping backup"
fi

# CrÃ©er nouveau datadir vide
mkdir -p "$DATADIR"

# Ã‰TAPE 4 : Copier le backup
echo ""
echo "ğŸ“‹ Step 4: Copying backup to datadir..."
START_TIME=$(date +%s)

mariabackup --copy-back --target-dir="$BACKUP_DIR"

COPY_STATUS=$?
END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))

if [ $COPY_STATUS -ne 0 ]; then
    echo "âŒ Copy-back FAILED"
    
    # Restaurer l'ancien datadir
    if [ -d "$DATADIR_BACKUP" ]; then
        echo "âš ï¸  Restoring old datadir..."
        rm -rf "$DATADIR"
        mv "$DATADIR_BACKUP" "$DATADIR"
    fi
    
    exit 1
fi

echo "âœ… Backup copied in ${DURATION}s"

# Ã‰TAPE 5 : Corriger les permissions
echo ""
echo "ğŸ”’ Step 5: Fixing permissions..."

chown -R mysql:mysql "$DATADIR"
chmod 750 "$DATADIR"

echo "âœ… Permissions fixed"

# Ã‰TAPE 6 : DÃ©marrer MariaDB
echo ""
echo "â–¶ï¸  Step 6: Starting MariaDB..."

systemctl start mariadb

# Attendre le dÃ©marrage
sleep 5

if ! systemctl is-active --quiet mariadb; then
    echo "âŒ MariaDB failed to start"
    echo "ğŸ“„ Check error log: journalctl -u mariadb -n 50"
    exit 1
fi

echo "âœ… MariaDB started successfully"

# Ã‰TAPE 7 : Validation
echo ""
echo "âœ… Step 7: Validating restore..."

# Test connexion
if mariadb -e "SELECT VERSION();" &>/dev/null; then
    echo "âœ… Database connection OK"
else
    echo "âŒ Cannot connect to database"
    exit 1
fi

# Compter les bases
DB_COUNT=$(mariadb -N -e "SELECT COUNT(*) FROM information_schema.schemata WHERE schema_name NOT IN ('information_schema', 'performance_schema', 'mysql');")
echo "  - User databases: $DB_COUNT"

# VÃ©rifier l'absence d'erreurs InnoDB
ERROR_COUNT=$(mariadb -N -e "SELECT COUNT(*) FROM information_schema.innodb_trx WHERE trx_state = 'LOCK WAIT';")
if [ "$ERROR_COUNT" -gt 0 ]; then
    echo "  âš ï¸  $ERROR_COUNT transactions in LOCK WAIT state"
fi

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "âœ… Restore completed successfully!"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""
echo "ğŸ“Š Summary:"
echo "  - Restore duration: ${DURATION}s"
echo "  - Databases restored: $DB_COUNT"
echo "  - Old datadir: $DATADIR_BACKUP"
echo ""
echo "âš ï¸  Next steps:"
echo "  1. Run application smoke tests"
echo "  2. Verify critical data"
echo "  3. Check application connectivity"
echo "  4. Remove old datadir after validation:"
echo "     rm -rf $DATADIR_BACKUP"
```

---

### Exemple 2 : Restauration chaÃ®ne incrÃ©mentale (full + incrementaux)

```bash
#!/bin/bash
# restore_mariabackup_incremental.sh
# Restauration depuis full + chaÃ®ne incrÃ©mentale

set -euo pipefail

BACKUP_ROOT="/backups/mariadb"
FULL_BACKUP="$BACKUP_ROOT/full_20251213"
INCREMENTALS=(
    "$BACKUP_ROOT/inc_20251214"
    "$BACKUP_ROOT/inc_20251215"
    "$BACKUP_ROOT/inc_20251216"
)
DATADIR="/var/lib/mysql"

echo "ğŸ”„ Incremental Chain Restore"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Ã‰TAPE 1 : PrÃ©paration de la chaÃ®ne
echo "ğŸ”§ Step 1: Preparing incremental chain..."

# PrÃ©parer le FULL (avec --apply-log-only)
echo "  [1/4] Preparing FULL backup..."
mariabackup --prepare --apply-log-only --target-dir="$FULL_BACKUP"

if [ $? -ne 0 ]; then
    echo "âŒ Failed to prepare FULL backup"
    exit 1
fi

# Appliquer les incrÃ©mentaux
INC_COUNT=${#INCREMENTALS[@]}

for i in "${!INCREMENTALS[@]}"; do
    INC_DIR="${INCREMENTALS[$i]}"
    INC_NUM=$((i + 1))
    
    echo "  [$((INC_NUM + 1))/4] Applying incremental #$INC_NUM..."
    
    # Dernier incrÃ©mental : pas de --apply-log-only
    if [ $INC_NUM -eq $INC_COUNT ]; then
        mariabackup --prepare \
          --target-dir="$FULL_BACKUP" \
          --incremental-dir="$INC_DIR"
    else
        mariabackup --prepare \
          --apply-log-only \
          --target-dir="$FULL_BACKUP" \
          --incremental-dir="$INC_DIR"
    fi
    
    if [ $? -ne 0 ]; then
        echo "âŒ Failed to apply incremental #$INC_NUM"
        exit 1
    fi
done

echo "âœ… Incremental chain prepared"

# Ã‰TAPE 2-7 : Restauration (comme full backup)
echo ""
echo "ğŸ“‹ Step 2-7: Restoring prepared backup..."

# [Reprendre les Ã©tapes 2-7 du script full backup ci-dessus]
# Pour Ã©viter duplication, on appelle le script prÃ©cÃ©dent
# ou on rÃ©implÃ©mente les Ã©tapes

systemctl stop mariadb
mv "$DATADIR" "/var/lib/mysql_old_$(date +%s)"
mkdir -p "$DATADIR"

mariabackup --copy-back --target-dir="$FULL_BACKUP"

chown -R mysql:mysql "$DATADIR"
systemctl start mariadb

sleep 5

if systemctl is-active --quiet mariadb; then
    echo "âœ… Restore from incremental chain completed"
else
    echo "âŒ MariaDB failed to start"
    exit 1
fi
```

---

## Gestion des erreurs courantes

### Erreur 1 : Espace disque insuffisant

**SymptÃ´me** :

```
ERROR: No space left on device
```

**Solution** :

```bash
# Avant restauration, vÃ©rifier l'espace disponible
REQUIRED_GB=200  # Ajuster selon taille backup
AVAILABLE=$(df -BG /var/lib/mysql | tail -1 | awk '{print $4}' | sed 's/G//')

if [ "$AVAILABLE" -lt "$REQUIRED_GB" ]; then
    echo "âŒ Insufficient space: ${AVAILABLE}GB < ${REQUIRED_GB}GB"
    
    # Options :
    # 1. Nettoyer logs anciens
    find /var/log -name "*.log" -mtime +30 -delete
    
    # 2. Purger anciens backups
    find /backups -name "backup_*" -mtime +60 -delete
    
    # 3. Utiliser un volume externe
    DATADIR="/mnt/external/mysql"
fi
```

---

### Erreur 2 : Permissions incorrectes

**SymptÃ´me** :

```
[ERROR] InnoDB: Operating system error number 13 in a file operation.
[ERROR] InnoDB: The error means mysqld does not have the access rights to the directory.
```

**Solution** :

```bash
# Corriger rÃ©cursivement les permissions
chown -R mysql:mysql /var/lib/mysql
chmod 750 /var/lib/mysql
chmod 660 /var/lib/mysql/ibdata*
chmod 660 /var/lib/mysql/ib_logfile*

# VÃ©rifier SELinux (si activÃ©)
restorecon -R /var/lib/mysql
```

---

### Erreur 3 : InnoDB refuse de dÃ©marrer (corruption)

**SymptÃ´me** :

```
[ERROR] InnoDB: Corrupted page [page id: space=0, page number=XXX]
[ERROR] InnoDB: Database page corruption on disk or a failed file read
```

**Solution** :

```bash
# Mode recovery InnoDB
# /etc/my.cnf.d/server.cnf

[mysqld]
innodb_force_recovery = 1  # Commencer par 1, monter jusqu'Ã  6 si nÃ©cessaire

# Niveaux :
# 1 = SRV_FORCE_IGNORE_CORRUPT
# 2 = SRV_FORCE_NO_BACKGROUND
# 3 = SRV_FORCE_NO_TRX_UNDO
# 4 = SRV_FORCE_NO_IBUF_MERGE
# 5 = SRV_FORCE_NO_UNDO_LOG_SCAN
# 6 = SRV_FORCE_NO_LOG_REDO
```

```bash
# RedÃ©marrer MariaDB
systemctl restart mariadb

# Si dÃ©marrage OK, exporter les donnÃ©es
mysqldump --all-databases > emergency_dump.sql

# RecrÃ©er depuis le backup sain
```

---

### Erreur 4 : Charset/collation mismatch

**SymptÃ´me** :

```
ERROR 1273 (HY000): Unknown collation: 'utf8mb4_0900_ai_ci'
```

**Solution** :

```bash
# Convertir le dump avant import
sed -i 's/utf8mb4_0900_ai_ci/utf8mb4_unicode_ci/g' backup.sql

# Ou forcer le charset Ã  la restauration
mariadb --default-character-set=utf8mb4 database < backup.sql
```

---

### Erreur 5 : Max packet size dÃ©passÃ©

**SymptÃ´me** :

```
ERROR 2006 (HY000): MySQL server has gone away
ERROR 1153 (08S01): Got a packet bigger than 'max_allowed_packet' bytes
```

**Solution** :

```bash
# Augmenter max_allowed_packet temporairement
mariadb --max-allowed-packet=1G database < backup.sql

# Ou dans my.cnf
[mysqld]
max_allowed_packet=1G

[mysql]
max_allowed_packet=1G
```

---

## Validation post-restauration

### Checklist de validation complÃ¨te

```bash
#!/bin/bash
# validate_restore.sh
# Validation complÃ¨te aprÃ¨s restauration

DATABASE="production_db"
VALIDATION_REPORT="/var/log/restore_validation_$(date +%Y%m%d_%H%M%S).log"

exec > >(tee -a "$VALIDATION_REPORT") 2>&1

echo "âœ… POST-RESTORE VALIDATION"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "Timestamp: $(date -Iseconds)"
echo ""

# Test 1 : Connexion MariaDB
echo "ğŸ“ Test 1: MariaDB Connection"
if mariadb -e "SELECT VERSION();" &>/dev/null; then
    VERSION=$(mariadb -N -e "SELECT VERSION();")
    echo "âœ… PASS - Version: $VERSION"
else
    echo "âŒ FAIL - Cannot connect to MariaDB"
    exit 1
fi

# Test 2 : Bases de donnÃ©es prÃ©sentes
echo ""
echo "ğŸ“ Test 2: Database Presence"
DB_COUNT=$(mariadb -N -e "SELECT COUNT(*) FROM information_schema.schemata WHERE schema_name='$DATABASE';")
if [ "$DB_COUNT" -eq 1 ]; then
    echo "âœ… PASS - Database '$DATABASE' exists"
else
    echo "âŒ FAIL - Database '$DATABASE' not found"
    exit 1
fi

# Test 3 : Nombre de tables
echo ""
echo "ğŸ“ Test 3: Table Count"
TABLE_COUNT=$(mariadb -N -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='$DATABASE';")
echo "  Tables found: $TABLE_COUNT"

if [ "$TABLE_COUNT" -eq 0 ]; then
    echo "âŒ FAIL - No tables found"
    exit 1
else
    echo "âœ… PASS"
fi

# Test 4 : Tables critiques non vides
echo ""
echo "ğŸ“ Test 4: Critical Tables Data"
CRITICAL_TABLES=("users" "orders" "products")

for table in "${CRITICAL_TABLES[@]}"; do
    COUNT=$(mariadb -N -e "SELECT COUNT(*) FROM $DATABASE.$table;" 2>/dev/null || echo "ERROR")
    
    if [ "$COUNT" = "ERROR" ]; then
        echo "  âš ï¸  WARNING - Table $table not found"
    elif [ "$COUNT" -eq 0 ]; then
        echo "  âš ï¸  WARNING - Table $table is empty"
    else
        echo "  âœ… $table: $COUNT rows"
    fi
done

# Test 5 : IntÃ©gritÃ© rÃ©fÃ©rentielle
echo ""
echo "ğŸ“ Test 5: Foreign Key Constraints"
FK_ERRORS=$(mariadb -N -e "
    SELECT COUNT(*) 
    FROM information_schema.table_constraints 
    WHERE constraint_schema='$DATABASE' 
    AND constraint_type='FOREIGN KEY'
    AND constraint_name NOT IN (
        SELECT constraint_name 
        FROM information_schema.referential_constraints
        WHERE constraint_schema='$DATABASE'
    );
")

if [ "$FK_ERRORS" -eq 0 ]; then
    echo "âœ… PASS - All foreign keys valid"
else
    echo "âš ï¸  WARNING - $FK_ERRORS foreign key issues detected"
fi

# Test 6 : Index prÃ©sents
echo ""
echo "ğŸ“ Test 6: Indexes"
INDEX_COUNT=$(mariadb -N -e "
    SELECT COUNT(*) 
    FROM information_schema.statistics 
    WHERE table_schema='$DATABASE';
")
echo "  Indexes found: $INDEX_COUNT"
echo "âœ… PASS"

# Test 7 : ProcÃ©dures stockÃ©es et triggers
echo ""
echo "ğŸ“ Test 7: Stored Objects"
PROC_COUNT=$(mariadb -N -e "SELECT COUNT(*) FROM information_schema.routines WHERE routine_schema='$DATABASE' AND routine_type='PROCEDURE';")
FUNC_COUNT=$(mariadb -N -e "SELECT COUNT(*) FROM information_schema.routines WHERE routine_schema='$DATABASE' AND routine_type='FUNCTION';")
TRIG_COUNT=$(mariadb -N -e "SELECT COUNT(*) FROM information_schema.triggers WHERE trigger_schema='$DATABASE';")

echo "  - Procedures: $PROC_COUNT"
echo "  - Functions: $FUNC_COUNT"
echo "  - Triggers: $TRIG_COUNT"
echo "âœ… PASS"

# Test 8 : Erreurs InnoDB
echo ""
echo "ğŸ“ Test 8: InnoDB Status"
LOCK_WAITS=$(mariadb -N -e "SELECT COUNT(*) FROM information_schema.innodb_trx WHERE trx_state='LOCK WAIT';")
if [ "$LOCK_WAITS" -eq 0 ]; then
    echo "âœ… PASS - No InnoDB lock waits"
else
    echo "âš ï¸  WARNING - $LOCK_WAITS transactions in LOCK WAIT"
fi

# Test 9 : Tailles des tables (comparaison si rÃ©fÃ©rence disponible)
echo ""
echo "ğŸ“ Test 9: Table Sizes"
mariadb -e "
    SELECT 
        table_name,
        ROUND((data_length + index_length) / 1024 / 1024, 2) AS size_mb,
        table_rows
    FROM information_schema.tables
    WHERE table_schema = '$DATABASE'
    ORDER BY (data_length + index_length) DESC
    LIMIT 10;
"

# Test 10 : Smoke test applicatif (exemple)
echo ""
echo "ğŸ“ Test 10: Application Smoke Test"
# Exemple : requÃªte applicative critique
USER_LOGIN=$(mariadb -N -e "SELECT COUNT(*) FROM $DATABASE.users WHERE status='active';" 2>/dev/null || echo "0")
if [ "$USER_LOGIN" -gt 0 ]; then
    echo "âœ… PASS - Active users found: $USER_LOGIN"
else
    echo "âš ï¸  WARNING - No active users found"
fi

# RÃ©sumÃ©
echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "âœ… VALIDATION COMPLETED"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""
echo "ğŸ“„ Full report: $VALIDATION_REPORT"
```

---

## Restauration cloud-native

### Restauration sur AWS RDS / Aurora (import)

```bash
#!/bin/bash
# restore_to_rds.sh
# Import vers RDS depuis S3

S3_BACKUP="s3://my-backups/mariadb/full_20251213.sql.gz"
RDS_ENDPOINT="mydb.xxxx.rds.amazonaws.com"
DATABASE="production_db"

echo "â˜ï¸  Restoring to AWS RDS..."

# TÃ©lÃ©charger depuis S3
aws s3 cp "$S3_BACKUP" - | \
  gunzip | \
  mariadb -h "$RDS_ENDPOINT" -u admin -p "$DATABASE"

if [ $? -eq 0 ]; then
    echo "âœ… Restore to RDS completed"
fi
```

---

### Restauration Kubernetes (StatefulSet)

```yaml
# restore-job.yaml
# Job Kubernetes pour restauration
apiVersion: batch/v1
kind: Job
metadata:
  name: mariadb-restore-20251213
  namespace: databases
spec:
  template:
    spec:
      restartPolicy: OnFailure
      initContainers:
      # 1. TÃ©lÃ©charger le backup depuis S3
      - name: download-backup
        image: amazon/aws-cli:latest
        command:
        - sh
        - -c
        - |
          aws s3 cp s3://my-backups/mariadb/full_20251213.tar.gz /backup/
          cd /backup && tar xzf full_20251213.tar.gz
        volumeMounts:
        - name: backup-download
          mountPath: /backup
      
      containers:
      # 2. Restaurer avec Mariabackup
      - name: mariabackup-restore
        image: mariadb:11.8
        command:
        - sh
        - -c
        - |
          # PrÃ©parer le backup
          mariabackup --prepare --target-dir=/backup/full_20251213
          
          # Copier vers le PVC MariaDB
          rm -rf /var/lib/mysql/*
          mariabackup --copy-back --target-dir=/backup/full_20251213 --datadir=/var/lib/mysql
          
          # Corriger permissions
          chown -R mysql:mysql /var/lib/mysql
          
          echo "âœ… Restore completed"
        volumeMounts:
        - name: backup-download
          mountPath: /backup
        - name: mariadb-data
          mountPath: /var/lib/mysql
      
      volumes:
      - name: backup-download
        emptyDir: {}
      - name: mariadb-data
        persistentVolumeClaim:
          claimName: mariadb-data-pvc
```

```bash
# Appliquer le job de restauration
kubectl apply -f restore-job.yaml

# Suivre les logs
kubectl logs -f job/mariadb-restore-20251213 -n databases

# AprÃ¨s restauration rÃ©ussie, redÃ©marrer MariaDB
kubectl rollout restart statefulset/mariadb -n databases
```

---

## Optimisation du RTO (Recovery Time Objective)

### Mesure du RTO

```bash
#!/bin/bash
# measure_rto.sh
# Mesurer le RTO d'une restauration complÃ¨te

BACKUP_FILE="/backups/test_backup.sql.gz"
DATABASE="test_restore"

echo "â±ï¸  Measuring RTO..."

# CrÃ©er base de test
mariadb -e "DROP DATABASE IF EXISTS $DATABASE; CREATE DATABASE $DATABASE;"

# Mesurer le temps
START=$(date +%s)

zcat "$BACKUP_FILE" | mariadb "$DATABASE"

END=$(date +%s)
RTO=$((END - START))

echo "ğŸ“Š RTO Results:"
echo "  - Total time: ${RTO}s ($(($RTO / 60))min)"
echo "  - Backup size: $(du -h $BACKUP_FILE | cut -f1)"

# Nettoyage
mariadb -e "DROP DATABASE $DATABASE;"
```

---

### StratÃ©gies d'optimisation RTO

| StratÃ©gie | Gain RTO | ComplexitÃ© | Recommandation |
|-----------|----------|------------|----------------|
| SSD/NVMe pour datadir | 50-70% | Faible | âœ… Prioritaire |
| Restauration parallÃ¨le (myloader) | 60-80% | Moyenne | âœ… RecommandÃ© |
| Backup prÃ©parÃ© en avance | 30-40% | Moyenne | âœ… Production |
| Serveur DR warm standby | 90-95% | Ã‰levÃ©e | ğŸ’° CoÃ»teux |
| --innodb-optimize-keys | 20-30% | Faible | âœ… Toujours |
| DÃ©sactiver FK checks temporairement | 15-25% | Faible | âš ï¸ Avec prudence |

---

### Script d'optimisation RTO maximal

```bash
#!/bin/bash
# ultra_fast_restore.sh
# Restauration optimisÃ©e pour RTO minimal

set -euo pipefail

BACKUP_DIR="/backups/prepared"  # Backup DÃ‰JÃ€ prÃ©parÃ©
DATADIR="/var/lib/mysql"

echo "âš¡ ULTRA-FAST RESTORE (RTO optimized)"

# Phase 1 : ArrÃªt rapide (kill si besoin)
timeout 10 systemctl stop mariadb || killall -9 mysqld || true

# Phase 2 : Nettoyage parallÃ¨le (si gros datadir)
rm -rf "$DATADIR" &
CLEANUP_PID=$!

# Phase 3 : PrÃ©paration rÃ©pertoire pendant nettoyage
mkdir -p "$DATADIR"

# Attendre fin nettoyage
wait $CLEANUP_PID

# Phase 4 : Copie optimisÃ©e
rsync -aP --no-compress "$BACKUP_DIR/" "$DATADIR/"

# Phase 5 : Permissions
chown -R mysql:mysql "$DATADIR"

# Phase 6 : DÃ©marrage avec skip-grant-tables (temporaire)
systemctl start mariadb

# Phase 7 : Flush privileges
mariadb -e "FLUSH PRIVILEGES;"

echo "âœ… Ultra-fast restore completed"
```

---

## âœ… Points clÃ©s Ã  retenir

- **Restauration complÃ¨te** = Reconstruction base depuis backup vers Ã©tat cohÃ©rent
- **3 types de restauration** : Logique (mysqldump), ParallÃ¨le (myloader), Physique (Mariabackup)
- **RTO typique** : 15 min (Mariabackup SSD) Ã  6h (mysqldump HDD grande base)
- **Validation obligatoire** : 10 tests post-restauration (connexion, tables, FK, smoke test)
- **Erreurs courantes** : Espace disque, permissions, charset, max_packet, InnoDB recovery
- **Optimisation RTO** : SSD, parallÃ©lisme, backup prÃ©parÃ©, --innodb-optimize-keys
- **Cloud-native** : Jobs Kubernetes, import S3, restauration vers RDS
- **Mariabackup** : Toujours `--prepare` avant `--copy-back`
- **SÃ©curitÃ©** : Toujours sauvegarder ancien datadir avant Ã©crasement
- **Automatisation** : Scripts robustes avec gestion erreurs et logs dÃ©taillÃ©s

---

## ğŸ”— Ressources et rÃ©fÃ©rences

- ğŸ“– [Mariabackup Restore Documentation](https://mariadb.com/kb/en/full-backup-and-restore-with-mariabackup/)
- ğŸ“– [mysqldump Restore](https://mariadb.com/kb/en/mysqldump/)
- ğŸ“– [InnoDB Recovery Modes](https://mariadb.com/kb/en/innodb-recovery-modes/)
- ğŸ“– [Restoring Data with myloader](https://github.com/mydumper/mydumper/wiki)
- ğŸ› ï¸ [Disaster Recovery Best Practices](https://mariadb.com/kb/en/backup-and-restore-overview/)
- ğŸ“Š [RTO Optimization Strategies](https://mariadb.com/resources/blog/mariadb-recovery-time/)

---

## â¡ï¸ Section suivante

**12.5.2 Point-in-Time Recovery (PITR)** : Restauration prÃ©cise Ã  un moment donnÃ© avec binary logs, pour rÃ©cupÃ©ration aprÃ¨s erreur humaine ou corruption spÃ©cifique (RPO < 1 minute).

â­ï¸ [Point-in-time recovery (PITR)](/12-sauvegarde-restauration/05.2-pitr.md)
