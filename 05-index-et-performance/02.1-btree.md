üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.2.1 B-Tree : Le standard

> **Niveau** : Interm√©diaire
> **Dur√©e estim√©e** : 2 heures

> **Pr√©requis** :
> - Section 5.1 - Fonctionnement des index B-Tree
> - Section 5.2 - Types d'index (vue d'ensemble)
> - Compr√©hension des requ√™tes SQL et des jointures

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Distinguer les index clustered (cl√© primaire) des index secondaires dans InnoDB
- Comprendre pourquoi le B-Tree est le type d'index par d√©faut et le plus utilis√©
- Ma√Ætriser les diff√©rents sc√©narios o√π le B-Tree excelle
- Optimiser l'utilisation des index B-Tree pour diff√©rents patterns de requ√™tes
- Identifier les limitations du B-Tree et les contournements possibles
- Choisir entre un index simple et un index composite selon le contexte

---

## Introduction

Le **B-Tree** (Balanced Tree) est le type d'index **par d√©faut** dans MariaDB et repr√©sente environ **95% de tous les index** cr√©√©s en production. Sa polyvalence en fait le choix standard pour la quasi-totalit√© des cas d'usage courants.

### Pourquoi B-Tree est le standard ?

```sql
-- Cr√©ation implicite : B-Tree par d√©faut
CREATE INDEX idx_customer ON orders(customer_id);

-- √âquivalent explicite
CREATE INDEX idx_customer ON orders(customer_id) USING BTREE;
```

**Raisons de sa dominance** :

1. **Polyvalence** : Supporte √©galit√©, plages, comparaisons, tri
2. **Performance pr√©visible** : O(log n) constant
3. **Bien document√©** : D√©cennies de pratiques √©prouv√©es
4. **Optimis√©** : InnoDB est hautement optimis√© pour B-Tree
5. **Compatible** : Fonctionne avec tous les moteurs de stockage

üí° **R√®gle d'or** : En cas de doute sur le type d'index √† utiliser, choisissez B-Tree. C'est rarement le mauvais choix.

---

## Clustered Index vs Secondary Index

### Concept fondamental d'InnoDB

InnoDB organise **toutes les donn√©es** autour d'un index sp√©cial appel√© **clustered index** (index cluster). C'est une distinction cruciale pour comprendre les performances.

```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY,          -- Clustered index
    email VARCHAR(255),
    name VARCHAR(100),
    created_at DATETIME,
    INDEX idx_email (email)           -- Secondary index
);
```

### Clustered Index (Index de clustering)

Le **clustered index** est l'index sur la **cl√© primaire**. Les donn√©es de la table sont **physiquement organis√©es** selon cet index.

```
Structure du Clustered Index (PRIMARY KEY) :

Index B-Tree sur user_id :
         [1000|2000|3000]
        /      |       \
   [100-999] [1000-1999] [2000-2999]
       |         |            |
    Feuilles = DONN√âES COMPL√àTES de la table
    [100: john@..., "John", 2024-01-01]
    [101: jane@..., "Jane", 2024-01-02]
    [102: bob@..., "Bob", 2024-01-03]
```

**Caract√©ristiques** :

- ‚úÖ Une seule instance par table (la PRIMARY KEY)
- ‚úÖ Contient TOUTES les colonnes de la table
- ‚úÖ Acc√®s direct aux donn√©es (pas de lookup suppl√©mentaire)
- ‚úÖ Tr√®s efficace pour recherches par cl√© primaire
- ‚úÖ Optimal pour range scans sur la cl√© primaire

```sql
-- Utilise directement le clustered index
SELECT * FROM users WHERE user_id = 1234;
-- Temps : 0.001 seconde (1 seul lookup)

-- Range scan tr√®s efficace
SELECT * FROM users
WHERE user_id BETWEEN 1000 AND 2000
ORDER BY user_id;
-- Les donn√©es sont d√©j√† tri√©es physiquement !
```

‚ö†Ô∏è **Important** : Si aucune PRIMARY KEY n'est d√©finie, InnoDB :
1. Utilise le premier UNIQUE NOT NULL index
2. Sinon, cr√©e un **clustered index cach√©** (6 bytes par ligne)

### Secondary Index (Index secondaire)

Un **secondary index** est cr√©√© sur n'importe quelle colonne autre que la cl√© primaire.

```
Structure d'un Secondary Index (email) :

Index B-Tree sur email :
         ["m@.."|"p@.."|"z@.."]
        /         |          \
   ["a@..."-     ["m@..."-    ["p@..."-
    "l@..."]      "o@..."]     "z@..."]
       |             |             |
    Feuilles = email + PRIMARY KEY (pointeur)
    ["alice@...": 105]  ‚Üê Contient la cl√© primaire !
    ["bob@...": 102]
    ["carol@...": 208]

Pour r√©cup√©rer les donn√©es compl√®tes :
1. Trouver dans index secondaire : "bob@..." ‚Üí PK = 102
2. Lookup dans clustered index : PK 102 ‚Üí Donn√©es compl√®tes
```

**Caract√©ristiques** :

- ‚úÖ Plusieurs par table possible
- ‚úÖ Contient uniquement : colonnes index√©es + PRIMARY KEY
- ‚ùå N√©cessite un **second lookup** pour r√©cup√©rer les autres colonnes
- ‚ùå Plus co√ªteux qu'un clustered index

```sql
-- Utilise l'index secondaire idx_email
SELECT * FROM users WHERE email = 'bob@example.com';

-- √âtapes :
-- 1. Recherche dans idx_email : "bob@example.com" ‚Üí user_id = 102
-- 2. Recherche dans PRIMARY KEY : user_id = 102 ‚Üí Toutes les colonnes
-- Temps : 0.002 seconde (2 lookups)
```

### Comparaison Clustered vs Secondary

| Aspect | Clustered Index | Secondary Index |
|--------|-----------------|-----------------|
| **Nombre** | 1 seul (PRIMARY KEY) | Plusieurs possibles |
| **Contenu feuilles** | Toutes les colonnes | Colonnes index√©es + PK |
| **Lookups** | 1 seul | 2 (index + clustered) |
| **Taille** | Plus grand | Plus compact |
| **Performance SELECT** | Meilleure | Bonne |
| **Performance INSERT** | Impact sur ordre physique | Plus rapide |
| **Ordre physique** | Donn√©es tri√©es par PK | N/A |

### Covering Index : √âviter le second lookup

Un **covering index** est un secondary index qui contient **toutes** les colonnes n√©cessaires √† une requ√™te.

```sql
-- Requ√™te qui r√©cup√®re seulement user_id et email
SELECT user_id, email FROM users WHERE email = 'bob@example.com';

-- Avec index : INDEX idx_email (email)
-- Le secondary index contient d√©j√† : email + user_id (PK)
-- ‚Üí Pas besoin de second lookup !
-- ‚Üí "Index-only scan" tr√®s rapide

-- EXPLAIN montre : "Using index" (covering index)
EXPLAIN SELECT user_id, email FROM users WHERE email = 'bob@example.com';
```

**Cr√©er explicitement un covering index** :

```sql
-- Requ√™te fr√©quente
SELECT user_id, email, created_at
FROM users
WHERE email = 'bob@example.com';

-- Index couvrant toutes les colonnes n√©cessaires
CREATE INDEX idx_email_covering ON users(email, created_at);

-- Maintenant : 1 seul lookup au lieu de 2 !
```

üí° **Best practice** : Pour les requ√™tes critiques fr√©quentes, envisagez un covering index pour √©liminer le second lookup.

---

## Cas d'usage optimaux du B-Tree

### 1. Recherche par √©galit√©

Le B-Tree excelle pour les recherches exactes :

```sql
-- Lookup par cl√© primaire (optimal)
SELECT * FROM orders WHERE order_id = 12345;
-- Complexit√© : O(log n)
-- I/O : 3-4 lectures pour des millions de lignes

-- Lookup par index secondaire
SELECT * FROM users WHERE email = 'user@example.com';
-- Complexit√© : O(log n) + 1 lookup clustered
-- I/O : 4-5 lectures

-- Multiple √©galit√©s (index composite)
CREATE INDEX idx_status_priority ON tickets(status, priority);
SELECT * FROM tickets WHERE status = 'open' AND priority = 'high';
-- Utilise l'index composite efficacement
```

### 2. Recherche par plage (Range Scans)

Le B-Tree est **excellent** pour les plages gr√¢ce √† la structure tri√©e :

```sql
-- Plage de dates
SELECT * FROM orders
WHERE order_date BETWEEN '2025-01-01' AND '2025-01-31';

-- Plage de valeurs num√©riques
SELECT * FROM products
WHERE price >= 10.00 AND price <= 50.00;

-- Avec ORDER BY automatiquement optimis√©
SELECT * FROM logs
WHERE created_at > '2025-01-01'
ORDER BY created_at;
-- Pas de tri n√©cessaire : les donn√©es sont d√©j√† tri√©es dans l'index !
```

**Exemple de performance** :

```sql
-- Table : 10 millions de commandes
-- Sans index sur order_date
SELECT * FROM orders WHERE order_date > '2025-01-01';
-- Temps : 8.5 secondes (full scan)

-- Avec index B-Tree sur order_date
CREATE INDEX idx_order_date ON orders(order_date);
SELECT * FROM orders WHERE order_date > '2025-01-01';
-- Temps : 0.23 secondes (range scan)
-- Am√©lioration : 37x plus rapide
```

### 3. Comparaisons (>, <, >=, <=)

```sql
-- Plus grand que
SELECT * FROM products WHERE price > 100;

-- Plus petit que
SELECT * FROM users WHERE age < 18;

-- Combinaison
SELECT * FROM employees
WHERE salary >= 50000 AND salary <= 100000;
```

### 4. Recherche par pr√©fixe

Le B-Tree supporte les recherches par **pr√©fixe** avec LIKE :

```sql
-- ‚úÖ Utilise l'index (pr√©fixe √† gauche)
SELECT * FROM users WHERE last_name LIKE 'Smith%';
SELECT * FROM products WHERE sku LIKE 'PROD-2025%';

-- ‚ùå N'utilise PAS l'index (wildcard au d√©but)
SELECT * FROM users WHERE email LIKE '%@example.com';
-- Solution : Index Full-Text ou recherche invers√©e

-- Astuce pour recherche de suffixe
ALTER TABLE users ADD COLUMN email_reversed VARCHAR(255);
UPDATE users SET email_reversed = REVERSE(email);
CREATE INDEX idx_email_rev ON users(email_reversed);

SELECT * FROM users WHERE email_reversed LIKE REVERSE('%@example.com') + '%';
```

### 5. Optimisation ORDER BY

Le B-Tree maintient l'ordre, √©vitant un tri co√ªteux :

```sql
-- Sans index : n√©cessite tri (filesort)
SELECT * FROM orders ORDER BY order_date DESC LIMIT 10;
-- Temps : 2.3 secondes (full scan + sort)

-- Avec index : donn√©es d√©j√† tri√©es
CREATE INDEX idx_order_date ON orders(order_date);
SELECT * FROM orders ORDER BY order_date DESC LIMIT 10;
-- Temps : 0.003 secondes (lecture directe des 10 derni√®res entr√©es)

-- EXPLAIN montre : "Using index" (pas de filesort)
```

**Index descendant pour ORDER BY DESC** :

```sql
-- Optimisation pour tri d√©croissant fr√©quent
CREATE INDEX idx_order_date_desc ON orders(order_date DESC);

-- Maintenant optimal pour :
SELECT * FROM orders ORDER BY order_date DESC LIMIT 100;
```

### 6. Optimisation GROUP BY

```sql
-- GROUP BY sur colonne index√©e
SELECT category_id, COUNT(*)
FROM products
GROUP BY category_id;

-- Avec index sur category_id : tr√®s efficace
CREATE INDEX idx_category ON products(category_id);

-- Le groupement utilise l'index tri√©
-- Pas de tri temporaire n√©cessaire
```

### 7. Jointures optimis√©es

```sql
-- Jointure sur cl√© √©trang√®re
SELECT o.*, c.name
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE o.status = 'pending';

-- Index recommand√©s :
CREATE INDEX idx_customer ON orders(customer_id);  -- Pour JOIN
CREATE INDEX idx_status ON orders(status);         -- Pour WHERE

-- La jointure utilise les index B-Tree pour un acc√®s rapide
```

---

## Index composites : La puissance du B-Tree

### Principe des index composites

Un **index composite** (ou multi-colonnes) indexe plusieurs colonnes ensemble :

```sql
-- Index composite sur 3 colonnes
CREATE INDEX idx_composite ON orders(customer_id, status, order_date);
```

### R√®gle du "leftmost prefix"

Un index composite peut √™tre utilis√© par des requ√™tes qui filtrent sur :
- La premi√®re colonne seule
- Les deux premi√®res colonnes
- Les trois colonnes
- Mais PAS sur la 2√®me ou 3√®me colonne seule

```sql
CREATE INDEX idx_abc ON table(a, b, c);

-- ‚úÖ Utilise l'index
WHERE a = ?
WHERE a = ? AND b = ?
WHERE a = ? AND b = ? AND c = ?
WHERE a = ? AND c = ?  -- Utilise partiellement (seulement a)

-- ‚ùå N'utilise PAS l'index
WHERE b = ?
WHERE c = ?
WHERE b = ? AND c = ?
```

**Exemple concret** :

```sql
CREATE INDEX idx_composite ON orders(customer_id, status, order_date);

-- ‚úÖ Excellent : utilise tout l'index
SELECT * FROM orders
WHERE customer_id = 123
AND status = 'pending'
AND order_date > '2025-01-01';

-- ‚úÖ Bon : utilise customer_id et status
SELECT * FROM orders
WHERE customer_id = 123
AND status = 'pending';

-- ‚úÖ Acceptable : utilise customer_id uniquement
SELECT * FROM orders
WHERE customer_id = 123;

-- ‚ùå Mauvais : n'utilise pas l'index (manque customer_id)
SELECT * FROM orders
WHERE status = 'pending';
```

### Ordre des colonnes : La r√®gle d'or

**Placez les colonnes dans l'ordre d√©croissant de s√©lectivit√© et fr√©quence d'usage** :

```sql
-- ‚ùå Ordre sous-optimal
CREATE INDEX idx_bad ON orders(status, customer_id, order_date);
-- status : 3-5 valeurs (faible s√©lectivit√©)
-- customer_id : millions de valeurs (haute s√©lectivit√©)

-- ‚úÖ Ordre optimal
CREATE INDEX idx_good ON orders(customer_id, status, order_date);
-- customer_id d'abord : filtre le plus de donn√©es
-- status ensuite : affine le r√©sultat
-- order_date : permet le tri sans filesort
```

**Formule de s√©lectivit√©** :

```sql
-- Calculer la s√©lectivit√© d'une colonne
SELECT
    COUNT(DISTINCT customer_id) / COUNT(*) AS selectivity_customer,
    COUNT(DISTINCT status) / COUNT(*) AS selectivity_status
FROM orders;

-- R√©sultat :
-- selectivity_customer : 0.85 (excellent)
-- selectivity_status : 0.0003 (tr√®s faible)

-- ‚Üí customer_id doit √™tre plac√© AVANT status
```

### Cas d'usage avanc√©s d'index composites

**1. Index couvrant avec ordre optimis√©**

```sql
-- Requ√™te fr√©quente (tableau de bord)
SELECT customer_id, status, order_date, total
FROM orders
WHERE customer_id = ?
AND status IN ('pending', 'processing')
ORDER BY order_date DESC
LIMIT 20;

-- Index couvrant optimal
CREATE INDEX idx_dashboard
ON orders(customer_id, status, order_date DESC, total);

-- Avantages :
-- ‚úÖ Filtre sur customer_id (haute s√©lectivit√©)
-- ‚úÖ Filtre sur status
-- ‚úÖ Tri gratuit sur order_date DESC
-- ‚úÖ Covering : contient total (pas de second lookup)
```

**2. Index pour requ√™te avec OR**

```sql
-- Requ√™te avec OR
SELECT * FROM products
WHERE category_id = 5 OR brand_id = 10;

-- Solution 1 : Deux index s√©par√©s (index merge)
CREATE INDEX idx_category ON products(category_id);
CREATE INDEX idx_brand ON products(brand_id);
-- MariaDB peut fusionner les deux index

-- Solution 2 : R√©√©crire avec UNION
SELECT * FROM products WHERE category_id = 5
UNION
SELECT * FROM products WHERE brand_id = 10;
```

---

## Limitations et contournements

### Limitation 1 : LIKE avec wildcard au d√©but

```sql
-- ‚ùå Index non utilis√©
SELECT * FROM users WHERE email LIKE '%@gmail.com';

-- ‚úÖ Contournement 1 : Full-Text index
ALTER TABLE users ADD FULLTEXT INDEX idx_email_ft (email);
SELECT * FROM users WHERE MATCH(email) AGAINST('gmail.com');

-- ‚úÖ Contournement 2 : Colonne invers√©e
ALTER TABLE users ADD COLUMN email_reversed VARCHAR(255);
UPDATE users SET email_reversed = REVERSE(email);
CREATE INDEX idx_email_rev ON users(email_reversed);
SELECT * FROM users WHERE email_reversed LIKE CONCAT(REVERSE('@gmail.com'), '%');
```

### Limitation 2 : Fonctions sur colonnes index√©es

```sql
-- ‚ùå Index non utilis√© (fonction sur colonne)
SELECT * FROM orders WHERE YEAR(order_date) = 2025;

-- ‚úÖ Contournement 1 : R√©√©crire sans fonction
SELECT * FROM orders
WHERE order_date >= '2025-01-01'
AND order_date < '2026-01-01';

-- ‚úÖ Contournement 2 : Colonne g√©n√©r√©e
ALTER TABLE orders
ADD COLUMN order_year INT AS (YEAR(order_date)) STORED,
ADD INDEX idx_order_year (order_year);

SELECT * FROM orders WHERE order_year = 2025;
```

### Limitation 3 : In√©galit√© (!=, <>)

```sql
-- ‚ùå Index peu efficace
SELECT * FROM users WHERE status != 'deleted';

-- ‚úÖ Contournement : R√©√©crire positivement
SELECT * FROM users WHERE status IN ('active', 'pending', 'suspended');

-- Ou cr√©er un index partiel (si beaucoup de 'deleted')
CREATE INDEX idx_active ON users(status) WHERE status != 'deleted';
```

### Limitation 4 : OR avec diff√©rentes colonnes

```sql
-- ‚ùå Index difficilement utilisable
SELECT * FROM products
WHERE name = 'Widget' OR description = 'Widget';

-- ‚úÖ Contournement : UNION
SELECT * FROM products WHERE name = 'Widget'
UNION
SELECT * FROM products WHERE description = 'Widget';

-- ‚úÖ Ou Full-Text sur les deux colonnes
ALTER TABLE products ADD FULLTEXT INDEX idx_search (name, description);
SELECT * FROM products WHERE MATCH(name, description) AGAINST('Widget');
```

---

## Optimisations avanc√©es

### 1. Index prefix pour longues cha√Ænes

Pour les colonnes VARCHAR/TEXT longues, indexer seulement un pr√©fixe :

```sql
-- ‚ùå Index complet sur longue cha√Æne (volumineux)
CREATE INDEX idx_url ON pages(url);  -- url VARCHAR(2000)

-- ‚úÖ Index sur pr√©fixe (plus compact)
CREATE INDEX idx_url_prefix ON pages(url(100));

-- Calcul de la longueur optimale de pr√©fixe
SELECT
    COUNT(DISTINCT url) AS total_distinct,
    COUNT(DISTINCT LEFT(url, 50)) AS distinct_50,
    COUNT(DISTINCT LEFT(url, 100)) AS distinct_100,
    COUNT(DISTINCT LEFT(url, 200)) AS distinct_200
FROM pages;

-- Choisir la longueur o√π distinct_N ‚âà total_distinct
```

**Trade-off** :
- ‚úÖ Index plus compact = moins d'I/O
- ‚ùå Peut n√©cessiter v√©rification suppl√©mentaire si collision

### 2. Index descendants pour tri inverse

```sql
-- Requ√™tes fr√©quentes avec ORDER BY DESC
SELECT * FROM posts ORDER BY created_at DESC LIMIT 20;

-- Index optimis√© pour tri descendant
CREATE INDEX idx_created_desc ON posts(created_at DESC);

-- MariaDB lit directement dans l'ordre descendant
-- Pas de backward scan
```

### 3. Index partiel / conditionnel

```sql
-- Indexer uniquement les lignes actives (90% de deleted)
CREATE INDEX idx_active_users ON users(email) WHERE status = 'active';

-- Index plus compact et plus rapide pour requ√™tes sur users actifs
SELECT * FROM users WHERE email = 'user@example.com' AND status = 'active';
```

‚ö†Ô∏è **Note** : Les index conditionnels (WHERE) ne sont pas encore support√©s dans MariaDB (feature PostgreSQL), mais on peut simuler avec des colonnes g√©n√©r√©es.

### 4. Index invisibles pour tests

```sql
-- Cr√©er un index invisible pour tester l'impact
CREATE INDEX idx_test ON orders(customer_id) INVISIBLE;

-- Activer temporairement pour une session
SET optimizer_switch='use_invisible_indexes=on';

-- Tester les performances

-- Rendre visible si b√©n√©fique
ALTER TABLE orders ALTER INDEX idx_test VISIBLE;

-- Ou supprimer si pas d'am√©lioration
DROP INDEX idx_test ON orders;
```

---

## Monitoring et diagnostic

### Analyser l'utilisation des index

```sql
-- Index existants sur une table
SHOW INDEX FROM orders;

-- Statistiques d'utilisation (Performance Schema)
SELECT
    object_schema,
    object_name,
    index_name,
    count_star AS total_accesses,
    count_read AS read_operations,
    count_insert AS insert_operations
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema = 'mydb'
AND object_name = 'orders'
AND index_name IS NOT NULL
ORDER BY count_star DESC;
```

### Identifier les index dupliqu√©s ou redondants

```sql
-- Trouver les index dupliqu√©s/redondants
SELECT
    t1.TABLE_NAME,
    t1.INDEX_NAME AS index1,
    t2.INDEX_NAME AS index2,
    t1.COLUMN_NAME
FROM information_schema.STATISTICS t1
JOIN information_schema.STATISTICS t2
    ON t1.TABLE_SCHEMA = t2.TABLE_SCHEMA
    AND t1.TABLE_NAME = t2.TABLE_NAME
    AND t1.COLUMN_NAME = t2.COLUMN_NAME
    AND t1.SEQ_IN_INDEX = t2.SEQ_IN_INDEX
    AND t1.INDEX_NAME < t2.INDEX_NAME
WHERE t1.TABLE_SCHEMA = 'mydb'
ORDER BY t1.TABLE_NAME, t1.INDEX_NAME;
```

**Exemples de redondance** :

```sql
-- ‚ùå Index redondant
CREATE INDEX idx_a ON table(a);
CREATE INDEX idx_ab ON table(a, b);
-- idx_a est redondant : idx_ab peut servir pour WHERE a = ?

-- ‚ùå Index dupliqu√©
CREATE INDEX idx_email1 ON users(email);
CREATE INDEX idx_email2 ON users(email);
-- Totalement identiques !

-- ‚úÖ Garder seulement le plus complet
DROP INDEX idx_a ON table;      -- Supprimer le simple
DROP INDEX idx_email2 ON users; -- Supprimer le doublon
```

### Analyser la fragmentation

```sql
-- Fragmentation d'index
SELECT
    index_name,
    ROUND(stat_value * @@innodb_page_size / 1024 / 1024, 2) AS size_mb
FROM mysql.innodb_index_stats
WHERE database_name = 'mydb'
AND table_name = 'orders'
AND stat_name = 'size';

-- Si fragmentation √©lev√©e
OPTIMIZE TABLE orders;
```

---

## Cas pratiques et exemples

### Exemple 1 : E-commerce - Recherche produits

```sql
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    name VARCHAR(255),
    category_id INT,
    brand_id INT,
    price DECIMAL(10,2),
    stock INT,
    created_at DATETIME
);

-- Index pour recherche par cat√©gorie + tri par prix
CREATE INDEX idx_category_price ON products(category_id, price);

-- Requ√™te optimis√©e
SELECT * FROM products
WHERE category_id = 15
ORDER BY price ASC
LIMIT 20;
-- Utilise idx_category_price : filtre + tri sans filesort

-- Index pour recherche multi-crit√®res
CREATE INDEX idx_search ON products(category_id, brand_id, price);

SELECT * FROM products
WHERE category_id = 15
AND brand_id = 42
AND price BETWEEN 50 AND 200;
-- Utilise pleinement idx_search
```

### Exemple 2 : SaaS - Donn√©es multi-tenant

```sql
CREATE TABLE documents (
    id BIGINT PRIMARY KEY,
    tenant_id INT,
    user_id INT,
    title VARCHAR(255),
    status VARCHAR(20),
    created_at DATETIME
);

-- Index pour isolation tenant
CREATE INDEX idx_tenant_user ON documents(tenant_id, user_id, created_at DESC);

-- Requ√™te typique SaaS
SELECT * FROM documents
WHERE tenant_id = 123  -- Isolation tenant (obligatoire)
AND user_id = 456
ORDER BY created_at DESC
LIMIT 50;
-- Index optimal : filtre tenant + user, tri gratuit
```

### Exemple 3 : Logs - S√©ries temporelles

```sql
CREATE TABLE logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    timestamp DATETIME,
    level VARCHAR(10),
    message TEXT,
    INDEX idx_time_level (timestamp, level)
);

-- Requ√™tes fr√©quentes
SELECT * FROM logs
WHERE timestamp >= DATE_SUB(NOW(), INTERVAL 1 HOUR)
AND level = 'ERROR'
ORDER BY timestamp DESC;
-- idx_time_level optimal pour filtre + tri

-- Purge des vieux logs (efficace avec index)
DELETE FROM logs
WHERE timestamp < DATE_SUB(NOW(), INTERVAL 90 DAY)
LIMIT 10000;
-- L'index permet de trouver rapidement les vieilles entr√©es
```

### Exemple 4 : Social network - Timeline

```sql
CREATE TABLE posts (
    post_id BIGINT PRIMARY KEY,
    user_id INT,
    content TEXT,
    created_at DATETIME,
    INDEX idx_user_created ON posts(user_id, created_at DESC)
);

-- Timeline d'un utilisateur
SELECT * FROM posts
WHERE user_id = 789
ORDER BY created_at DESC
LIMIT 20;
-- Index couvre parfaitement ce pattern
```

---

## Comparaison avec les autres types d'index

| Crit√®re | B-Tree | Hash | Full-Text | Spatial | VECTOR |
|---------|--------|------|-----------|---------|--------|
| **√âgalit√©** | ‚úÖ Excellent | ‚úÖ Meilleur | ‚ùå | ‚ùå | ‚ùå |
| **Plages** | ‚úÖ Excellent | ‚ùå | ‚ùå | ‚ùå | ‚ùå |
| **Tri** | ‚úÖ Excellent | ‚ùå | ‚ùå | ‚ùå | ‚ùå |
| **Pr√©fixe** | ‚úÖ Bon | ‚ùå | ‚úÖ Excellent | ‚ùå | ‚ùå |
| **Polyvalence** | ‚úÖ Maximale | ‚ùå Limit√© | ‚ùå Sp√©cialis√© | ‚ùå Sp√©cialis√© | ‚ùå Sp√©cialis√© |
| **Cas d'usage** | 95% des besoins | Cache en RAM | Recherche texte | GIS | IA/ML |

üí° **Recommandation** : Utilisez B-Tree par d√©faut, et les autres types uniquement pour des cas sp√©cialis√©s o√π B-Tree ne suffit pas.

---

## ‚úÖ Points cl√©s √† retenir

- üå≤ **B-Tree = Standard** : Type d'index par d√©faut, utilis√© dans 95% des cas
- üîë **Clustered vs Secondary** : PRIMARY KEY = donn√©es physiques, autres index = pointeurs vers PK
- üìä **Complexit√© O(log n)** : Performance pr√©visible et excellente m√™me pour des milliards de lignes
- ‚úÖ **Polyvalent** : √âgalit√©, plages, comparaisons, tri, pr√©fixes, jointures
- üéØ **Index composites** : Suivre la r√®gle du "leftmost prefix" pour maximiser l'utilisation
- üìè **Ordre des colonnes** : S√©lectivit√© d√©croissante (plus s√©lectif d'abord)
- üí° **Covering index** : Inclure toutes les colonnes n√©cessaires pour √©viter le second lookup
- ‚ö†Ô∏è **Limitations** : Wildcard au d√©but, fonctions sur colonnes, in√©galit√©s
- üîß **Contournements** : Colonnes g√©n√©r√©es, r√©√©criture de requ√™tes, index prefix
- üìê **Index prefix** : Pour longues cha√Ænes, indexer seulement les premiers caract√®res
- üîÑ **Ordre DESC** : Utiliser pour optimiser ORDER BY DESC fr√©quents
- üßπ **√âviter redondance** : idx(a,b) rend idx(a) redondant

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB

- [üìñ InnoDB Indexes](https://mariadb.com/kb/en/innodb-indexes/)
- [üìñ CREATE INDEX](https://mariadb.com/kb/en/create-index/)
- [üìñ Clustered Index vs Secondary Index](https://mariadb.com/kb/en/innodb-primary-key/)
- [üìñ Composite Indexes](https://mariadb.com/kb/en/getting-the-best-out-of-mariadb-compound-indexes/)
- [üìñ Index Hints](https://mariadb.com/kb/en/index-hints-how-to-force-query-plans/)

### Ressources externes

- [Use The Index, Luke! - B-Tree](https://use-the-index-luke.com/sql/anatomy/the-tree)
- [High Performance MySQL - Chapter 5: Indexing](https://www.oreilly.com/library/view/high-performance-mysql/9781492080503/)
- [MariaDB Performance Blog](https://mariadb.org/category/performance/)

### Articles techniques

- [Understanding InnoDB Clustered Indexes](https://www.percona.com/blog/understanding-innodb-clustered-indexes/)
- [Composite Index Best Practices](https://use-the-index-luke.com/sql/where-clause/the-equals-operator/concatenated-keys)

---

## ‚û°Ô∏è Section suivante

**[5.2.2 Hash : √âgalit√© stricte](./02.2-hash.md)**

D√©couvrez l'index Hash, sp√©cialis√© pour les recherches par √©galit√© stricte avec complexit√© O(1). Apprenez quand l'utiliser avec le moteur MEMORY, ses limitations (pas de plages, pas de tri), et pourquoi il est rarement utilis√© avec InnoDB.

---


‚è≠Ô∏è [Hash : √âgalit√© stricte](/05-index-et-performance/02.2-hash.md)
