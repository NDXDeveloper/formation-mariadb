üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.5.3 Index pour ORDER BY et GROUP BY

> **Niveau** : Interm√©diaire
> **Dur√©e estim√©e** : 2 heures
> **Pr√©requis** : Section 5.1 √† 5.5.2 (Index B-Tree et strat√©gies d'indexation)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre le co√ªt des op√©rations de tri et de regroupement sans index
- Cr√©er des index optimaux pour √©liminer les op√©rations filesort
- Optimiser les requ√™tes avec ORDER BY simple et multi-colonnes
- Optimiser les requ√™tes avec GROUP BY et agr√©gations
- Combiner WHERE, ORDER BY et GROUP BY dans un m√™me index
- Analyser les plans d'ex√©cution pour identifier les opportunit√©s d'optimisation
- G√©rer les tris ascendants et descendants (ASC/DESC)

---

## Introduction

Les op√©rations de **tri (ORDER BY)** et de **regroupement (GROUP BY)** sont parmi les plus co√ªteuses en bases de donn√©es. Sans index appropri√©, MariaDB doit :

1. **Lire toutes les lignes** correspondant √† la clause WHERE
2. **Les copier dans une zone de tri** (en m√©moire ou sur disque)
3. **Effectuer le tri ou le regroupement** (op√©ration O(n log n))
4. **Retourner les r√©sultats**

Cette op√©ration, appel√©e **filesort** dans MariaDB, peut prendre plusieurs secondes sur de grandes tables, m√™me si la clause WHERE est bien index√©e.

‚ö†Ô∏è **Id√©e re√ßue** : Le terme "filesort" ne signifie pas n√©cessairement un tri sur disque. Il d√©signe toute op√©ration de tri qui ne peut pas utiliser directement un index.

üí° **Solution** : Un index bien con√ßu permet √† MariaDB de **lire les donn√©es d√©j√† tri√©es**, √©liminant compl√®tement le besoin de filesort.

---

## Comprendre le co√ªt du filesort

### Sans index : op√©ration filesort

```sql
-- Table exemple : articles de blog
CREATE TABLE articles (
    article_id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    author_id INT NOT NULL,
    category_id INT NOT NULL,
    published_at DATETIME NOT NULL,
    views INT DEFAULT 0,
    INDEX idx_articles_category (category_id)
) ENGINE=InnoDB;

-- Ins√©rer 1 million d'articles pour les tests
-- ... (donn√©es de test)

-- Requ√™te typique : articles r√©cents d'une cat√©gorie
SELECT article_id, title, published_at
FROM articles
WHERE category_id = 5
ORDER BY published_at DESC
LIMIT 20;
```

**Analyse sans index sur published_at** :

```sql
EXPLAIN
SELECT article_id, title, published_at
FROM articles
WHERE category_id = 5
ORDER BY published_at DESC
LIMIT 20;

-- R√©sultat :
-- id | type | key                 | rows  | Extra
-- 1  | ref  | idx_articles_category| 50000 | Using where; Using filesort
--
-- ‚ö†Ô∏è "Using filesort" = op√©ration de tri co√ªteuse
```

**Processus interne** :
1. MariaDB lit les 50 000 articles de category_id = 5 via l'index
2. Copie ces 50 000 lignes dans le sort buffer (en m√©moire)
3. Si trop volumineux ‚Üí √©crit sur disque (tr√®s lent)
4. Trie par published_at
5. Retourne les 20 premiers

**Co√ªt** : 500 ms - 2 secondes selon la m√©moire disponible.

### Avec index : lecture directe

```sql
-- Cr√©er un index composite : WHERE + ORDER BY
CREATE INDEX idx_articles_category_published
ON articles(category_id, published_at DESC);

EXPLAIN
SELECT article_id, title, published_at
FROM articles
WHERE category_id = 5
ORDER BY published_at DESC
LIMIT 20;

-- R√©sultat optimis√© :
-- id | type | key                          | rows | Extra
-- 1  | ref  | idx_articles_category_published| 20   | Using index condition
--
-- ‚úÖ PAS de "Using filesort" !
```

**Processus optimis√©** :
1. MariaDB utilise l'index pour lire directement les 20 premi√®res lignes
2. Les donn√©es sont d√©j√† tri√©es dans l'index
3. Retourne imm√©diatement les r√©sultats

**Co√ªt** : 5-20 ms (am√©lioration x25-x400).

---

## Indexation pour ORDER BY

### Principe de base : ordre des colonnes

Pour qu'un index puisse √©liminer filesort, l'ordre des colonnes dans l'index doit correspondre √† l'ordre dans la requ√™te.

```sql
-- Requ√™te simple avec ORDER BY
SELECT * FROM articles ORDER BY published_at DESC LIMIT 10;

-- ‚úÖ Index simple sur colonne de tri
CREATE INDEX idx_articles_published ON articles(published_at DESC);

EXPLAIN SELECT * FROM articles ORDER BY published_at DESC LIMIT 10;
-- Extra: (rien) ‚Üê Pas de filesort, utilise l'index directement
```

### ORDER BY avec WHERE : index composite

**R√®gle d'or** : Dans un index composite, placer les colonnes WHERE **avant** les colonnes ORDER BY.

```sql
-- Pattern fr√©quent : filtrer + trier
SELECT article_id, title
FROM articles
WHERE author_id = 123
ORDER BY published_at DESC
LIMIT 10;

-- ‚ùå Mauvais : ORDER BY avant WHERE
CREATE INDEX idx_bad ON articles(published_at, author_id);
-- Index ne peut pas √™tre utilis√© efficacement

-- ‚úÖ Bon : WHERE avant ORDER BY
CREATE INDEX idx_articles_author_published
ON articles(author_id, published_at DESC);

EXPLAIN SELECT article_id, title
FROM articles
WHERE author_id = 123
ORDER BY published_at DESC
LIMIT 10;

-- R√©sultat :
-- type: ref
-- key: idx_articles_author_published
-- rows: 10
-- Extra: Using index condition (pas de filesort)
```

**Explication** :
1. L'index filtre d'abord par `author_id = 123` (√©galit√©)
2. Puis lit les lignes d√©j√† tri√©es par `published_at DESC`
3. S'arr√™te apr√®s 10 lignes (gr√¢ce √† LIMIT)

### ORDER BY multi-colonnes

Pour trier sur plusieurs colonnes, l'index doit contenir **toutes les colonnes** dans le **m√™me ordre**.

```sql
-- Tri sur plusieurs colonnes
SELECT * FROM articles
WHERE category_id = 5
ORDER BY published_at DESC, article_id DESC
LIMIT 20;

-- ‚úÖ Index avec toutes les colonnes de tri
CREATE INDEX idx_articles_category_sort
ON articles(category_id, published_at DESC, article_id DESC);

EXPLAIN -- Pas de filesort
```

‚ö†Ô∏è **Important** : Si l'ordre diff√®re, l'index ne peut pas √™tre utilis√© :

```sql
-- Requ√™te avec ordre diff√©rent
SELECT * FROM articles
ORDER BY published_at DESC, title ASC; -- DESC puis ASC

-- Index avec m√™me ordre
CREATE INDEX idx_mix ON articles(published_at DESC, title ASC);
-- ‚úÖ Fonctionne : ordre correspond

-- Index avec ordre diff√©rent
CREATE INDEX idx_bad ON articles(published_at ASC, title ASC);
-- ‚ùå Ne fonctionne pas : ordre ne correspond pas
```

### Ordre ASC vs DESC

MariaDB peut lire un index **dans les deux sens**, mais avec des nuances.

```sql
-- Index cr√©√© en ordre ASC (par d√©faut)
CREATE INDEX idx_articles_published ON articles(published_at);

-- ‚úÖ Requ√™te ASC : utilise l'index naturellement
SELECT * FROM articles ORDER BY published_at ASC LIMIT 10;
-- Lit l'index du d√©but

-- ‚úÖ Requ√™te DESC : utilise l'index en sens inverse
SELECT * FROM articles ORDER BY published_at DESC LIMIT 10;
-- Lit l'index de la fin (backward scan)
```

**Mais pour ORDER BY multi-colonnes, la direction compte** :

```sql
-- Tri mixte ASC/DESC sur 2 colonnes
SELECT * FROM articles
ORDER BY published_at DESC, views ASC
LIMIT 20;

-- ‚ùå Index avec directions identiques
CREATE INDEX idx_same ON articles(published_at DESC, views DESC);
-- Ne peut pas √©liminer filesort pour "views ASC"

-- ‚úÖ Index avec directions correspondantes
CREATE INDEX idx_mixed ON articles(published_at DESC, views ASC);
-- √âlimine filesort
```

üí° **Depuis MariaDB 10.8** : Support complet des index avec directions mixtes (ASC/DESC).

---

## Indexation pour GROUP BY

### Principe de base

Les op√©rations **GROUP BY** b√©n√©ficient des m√™mes principes d'indexation que ORDER BY, car le regroupement n√©cessite √©galement un tri des donn√©es.

```sql
-- Requ√™te avec GROUP BY
SELECT author_id, COUNT(*) as article_count
FROM articles
WHERE category_id = 5
GROUP BY author_id;

-- ‚úÖ Index composite : WHERE + GROUP BY
CREATE INDEX idx_articles_category_author
ON articles(category_id, author_id);

EXPLAIN
SELECT author_id, COUNT(*) as article_count
FROM articles
WHERE category_id = 5
GROUP BY author_id;

-- R√©sultat :
-- key: idx_articles_category_author
-- Extra: Using index (index-only scan)
```

**Optimisation maximale** : Index covering incluant toutes les colonnes SELECT :

```sql
-- Requ√™te avec agr√©gation
SELECT author_id, COUNT(*) as cnt, SUM(views) as total_views
FROM articles
WHERE category_id = 5
GROUP BY author_id;

-- ‚úÖ Index covering
CREATE INDEX idx_articles_group_covering
ON articles(category_id, author_id, views);
-- Contient category_id (WHERE), author_id (GROUP BY), views (SUM)

EXPLAIN
-- Extra: Using index (optimal, pas d'acc√®s table)
```

### GROUP BY avec ORDER BY

Combiner GROUP BY et ORDER BY n√©cessite un index soigneusement construit.

```sql
-- Pattern fr√©quent : top N par groupe
SELECT author_id, COUNT(*) as article_count
FROM articles
WHERE category_id = 5
GROUP BY author_id
ORDER BY article_count DESC
LIMIT 10;
```

‚ö†Ô∏è **Limitation** : On ne peut pas indexer directement `COUNT(*)` car c'est une **valeur calcul√©e**.

**Solutions** :

1. **Index couvre GROUP BY** (√©limine filesort du GROUP BY, mais pas du ORDER BY) :
```sql
CREATE INDEX idx_articles_category_author
ON articles(category_id, author_id);
-- √âlimine le tri pour GROUP BY
-- Mais ORDER BY COUNT(*) n√©cessite quand m√™me un tri
```

2. **Colonne pr√©-calcul√©e** (si tri sur colonne existante) :
```sql
-- Si on trie sur une colonne r√©elle
SELECT author_id, COUNT(*) as cnt, MAX(published_at) as last_article
FROM articles
GROUP BY author_id
ORDER BY last_article DESC;

-- Index covering avec colonne de tri
CREATE INDEX idx_author_published
ON articles(author_id, published_at DESC);
```

3. **Table de mat√©rialisation** (pour agr√©gations fr√©quentes) :
```sql
-- Table pr√©-calcul√©e mise √† jour par trigger
CREATE TABLE author_stats (
    author_id INT PRIMARY KEY,
    article_count INT,
    total_views INT,
    last_updated DATETIME
);

-- Requ√™te rapide sur table mat√©rialis√©e
SELECT * FROM author_stats
ORDER BY article_count DESC
LIMIT 10;
```

### GROUP BY multi-colonnes

```sql
-- Regroupement sur plusieurs colonnes
SELECT category_id, author_id, COUNT(*) as cnt
FROM articles
WHERE published_at >= '2024-01-01'
GROUP BY category_id, author_id;

-- ‚úÖ Index composite : WHERE + toutes colonnes GROUP BY
CREATE INDEX idx_articles_published_group
ON articles(published_at, category_id, author_id);
-- Remarque : colonnes GROUP BY peuvent √™tre dans n'importe quel ordre apr√®s WHERE
```

üí° **Flexibilit√© GROUP BY** : Contrairement √† ORDER BY, l'ordre des colonnes dans GROUP BY n'a pas besoin de correspondre exactement √† l'ordre dans l'index (MariaDB peut r√©organiser).

---

## Cas avanc√©s et optimisations

### LIMIT avec ORDER BY : Index optimal

Le **LIMIT** change radicalement la strat√©gie d'optimisation.

```sql
-- Sans LIMIT : doit trier toutes les lignes
SELECT * FROM articles
WHERE category_id = 5
ORDER BY published_at DESC;
-- Trie potentiellement 50 000 lignes

-- Avec LIMIT : peut s'arr√™ter t√¥t
SELECT * FROM articles
WHERE category_id = 5
ORDER BY published_at DESC
LIMIT 10;
-- Avec bon index, lit seulement 10 lignes !
```

**Index optimal pour LIMIT + ORDER BY** :

```sql
CREATE INDEX idx_articles_category_published
ON articles(category_id, published_at DESC);

EXPLAIN SELECT * FROM articles
WHERE category_id = 5
ORDER BY published_at DESC
LIMIT 10;

-- R√©sultat :
-- rows: 10 (pas 50000 !)
-- Extra: Using index condition
```

MariaDB s'arr√™te apr√®s avoir lu **exactement 10 lignes** de l'index.

### Pagination avec ORDER BY

```sql
-- ‚ùå Pagination classique : lente sur grandes offsets
SELECT * FROM articles
WHERE category_id = 5
ORDER BY published_at DESC
LIMIT 10 OFFSET 10000;
-- Doit lire et ignorer 10 000 lignes m√™me avec index !

-- ‚úÖ Pagination par curseur (keyset pagination)
SELECT * FROM articles
WHERE category_id = 5
  AND published_at < '2024-01-15 10:30:00' -- Dernier published_at page pr√©c√©dente
ORDER BY published_at DESC
LIMIT 10;

-- Index covering optimal
CREATE INDEX idx_articles_category_published_id
ON articles(category_id, published_at DESC, article_id);
```

**Avantage** : Performance constante quelle que soit la page (toujours 10 lignes lues).

### ORDER BY avec fonctions : colonnes g√©n√©r√©es

```sql
-- ‚ùå Fonction sur colonne emp√™che l'utilisation d'index
SELECT * FROM articles
ORDER BY YEAR(published_at), MONTH(published_at)
LIMIT 10;
-- Filesort obligatoire

-- ‚úÖ Solution : colonnes g√©n√©r√©es
ALTER TABLE articles
ADD COLUMN published_year_month CHAR(7)
    AS (DATE_FORMAT(published_at, '%Y-%m')) VIRTUAL;

CREATE INDEX idx_articles_year_month
ON articles(published_year_month);

-- Requ√™te optimis√©e
SELECT * FROM articles
ORDER BY published_year_month
LIMIT 10;
-- Utilise l'index, pas de filesort
```

### DISTINCT vs GROUP BY

```sql
-- DISTINCT et GROUP BY utilisent le m√™me m√©canisme interne

-- DISTINCT sur une colonne
SELECT DISTINCT author_id FROM articles;
-- √âquivalent √† :
SELECT author_id FROM articles GROUP BY author_id;

-- ‚úÖ Index pour DISTINCT
CREATE INDEX idx_articles_author ON articles(author_id);

EXPLAIN SELECT DISTINCT author_id FROM articles;
-- Extra: Using index (index-only scan, optimal)
```

---

## Combinaisons WHERE + ORDER BY + GROUP BY

### Ordre optimal des colonnes dans l'index

**R√®gle g√©n√©rale** :
1. **Colonnes WHERE avec √©galit√©** (=) en premier
2. **Colonnes GROUP BY** ensuite
3. **Colonnes ORDER BY** en dernier
4. **Colonnes SELECT** (pour index covering) √† la fin

```sql
-- Requ√™te complexe
SELECT
    author_id,
    category_id,
    COUNT(*) as cnt,
    MAX(views) as max_views
FROM articles
WHERE status = 'published'           -- √âgalit√©
  AND published_at >= '2024-01-01'   -- Plage
GROUP BY author_id, category_id
ORDER BY max_views DESC
LIMIT 20;

-- ‚úÖ Index optimal
CREATE INDEX idx_articles_complex
ON articles(
    status,                    -- WHERE √©galit√©
    published_at,              -- WHERE plage
    author_id, category_id,    -- GROUP BY
    views                      -- ORDER BY (MAX(views)) + covering
);
```

**Analyse EXPLAIN** :

```sql
EXPLAIN
-- R√©sultat attendu :
-- type: range
-- key: idx_articles_complex
-- Extra: Using index condition; Using temporary; Using filesort
```

‚ö†Ô∏è **Note** : Pour des requ√™tes tr√®s complexes avec GROUP BY + ORDER BY sur agr√©gation, un "Using filesort" peut persister car l'ordre final d√©pend de l'agr√©gation calcul√©e, pas des colonnes de base.

### Index s√©par√©s vs index composite

```sql
-- Sc√©nario : requ√™tes vari√©es

-- Requ√™te 1 : Tri par date
SELECT * FROM articles WHERE category_id = 5 ORDER BY published_at DESC;

-- Requ√™te 2 : Tri par vues
SELECT * FROM articles WHERE category_id = 5 ORDER BY views DESC;

-- Requ√™te 3 : Tri par titre
SELECT * FROM articles WHERE category_id = 5 ORDER BY title;
```

**Option A : Index composite pour chaque requ√™te** (sp√©cialis√©)
```sql
CREATE INDEX idx_cat_date ON articles(category_id, published_at DESC);
CREATE INDEX idx_cat_views ON articles(category_id, views DESC);
CREATE INDEX idx_cat_title ON articles(category_id, title);
-- ‚úÖ Performance maximale
-- ‚ùå 3 index = co√ªt √©criture √ó3
```

**Option B : Index partag√© + filesort** (compromis)
```sql
CREATE INDEX idx_cat ON articles(category_id);
-- ‚úÖ Un seul index = co√ªt √©criture minimal
-- ‚ùå Toutes les requ√™tes auront "Using filesort"
-- Acceptable si tris portent sur peu de lignes
```

**D√©cision** :
- Tables **lecture intensive** (95%+ SELECT) ‚Üí Option A
- Tables **√©criture intensive** (50%+ INSERT/UPDATE) ‚Üí Option B
- **Mesurer** l'impact r√©el avec slow query log

---

## Analyse avec EXPLAIN et EXPLAIN ANALYZE

### Interpr√©ter les indicateurs EXPLAIN

```sql
EXPLAIN
SELECT * FROM articles
WHERE category_id = 5
ORDER BY published_at DESC
LIMIT 10;
```

**Colonne "Extra" - Indicateurs cl√©s** :

| Indicateur | Signification | Action |
|------------|---------------|--------|
| `Using filesort` | Tri en m√©moire/disque | ‚ö†Ô∏è Cr√©er index ORDER BY |
| `Using temporary` | Table temporaire cr√©√©e | ‚ö†Ô∏è Optimiser GROUP BY |
| `Using index` | Index covering (optimal) | ‚úÖ Parfait |
| `Using index condition` | Index pushdown | ‚úÖ Bien |
| `Using where` | Filtrage apr√®s lecture | ‚ö†Ô∏è Peut √™tre optimis√© |

**Colonne "rows"** : Nombre de lignes examin√©es
- Doit √™tre proche du nombre de lignes retourn√©es
- Si `rows` >> r√©sultat ‚Üí opportunit√© d'optimisation

### EXPLAIN ANALYZE pour mesures r√©elles

```sql
-- EXPLAIN ANALYZE (MariaDB 10.6+) : temps r√©els
EXPLAIN ANALYZE
SELECT * FROM articles
WHERE category_id = 5
ORDER BY published_at DESC
LIMIT 10\G

-- R√©sultat d√©taill√© :
*************************** 1. row ***************************
EXPLAIN: -> Limit: 10 row(s)
    (cost=125.23 rows=10)
    (actual time=0.156..0.234 rows=10 loops=1)
  -> Index lookup on articles using idx_articles_category_published
    (category_id=5)
    (cost=125.23 rows=500)
    (actual time=0.154..0.230 rows=10 loops=1)
```

**M√©triques importantes** :
- `cost` : Estimation du co√ªt (optimizer)
- `rows` : Estimation du nombre de lignes
- `actual time` : **Temps r√©el d'ex√©cution** (ms)
- `actual rows` : **Nombre r√©el de lignes** trait√©es

üí° **Comparaison** : Si `actual rows` >> `rows` estim√© ‚Üí Statistiques d'index obsol√®tes :
```sql
ANALYZE TABLE articles;
```

---

## Monitoring et optimisation continue

### Identifier les requ√™tes avec filesort

```sql
-- Activer le slow query log avec flag filesort
SET GLOBAL log_queries_not_using_indexes = 'ON';
SET GLOBAL long_query_time = 1;

-- Requ√™te Performance Schema : top requ√™tes avec filesort
SELECT
    DIGEST_TEXT,
    COUNT_STAR,
    SUM_SORT_ROWS,
    AVG_TIMER_WAIT / 1000000000 as avg_time_sec
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = 'your_database'
  AND SUM_SORT_ROWS > 0  -- A utilis√© filesort
ORDER BY SUM_SORT_ROWS DESC
LIMIT 20;
```

### Surveiller l'utilisation du sort buffer

```sql
-- Voir la configuration actuelle
SHOW VARIABLES LIKE 'sort_buffer_size';
-- D√©faut : 256KB √† 2MB selon version

-- Statistiques de tri (session courante)
SHOW STATUS LIKE 'Sort%';
-- Sort_merge_passes : nombre de passes disque (0 = optimal)
-- Sort_range : nombre de tris pour plages
-- Sort_rows : nombre de lignes tri√©es
-- Sort_scan : nombre de full scans tri√©s
```

üí° **Si `Sort_merge_passes` > 0** : Le sort buffer est trop petit, le tri d√©borde sur disque.

**Solution** :
```sql
-- Augmenter temporairement pour session
SET SESSION sort_buffer_size = 4194304; -- 4MB

-- Ou globalement dans my.cnf
[mysqld]
sort_buffer_size = 4M
```

‚ö†Ô∏è **Attention** : Ne pas mettre trop haut (4-8MB max), car allou√© **par connexion** (consommation m√©moire).

---

## Cas d'usage r√©els

### Dashboard analytics : top produits

```sql
-- Requ√™te : top 10 produits les plus vendus ce mois
SELECT
    p.product_id,
    p.name,
    COUNT(oi.item_id) as order_count,
    SUM(oi.quantity * oi.unit_price) as revenue
FROM products p
INNER JOIN order_items oi ON p.product_id = oi.product_id
INNER JOIN orders o ON oi.order_id = o.order_id
WHERE o.order_date >= DATE_FORMAT(NOW(), '%Y-%m-01')
  AND o.status = 'completed'
GROUP BY p.product_id, p.name
ORDER BY revenue DESC
LIMIT 10;

-- Index optimaux
CREATE INDEX idx_orders_status_date
ON orders(status, order_date);

CREATE INDEX idx_order_items_order_product
ON order_items(order_id, product_id, quantity, unit_price);
-- Index covering pour √©viter acc√®s table order_items
```

### Fil d'actualit√© : posts r√©cents

```sql
-- Requ√™te : feed utilisateur avec posts d'amis
SELECT p.post_id, p.content, p.created_at, u.username
FROM posts p
INNER JOIN users u ON p.user_id = u.user_id
WHERE p.user_id IN (
    SELECT friend_id FROM friendships WHERE user_id = 12345
)
ORDER BY p.created_at DESC
LIMIT 20;

-- Optimisation avec index
CREATE INDEX idx_posts_user_created
ON posts(user_id, created_at DESC);
-- Permet tri sans filesort apr√®s filtrage par user_id
```

### Pagination de r√©sultats de recherche

```sql
-- Recherche avec tri par pertinence + r√©cence
SELECT product_id, name, score
FROM (
    SELECT
        product_id,
        name,
        MATCH(name, description) AGAINST('laptop' IN BOOLEAN MODE) as score,
        created_at
    FROM products
    WHERE MATCH(name, description) AGAINST('laptop' IN BOOLEAN MODE)
) as search_results
ORDER BY score DESC, created_at DESC
LIMIT 20 OFFSET 0;

-- Index FULLTEXT + index date
CREATE FULLTEXT INDEX idx_products_search
ON products(name, description);

CREATE INDEX idx_products_created
ON products(created_at DESC);
```

---

## ‚úÖ Points cl√©s √† retenir

- **"Using filesort" = opportunit√© d'optimisation** : cr√©er un index ORDER BY
- **Ordre des colonnes crucial** : WHERE (√©galit√©) ‚Üí ORDER BY ‚Üí colonnes SELECT
- **LIMIT change tout** : avec bon index, lit seulement N lignes, pas tout le dataset
- **Directions ASC/DESC** : doivent correspondre dans l'index pour multi-colonnes
- **GROUP BY** : m√™mes principes qu'ORDER BY, b√©n√©ficie d'index similaires
- **Index covering = optimal** : inclut toutes les colonnes SELECT, WHERE, ORDER BY
- **Pagination** : pr√©f√©rer keyset pagination pour grandes offsets
- **Colonnes g√©n√©r√©es** : solution pour ORDER BY avec fonctions
- **EXPLAIN ANALYZE** : mesurer l'impact r√©el des optimisations
- **Compromis** : index multiples (performance) vs co√ªt d'√©criture

---

## üîó Ressources et r√©f√©rences

- [üìñ MariaDB ORDER BY Optimization](https://mariadb.com/kb/en/order-by-optimization/)
- [üìñ MariaDB GROUP BY Optimization](https://mariadb.com/kb/en/group-by-optimization/)
- [üìñ EXPLAIN Documentation](https://mariadb.com/kb/en/explain/)
- [üìñ EXPLAIN ANALYZE](https://mariadb.com/kb/en/explain-analyze/)
- [üìñ Index Hints](https://mariadb.com/kb/en/index-hints-how-to-force-query-plans/)
- [üìñ Generated Columns](https://mariadb.com/kb/en/generated-columns/)
- [üìä Performance Schema](https://mariadb.com/kb/en/performance-schema/)

---

## ‚û°Ô∏è Section suivante

**5.6 Index composites et ordre des colonnes** : Ma√Ætriser l'art des index multi-colonnes, comprendre la r√®gle du pr√©fixe gauche et optimiser l'ordre des colonnes pour maximiser la r√©utilisation des index.

‚è≠Ô∏è [Index composites et ordre des colonnes](/05-index-et-performance/06-index-composites.md)
