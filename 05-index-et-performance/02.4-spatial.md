üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.2.4 Spatial : Donn√©es g√©ographiques

> **Niveau** : Interm√©diaire
> **Dur√©e estim√©e** : 2-2.5 heures

> **Pr√©requis** :
> - Section 5.1 - Fonctionnement des index B-Tree
> - Section 5.2.1 - B-Tree : Le standard
> - Notions de g√©om√©trie de base (points, lignes, polygones)
> - Compr√©hension du syst√®me GPS/coordonn√©es

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre le fonctionnement des index Spatial (R-Tree) et leur structure
- Utiliser les types de donn√©es g√©om√©triques (POINT, LINESTRING, POLYGON, etc.)
- Ma√Ætriser les fonctions spatiales pour calculs de distance et relations g√©om√©triques
- Cr√©er et optimiser des index Spatial pour des requ√™tes g√©ographiques performantes
- Impl√©menter des cas d'usage r√©els (cartographie, livraison, localisation)
- Comprendre les syst√®mes de r√©f√©rence spatiale (SRID) et leur importance
- Identifier quand utiliser Spatial vs solutions externes (PostGIS)

---

## Introduction

Les index **Spatial** sont optimis√©s pour les **donn√©es g√©ographiques et g√©om√©triques**. Ils permettent d'effectuer efficacement des requ√™tes comme "trouver tous les points dans un rayon de 5 km" ou "v√©rifier si un point est dans une zone".

### Pourquoi des index Spatial ?

```sql
-- ‚ùå Sans index Spatial : calcul sur chaque ligne (tr√®s lent)
SELECT name, address
FROM restaurants
WHERE SQRT(POW(latitude - 48.8566, 2) + POW(longitude - 2.3522, 2)) < 0.05;
-- Full scan + calcul pour chaque restaurant

-- ‚úÖ Avec index Spatial : recherche optimis√©e
SELECT name, address
FROM restaurants
WHERE ST_Distance_Sphere(
    location,
    ST_GeomFromText('POINT(2.3522 48.8566)', 4326)
) < 5000;  -- 5 km
-- Utilise l'index R-Tree : 100-1000x plus rapide
```

### Applications typiques

- üó∫Ô∏è **Applications de cartographie** : Google Maps, OpenStreetMap
- üöó **Services de livraison** : Uber Eats, Deliveroo (trouver livreurs proches)
- üìç **Localisation de POI** : Restaurants, h√¥tels, magasins √† proximit√©
- üè¢ **GIS d'entreprise** : Gestion d'actifs g√©ographiques
- üåç **Analyse territoriale** : D√©mographie, urbanisme
- üö® **Services d'urgence** : Trouver ambulance la plus proche

---

## Structure R-Tree : Le moteur des index Spatial

### Principe du R-Tree

Un **R-Tree** (Rectangle Tree) est une structure d'index hi√©rarchique qui organise les objets g√©om√©triques en **rectangles englobants** (Minimum Bounding Rectangle - MBR).

```
Principe du R-Tree :

                    Niveau 0 (Racine)
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ   Rectangle global      ‚îÇ
              ‚îÇ   (toute la zone)       ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
        ‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
        ‚îÉ                                    ‚îÉ
   Niveau 1                             Niveau 1
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Zone Nord     ‚îÇ                  ‚îÇ  Zone Sud      ‚îÇ
‚îÇ  MBR(N)        ‚îÇ                  ‚îÇ  MBR(S)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                                   ‚îÇ
     ‚îè‚îÅ‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚îÅ‚îì                           ‚îè‚îÅ‚îÅ‚îÅ‚îª‚îÅ‚îÅ‚îÅ‚îì
     ‚îÉ       ‚îÉ                           ‚îÉ       ‚îÉ
 Niveau 2  Niveau 2                  Niveau 2  Niveau 2
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇNord-‚îÇ ‚îÇNord-‚îÇ                    ‚îÇSud- ‚îÇ ‚îÇSud- ‚îÇ
 ‚îÇOuest‚îÇ ‚îÇEst  ‚îÇ                    ‚îÇOuest‚îÇ ‚îÇEst  ‚îÇ
 ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò
    ‚îÇ       ‚îÇ                          ‚îÇ       ‚îÇ
 Points  Points                     Points  Points
 r√©els   r√©els                      r√©els   r√©els

Chaque niveau encapsule g√©om√©triquement les niveaux inf√©rieurs
```

### MBR (Minimum Bounding Rectangle)

Un **MBR** est le plus petit rectangle qui englobe compl√®tement un objet g√©om√©trique :

```
Exemples de MBR :

Point :                  Ligne :                 Polygone :
    ‚Ä¢                   /                     ___
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              /‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            /   \‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   ‚Ä¢   ‚îÇ             / ‚îÇ   /   ‚îÇ           ‚îÇ     ‚îÇ       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            /  ‚îî‚îÄ‚îÄ/‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ  ‚Ä¢  ‚îÇ   ‚Ä¢   ‚îÇ
  MBR                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 \___/‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       MBR                        MBR

Le MBR est toujours un rectangle align√© sur les axes
```

### Algorithme de recherche R-Tree

```
Recherche spatiale (exemple : points dans une zone) :

1. Commencer √† la racine
2. Pour chaque n≈ìud :
   a. V√©rifier si MBR du n≈ìud intersecte la zone recherch√©e
   b. Si OUI : Descendre dans ce sous-arbre
   c. Si NON : Ignorer ce sous-arbre (√©lagage)
3. Au niveau feuilles : Tester pr√©cis√©ment chaque objet
4. Retourner les objets qui satisfont la condition

Complexit√© : O(log n) en moyenne (comme B-Tree)
Mais d√©pend de la distribution spatiale des donn√©es
```

**Avantage cl√©** : Le R-Tree √©lague rapidement les branches qui ne peuvent pas contenir de r√©sultats pertinents.

---

## Types de donn√©es g√©om√©triques

### Types disponibles dans MariaDB

| Type | Description | Dimensions | Exemple d'utilisation |
|------|-------------|------------|----------------------|
| **POINT** | Un point unique (x, y) | 2D | Localisation restaurant, position GPS |
| **LINESTRING** | Une ligne (s√©rie de points) | 2D | Route, trajet, c√¢ble |
| **POLYGON** | Un polygone ferm√© | 2D | Zone de livraison, fronti√®re, parcelle |
| **MULTIPOINT** | Collection de points | 2D | Points d'int√©r√™t multiples |
| **MULTILINESTRING** | Collection de lignes | 2D | R√©seau routier |
| **MULTIPOLYGON** | Collection de polygones | 2D | Pays avec √Æles |
| **GEOMETRY** | Type g√©n√©rique | 2D | Stockage flexible |
| **GEOMETRYCOLLECTION** | Collection h√©t√©rog√®ne | 2D | Mix de types |

### POINT : Le type le plus courant

```sql
-- Cr√©ation d'une table avec POINT
CREATE TABLE stores (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255),
    address TEXT,
    location POINT NOT NULL,
    SPATIAL INDEX idx_location (location)
) ENGINE=InnoDB;

-- Insertion de points (longitude, latitude)
INSERT INTO stores (name, address, location) VALUES
('Store Paris', '123 Rue de Rivoli, Paris',
 ST_GeomFromText('POINT(2.3522 48.8566)', 4326)),

('Store Lyon', '45 Cours Lafayette, Lyon',
 ST_GeomFromText('POINT(4.8357 45.7640)', 4326)),

('Store Marseille', '10 La Canebi√®re, Marseille',
 ST_GeomFromText('POINT(5.3698 43.2965)', 4326));

-- ‚ö†Ô∏è IMPORTANT : Ordre des coordonn√©es
-- POINT(longitude, latitude) et non POINT(latitude, longitude) !
-- Longitude = X (horizontal) : -180 √† +180
-- Latitude = Y (vertical) : -90 √† +90
```

üí° **Pi√®ge courant** : Beaucoup de d√©veloppeurs inversent longitude/latitude. Retenez : **POINT(X, Y)** o√π X=longitude, Y=latitude.

### LINESTRING : Lignes et trajets

```sql
-- Table pour trajets GPS
CREATE TABLE routes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255),
    path LINESTRING NOT NULL,
    distance_km DECIMAL(10,2),
    SPATIAL INDEX idx_path (path)
) ENGINE=InnoDB;

-- Insertion d'une route (s√©rie de points)
INSERT INTO routes (name, path, distance_km) VALUES
('Route Paris-Lyon',
 ST_GeomFromText('LINESTRING(
    2.3522 48.8566,  -- Paris
    2.5 48.7,        -- Point interm√©diaire
    3.0 47.5,        -- Point interm√©diaire
    4.8357 45.7640   -- Lyon
 )', 4326),
 465);
```

### POLYGON : Zones et fronti√®res

```sql
-- Table pour zones de livraison
CREATE TABLE delivery_zones (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255),
    zone POLYGON NOT NULL,
    active BOOLEAN DEFAULT TRUE,
    SPATIAL INDEX idx_zone (zone)
) ENGINE=InnoDB;

-- Insertion d'un polygone (zone rectangulaire autour de Paris)
INSERT INTO delivery_zones (name, zone) VALUES
('Paris Centre',
 ST_GeomFromText('POLYGON((
    2.25 48.82,  -- Sud-Ouest
    2.25 48.90,  -- Nord-Ouest
    2.42 48.90,  -- Nord-Est
    2.42 48.82,  -- Sud-Est
    2.25 48.82   -- Retour au point de d√©part (fermer le polygone)
 ))', 4326));

-- ‚ö†Ô∏è Le premier et dernier point doivent √™tre identiques
```

### MULTIPOINT, MULTILINESTRING, MULTIPOLYGON

```sql
-- MULTIPOINT : Plusieurs points d'int√©r√™t
CREATE TABLE tourist_attractions (
    id INT PRIMARY KEY,
    city VARCHAR(100),
    attractions MULTIPOINT NOT NULL,
    SPATIAL INDEX idx_attractions (attractions)
);

INSERT INTO tourist_attractions VALUES
(1, 'Paris', ST_GeomFromText('MULTIPOINT(
    2.2945 48.8584,  -- Tour Eiffel
    2.3522 48.8566,  -- Louvre
    2.3508 48.8529   -- Notre-Dame
)', 4326));

-- MULTIPOLYGON : Pays avec √Æles
CREATE TABLE countries (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    territory MULTIPOLYGON NOT NULL,
    SPATIAL INDEX idx_territory (territory)
);

-- France m√©tropolitaine + Corse (exemple simplifi√©)
INSERT INTO countries VALUES
(1, 'France', ST_GeomFromText('MULTIPOLYGON(
    ((...)),  -- M√©tropole
    ((9.0 41.5, 9.5 41.5, 9.5 43.0, 9.0 43.0, 9.0 41.5))  -- Corse
)', 4326));
```

---

## Syst√®mes de r√©f√©rence spatiale (SRID)

### Qu'est-ce qu'un SRID ?

Un **SRID** (Spatial Reference System Identifier) d√©finit comment les coordonn√©es sont interpr√©t√©es sur la Terre.

```sql
-- Sans SRID (obsol√®te, √©viter)
ST_GeomFromText('POINT(2.3522 48.8566)')

-- Avec SRID 4326 (WGS 84 - standard GPS, recommand√©)
ST_GeomFromText('POINT(2.3522 48.8566)', 4326)
```

### SRID courants

| SRID | Nom | Description | Usage |
|------|-----|-------------|-------|
| **4326** | WGS 84 | Syst√®me GPS standard mondial | Applications GPS, web mapping |
| **3857** | Web Mercator | Projection web (Google Maps) | Tuiles cartographiques web |
| **2154** | Lambert-93 | Projection France m√©tropolitaine | Cartographie officielle France |
| **0** | Cart√©sien | Plan 2D sans g√©od√©sie | Calculs abstraits |

üí° **Recommandation** : Utilisez toujours **SRID 4326** pour des applications GPS/web sauf besoin sp√©cifique.

### Impact du SRID sur les calculs

```sql
-- Cr√©er une table avec SRID d√©clar√©
CREATE TABLE locations (
    id INT PRIMARY KEY,
    name VARCHAR(255),
    position POINT NOT NULL SRID 4326,  -- SRID obligatoire
    SPATIAL INDEX idx_position (position)
) ENGINE=InnoDB;

-- Les fonctions respectent le SRID
INSERT INTO locations VALUES
(1, 'Paris', ST_GeomFromText('POINT(2.3522 48.8566)', 4326));

-- V√©rifier le SRID
SELECT ST_SRID(position) FROM locations WHERE id = 1;
-- R√©sultat : 4326
```

---

## Fonctions spatiales essentielles

### Cr√©ation de g√©om√©tries

```sql
-- ST_GeomFromText : Cr√©er depuis WKT (Well-Known Text)
SET @paris = ST_GeomFromText('POINT(2.3522 48.8566)', 4326);

-- ST_Point : Raccourci pour cr√©er un point
SET @lyon = ST_Point(4.8357, 45.7640);

-- ST_PointFromText : Alternative explicite
SET @marseille = ST_PointFromText('POINT(5.3698 43.2965)', 4326);

-- ST_Buffer : Cr√©er zone tampon autour d'un point
SET @zone_5km = ST_Buffer(@paris, 0.05);  -- ~5 km en degr√©s
```

### Calculs de distance

**ST_Distance** : Distance cart√©sienne (en degr√©s si SRID 4326)

```sql
SELECT ST_Distance(
    ST_GeomFromText('POINT(2.3522 48.8566)', 4326),  -- Paris
    ST_GeomFromText('POINT(4.8357 45.7640)', 4326)   -- Lyon
) AS distance_degrees;
-- R√©sultat : ~3.16 degr√©s (pas tr√®s utile)
```

**ST_Distance_Sphere** : Distance sph√©rique en m√®tres (recommand√©)

```sql
SELECT ST_Distance_Sphere(
    ST_GeomFromText('POINT(2.3522 48.8566)', 4326),  -- Paris
    ST_GeomFromText('POINT(4.8357 45.7640)', 4326)   -- Lyon
) / 1000 AS distance_km;
-- R√©sultat : ~392 km (pr√©cis)
```

**Recherche de proximit√©** :

```sql
-- Restaurants dans un rayon de 5 km
SELECT
    id,
    name,
    ST_Distance_Sphere(
        location,
        ST_GeomFromText('POINT(2.3522 48.8566)', 4326)
    ) / 1000 AS distance_km
FROM restaurants
WHERE ST_Distance_Sphere(
    location,
    ST_GeomFromText('POINT(2.3522 48.8566)', 4326)
) < 5000  -- 5000 m√®tres = 5 km
ORDER BY distance_km
LIMIT 10;
```

### Relations spatiales

**ST_Contains** : V√©rifie si une g√©om√©trie contient une autre

```sql
-- V√©rifier si un point est dans une zone de livraison
SELECT z.name
FROM delivery_zones z
WHERE ST_Contains(
    z.zone,
    ST_GeomFromText('POINT(2.35 48.86)', 4326)
);

-- Tous les restaurants dans une zone
SELECT r.name
FROM restaurants r, delivery_zones z
WHERE z.id = 1
AND ST_Contains(z.zone, r.location);
```

**ST_Within** : Inverse de ST_Contains

```sql
-- M√™me r√©sultat que ST_Contains, syntaxe invers√©e
SELECT r.name
FROM restaurants r, delivery_zones z
WHERE z.id = 1
AND ST_Within(r.location, z.zone);
```

**ST_Intersects** : V√©rifie si deux g√©om√©tries se croisent

```sql
-- Zones de livraison qui intersectent une route
SELECT z.name
FROM delivery_zones z, routes r
WHERE r.id = 1
AND ST_Intersects(z.zone, r.path);

-- V√©rifier si deux zones se chevauchent
SELECT z1.name AS zone1, z2.name AS zone2
FROM delivery_zones z1, delivery_zones z2
WHERE z1.id < z2.id
AND ST_Intersects(z1.zone, z2.zone);
```

**ST_Disjoint** : V√©rifie si deux g√©om√©tries ne se touchent pas

```sql
SELECT COUNT(*) FROM zones z1, zones z2
WHERE z1.id < z2.id
AND ST_Disjoint(z1.zone, z2.zone);
```

**ST_Touches** : V√©rifie si deux g√©om√©tries se touchent (fronti√®re commune)

```sql
-- Zones adjacentes (partageant une fronti√®re)
SELECT z1.name, z2.name
FROM zones z1, zones z2
WHERE z1.id != z2.id
AND ST_Touches(z1.zone, z2.zone);
```

### Propri√©t√©s g√©om√©triques

```sql
-- ST_Area : Calcul de surface (en unit√©s carr√©es)
SELECT
    name,
    ST_Area(zone) AS area_degrees_sq,
    ST_Area(zone) * 111 * 111 AS area_km_sq_approx  -- Approximation
FROM delivery_zones;

-- ST_Length : Longueur d'une ligne
SELECT
    name,
    ST_Length(path) AS length_degrees
FROM routes;

-- ST_Centroid : Centre g√©om√©trique
SELECT
    name,
    ST_AsText(ST_Centroid(zone)) AS center
FROM delivery_zones;

-- ST_Envelope : Rectangle englobant (MBR)
SELECT
    name,
    ST_AsText(ST_Envelope(zone)) AS mbr
FROM delivery_zones;
```

### Formats d'export

```sql
-- ST_AsText : Export en WKT (Well-Known Text)
SELECT ST_AsText(location) FROM stores WHERE id = 1;
-- R√©sultat : 'POINT(2.3522 48.8566)'

-- ST_AsGeoJSON : Export en GeoJSON
SELECT ST_AsGeoJSON(location) FROM stores WHERE id = 1;
-- R√©sultat : {"type":"Point","coordinates":[2.3522,48.8566]}

-- ST_X, ST_Y : Extraire longitude/latitude
SELECT
    name,
    ST_X(location) AS longitude,
    ST_Y(location) AS latitude
FROM stores;
```

---

## Cr√©ation et optimisation d'index Spatial

### Syntaxe de cr√©ation

```sql
-- Lors de la cr√©ation de table
CREATE TABLE pois (
    id INT PRIMARY KEY,
    name VARCHAR(255),
    location POINT NOT NULL SRID 4326,
    SPATIAL INDEX idx_location (location)
) ENGINE=InnoDB;

-- Ajout d'index sur table existante
ALTER TABLE pois ADD SPATIAL INDEX idx_location (location);

-- Ou avec CREATE INDEX
CREATE SPATIAL INDEX idx_location ON pois(location);
```

### Contraintes et limitations

```sql
-- ‚úÖ CORRECT : Colonne NOT NULL
CREATE TABLE valid (
    location POINT NOT NULL,
    SPATIAL INDEX (location)
);

-- ‚ùå ERREUR : Colonne nullable
CREATE TABLE invalid (
    location POINT,  -- Pas de NOT NULL
    SPATIAL INDEX (location)  -- ERREUR !
);
-- ERROR: All spatial columns must be NOT NULL

-- ‚úÖ CORRECT : Un seul index Spatial par colonne
CREATE SPATIAL INDEX idx1 ON table(geom_col);

-- ‚ùå Plusieurs colonnes dans un index Spatial non support√©
CREATE SPATIAL INDEX idx_multi ON table(col1, col2);  -- ERREUR
```

### Performance des index Spatial

**Facteurs influen√ßant la performance** :

1. **Distribution spatiale** : Donn√©es uniform√©ment r√©parties = meilleures performances
2. **Taille des MBR** : MBR compacts = moins de faux positifs
3. **Niveau de zoom** : Requ√™tes localis√©es = tr√®s rapides

```sql
-- ‚úÖ Excellent : Recherche locale (petit rayon)
SELECT * FROM stores
WHERE ST_Distance_Sphere(location, :user_location) < 2000;
-- Index R-Tree tr√®s efficace

-- ‚ùå Moins bon : Recherche globale (grand rayon)
SELECT * FROM stores
WHERE ST_Distance_Sphere(location, :user_location) < 500000;
-- Beaucoup de MBR √† tester

-- ‚úÖ Optimisation : Filtrer d'abord avec MBR simple
SELECT * FROM stores
WHERE MBRContains(
    ST_GeomFromText('POLYGON((2.2 48.8, 2.5 48.8, 2.5 48.9, 2.2 48.9, 2.2 48.8))'),
    location
);
```

### Analyse avec EXPLAIN

```sql
EXPLAIN SELECT * FROM stores
WHERE ST_Distance_Sphere(
    location,
    ST_GeomFromText('POINT(2.3522 48.8566)', 4326)
) < 5000\G

-- V√©rifier :
-- type: range (utilise l'index Spatial)
-- key: idx_location (nom de l'index)
-- rows: estimation du nombre de lignes
```

---

## Cas d'usage pratiques

### Cas 1 : Application de livraison √† la demande

```sql
-- Structure pour livreurs et commandes
CREATE TABLE drivers (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    phone VARCHAR(20),
    current_location POINT NOT NULL SRID 4326,
    status ENUM('available', 'busy', 'offline') DEFAULT 'available',
    last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    SPATIAL INDEX idx_location (current_location),
    INDEX idx_status (status)
) ENGINE=InnoDB;

CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    customer_location POINT NOT NULL SRID 4326,
    restaurant_location POINT NOT NULL SRID 4326,
    status ENUM('pending', 'assigned', 'picked_up', 'delivered'),
    driver_id INT,
    SPATIAL INDEX idx_customer_loc (customer_location),
    SPATIAL INDEX idx_restaurant_loc (restaurant_location),
    INDEX idx_status (status)
) ENGINE=InnoDB;

-- Trouver les 5 livreurs disponibles les plus proches
SET @customer_location = ST_GeomFromText('POINT(2.3522 48.8566)', 4326);

SELECT
    d.id,
    d.name,
    d.phone,
    ST_Distance_Sphere(d.current_location, @customer_location) / 1000 AS distance_km,
    ST_X(d.current_location) AS longitude,
    ST_Y(d.current_location) AS latitude
FROM drivers d
WHERE d.status = 'available'
AND ST_Distance_Sphere(d.current_location, @customer_location) < 10000  -- 10 km max
ORDER BY distance_km
LIMIT 5;

-- Estimation du temps de trajet (basique : 30 km/h en ville)
SELECT
    d.id,
    d.name,
    ST_Distance_Sphere(d.current_location, @customer_location) / 1000 AS distance_km,
    (ST_Distance_Sphere(d.current_location, @customer_location) / 1000) / 30 * 60 AS eta_minutes
FROM drivers d
WHERE d.status = 'available'
ORDER BY distance_km
LIMIT 1;
```

### Cas 2 : Recherche de points d'int√©r√™t (POI)

```sql
CREATE TABLE points_of_interest (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255),
    category ENUM('restaurant', 'hotel', 'museum', 'park', 'pharmacy', 'hospital'),
    location POINT NOT NULL SRID 4326,
    rating DECIMAL(2,1),
    address TEXT,
    phone VARCHAR(20),
    SPATIAL INDEX idx_location (location),
    INDEX idx_category (category),
    INDEX idx_rating (rating)
) ENGINE=InnoDB;

-- Requ√™te typique : "Restaurants dans un rayon de 1 km, not√©s > 4.0"
SET @user_position = ST_GeomFromText('POINT(2.3522 48.8566)', 4326);

SELECT
    p.id,
    p.name,
    p.address,
    p.rating,
    ST_Distance_Sphere(p.location, @user_position) AS distance_meters,
    ROUND(ST_Distance_Sphere(p.location, @user_position)) AS distance_m_rounded
FROM points_of_interest p
WHERE p.category = 'restaurant'
AND p.rating >= 4.0
AND ST_Distance_Sphere(p.location, @user_position) < 1000
ORDER BY distance_meters, p.rating DESC
LIMIT 20;
```

### Cas 3 : Gestion de zones de couverture

```sql
CREATE TABLE service_areas (
    id INT PRIMARY KEY AUTO_INCREMENT,
    provider_name VARCHAR(100),
    coverage_zone POLYGON NOT NULL SRID 4326,
    service_type VARCHAR(50),
    active BOOLEAN DEFAULT TRUE,
    SPATIAL INDEX idx_coverage (coverage_zone)
) ENGINE=InnoDB;

-- V√©rifier si un client est dans une zone de couverture
SET @client_address = ST_GeomFromText('POINT(2.35 48.86)', 4326);

SELECT
    s.provider_name,
    s.service_type
FROM service_areas s
WHERE s.active = TRUE
AND ST_Contains(s.coverage_zone, @client_address);

-- Trouver tous les clients dans une zone donn√©e
SELECT
    c.id,
    c.name,
    c.address
FROM customers c, service_areas s
WHERE s.id = 5
AND ST_Contains(s.zone, c.location);

-- Calculer la surface de couverture
SELECT
    provider_name,
    ST_Area(coverage_zone) * 111 * 111 AS area_km2_approx
FROM service_areas
WHERE active = TRUE;
```

### Cas 4 : Analyse de trajectoires GPS

```sql
CREATE TABLE gps_tracks (
    id INT PRIMARY KEY AUTO_INCREMENT,
    vehicle_id INT,
    recorded_at TIMESTAMP,
    location POINT NOT NULL SRID 4326,
    speed_kmh DECIMAL(5,2),
    heading INT,  -- 0-360 degr√©s
    SPATIAL INDEX idx_location (location),
    INDEX idx_vehicle_time (vehicle_id, recorded_at)
) ENGINE=InnoDB;

-- Reconstituer le trajet d'un v√©hicule
SELECT
    recorded_at,
    ST_X(location) AS longitude,
    ST_Y(location) AS latitude,
    speed_kmh
FROM gps_tracks
WHERE vehicle_id = 123
AND recorded_at BETWEEN '2025-01-15 08:00:00' AND '2025-01-15 18:00:00'
ORDER BY recorded_at;

-- Calculer la distance totale parcourue
WITH track_points AS (
    SELECT
        location,
        LAG(location) OVER (ORDER BY recorded_at) AS prev_location
    FROM gps_tracks
    WHERE vehicle_id = 123
    AND recorded_at BETWEEN '2025-01-15 08:00:00' AND '2025-01-15 18:00:00'
)
SELECT
    SUM(ST_Distance_Sphere(location, prev_location)) / 1000 AS total_distance_km
FROM track_points
WHERE prev_location IS NOT NULL;

-- V√©hicules entr√©s dans une zone interdite
SELECT DISTINCT
    t.vehicle_id,
    t.recorded_at
FROM gps_tracks t, restricted_zones r
WHERE r.active = TRUE
AND ST_Contains(r.zone, t.location)
AND t.recorded_at > DATE_SUB(NOW(), INTERVAL 24 HOUR);
```

### Cas 5 : Syst√®me immobilier avec g√©olocalisation

```sql
CREATE TABLE properties (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255),
    description TEXT,
    location POINT NOT NULL SRID 4326,
    price DECIMAL(12,2),
    bedrooms INT,
    surface_m2 DECIMAL(6,2),
    property_type ENUM('apartment', 'house', 'studio'),
    SPATIAL INDEX idx_location (location),
    INDEX idx_price (price),
    INDEX idx_bedrooms (bedrooms)
) ENGINE=InnoDB;

-- Recherche multi-crit√®res avec g√©olocalisation
SET @search_center = ST_GeomFromText('POINT(2.3522 48.8566)', 4326);

SELECT
    p.id,
    p.title,
    p.price,
    p.bedrooms,
    p.surface_m2,
    ST_Distance_Sphere(p.location, @search_center) / 1000 AS distance_km
FROM properties p
WHERE p.property_type = 'apartment'
AND p.bedrooms >= 2
AND p.price BETWEEN 200000 AND 500000
AND ST_Distance_Sphere(p.location, @search_center) < 5000
ORDER BY distance_km, p.price
LIMIT 50;

-- Propri√©t√©s dans un quartier d√©limit√© (polygone)
SET @quartier = ST_GeomFromText('POLYGON((
    2.28 48.84,
    2.28 48.88,
    2.35 48.88,
    2.35 48.84,
    2.28 48.84
))', 4326);

SELECT
    p.id,
    p.title,
    p.price
FROM properties p
WHERE ST_Contains(@quartier, p.location)
AND p.price < 400000
ORDER BY p.price;
```

---

## Optimisations avanc√©es

### 1. MBR pour pr√©-filtrage rapide

```sql
-- MBRContains : Version rapide mais approximative
-- Utilise uniquement les rectangles englobants (plus rapide)
SELECT * FROM stores
WHERE MBRContains(
    ST_GeomFromText('POLYGON((2.2 48.8, 2.5 48.8, 2.5 48.9, 2.2 48.9, 2.2 48.8))'),
    location
);

-- ST_Contains : Version pr√©cise mais plus lente
-- Teste la g√©om√©trie r√©elle (plus pr√©cis)
SELECT * FROM stores
WHERE ST_Contains(
    ST_GeomFromText('POLYGON((2.2 48.8, 2.5 48.8, 2.5 48.9, 2.2 48.9, 2.2 48.8))'),
    location
);

-- ‚úÖ Combinaison optimale : MBR puis test pr√©cis
SELECT * FROM stores
WHERE MBRContains(@zone_mbr, location)  -- Filtre rapide
AND ST_Contains(@zone_precise, location);  -- Test pr√©cis final
```

### 2. D√©normalisation pour performance

```sql
-- Stocker des colonnes calcul√©es
CREATE TABLE locations_optimized (
    id INT PRIMARY KEY,
    name VARCHAR(255),
    location POINT NOT NULL SRID 4326,
    latitude DECIMAL(10,8) AS (ST_Y(location)) STORED,  -- Colonne g√©n√©r√©e
    longitude DECIMAL(10,8) AS (ST_X(location)) STORED,
    SPATIAL INDEX idx_location (location),
    INDEX idx_lat_lon (latitude, longitude)  -- Index B-Tree classique
) ENGINE=InnoDB;

-- Requ√™tes peuvent utiliser l'un ou l'autre selon le cas
```

### 3. Partitionnement g√©ographique

```sql
-- Partitionner par r√©gions pour grandes tables
CREATE TABLE global_stores (
    id INT PRIMARY KEY,
    name VARCHAR(255),
    location POINT NOT NULL SRID 4326,
    region VARCHAR(50),
    SPATIAL INDEX idx_location (location)
) ENGINE=InnoDB
PARTITION BY LIST COLUMNS(region) (
    PARTITION p_europe VALUES IN ('FR', 'DE', 'UK', 'ES', 'IT'),
    PARTITION p_americas VALUES IN ('US', 'CA', 'BR', 'MX'),
    PARTITION p_asia VALUES IN ('CN', 'JP', 'IN', 'SG')
);

-- Les requ√™tes filtr√©es par r√©gion sont plus rapides
SELECT * FROM global_stores
WHERE region = 'FR'
AND ST_Distance_Sphere(location, @paris) < 50000;
```

---

## Limitations et alternatives

### Limitations de MariaDB Spatial

| Limitation | Description | Workaround |
|------------|-------------|------------|
| **Pas de g√©od√©sie compl√®te** | Calculs simplifi√©s sur sph√®re | ST_Distance_Sphere est suffisant pour la plupart des cas |
| **2D uniquement** | Pas de support 3D (altitude) | Stocker altitude dans colonne s√©par√©e |
| **Fonctions limit√©es** | Moins riche que PostGIS | Calculs c√¥t√© application si n√©cessaire |
| **Pas de routage** | Pas de calcul d'itin√©raire | OSRM, GraphHopper en externe |
| **Performance SRID** | Calculs SRID peuvent √™tre lents | Utiliser SRID 0 pour calculs Cart√©siens si possible |

### PostGIS : L'alternative PostgreSQL

Si vous avez des besoins GIS tr√®s avanc√©s :

```
PostGIS (PostgreSQL) offre :
- Support 3D et 4D (temps)
- G√©od√©sie compl√®te (ellipso√Øde)
- 500+ fonctions spatiales
- Support raster
- Analyse de r√©seau (routage)
- Topologie avanc√©e

MariaDB Spatial est suffisant pour :
- Applications de livraison/localisation
- POI et cartographie simple
- Zones de couverture
- 95% des besoins "location-aware"
```

### Int√©gration avec services externes

```sql
-- MariaDB : stockage et filtrage spatial
-- Services externes : Calculs avanc√©s

-- 1. Routage : OSRM, GraphHopper
-- MariaDB trouve les points A et B
-- Service externe calcule l'itin√©raire optimal

-- 2. G√©ocodage : Google Maps API, Nominatim
-- Convertir adresses ‚Üí coordonn√©es
-- Stocker dans MariaDB

-- 3. Cartographie : Leaflet, Mapbox, Google Maps
-- MariaDB fournit les donn√©es
-- JavaScript affiche sur carte interactive
```

---

## ‚úÖ Points cl√©s √† retenir

- üó∫Ô∏è **R-Tree** : Structure d'index hi√©rarchique avec rectangles englobants (MBR)
- üìç **POINT(long, lat)** : Ordre X=longitude, Y=latitude (pi√®ge courant !)
- üåç **SRID 4326** : Standard GPS (WGS 84), toujours recommand√©
- üìè **ST_Distance_Sphere** : Distance r√©elle en m√®tres sur sph√®re (pas ST_Distance)
- üéØ **ST_Contains** : V√©rifier si point dans zone (use case le plus fr√©quent)
- üì¶ **Types g√©om√©triques** : POINT, LINESTRING, POLYGON + variantes MULTI*
- ‚ö° **Index obligatoire** : NOT NULL requis pour colonnes spatiales
- üîç **MBRContains** : Pr√©-filtrage rapide mais approximatif
- üí° **Cas d'usage** : Livraison, POI, zones de couverture, immobilier, GPS tracking
- ‚ö†Ô∏è **Limitations** : 2D uniquement, pas de routage natif, fonctions moins riches que PostGIS
- üé™ **Suffisant pour** : 95% des applications "location-aware" standards
- üöÄ **Alternative** : PostGIS si besoins GIS tr√®s avanc√©s (3D, topologie, r√©seau)

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB

- [üìñ Spatial Data Types](https://mariadb.com/kb/en/spatial-data-types/)
- [üìñ Spatial Indexes](https://mariadb.com/kb/en/spatial-index/)
- [üìñ Spatial Functions](https://mariadb.com/kb/en/spatial-functions/)
- [üìñ Geometry Constructors](https://mariadb.com/kb/en/geometry-constructors/)
- [üìñ Spatial Relationships](https://mariadb.com/kb/en/spatial-relationships/)

### Standards et r√©f√©rences

- [OGC Simple Features](https://www.ogc.org/standards/sfa) - Standard g√©ospatial
- [SRID 4326 (WGS 84)](https://epsg.io/4326) - Syst√®me de coordonn√©es GPS
- [Well-Known Text (WKT)](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry)
- [GeoJSON Format](https://geojson.org/)

### Outils et biblioth√®ques

- [Leaflet.js](https://leafletjs.com/) - Cartographie JavaScript
- [OSRM](http://project-osrm.org/) - Routage open-source
- [Nominatim](https://nominatim.org/) - G√©ocodage OpenStreetMap
- [PostGIS](https://postgis.net/) - Extension spatiale PostgreSQL (alternative)

### Articles et tutoriels

- [MariaDB Spatial Indexes Explained](https://mariadb.org/spatial-indexes/)
- [Building Location-Aware Applications](https://www.percona.com/blog/)
- [R-Tree Index Structure](https://en.wikipedia.org/wiki/R-tree)

---

## ‚û°Ô∏è Section suivante

**[5.3 Index VECTOR (HNSW) pour la recherche vectorielle](./03-index-vector-hnsw.md)** üÜï

D√©couvrez la grande nouveaut√© de MariaDB 11.8 LTS : les index VECTOR avec algorithme HNSW pour la recherche vectorielle et l'intelligence artificielle. Explorez les cas d'usage IA/ML : semantic search, chatbots RAG, syst√®mes de recommandation, et int√©gration avec OpenAI, LangChain et autres frameworks d'IA.

---


‚è≠Ô∏è [Index VECTOR (HNSW) pour la recherche vectorielle](/05-index-et-performance/03-index-vector-hnsw.md)
