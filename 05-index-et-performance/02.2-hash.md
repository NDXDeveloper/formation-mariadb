üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.2.2 Hash : √âgalit√© stricte

> **Niveau** : Interm√©diaire
> **Dur√©e estim√©e** : 1-1.5 heures

> **Pr√©requis** :
> - Section 5.1 - Fonctionnement des index B-Tree
> - Section 5.2.1 - B-Tree : Le standard
> - Notions de structures de donn√©es (hash tables)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre le fonctionnement d'un index Hash et sa structure interne
- Identifier les cas o√π un index Hash est appropri√© (et ceux o√π il ne l'est pas)
- Utiliser efficacement les index Hash avec le moteur MEMORY
- Distinguer les performances Hash (O(1)) vs B-Tree (O(log n))
- Comprendre pourquoi les index Hash sont rarement utilis√©s avec InnoDB
- √âviter les erreurs courantes li√©es aux index Hash

---

## Introduction

L'index **Hash** utilise une **table de hachage** pour mapper directement une cl√© √† un pointeur de ligne, permettant des recherches par √©galit√© en **temps constant O(1)**. C'est th√©oriquement l'index le plus rapide possible pour les lookups par √©galit√© stricte.

### Promesse vs R√©alit√©

```sql
-- Cr√©ation d'un index Hash
CREATE TABLE cache (
    key_id CHAR(32) PRIMARY KEY,
    value BLOB,
    expires_at TIMESTAMP,
    INDEX idx_key (key_id) USING HASH
) ENGINE=MEMORY;
```

**La promesse** :
- ‚ö° Recherche en O(1) - temps constant
- üéØ Ultra-rapide pour `WHERE column = value`
- üíæ Compact en m√©moire

**La r√©alit√©** :
- ‚ö†Ô∏è **Uniquement √©galit√© stricte** - pas de plages, pas de tri
- ‚ö†Ô∏è **Moteur MEMORY principalement** - InnoDB ignore USING HASH
- ‚ö†Ô∏è **Collisions possibles** - n√©cessite gestion des conflits
- ‚ö†Ô∏è **Pas d'index composites efficaces**

üí° **En pratique** : Les index Hash sont un **cas d'usage de niche**, principalement pour les tables en RAM avec lookups par cl√© unique.

---

## Fonctionnement d'un index Hash

### Principe de la table de hachage

Une table de hachage transforme une cl√© en position m√©moire via une **fonction de hachage** :

```
Fonction de hachage : key ‚Üí hash_value ‚Üí bucket

Exemple :
"session_abc123" ‚Üí hash("session_abc123") ‚Üí 3847362 ‚Üí bucket[3847362 % table_size]
```

### Structure interne

```
Table de hachage avec cha√Ænage pour collisions :

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Hash Table (array de buckets)               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Bucket  ‚îÇ Liste cha√Æn√©e (collisions)        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   0     ‚îÇ ‚Üí NULL                            ‚îÇ
‚îÇ   1     ‚îÇ ‚Üí [key: "abc", ptr: Row#123]      ‚îÇ
‚îÇ   2     ‚îÇ ‚Üí NULL                            ‚îÇ
‚îÇ   3     ‚îÇ ‚Üí [key: "xyz", ptr: Row#456] ‚Üí    ‚îÇ
‚îÇ         ‚îÇ   [key: "def", ptr: Row#789]      ‚îÇ ‚Üê Collision !
‚îÇ   4     ‚îÇ ‚Üí [key: "ghi", ptr: Row#012]      ‚îÇ
‚îÇ  ...    ‚îÇ                                   ‚îÇ
‚îÇ 1023    ‚îÇ ‚Üí NULL                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Taille typique : 1024-65536 buckets
```

### Algorithme de recherche

```
Recherche (key) :
1. hash_value = hash_function(key)
2. bucket_index = hash_value % table_size
3. bucket = hash_table[bucket_index]
4. Pour chaque entr√©e dans bucket :
   a. Si entr√©e.key == key : Retourner entr√©e.row_pointer
5. Si non trouv√© : Retourner NULL

Complexit√© :
- Cas id√©al (pas de collision) : O(1)
- Cas moyen : O(1) si table bien dimensionn√©e
- Pire cas (beaucoup de collisions) : O(n) dans le bucket
```

### Gestion des collisions

Deux cl√©s diff√©rentes peuvent produire le m√™me hash (collision) :

```sql
-- Exemple conceptuel de collision
hash("john@example.com")  ‚Üí 3847362
hash("jane@example.com")  ‚Üí 3847362  ‚Üê M√™me hash !

-- Les deux entr√©es vont dans le m√™me bucket
-- N√©cessite parcourir la liste cha√Æn√©e du bucket
```

**M√©thodes de r√©solution** :
1. **Cha√Ænage** (m√©thode de MariaDB) : Liste cha√Æn√©e dans chaque bucket
2. **Adressage ouvert** : Recherche du prochain bucket libre
3. **Double hashing** : Utiliser une seconde fonction de hachage

---

## Index Hash avec le moteur MEMORY

### Moteur MEMORY : Le cas d'usage principal

Le moteur **MEMORY** (anciennement HEAP) stocke toutes les donn√©es en RAM et supporte nativement les index Hash.

```sql
-- Table enti√®rement en m√©moire avec index Hash
CREATE TABLE sessions (
    session_id CHAR(64) PRIMARY KEY,
    user_id INT NOT NULL,
    ip_address VARCHAR(45),
    created_at TIMESTAMP,
    last_activity TIMESTAMP,
    data JSON,
    INDEX idx_session (session_id) USING HASH,
    INDEX idx_user (user_id) USING HASH
) ENGINE=MEMORY;
```

**Caract√©ristiques MEMORY + Hash** :

| Aspect | D√©tails |
|--------|---------|
| **Stockage** | 100% en RAM (dispara√Æt au red√©marrage) |
| **Vitesse** | Ultra-rapide (pas d'I/O disque) |
| **Index par d√©faut** | Hash (pas B-Tree !) |
| **Taille max** | Limit√©e par max_heap_table_size |
| **Persistance** | ‚ùå Aucune (donn√©es volatiles) |
| **Cas d'usage** | Cache, sessions, lookups temporaires |

### Configuration MEMORY

```sql
-- Taille maximale d'une table MEMORY
SHOW VARIABLES LIKE 'max_heap_table_size';
-- D√©faut : 16 MB

-- Augmenter pour tables plus grandes
SET GLOBAL max_heap_table_size = 134217728;  -- 128 MB

-- Taille maximale tmp tables en RAM
SHOW VARIABLES LIKE 'tmp_table_size';
```

### Requ√™tes optimis√©es avec Hash

```sql
-- ‚úÖ EXCELLENT : √âgalit√© stricte (O(1))
SELECT * FROM sessions WHERE session_id = 'abc123...xyz789';
-- Temps : 0.0001 seconde

-- ‚úÖ EXCELLENT : Lookup par cl√© unique
SELECT user_id, last_activity
FROM sessions
WHERE session_id = ?;

-- ‚úÖ BON : Multiple lookups
SELECT * FROM sessions
WHERE session_id IN ('abc123', 'def456', 'ghi789');
-- Chaque lookup est O(1)

-- ‚ùå TR√àS MAUVAIS : Range scan (full scan!)
SELECT * FROM sessions
WHERE session_id > 'abc123';
-- L'index Hash est IGNOR√â, full table scan

-- ‚ùå TR√àS MAUVAIS : Tri (full scan + sort!)
SELECT * FROM sessions
ORDER BY session_id;
-- L'index Hash ne peut pas aider au tri
```

---

## Limitations critiques des index Hash

### 1. √âgalit√© uniquement (pas de plages)

```sql
CREATE TABLE tokens (
    token CHAR(32) PRIMARY KEY,
    created INT,
    INDEX idx_token (token) USING HASH
) ENGINE=MEMORY;

-- ‚úÖ Utilise l'index Hash
SELECT * FROM tokens WHERE token = 'abc123';

-- ‚ùå N'utilise PAS l'index (full scan)
SELECT * FROM tokens WHERE token > 'abc123';
SELECT * FROM tokens WHERE token BETWEEN 'a' AND 'z';
SELECT * FROM tokens WHERE token >= 'abc123' AND token <= 'xyz789';

-- Raison : Hash ne maintient AUCUN ordre
-- Les valeurs sont dispers√©es al√©atoirement dans la table
```

### 2. Pas de tri (ORDER BY ignor√©)

```sql
-- ‚ùå Full scan + sort (tr√®s lent)
SELECT * FROM sessions
ORDER BY session_id
LIMIT 100;

-- L'index Hash ne peut pas fournir l'ordre
-- MariaDB doit :
-- 1. Scanner toute la table
-- 2. Trier en m√©moire (filesort)
-- 3. Retourner les 100 premiers
```

### 3. Pas de LIKE avec pr√©fixe

```sql
-- ‚ùå N'utilise PAS l'index
SELECT * FROM users WHERE username LIKE 'john%';

-- Hash ne supporte pas les recherches partielles
-- M√™me pour les pr√©fixes (contrairement √† B-Tree)
```

### 4. Index composites inefficaces

```sql
CREATE TABLE lookup (
    key1 VARCHAR(50),
    key2 VARCHAR(50),
    value TEXT,
    INDEX idx_composite (key1, key2) USING HASH
) ENGINE=MEMORY;

-- ‚ö†Ô∏è L'index composite Hash fonctionne DIFF√âREMMENT de B-Tree
-- Hash(key1, key2) ‚â† Hash(key1) + Hash(key2)

-- ‚úÖ Utilise l'index : toutes les colonnes sp√©cifi√©es
SELECT * FROM lookup WHERE key1 = 'a' AND key2 = 'b';

-- ‚ùå N'utilise PAS l'index : colonne partielle
SELECT * FROM lookup WHERE key1 = 'a';

-- Avec B-Tree, WHERE key1 = 'a' utiliserait l'index
-- Avec Hash, il faut TOUTES les colonnes de l'index
```

### 5. Pas de MIN/MAX optimis√©

```sql
-- ‚ùå Full scan n√©cessaire
SELECT MIN(session_id) FROM sessions;
SELECT MAX(created_at) FROM sessions;

-- L'index Hash ne maintient pas d'ordre
-- ‚Üí Doit scanner toutes les lignes
```

---

## Hash vs B-Tree : Comparaison d√©taill√©e

### Tableau comparatif

| Op√©ration | Hash | B-Tree | Gagnant |
|-----------|------|--------|---------|
| `WHERE col = value` | O(1) ‚ö° | O(log n) | Hash |
| `WHERE col IN (...)` | O(k) * O(1) | O(k) * O(log n) | Hash |
| `WHERE col BETWEEN x AND y` | ‚ùå O(n) | ‚úÖ O(log n + k) | B-Tree |
| `WHERE col > value` | ‚ùå O(n) | ‚úÖ O(log n + k) | B-Tree |
| `WHERE col LIKE 'abc%'` | ‚ùå O(n) | ‚úÖ O(log n + k) | B-Tree |
| `ORDER BY col` | ‚ùå O(n log n) | ‚úÖ O(n) ou O(k) | B-Tree |
| `MIN(col)` / `MAX(col)` | ‚ùå O(n) | ‚úÖ O(log n) | B-Tree |
| `GROUP BY col` | ‚ùå O(n log n) | ‚úÖ O(n) | B-Tree |
| Espace m√©moire | Plus compact | Plus volumineux | Hash |
| Index composite | Limit√© | Excellent | B-Tree |

*n = nombre total de lignes, k = nombre de r√©sultats*

### Benchmarks r√©els

Test sur table de 1 million de lignes en MEMORY :

```sql
-- Pr√©paration
CREATE TABLE benchmark (
    id INT PRIMARY KEY,
    lookup_key CHAR(32),
    value VARCHAR(255)
) ENGINE=MEMORY;

-- 1 million de lignes ins√©r√©es...

-- Test 1 : Index Hash
CREATE INDEX idx_hash ON benchmark(lookup_key) USING HASH;

SELECT * FROM benchmark WHERE lookup_key = 'test_key_500000';
-- Temps : 0.0001 seconde

SELECT * FROM benchmark WHERE lookup_key > 'test_key_500000' LIMIT 1000;
-- Temps : 1.2 secondes (full scan !)

-- Test 2 : Index B-Tree
DROP INDEX idx_hash ON benchmark;
CREATE INDEX idx_btree ON benchmark(lookup_key) USING BTREE;

SELECT * FROM benchmark WHERE lookup_key = 'test_key_500000';
-- Temps : 0.0002 seconde (2x plus lent que Hash, mais n√©gligeable)

SELECT * FROM benchmark WHERE lookup_key > 'test_key_500000' LIMIT 1000;
-- Temps : 0.003 seconde (400x plus rapide que Hash !)
```

**Conclusion** : La l√©g√®re perte de performance sur l'√©galit√© (0.0001 vs 0.0002s) est largement compens√©e par la polyvalence du B-Tree.

---

## Index Hash avec InnoDB : La v√©rit√©

### InnoDB ignore USING HASH

```sql
-- ‚ö†Ô∏è ATTENTION : Cette syntaxe est accept√©e mais IGNOR√âE
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    email VARCHAR(255),
    INDEX idx_email (email) USING HASH  -- Converti en B-Tree !
) ENGINE=InnoDB;

-- V√©rifier le type r√©el
SHOW INDEX FROM users;

-- R√©sultat :
-- Index_type: BTREE  ‚Üê Pas HASH !
```

**Pourquoi InnoDB ignore Hash ?**

1. **Architecture diff√©rente** : InnoDB utilise des pages de 16 KB, optimis√©es pour B-Tree
2. **Persistance** : Les index doivent survivre aux red√©marrages
3. **Transactions** : B-Tree supporte mieux MVCC et les verrous
4. **I/O s√©quentiel** : B-Tree est plus efficace pour les lectures disque

### Adaptive Hash Index : L'exception

InnoDB poss√®de un **Adaptive Hash Index** (AHI) interne :

```sql
-- V√©rifier si AHI est activ√©
SHOW VARIABLES LIKE 'innodb_adaptive_hash_index';

-- Statistiques AHI
SHOW ENGINE INNODB STATUS\G

-- Section "INSERT BUFFER AND ADAPTIVE HASH INDEX" :
-- Hash table size 34679, node heap has 0 buffer(s)
-- 15.23 hash searches/s, 10.45 non-hash searches/s
```

**Fonctionnement AHI** :
- InnoDB construit **automatiquement** des index Hash en m√©moire
- Pour les pages B-Tree **fr√©quemment acc√©d√©es**
- Compl√®tement **transparent** (pas de configuration n√©cessaire)
- Am√©liore les performances sans intervention manuelle

üí° **Note** : L'AHI est un m√©canisme interne diff√©rent de `USING HASH` explicite.

---

## Cas d'usage appropri√©s pour Hash

### 1. Cache de sessions applicatif

```sql
CREATE TABLE session_cache (
    session_id CHAR(64) PRIMARY KEY,
    user_id INT,
    username VARCHAR(100),
    permissions JSON,
    created_at TIMESTAMP,
    expires_at TIMESTAMP,
    INDEX idx_session (session_id) USING HASH
) ENGINE=MEMORY
MAX_ROWS=100000;

-- Insertion
INSERT INTO session_cache VALUES
('abc123...', 1001, 'john', '["read","write"]', NOW(), NOW() + INTERVAL 1 HOUR);

-- Lookup ultra-rapide
SELECT user_id, username, permissions
FROM session_cache
WHERE session_id = 'abc123...';

-- Nettoyage p√©riodique des sessions expir√©es
DELETE FROM session_cache WHERE expires_at < NOW();
```

### 2. Lookup tables de r√©f√©rence

```sql
CREATE TABLE country_codes (
    code CHAR(2) PRIMARY KEY,
    name VARCHAR(100),
    currency CHAR(3),
    phone_prefix VARCHAR(10),
    INDEX idx_code (code) USING HASH
) ENGINE=MEMORY;

-- 200-300 pays : table petite, 100% en RAM
INSERT INTO country_codes VALUES
('FR', 'France', 'EUR', '+33'),
('US', 'United States', 'USD', '+1'),
('DE', 'Germany', 'EUR', '+49');

-- Lookup O(1)
SELECT name, currency FROM country_codes WHERE code = 'FR';
```

### 3. Cache de r√©sultats de calculs

```sql
CREATE TABLE computation_cache (
    input_hash CHAR(32) PRIMARY KEY,
    result TEXT,
    computed_at TIMESTAMP,
    INDEX idx_hash (input_hash) USING HASH
) ENGINE=MEMORY;

-- √âviter de recalculer des r√©sultats identiques
-- 1. Calculer hash des param√®tres d'entr√©e
-- 2. V√©rifier si r√©sultat existe en cache
SELECT result FROM computation_cache WHERE input_hash = MD5(CONCAT(param1, param2));
-- 3. Si absent, calculer et stocker
```

### 4. Rate limiting / Compteurs temporaires

```sql
CREATE TABLE rate_limit (
    identifier VARCHAR(100) PRIMARY KEY,  -- IP ou user_id
    request_count INT DEFAULT 1,
    window_start TIMESTAMP,
    INDEX idx_identifier (identifier) USING HASH
) ENGINE=MEMORY;

-- Check + increment en une transaction
INSERT INTO rate_limit VALUES (?, 1, NOW())
ON DUPLICATE KEY UPDATE
    request_count = request_count + 1;

-- V√©rifier la limite
SELECT request_count FROM rate_limit
WHERE identifier = ?
AND window_start > NOW() - INTERVAL 1 MINUTE;
```

---

## Quand NE PAS utiliser Hash

### ‚ùå Anti-pattern 1 : Tables de production persistantes

```sql
-- ‚ùå MAUVAIS : Donn√©es critiques
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    INDEX idx_customer (customer_id) USING HASH
) ENGINE=MEMORY;  -- Perdu au red√©marrage !

-- ‚úÖ BON : Persistance avec InnoDB
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    INDEX idx_customer (customer_id)  -- B-Tree implicite
) ENGINE=InnoDB;
```

### ‚ùå Anti-pattern 2 : Requ√™tes avec plages

```sql
-- ‚ùå MAUVAIS : Pattern avec range scans
CREATE TABLE events (
    event_id INT PRIMARY KEY,
    timestamp DATETIME,
    INDEX idx_time (timestamp) USING HASH  -- Inefficace !
) ENGINE=MEMORY;

SELECT * FROM events
WHERE timestamp >= '2025-01-01'
AND timestamp < '2025-02-01';
-- Full scan avec index Hash

-- ‚úÖ BON : B-Tree pour plages
CREATE INDEX idx_time ON events(timestamp) USING BTREE;
```

### ‚ùå Anti-pattern 3 : Besoin de tri

```sql
-- ‚ùå MAUVAIS : Requ√™tes avec ORDER BY
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    name VARCHAR(255),
    price DECIMAL(10,2),
    INDEX idx_price (price) USING HASH
) ENGINE=MEMORY;

SELECT * FROM products ORDER BY price LIMIT 10;
-- Index ignor√©, full scan + filesort

-- ‚úÖ BON : B-Tree pour tri
CREATE INDEX idx_price ON products(price) USING BTREE;
```

### ‚ùå Anti-pattern 4 : Tables volumineuses

```sql
-- ‚ùå MAUVAIS : Millions de lignes en RAM
CREATE TABLE logs (
    log_id BIGINT PRIMARY KEY,
    message TEXT
) ENGINE=MEMORY;
-- ‚Üí √âpuise la RAM rapidement

-- ‚úÖ BON : InnoDB avec gestion I/O
CREATE TABLE logs (
    log_id BIGINT PRIMARY KEY,
    message TEXT
) ENGINE=InnoDB;
```

---

## Configuration et tuning

### Taille de la table Hash

```sql
-- Taille maximale tables MEMORY (par table)
SET GLOBAL max_heap_table_size = 268435456;  -- 256 MB

-- Pour session courante uniquement
SET SESSION max_heap_table_size = 268435456;

-- V√©rifier l'utilisation actuelle
SELECT
    table_name,
    ROUND((data_length + index_length) / 1024 / 1024, 2) AS size_mb
FROM information_schema.TABLES
WHERE engine = 'MEMORY'
AND table_schema = 'mydb';
```

### Nombre de buckets

Le nombre de buckets influence les collisions :

```sql
-- Plus de lignes ‚Üí plus de buckets n√©cessaires
-- Nombre de buckets ‚âà nombre de lignes attendu

CREATE TABLE large_cache (
    key_id INT PRIMARY KEY,
    value TEXT
) ENGINE=MEMORY
MAX_ROWS=1000000;  -- Indique le volume attendu

-- MariaDB ajuste automatiquement le nombre de buckets
-- en fonction de MAX_ROWS
```

### Monitoring des tables MEMORY

```sql
-- Tables en m√©moire et leur taille
SELECT
    table_name,
    engine,
    table_rows,
    ROUND((data_length + index_length) / 1024 / 1024, 2) AS size_mb,
    max_data_length / 1024 / 1024 AS max_size_mb
FROM information_schema.TABLES
WHERE engine = 'MEMORY'
ORDER BY data_length + index_length DESC;

-- V√©rifier si limite atteinte
SHOW WARNINGS;
-- "The table 'X' is full" si max_heap_table_size d√©pass√©
```

---

## Migration Hash ‚Üí B-Tree

### √âvaluer si Hash est n√©cessaire

```sql
-- Analyser les requ√™tes sur une table
-- Via slow query log ou Performance Schema

SELECT
    digest_text,
    count_star AS executions,
    sum_rows_examined AS total_rows_examined,
    sum_rows_sent AS total_rows_sent
FROM performance_schema.events_statements_summary_by_digest
WHERE digest_text LIKE '%your_table%'
ORDER BY count_star DESC
LIMIT 10;

-- Questions √† se poser :
-- 1. Y a-t-il des plages (BETWEEN, >, <) ? ‚Üí B-Tree
-- 2. Y a-t-il des ORDER BY ? ‚Üí B-Tree
-- 3. Uniquement des √©galit√©s exactes ? ‚Üí Hash possible
-- 4. Les donn√©es doivent persister ? ‚Üí InnoDB + B-Tree
```

### Conversion MEMORY ‚Üí InnoDB

```sql
-- Avant : Table volatile en RAM
CREATE TABLE temp_cache (
    id INT PRIMARY KEY,
    data TEXT,
    INDEX idx_id (id) USING HASH
) ENGINE=MEMORY;

-- Apr√®s : Table persistante
CREATE TABLE persistent_cache (
    id INT PRIMARY KEY,
    data TEXT,
    INDEX idx_id (id)  -- B-Tree par d√©faut
) ENGINE=InnoDB;

-- Migration des donn√©es
INSERT INTO persistent_cache SELECT * FROM temp_cache;

-- Supprimer l'ancienne table
DROP TABLE temp_cache;
```

---

## Alternatives modernes

### 1. Redis / Memcached pour cache

Pour du cache pur avec lookups par cl√© :

```sql
-- Au lieu de :
CREATE TABLE cache (key VARCHAR(255), value TEXT) ENGINE=MEMORY;

-- Consid√©rer :
-- Redis : Structure de donn√©es avanc√©es, persistance optionnelle
-- Memcached : Ultra-simple, ultra-rapide, volatile
```

**Avantages** :
- Serveur d√©di√© (pas de contention avec MySQL)
- Meilleures performances en g√©n√©ral
- Gestion automatique de l'√©viction (LRU)
- Scaling horizontal plus facile

### 2. InnoDB avec Adaptive Hash Index

```sql
-- Laisser InnoDB g√©rer automatiquement
CREATE TABLE hot_data (
    id INT PRIMARY KEY,
    value TEXT,
    INDEX idx_id (id)  -- B-Tree
) ENGINE=InnoDB;

-- InnoDB cr√©era automatiquement des hash indexes internes
-- pour les pages fr√©quemment acc√©d√©es
```

### 3. ProxySQL Query Cache

```sql
-- Cache de r√©sultats au niveau proxy
-- Plus efficace que tables MEMORY dans certains cas
-- Configuration ProxySQL :
-- mysql_query_rules : cache_ttl, cache_empty_result
```

---

## Erreurs courantes

### Erreur 1 : Croire que Hash fonctionne avec InnoDB

```sql
-- ‚ùå Croit utiliser Hash, utilise B-Tree en r√©alit√©
CREATE TABLE users (
    id INT PRIMARY KEY,
    email VARCHAR(255),
    INDEX idx_email (email) USING HASH
) ENGINE=InnoDB;  -- Hash ignor√© !

-- ‚úÖ V√©rifier syst√©matiquement
SHOW INDEX FROM users;
-- Index_type: BTREE
```

### Erreur 2 : Hash pour donn√©es avec range queries

```sql
-- ‚ùå Pattern inappropri√©
CREATE TABLE logs (
    timestamp DATETIME,
    message TEXT,
    INDEX idx_time (timestamp) USING HASH
) ENGINE=MEMORY;

-- Les requ√™tes r√©elles utilisent des plages
SELECT * FROM logs
WHERE timestamp BETWEEN '2025-01-01' AND '2025-01-31';
-- Full scan car Hash ne supporte pas les plages

-- ‚úÖ Utiliser B-Tree
CREATE INDEX idx_time ON logs(timestamp) USING BTREE;
```

### Erreur 3 : Oublier la volatilit√© de MEMORY

```sql
-- ‚ùå Donn√©es critiques en MEMORY
CREATE TABLE user_sessions (
    session_id CHAR(64) PRIMARY KEY,
    user_id INT
) ENGINE=MEMORY;

-- Red√©marrage MySQL ‚Üí TOUTES LES DONN√âES PERDUES

-- ‚úÖ Accepter la volatilit√© OU utiliser InnoDB
-- Si perte acceptable : OK
-- Si persistance n√©cessaire : InnoDB
```

---

## ‚úÖ Points cl√©s √† retenir

- #Ô∏è‚É£ **Hash = O(1)** : Complexit√© temps constant pour √©galit√© stricte (th√©orique)
- üéØ **√âgalit√© uniquement** : Pas de plages, pas de tri, pas de LIKE, pas de comparaisons
- üíæ **MEMORY engine** : Cas d'usage principal, donn√©es 100% en RAM
- üîÑ **InnoDB ignore Hash** : Converti automatiquement en B-Tree
- üìä **B-Tree souvent meilleur** : La diff√©rence O(1) vs O(log n) est n√©gligeable en pratique
- ‚ö° **Cas d'usage** : Sessions, cache, lookup tables, rate limiting
- ‚ùå **√âviter pour** : Donn√©es persistantes, plages, tri, production critique
- üîß **Adaptive Hash Index** : InnoDB cr√©e automatiquement des hash internes (transparent)
- üöÄ **Alternatives** : Redis/Memcached pour cache, InnoDB pour tout le reste
- üìè **Trade-off** : Gain minime sur √©galit√© vs perte massive sur tout le reste
- üí° **R√®gle pratique** : Utilisez B-Tree par d√©faut, Hash uniquement si besoin sp√©cifique prouv√©
- üéì **Hash != Silver bullet** : Type d'index le plus sp√©cialis√© et limit√©

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB

- [üìñ MEMORY Storage Engine](https://mariadb.com/kb/en/memory-storage-engine/)
- [üìñ CREATE INDEX - USING HASH](https://mariadb.com/kb/en/create-index/#using-hash)
- [üìñ InnoDB Adaptive Hash Index](https://mariadb.com/kb/en/innodb-adaptive-hash-index/)
- [üìñ Index Types](https://mariadb.com/kb/en/storage-engine-index-types/)

### Articles techniques

- [Hash Index vs B-Tree Index](https://www.percona.com/blog/hash-index-vs-btree-index/)
- [MySQL MEMORY Tables](https://dev.mysql.com/doc/refman/8.0/en/memory-storage-engine.html)
- [When to Use HASH Indexes](https://use-the-index-luke.com/)

### Ressources compl√©mentaires

- [Redis vs MySQL for Caching](https://scalegrid.io/blog/redis-vs-mysql-cache/)
- [Understanding Hash Tables](https://en.wikipedia.org/wiki/Hash_table)

---

## ‚û°Ô∏è Section suivante

**[5.2.3 Full-Text : Recherche textuelle](./02.3-full-text.md)**

D√©couvrez les index Full-Text, sp√©cialis√©s pour la recherche de mots-cl√©s dans des textes longs : modes de recherche (Natural Language, Boolean, Query Expansion), configuration des stopwords, scoring de pertinence, et cas d'usage pour blogs, documentation et syst√®mes de support.

---


‚è≠Ô∏è [Full-Text : Recherche textuelle](/05-index-et-performance/02.3-full-text.md)
