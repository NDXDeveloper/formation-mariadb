üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.5.1 Index sur colonnes fr√©quemment filtr√©es

> **Niveau** : Interm√©diaire
> **Dur√©e estim√©e** : 1.5 heures
> **Pr√©requis** : Section 5.5 (Strat√©gies d'indexation)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Identifier les colonnes prioritaires pour l'indexation dans les clauses WHERE
- Appliquer les bonnes pratiques d'indexation selon le type de donn√©es
- Optimiser les requ√™tes avec op√©rateurs de comparaison et recherche
- Comprendre les limitations et cas particuliers de l'utilisation des index
- √âviter les pi√®ges courants qui emp√™chent l'utilisation des index

---

## Introduction

Les colonnes utilis√©es dans les clauses **WHERE** sont les candidates prioritaires pour l'indexation, car elles d√©terminent directement **combien de lignes** MariaDB doit examiner pour r√©pondre √† une requ√™te. Un index bien plac√© peut r√©duire cette quantit√© de plusieurs **millions de lignes √† quelques centaines**, transformant une requ√™te de 10 secondes en quelques millisecondes.

Cependant, toutes les colonnes filtr√©es ne b√©n√©ficient pas √©galement de l'indexation. Cette section explore les **patterns sp√©cifiques** o√π les index apportent le plus de valeur.

üí° **Principe fondamental** : Un index sur une colonne WHERE n'est utile que si la requ√™te filtre **suffisamment de donn√©es** pour justifier le parcours de l'index plut√¥t qu'un full scan.

---

## Identification des colonnes √† indexer

### Analyse des requ√™tes fr√©quentes

La premi√®re √©tape consiste √† identifier quelles colonnes apparaissent le plus souvent dans vos clauses WHERE :

```sql
-- Activer le monitoring des requ√™tes
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 0.5; -- Capturer requ√™tes > 0.5 sec
SET GLOBAL log_queries_not_using_indexes = 'ON';

-- Apr√®s quelques jours, analyser les patterns avec Performance Schema
SELECT
    DIGEST_TEXT,
    COUNT_STAR as execution_count,
    AVG_TIMER_WAIT / 1000000000 as avg_time_sec,
    SUM_ROWS_EXAMINED / COUNT_STAR as avg_rows_examined
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = 'your_database'
ORDER BY COUNT_STAR DESC
LIMIT 20;
```

### Crit√®res de priorisation

**Colonnes hautement prioritaires pour l'indexation** :

1. **Cl√©s primaires et uniques** : D√©j√† index√©es automatiquement
2. **Cl√©s √©trang√®res** : Utilis√©es dans les jointures
3. **Colonnes de filtrage principal** : Utilis√©es dans 80%+ des requ√™tes
4. **Colonnes √† haute s√©lectivit√©** : Beaucoup de valeurs distinctes
5. **Colonnes des requ√™tes critiques** : Impact business important

```sql
-- Exemple : identification des colonnes √† forte s√©lectivit√©
SELECT
    'email' AS column_name,
    COUNT(DISTINCT email) AS distinct_values,
    COUNT(*) AS total_rows,
    COUNT(DISTINCT email) / COUNT(*) AS selectivity
FROM users
UNION ALL
SELECT
    'country',
    COUNT(DISTINCT country),
    COUNT(*),
    COUNT(DISTINCT country) / COUNT(*)
FROM users
UNION ALL
SELECT
    'status',
    COUNT(DISTINCT status),
    COUNT(*),
    COUNT(DISTINCT status) / COUNT(*)
FROM users;

-- R√©sultat exemple :
-- email    : 150000 valeurs / 150000 lignes = 1.00 (excellent)
-- country  : 195 valeurs / 150000 lignes    = 0.001 (faible)
-- status   : 3 valeurs / 150000 lignes      = 0.00002 (tr√®s faible)
```

**R√®gle empirique de s√©lectivit√©** :
- **> 0.5** : Index probablement tr√®s efficace
- **0.1-0.5** : Index utile selon volum√©trie et patterns
- **< 0.1** : Questionner la pertinence, sauf dans index composite

---

## Indexation par type de donn√©es

### Colonnes num√©riques (INT, BIGINT, DECIMAL)

Les **types num√©riques** sont les plus efficaces pour l'indexation gr√¢ce √† leur taille fixe et compacte.

```sql
-- Table exemple : produits e-commerce
CREATE TABLE products (
    product_id INT AUTO_INCREMENT PRIMARY KEY,
    sku VARCHAR(50) NOT NULL,
    name VARCHAR(255),
    price DECIMAL(10,2),
    stock_quantity INT,
    category_id INT,
    brand_id INT,
    is_active TINYINT(1),
    created_at DATETIME
) ENGINE=InnoDB;

-- Requ√™te typique : recherche par cat√©gorie
SELECT product_id, name, price
FROM products
WHERE category_id = 15
  AND is_active = 1
ORDER BY price ASC
LIMIT 20;

-- Index recommand√©
CREATE INDEX idx_products_category_active_price
ON products(category_id, is_active, price);
```

**Avantages des colonnes num√©riques** :
- ‚úÖ Comparaisons tr√®s rapides (CPU)
- ‚úÖ Taille compacte en m√©moire (4-8 octets)
- ‚úÖ Index B-Tree optimal pour plages de valeurs

**Cas d'usage fr√©quents** :
```sql
-- √âgalit√© stricte
WHERE user_id = 12345;
CREATE INDEX idx_table_user_id ON table_name(user_id);

-- Plages de valeurs
WHERE price BETWEEN 10.00 AND 50.00;
WHERE quantity > 100;
CREATE INDEX idx_products_price ON products(price);

-- IN avec liste de valeurs
WHERE category_id IN (1, 5, 8, 12);
CREATE INDEX idx_products_category ON products(category_id);
```

‚ö†Ô∏è **Attention aux colonnes bool√©ennes** :
```sql
-- Colonne is_active avec seulement 2 valeurs (0, 1)
-- Index seul peu efficace si distribution d√©s√©quilibr√©e

-- ‚ùå Faible utilit√© si 95% des lignes ont is_active = 1
CREATE INDEX idx_products_active ON products(is_active);

-- ‚úÖ Meilleur dans un index composite pour filtrer en amont
CREATE INDEX idx_products_active_category
ON products(is_active, category_id);
```

### Colonnes de cha√Ænes (VARCHAR, CHAR)

Les **cha√Ænes de caract√®res** sont plus co√ªteuses en espace et comparaisons, mais restent tr√®s courantes.

```sql
-- Requ√™te typique : recherche par code produit
SELECT * FROM products WHERE sku = 'LAPTOP-DELL-XPS15-2024';

-- Index sur VARCHAR
CREATE INDEX idx_products_sku ON products(sku);
```

**Optimisations pour VARCHAR** :

1. **Index sur pr√©fixe** pour colonnes longues :
```sql
-- Colonnes tr√®s longues (URL, description)
ALTER TABLE articles ADD COLUMN url VARCHAR(2000);

-- ‚ùå Index complet = co√ªteux en espace
CREATE INDEX idx_articles_url ON articles(url);

-- ‚úÖ Index sur pr√©fixe (premiers N caract√®res)
CREATE INDEX idx_articles_url_prefix ON articles(url(100));

-- V√©rifier la s√©lectivit√© du pr√©fixe
SELECT
    COUNT(DISTINCT url) AS full_column,
    COUNT(DISTINCT LEFT(url, 50)) AS prefix_50,
    COUNT(DISTINCT LEFT(url, 100)) AS prefix_100,
    COUNT(DISTINCT LEFT(url, 150)) AS prefix_150
FROM articles;
```

üí° **R√®gle** : Choisir une longueur de pr√©fixe qui capte **95%+ de la s√©lectivit√©** de la colonne compl√®te.

2. **Sensibilit√© √† la casse** :
```sql
-- Par d√©faut, utf8mb4_general_ci est case-insensitive
SELECT * FROM users WHERE email = 'john@example.com';
SELECT * FROM users WHERE email = 'JOHN@EXAMPLE.COM';
-- Ces deux requ√™tes utilisent le m√™me index

-- Pour recherche case-sensitive
ALTER TABLE users MODIFY email VARCHAR(255)
COLLATE utf8mb4_bin;

CREATE INDEX idx_users_email ON users(email);
```

3. **Pattern LIKE** :
```sql
-- ‚úÖ Index utilisable : wildcard √† la fin
SELECT * FROM products WHERE sku LIKE 'LAPTOP%';
-- Utilise idx_products_sku

-- ‚ùå Index NON utilisable : wildcard au d√©but
SELECT * FROM products WHERE sku LIKE '%LAPTOP';
-- Full table scan obligatoire

-- ‚ùå Index NON utilisable : wildcard des deux c√¥t√©s
SELECT * FROM products WHERE sku LIKE '%LAPTOP%';
-- Utiliser FULLTEXT index pour ce cas
```

**Solution pour recherche avec wildcards** :
```sql
-- Cr√©er un index FULLTEXT pour recherche textuelle
CREATE FULLTEXT INDEX idx_products_sku_fulltext
ON products(sku);

-- Requ√™te avec MATCH AGAINST
SELECT * FROM products
WHERE MATCH(sku) AGAINST('LAPTOP' IN BOOLEAN MODE);
```

### Colonnes temporelles (DATE, DATETIME, TIMESTAMP)

Les **colonnes de dates** sont tr√®s fr√©quentes pour filtrer par p√©riodes (logs, commandes, √©v√©nements).

```sql
-- Table exemple : commandes
CREATE TABLE orders (
    order_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date DATETIME NOT NULL,
    status VARCHAR(20),
    total_amount DECIMAL(10,2),
    INDEX idx_customer (customer_id)
) ENGINE=InnoDB;

-- Requ√™te typique : commandes sur p√©riode
SELECT order_id, total_amount
FROM orders
WHERE order_date >= '2024-01-01'
  AND order_date < '2025-01-01'
  AND status = 'completed';

-- Index recommand√© : status avant date (filtre √©galit√© en premier)
CREATE INDEX idx_orders_status_date
ON orders(status, order_date);
```

**Patterns de requ√™tes temporelles** :

1. **Plages de dates** :
```sql
-- Plage explicite (recommand√©)
WHERE order_date BETWEEN '2024-01-01' AND '2024-12-31';
WHERE order_date >= '2024-01-01' AND order_date < '2025-01-01';

-- Index simple ou composite
CREATE INDEX idx_orders_date ON orders(order_date);
```

2. **üÜï √âviter les fonctions sur colonnes index√©es** :
```sql
-- ‚ùå MAUVAIS : fonction emp√™che l'utilisation de l'index
SELECT * FROM orders
WHERE YEAR(order_date) = 2024;
-- Index idx_orders_date NON utilis√© !

-- ‚úÖ BON : condition directe sur la colonne
SELECT * FROM orders
WHERE order_date >= '2024-01-01'
  AND order_date < '2025-01-01';
-- Index idx_orders_date utilis√©

-- Alternative : colonne g√©n√©r√©e
ALTER TABLE orders
ADD COLUMN order_year SMALLINT AS (YEAR(order_date)) VIRTUAL;

CREATE INDEX idx_orders_year ON orders(order_year);

-- Requ√™te avec colonne g√©n√©r√©e
SELECT * FROM orders WHERE order_year = 2024;
```

3. **Requ√™tes relatives (aujourd'hui, cette semaine)** :
```sql
-- Aujourd'hui
WHERE order_date >= CURDATE()
  AND order_date < CURDATE() + INTERVAL 1 DAY;

-- 30 derniers jours
WHERE order_date >= NOW() - INTERVAL 30 DAY;

-- Ce mois
WHERE order_date >= DATE_FORMAT(NOW(), '%Y-%m-01')
  AND order_date < DATE_FORMAT(NOW(), '%Y-%m-01') + INTERVAL 1 MONTH;
```

üí° **Astuce** : Pour requ√™tes fr√©quentes sur "mois en cours", cr√©er une colonne g√©n√©r√©e :
```sql
ALTER TABLE orders
ADD COLUMN order_month CHAR(7) AS (DATE_FORMAT(order_date, '%Y-%m')) VIRTUAL;

CREATE INDEX idx_orders_month ON orders(order_month);

-- Requ√™te rapide
SELECT * FROM orders WHERE order_month = '2024-12';
```

4. **üÜï Extension TIMESTAMP 2106 (MariaDB 11.8)** :
```sql
-- Depuis MariaDB 11.8, TIMESTAMP √©tendu jusqu'en 2106
-- R√©solution du probl√®me Y2038 (auparavant limit√© √† 2038-01-19)

CREATE TABLE events (
    event_id BIGINT PRIMARY KEY,
    event_timestamp TIMESTAMP NOT NULL, -- Supporte dates jusqu'en 2106
    description TEXT
);

CREATE INDEX idx_events_timestamp ON events(event_timestamp);

-- Requ√™tes sur dates futures (au-del√† de 2038)
SELECT * FROM events
WHERE event_timestamp >= '2050-01-01 00:00:00';
```

### Colonnes UUID et GUID

Les **UUID** (Universally Unique Identifier) sont de plus en plus utilis√©s comme cl√©s primaires dans les architectures distribu√©es.

```sql
-- Table avec UUID comme cl√© primaire
CREATE TABLE customers (
    customer_uuid BINARY(16) PRIMARY KEY, -- Stockage optimis√©
    email VARCHAR(255) UNIQUE NOT NULL,
    name VARCHAR(100),
    created_at DATETIME DEFAULT NOW()
) ENGINE=InnoDB;

-- Index sur UUID
CREATE INDEX idx_customers_email ON customers(email);
```

**Recommandations UUID** :

1. **Format de stockage** :
```sql
-- ‚ùå √âviter : stockage en VARCHAR(36) = 36 octets
customer_uuid CHAR(36) -- '550e8400-e29b-41d4-a716-446655440000'

-- ‚úÖ Pr√©f√©rer : stockage en BINARY(16) = 16 octets
customer_uuid BINARY(16) -- Stockage compact

-- Conversion lors de l'insertion
INSERT INTO customers (customer_uuid, email, name)
VALUES (UNHEX(REPLACE(UUID(), '-', '')), 'user@example.com', 'John Doe');

-- Conversion lors de la lecture
SELECT
    LOWER(CONCAT(
        SUBSTR(HEX(customer_uuid), 1, 8), '-',
        SUBSTR(HEX(customer_uuid), 9, 4), '-',
        SUBSTR(HEX(customer_uuid), 13, 4), '-',
        SUBSTR(HEX(customer_uuid), 17, 4), '-',
        SUBSTR(HEX(customer_uuid), 21)
    )) AS customer_uuid,
    email, name
FROM customers;
```

2. **UUID v1 vs UUID v4** :
```sql
-- UUID v4 (random) : fragmentation d'index importante
-- UUID v1 (time-based) : meilleure localit√©, moins de fragmentation

-- Utiliser UUID v1 pour cl√©s primaires quand possible
-- Ou UUID v7 (time-ordered, draft RFC)
```

üí° **Alternative moderne** : Type **UUID** natif (MariaDB 10.7+) :
```sql
-- Type UUID natif
CREATE TABLE orders_v2 (
    order_uuid UUID PRIMARY KEY DEFAULT UUID(),
    customer_id INT,
    total DECIMAL(10,2)
) ENGINE=InnoDB;

-- Recherche directe
SELECT * FROM orders_v2
WHERE order_uuid = '550e8400-e29b-41d4-a716-446655440000';
```

### Colonnes JSON

Les **colonnes JSON** permettent un sch√©ma flexible, mais l'indexation n√©cessite des techniques sp√©cifiques.

```sql
-- Table avec donn√©es JSON
CREATE TABLE products_catalog (
    product_id INT AUTO_INCREMENT PRIMARY KEY,
    data JSON NOT NULL,
    created_at DATETIME DEFAULT NOW()
) ENGINE=InnoDB;

-- Exemple de document JSON
INSERT INTO products_catalog (data) VALUES (
'{
    "sku": "LAPTOP-001",
    "name": "Dell XPS 15",
    "price": 1299.99,
    "specs": {
        "cpu": "Intel i7",
        "ram": "16GB",
        "storage": "512GB SSD"
    },
    "tags": ["laptop", "premium", "business"]
}'
);
```

**Strat√©gie d'indexation JSON** :

1. **Colonnes virtuelles extraites** :
```sql
-- Cr√©er des colonnes virtuelles pour les champs fr√©quemment filtr√©s
ALTER TABLE products_catalog
ADD COLUMN sku VARCHAR(50)
    AS (JSON_UNQUOTE(JSON_EXTRACT(data, '$.sku'))) VIRTUAL,
ADD COLUMN price DECIMAL(10,2)
    AS (JSON_EXTRACT(data, '$.price')) VIRTUAL,
ADD COLUMN cpu VARCHAR(50)
    AS (JSON_UNQUOTE(JSON_EXTRACT(data, '$.specs.cpu'))) VIRTUAL;

-- Indexer les colonnes virtuelles
CREATE INDEX idx_catalog_sku ON products_catalog(sku);
CREATE INDEX idx_catalog_price ON products_catalog(price);
CREATE INDEX idx_catalog_cpu ON products_catalog(cpu);

-- Requ√™te optimis√©e
SELECT product_id, data
FROM products_catalog
WHERE sku = 'LAPTOP-001'
  AND price < 1500;
-- Utilise les index sur colonnes virtuelles
```

2. **Index multi-valeurs pour tableaux JSON** (MariaDB 10.6+) :
```sql
-- Colonne virtuelle pour tags (tableau JSON)
ALTER TABLE products_catalog
ADD COLUMN tags_extracted VARCHAR(1000)
    AS (JSON_UNQUOTE(JSON_EXTRACT(data, '$.tags'))) STORED;

-- Pour requ√™tes JSON_CONTAINS, index sur colonne extraite
CREATE INDEX idx_catalog_tags ON products_catalog(tags_extracted);

-- Requ√™te
SELECT product_id, data
FROM products_catalog
WHERE JSON_CONTAINS(data, '"laptop"', '$.tags');
```

‚ö†Ô∏è **Limitation** : MariaDB ne supporte pas encore les **multi-valued indexes** (contrairement √† MySQL 8.0+). Utiliser des colonnes virtuelles STORED comme workaround.

---

## Op√©rateurs et utilisation des index

### Op√©rateurs compatibles avec les index

**Op√©rateurs qui UTILISENT les index** :

```sql
-- √âgalit√© stricte
WHERE column = value;
WHERE column <=> value; -- NULL-safe equality

-- Comparaisons
WHERE column > value;
WHERE column >= value;
WHERE column < value;
WHERE column <= value;

-- Plages
WHERE column BETWEEN value1 AND value2;

-- Listes de valeurs (si petite liste)
WHERE column IN (val1, val2, val3);

-- LIKE avec wildcard √† la fin uniquement
WHERE column LIKE 'prefix%';

-- IS NULL / IS NOT NULL
WHERE column IS NULL;
WHERE column IS NOT NULL;
```

**Op√©rateurs qui N'UTILISENT PAS les index** :

```sql
-- ‚ùå N√©gations
WHERE column != value;
WHERE column <> value;
WHERE column NOT IN (val1, val2, val3);

-- ‚ùå LIKE avec wildcard au d√©but
WHERE column LIKE '%suffix';
WHERE column LIKE '%middle%';

-- ‚ùå Fonctions appliqu√©es sur colonne index√©e
WHERE UPPER(column) = 'VALUE';
WHERE YEAR(date_column) = 2024;
WHERE column + 10 > 100;

-- ‚ùå Op√©rateurs complexes
WHERE column IS NOT NULL AND column <> '';
```

### Cas particuliers : NULL

```sql
-- Index sur colonnes nullable
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    phone VARCHAR(20), -- Peut √™tre NULL
    last_login DATETIME
);

CREATE INDEX idx_users_phone ON users(phone);

-- ‚úÖ IS NULL utilise l'index
SELECT * FROM users WHERE phone IS NULL;

-- ‚úÖ IS NOT NULL utilise l'index
SELECT * FROM users WHERE phone IS NOT NULL;

-- ‚ö†Ô∏è Mais si 90% des valeurs sont NULL, l'optimizer peut pr√©f√©rer full scan
```

üí° **Optimisation pour colonnes avec beaucoup de NULL** :
```sql
-- Si beaucoup de NULL, cr√©er index partiel avec WHERE clause
-- (Feature disponible dans PostgreSQL, pas dans MariaDB)

-- Workaround MariaDB : colonne g√©n√©r√©e
ALTER TABLE users
ADD COLUMN has_phone TINYINT(1)
    AS (phone IS NOT NULL) VIRTUAL;

CREATE INDEX idx_users_has_phone ON users(has_phone);

-- Requ√™te optimis√©e
SELECT * FROM users WHERE has_phone = 1 AND phone LIKE '06%';
```

### IN vs OR : Impact sur les index

```sql
-- IN avec liste courte : index utilis√© efficacement
SELECT * FROM orders
WHERE status IN ('pending', 'processing', 'shipped');
-- Utilise idx_orders_status

-- OR avec colonnes diff√©rentes : index difficile √† utiliser
SELECT * FROM orders
WHERE status = 'pending'
   OR customer_id = 12345;
-- Peut n√©cessiter index merge ou full scan

-- ‚úÖ Solution : UNION ALL si s√©lectif
SELECT * FROM orders WHERE status = 'pending'
UNION ALL
SELECT * FROM orders WHERE customer_id = 12345 AND status != 'pending';
```

---

## Cas d'usage sp√©cifiques

### Recherche multi-crit√®res

**Sc√©nario** : Interface de recherche produits avec filtres multiples.

```sql
-- Requ√™te avec filtres optionnels
SELECT product_id, name, price
FROM products
WHERE
    (category_id = 5 OR @category IS NULL)
    AND (brand_id = 10 OR @brand IS NULL)
    AND price BETWEEN @min_price AND @max_price
    AND is_active = 1;

-- ‚ùå Probl√®me : index difficile √† utiliser avec OR

-- ‚úÖ Solution : Requ√™te dynamique c√¥t√© application
-- Si category fournie :
SELECT * FROM products
WHERE category_id = 5
  AND brand_id = 10
  AND price BETWEEN 100 AND 500
  AND is_active = 1;

-- Index optimal
CREATE INDEX idx_products_search
ON products(category_id, brand_id, is_active, price);
```

### Pagination efficace

```sql
-- ‚ùå Pagination classique : lente sur grandes offsets
SELECT * FROM products
WHERE category_id = 5
ORDER BY product_id
LIMIT 100 OFFSET 50000; -- Tr√®s lent

-- ‚úÖ Pagination par curseur (keyset pagination)
SELECT * FROM products
WHERE category_id = 5
  AND product_id > 50000 -- Dernier ID de la page pr√©c√©dente
ORDER BY product_id
LIMIT 100;

-- Index covering optimal
CREATE INDEX idx_products_category_id
ON products(category_id, product_id);
```

### Recherche de plages avec agr√©gations

```sql
-- Requ√™te : nombre de commandes par statut sur p√©riode
SELECT status, COUNT(*) as order_count, SUM(total_amount) as total
FROM orders
WHERE order_date >= '2024-01-01'
  AND order_date < '2025-01-01'
GROUP BY status;

-- Index covering pour √©viter acc√®s table
CREATE INDEX idx_orders_reporting
ON orders(order_date, status, total_amount);
-- Contient toutes les colonnes n√©cessaires
```

### Recherche approximative (fuzzy search)

```sql
-- Recherche phon√©tique ou floue
-- Utiliser SOUNDEX ou FULLTEXT

-- Option 1 : SOUNDEX pour noms propres
CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    last_name VARCHAR(100),
    first_name VARCHAR(100)
);

ALTER TABLE customers
ADD COLUMN last_name_soundex VARCHAR(10)
    AS (SOUNDEX(last_name)) VIRTUAL;

CREATE INDEX idx_customers_soundex
ON customers(last_name_soundex);

-- Recherche approximative
SELECT * FROM customers
WHERE last_name_soundex = SOUNDEX('Smith');
-- Trouve 'Smith', 'Smyth', 'Smitt', etc.

-- Option 2 : FULLTEXT pour recherche textuelle avanc√©e
CREATE FULLTEXT INDEX idx_customers_names
ON customers(last_name, first_name);

SELECT * FROM customers
WHERE MATCH(last_name, first_name)
AGAINST('John Smith' IN NATURAL LANGUAGE MODE);
```

---

## Monitoring et validation

### V√©rifier l'utilisation de l'index

```sql
-- Analyser le plan d'ex√©cution
EXPLAIN
SELECT * FROM products
WHERE category_id = 5 AND price < 100;

-- Colonnes importantes dans EXPLAIN :
-- - key : nom de l'index utilis√© (NULL = pas d'index)
-- - type : ALL (full scan), range, ref, eq_ref, const
-- - rows : estimation du nombre de lignes examin√©es
-- - Extra : Using index (covering), Using where, Using filesort

-- Exemple de r√©sultat optimal :
-- id | type | key                    | rows | Extra
-- 1  | ref  | idx_products_category  | 100  | Using index condition
```

### EXPLAIN ANALYZE pour statistiques r√©elles

```sql
-- EXPLAIN ANALYZE (MariaDB 10.6+) : temps d'ex√©cution r√©els
EXPLAIN ANALYZE
SELECT * FROM orders
WHERE customer_id = 12345
  AND order_date >= '2024-01-01';

-- R√©sultat avec temps r√©els :
-- -> Index lookup on orders using idx_customer_date
--    (customer_id=12345, order_date>='2024-01-01')
--    (cost=25.3 rows=18) (actual time=0.15..0.42 rows=15 loops=1)
```

### D√©tecter les index manquants

```sql
-- Requ√™te pour identifier les full table scans
SELECT
    DIGEST_TEXT,
    COUNT_STAR,
    SUM_ROWS_EXAMINED,
    SUM_ROWS_SENT,
    SUM_ROWS_EXAMINED / COUNT_STAR AS avg_rows_examined
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = 'your_database'
  AND SUM_ROWS_EXAMINED / COUNT_STAR > 1000 -- Plus de 1000 lignes examin√©es en moyenne
ORDER BY SUM_ROWS_EXAMINED DESC
LIMIT 20;
```

---

## ‚úÖ Points cl√©s √† retenir

- **Prioriser les colonnes √† haute s√©lectivit√©** : beaucoup de valeurs distinctes
- **Colonnes num√©riques = index les plus efficaces** : taille compacte, comparaisons rapides
- **VARCHAR** : utiliser index sur pr√©fixe pour colonnes longues
- **Dates** : √©viter les fonctions (YEAR, MONTH), utiliser plages directes
- **üÜï TIMESTAMP √©tendu 2106** : r√©solution Y2038 dans MariaDB 11.8
- **JSON** : indexer via colonnes virtuelles extraites
- **UUID** : pr√©f√©rer BINARY(16) ou type UUID natif
- **LIKE** : index utilisable uniquement avec wildcard √† la fin (`prefix%`)
- **√âviter fonctions sur colonnes index√©es** : emp√™che utilisation de l'index
- **Valider avec EXPLAIN** : v√©rifier que l'index est effectivement utilis√©

---

## üîó Ressources et r√©f√©rences

- [üìñ MariaDB Index Types](https://mariadb.com/kb/en/storage-engine-index-types/)
- [üìñ EXPLAIN Documentation](https://mariadb.com/kb/en/explain/)
- [üìñ Generated Columns](https://mariadb.com/kb/en/generated-columns/)
- [üìñ JSON Data Type](https://mariadb.com/kb/en/json-data-type/)
- [üÜï TIMESTAMP Extension](https://mariadb.com/kb/en/timestamp/)
- [üìä Performance Schema](https://mariadb.com/kb/en/performance-schema/)

---

## ‚û°Ô∏è Section suivante

**5.5.2 Index sur cl√©s √©trang√®res** : Comprendre l'importance critique de l'indexation des cl√©s √©trang√®res pour les performances des jointures et l'int√©grit√© r√©f√©rentielle.

‚è≠Ô∏è [Index sur cl√©s √©trang√®res](/05-index-et-performance/05.2-index-cles-etrangeres.md)
