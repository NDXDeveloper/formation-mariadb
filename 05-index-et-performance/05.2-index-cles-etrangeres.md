üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.5.2 Index sur cl√©s √©trang√®res

> **Niveau** : Interm√©diaire
> **Dur√©e estim√©e** : 1.5 heures
> **Pr√©requis** : Section 5.5 et 5.5.1 (Strat√©gies d'indexation)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre pourquoi les cl√©s √©trang√®res doivent √™tre syst√©matiquement index√©es
- Mesurer l'impact des index FK sur les performances des jointures
- Identifier l'impact des index FK sur les op√©rations DELETE et UPDATE
- Appliquer les bonnes pratiques d'indexation pour les relations many-to-one et many-to-many
- Optimiser les requ√™tes impliquant des jointures multiples
- Diagnostiquer les probl√®mes de performance li√©s aux FK non index√©es

---

## Introduction

L'indexation des **cl√©s √©trang√®res** (Foreign Keys) est l'une des optimisations les plus importantes et souvent n√©glig√©es en bases de donn√©es relationnelles. Une cl√© √©trang√®re non index√©e peut d√©grader les performances de **plusieurs ordres de grandeur**, transformant une jointure de quelques millisecondes en plusieurs secondes.

‚ö†Ô∏è **Point critique** : Contrairement √† certains SGBD (comme Oracle ou SQL Server), **MariaDB ne cr√©e PAS automatiquement d'index sur les cl√©s √©trang√®res** lors de leur d√©claration. C'est la responsabilit√© du d√©veloppeur/DBA de cr√©er ces index manuellement.

üí° **R√®gle d'or** : Toute colonne d√©clar√©e comme cl√© √©trang√®re doit avoir un index, sauf exception d√ªment justifi√©e.

---

## Pourquoi indexer les cl√©s √©trang√®res ?

### Impact sur les jointures

Les **jointures** (JOIN) sont l'op√©ration la plus fr√©quente impliquant des cl√©s √©trang√®res. Sans index, MariaDB doit effectuer un **full table scan** sur la table r√©f√©renc√©e pour chaque ligne de la table principale.

```sql
-- Sch√©ma exemple : syst√®me de commandes e-commerce
CREATE TABLE customers (
    customer_id INT AUTO_INCREMENT PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    name VARCHAR(100),
    country VARCHAR(2)
) ENGINE=InnoDB;

CREATE TABLE orders (
    order_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date DATETIME NOT NULL,
    total_amount DECIMAL(10,2),
    status VARCHAR(20),
    CONSTRAINT fk_orders_customer
        FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
    -- ‚ö†Ô∏è Pas d'index automatique sur customer_id !
) ENGINE=InnoDB;

-- Requ√™te typique : commandes avec informations client
SELECT o.order_id, o.order_date, o.total_amount, c.name, c.email
FROM orders o
INNER JOIN customers c ON o.customer_id = c.customer_id
WHERE o.order_date >= '2024-01-01';
```

**Sans index sur orders.customer_id** :
```sql
EXPLAIN
SELECT o.order_id, c.name
FROM orders o
INNER JOIN customers c ON o.customer_id = c.customer_id
WHERE o.order_date >= '2024-01-01';

-- R√©sultat (probl√©matique) :
-- id | table | type | key     | rows    | Extra
-- 1  | o     | ALL  | NULL    | 500000  | Using where
-- 1  | c     | ALL  | NULL    | 100000  | Using where; Using join buffer
--
-- Temps d'ex√©cution : 8-15 secondes (500k √ó 100k comparaisons)
```

**Avec index sur orders.customer_id** :
```sql
-- Cr√©er l'index manquant
CREATE INDEX idx_orders_customer_id ON orders(customer_id);

EXPLAIN
SELECT o.order_id, c.name
FROM orders o
INNER JOIN customers c ON o.customer_id = c.customer_id
WHERE o.order_date >= '2024-01-01';

-- R√©sultat (optimis√©) :
-- id | table | type   | key                    | rows  | Extra
-- 1  | o     | ALL    | NULL                   | 500000| Using where
-- 1  | c     | eq_ref | PRIMARY                | 1     | NULL
--
-- Temps d'ex√©cution : 150-300 ms (am√©lioration x50-100)
```

üí° **Explication** :
- `eq_ref` indique que MariaDB utilise la cl√© primaire de `customers` pour acc√©der directement √† 1 seule ligne
- Sans l'index FK, le type serait `ALL` (full scan) sur la table `customers` pour chaque ligne de `orders`

### Impact sur les op√©rations DELETE et UPDATE

Les index sur cl√©s √©trang√®res sont **cruciaux pour les performances** lors de suppressions et mises √† jour en cascade.

```sql
-- Sc√©nario : suppression d'un client avec contrainte CASCADE
ALTER TABLE orders
ADD CONSTRAINT fk_orders_customer
    FOREIGN KEY (customer_id)
    REFERENCES customers(customer_id)
    ON DELETE CASCADE;

-- Suppression d'un client
DELETE FROM customers WHERE customer_id = 12345;
```

**Sans index sur orders.customer_id** :
```
-- MariaDB doit scanner TOUTE la table orders pour trouver les lignes √† supprimer
-- Temps : 5-10 secondes sur table de 1M lignes
```

**Avec index sur orders.customer_id** :
```
-- MariaDB utilise l'index pour trouver instantan√©ment les lignes concern√©es
-- Temps : 10-50 ms
```

‚ö†Ô∏è **Cas probl√©matique** : Sans index, une simple suppression peut **verrouiller toute la table** orders pendant plusieurs secondes, bloquant toutes les autres transactions.

### Impact sur les v√©rifications d'int√©grit√© r√©f√©rentielle

```sql
-- Insertion d'une commande : MariaDB doit v√©rifier que le customer_id existe
INSERT INTO orders (customer_id, order_date, total_amount, status)
VALUES (12345, NOW(), 199.99, 'pending');

-- MariaDB ex√©cute implicitement :
-- SELECT 1 FROM customers WHERE customer_id = 12345 FOR SHARE;
```

**Sans index sur la cl√© primaire r√©f√©renc√©e** (rare mais possible avec InnoDB) :
- Verification tr√®s lente sur grandes tables
- Risque de deadlocks accrus

**Avec index (cl√© primaire)** :
- V√©rification instantan√©e via l'index clustered
- Verrouillage minimal et cibl√©

---

## Cr√©ation d'index sur cl√©s √©trang√®res

### D√©tection des FK sans index

```sql
-- Requ√™te pour identifier les cl√©s √©trang√®res non index√©es
SELECT
    TABLE_SCHEMA,
    TABLE_NAME,
    CONSTRAINT_NAME,
    COLUMN_NAME,
    REFERENCED_TABLE_NAME,
    REFERENCED_COLUMN_NAME
FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
WHERE REFERENCED_TABLE_NAME IS NOT NULL  -- C'est une FK
  AND TABLE_SCHEMA = 'your_database'
  AND CONCAT(TABLE_NAME, '.', COLUMN_NAME) NOT IN (
      -- V√©rifier si un index existe sur cette colonne
      SELECT CONCAT(TABLE_NAME, '.', COLUMN_NAME)
      FROM INFORMATION_SCHEMA.STATISTICS
      WHERE TABLE_SCHEMA = 'your_database'
        AND SEQ_IN_INDEX = 1  -- Premi√®re colonne de l'index
  )
ORDER BY TABLE_NAME, CONSTRAINT_NAME;
```

üí° **Note** : Cette requ√™te identifie les FK o√π la colonne n'est **pas la premi√®re** d'un index existant.

### Cr√©ation syst√©matique des index FK

```sql
-- ‚úÖ Bonne pratique : cr√©er l'index AVANT la contrainte FK
CREATE TABLE order_items (
    item_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    unit_price DECIMAL(10,2),

    -- Cr√©er les index AVANT les contraintes
    INDEX idx_order_items_order_id (order_id),
    INDEX idx_order_items_product_id (product_id),

    -- Puis les contraintes FK
    CONSTRAINT fk_order_items_order
        FOREIGN KEY (order_id) REFERENCES orders(order_id)
        ON DELETE CASCADE,
    CONSTRAINT fk_order_items_product
        FOREIGN KEY (product_id) REFERENCES products(product_id)
        ON DELETE RESTRICT
) ENGINE=InnoDB;
```

**Avantages de cette approche** :
1. ‚úÖ Index cr√©√© en une seule passe (plus rapide)
2. ‚úÖ √âvite les probl√®mes de performance d√®s la cr√©ation de la table
3. ‚úÖ Facilite la maintenance et la lisibilit√© du sch√©ma

### Correction sur tables existantes

```sql
-- Pour une table existante sans index FK
-- √âtape 1 : Analyser les FK existantes
SHOW CREATE TABLE orders;

-- √âtape 2 : Cr√©er les index manquants
CREATE INDEX idx_orders_customer_id ON orders(customer_id);

-- √âtape 3 : Sur tr√®s grandes tables, utiliser ALGORITHM=INPLACE
ALTER TABLE orders
ADD INDEX idx_orders_customer_id (customer_id),
ALGORITHM=INPLACE, LOCK=NONE;
```

üí° **MariaDB 10.0+** : `ALGORITHM=INPLACE` permet d'ajouter des index **sans copier toute la table**, avec verrouillage minimal.

---

## Strat√©gies d'indexation par type de relation

### Relation One-to-Many (1:N)

C'est le cas le plus fr√©quent : un client a plusieurs commandes, un produit a plusieurs avis, etc.

```sql
-- Exemple : clients (1) ‚Üí commandes (N)
CREATE TABLE customers (
    customer_id INT AUTO_INCREMENT PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL
) ENGINE=InnoDB;

CREATE TABLE orders (
    order_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date DATETIME NOT NULL,

    -- Index sur FK (c√¥t√© "Many")
    INDEX idx_orders_customer_id (customer_id),

    CONSTRAINT fk_orders_customer
        FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
) ENGINE=InnoDB;
```

**Requ√™tes typiques optimis√©es** :
```sql
-- 1. Trouver toutes les commandes d'un client (utilise l'index FK)
SELECT * FROM orders WHERE customer_id = 12345;

-- 2. Jointure client ‚Üí commandes (utilise l'index FK)
SELECT c.name, COUNT(o.order_id) as order_count
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id;

-- 3. Suppression cascade d'un client (utilise l'index FK)
DELETE FROM customers WHERE customer_id = 12345;
-- Toutes les commandes sont supprim√©es efficacement
```

### Relation Many-to-Many (N:M)

Les relations many-to-many n√©cessitent une **table de jointure** avec **deux cl√©s √©trang√®res**, donc **deux index**.

```sql
-- Exemple : produits ‚Üê‚Üí cat√©gories (many-to-many)
CREATE TABLE products (
    product_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL
) ENGINE=InnoDB;

CREATE TABLE categories (
    category_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL
) ENGINE=InnoDB;

-- Table de jointure
CREATE TABLE product_categories (
    product_id INT NOT NULL,
    category_id INT NOT NULL,
    display_order INT DEFAULT 0,

    PRIMARY KEY (product_id, category_id),

    -- ‚úÖ Index sur les deux FK (crucial !)
    INDEX idx_product_categories_product (product_id),
    INDEX idx_product_categories_category (category_id),

    CONSTRAINT fk_pc_product
        FOREIGN KEY (product_id) REFERENCES products(product_id)
        ON DELETE CASCADE,
    CONSTRAINT fk_pc_category
        FOREIGN KEY (category_id) REFERENCES categories(category_id)
        ON DELETE CASCADE
) ENGINE=InnoDB;
```

üí° **Optimisation** : La cl√© primaire composite `(product_id, category_id)` sert d√©j√† d'index pour `product_id`. On peut donc **supprimer** `idx_product_categories_product` :

```sql
-- Version optimis√©e : un seul index suppl√©mentaire
CREATE TABLE product_categories (
    product_id INT NOT NULL,
    category_id INT NOT NULL,

    -- PK composite = index sur (product_id, category_id)
    PRIMARY KEY (product_id, category_id),

    -- ‚úÖ Un seul index suppl√©mentaire n√©cessaire
    INDEX idx_product_categories_category (category_id),

    CONSTRAINT fk_pc_product
        FOREIGN KEY (product_id) REFERENCES products(product_id),
    CONSTRAINT fk_pc_category
        FOREIGN KEY (category_id) REFERENCES categories(category_id)
) ENGINE=InnoDB;
```

**Requ√™tes optimis√©es** :
```sql
-- 1. Produits d'une cat√©gorie (utilise idx_category)
SELECT p.product_id, p.name
FROM products p
INNER JOIN product_categories pc ON p.product_id = pc.product_id
WHERE pc.category_id = 5;

-- 2. Cat√©gories d'un produit (utilise PRIMARY KEY)
SELECT c.category_id, c.name
FROM categories c
INNER JOIN product_categories pc ON c.category_id = pc.category_id
WHERE pc.product_id = 100;

-- 3. Suppression d'une cat√©gorie (utilise idx_category)
DELETE FROM categories WHERE category_id = 5;
-- Supprime automatiquement les associations dans product_categories
```

### Cl√©s √©trang√®res composites

Parfois, une cl√© √©trang√®re r√©f√©rence une cl√© primaire composite.

```sql
-- Cl√© primaire composite
CREATE TABLE order_items (
    order_id BIGINT NOT NULL,
    item_sequence INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT,

    PRIMARY KEY (order_id, item_sequence)
) ENGINE=InnoDB;

-- Table r√©f√©ren√ßant la FK composite
CREATE TABLE order_item_shipments (
    shipment_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT NOT NULL,
    item_sequence INT NOT NULL,
    tracking_number VARCHAR(50),

    -- Index composite pour FK composite
    INDEX idx_shipments_order_item (order_id, item_sequence),

    CONSTRAINT fk_shipments_order_item
        FOREIGN KEY (order_id, item_sequence)
        REFERENCES order_items(order_id, item_sequence)
) ENGINE=InnoDB;
```

‚ö†Ô∏è **Important** : L'index doit contenir **toutes les colonnes de la FK composite** dans le **m√™me ordre** que la cl√© primaire r√©f√©renc√©e.

---

## Index composites incluant des FK

Dans de nombreux cas, il est judicieux de cr√©er un **index composite** commen√ßant par la cl√© √©trang√®re, plut√¥t qu'un index simple.

### FK + colonnes de filtrage fr√©quentes

```sql
-- Sc√©nario : requ√™tes fr√©quentes sur customer_id + status
CREATE TABLE orders (
    order_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date DATETIME NOT NULL,
    status VARCHAR(20) NOT NULL,
    total_amount DECIMAL(10,2),

    -- ‚úÖ Index composite : FK + colonnes fr√©quemment filtr√©es
    INDEX idx_orders_customer_status (customer_id, status),
    INDEX idx_orders_customer_date (customer_id, order_date),

    CONSTRAINT fk_orders_customer
        FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
) ENGINE=InnoDB;
```

**Requ√™tes optimis√©es** :
```sql
-- 1. Commandes en attente d'un client (utilise idx_customer_status)
SELECT * FROM orders
WHERE customer_id = 12345
  AND status = 'pending';

-- 2. Commandes d'un client sur p√©riode (utilise idx_customer_date)
SELECT * FROM orders
WHERE customer_id = 12345
  AND order_date >= '2024-01-01';

-- 3. Simple recherche par FK (utilise le pr√©fixe des index composites)
SELECT * FROM orders WHERE customer_id = 12345;
-- Peut utiliser idx_customer_status OU idx_customer_date
```

üí° **Avantage** : Un index composite `(customer_id, status)` peut servir **deux usages** :
1. Requ√™tes filtr√©es par `customer_id` seul (pr√©fixe gauche)
2. Requ√™tes filtr√©es par `customer_id` ET `status`

### FK + ORDER BY

```sql
-- Sc√©nario : afficher les derni√®res commandes d'un client
SELECT * FROM orders
WHERE customer_id = 12345
ORDER BY order_date DESC
LIMIT 10;

-- Index optimal : FK + colonne de tri
CREATE INDEX idx_orders_customer_date_desc
ON orders(customer_id, order_date DESC);

-- EXPLAIN montre :
-- type: ref
-- key: idx_orders_customer_date_desc
-- Extra: Using index condition (PAS de "Using filesort")
```

### FK + Index covering

```sql
-- Requ√™te fr√©quente : montant total des commandes par client
SELECT customer_id, SUM(total_amount) as total_spent
FROM orders
WHERE status = 'completed'
GROUP BY customer_id;

-- Index covering : toutes colonnes n√©cessaires
CREATE INDEX idx_orders_covering
ON orders(status, customer_id, total_amount);

-- EXPLAIN Extra: Using index (index-only scan, optimal)
```

---

## Cas particuliers et optimisations

### FK optionnelles (NULL autoris√©)

```sql
-- Colonne FK pouvant √™tre NULL
CREATE TABLE orders (
    order_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT,  -- Peut √™tre NULL (commande "invit√©")
    guest_email VARCHAR(255),
    order_date DATETIME NOT NULL,

    INDEX idx_orders_customer_id (customer_id),

    CONSTRAINT fk_orders_customer
        FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
        ON DELETE SET NULL
) ENGINE=InnoDB;
```

**Impact sur les requ√™tes** :
```sql
-- Requ√™tes avec IS NULL / IS NOT NULL utilisent l'index
SELECT * FROM orders WHERE customer_id IS NULL; -- Commandes invit√©s
SELECT * FROM orders WHERE customer_id IS NOT NULL; -- Commandes clients

-- Mais si 90% des valeurs sont NOT NULL, cr√©er index partiel peut aider :
-- (MariaDB ne supporte pas les index partiels comme PostgreSQL)

-- Workaround : colonne g√©n√©r√©e
ALTER TABLE orders
ADD COLUMN is_guest TINYINT(1) AS (customer_id IS NULL) VIRTUAL;

CREATE INDEX idx_orders_is_guest ON orders(is_guest);
```

### Self-referencing FK (hi√©rarchies)

```sql
-- Exemple : cat√©gories avec sous-cat√©gories
CREATE TABLE categories (
    category_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    parent_category_id INT,  -- R√©f√©rence categories.category_id

    -- Index sur FK self-referencing
    INDEX idx_categories_parent (parent_category_id),

    CONSTRAINT fk_categories_parent
        FOREIGN KEY (parent_category_id)
        REFERENCES categories(category_id)
        ON DELETE CASCADE
) ENGINE=InnoDB;
```

**Requ√™tes hi√©rarchiques** :
```sql
-- Trouver toutes les sous-cat√©gories d'une cat√©gorie
SELECT * FROM categories WHERE parent_category_id = 5;
-- Utilise idx_categories_parent

-- Requ√™te r√©cursive (MariaDB 10.2+)
WITH RECURSIVE category_tree AS (
    SELECT category_id, name, parent_category_id, 0 as level
    FROM categories
    WHERE parent_category_id IS NULL

    UNION ALL

    SELECT c.category_id, c.name, c.parent_category_id, ct.level + 1
    FROM categories c
    INNER JOIN category_tree ct ON c.parent_category_id = ct.category_id
)
SELECT * FROM category_tree;
-- L'index sur parent_category_id est crucial ici
```

### Soft deletes et FK

```sql
-- Pattern soft delete : colonne deleted_at
CREATE TABLE products (
    product_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255),
    deleted_at DATETIME,

    INDEX idx_products_deleted (deleted_at)
) ENGINE=InnoDB;

CREATE TABLE order_items (
    item_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT NOT NULL,
    product_id INT NOT NULL,

    -- Index composite : FK + condition soft delete
    INDEX idx_order_items_product (product_id),

    CONSTRAINT fk_order_items_product
        FOREIGN KEY (product_id) REFERENCES products(product_id)
        -- ‚ö†Ô∏è Pas de ON DELETE CASCADE avec soft deletes !
) ENGINE=InnoDB;
```

**Requ√™tes avec soft deletes** :
```sql
-- Produits actifs seulement
SELECT p.product_id, p.name
FROM products p
INNER JOIN order_items oi ON p.product_id = oi.product_id
WHERE p.deleted_at IS NULL
  AND oi.order_id = 12345;
```

---

## Impact des FK sur les performances d'√©criture

### Co√ªt des v√©rifications d'int√©grit√©

Chaque INSERT/UPDATE/DELETE sur une table avec FK entra√Æne des v√©rifications :

```sql
-- Insertion dans orders
INSERT INTO orders (customer_id, order_date, total_amount)
VALUES (12345, NOW(), 99.99);

-- MariaDB ex√©cute en coulisses :
-- 1. SELECT FOR SHARE sur customers pour v√©rifier customer_id existe
-- 2. Acquisition de verrous partag√©s (S-lock)
-- 3. Insertion dans orders
-- 4. Lib√©ration des verrous
```

**Impact sur concurrence** :
- ‚úÖ Avec index FK : v√©rification quasi-instantan√©e, verrous cibl√©s
- ‚ùå Sans index FK : full scan, verrous √©tendus, deadlocks fr√©quents

### Optimisations pour chargements massifs

```sql
-- Lors d'imports massifs, d√©sactiver temporairement les v√©rifications FK
SET FOREIGN_KEY_CHECKS = 0;

-- Chargement de donn√©es
LOAD DATA INFILE '/data/orders.csv'
INTO TABLE orders
FIELDS TERMINATED BY ','
(order_id, customer_id, order_date, total_amount, status);

-- R√©activer les v√©rifications
SET FOREIGN_KEY_CHECKS = 1;

-- ‚ö†Ô∏è V√©rifier manuellement l'int√©grit√© apr√®s import
SELECT o.customer_id
FROM orders o
LEFT JOIN customers c ON o.customer_id = c.customer_id
WHERE c.customer_id IS NULL;
-- Doit retourner 0 ligne
```

‚ö†Ô∏è **Attention** : `FOREIGN_KEY_CHECKS = 0` doit √™tre utilis√© **uniquement** pendant les imports/migrations, jamais en production normale.

---

## Monitoring et diagnostics

### Identifier les requ√™tes lentes √† cause de FK

```sql
-- Activer le slow query log
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;

-- Analyser les requ√™tes avec jointures lentes
SELECT
    DIGEST_TEXT,
    COUNT_STAR as execution_count,
    AVG_TIMER_WAIT / 1000000000 as avg_time_sec,
    SUM_ROWS_EXAMINED / COUNT_STAR as avg_rows_examined
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE '%JOIN%'
  AND SCHEMA_NAME = 'your_database'
ORDER BY avg_time_sec DESC
LIMIT 20;
```

### D√©tecter les FK causant des deadlocks

```sql
-- Analyser les deadlocks r√©cents
SHOW ENGINE INNODB STATUS\G

-- Section "LATEST DETECTED DEADLOCK" montre :
-- - Transactions impliqu√©es
-- - Verrous attendus
-- - Tables/index concern√©s

-- Souvent caus√© par FK sans index lors de DELETE/UPDATE cascade
```

**Exemple de deadlock typique** :
```
Transaction 1:
- DELETE FROM customers WHERE customer_id = 100 (acquiert X-lock)
- Tente de supprimer dans orders (scan sans index ‚Üí attend)

Transaction 2:
- DELETE FROM customers WHERE customer_id = 200 (acquiert X-lock)
- Tente de supprimer dans orders (scan sans index ‚Üí attend)

‚Üí Deadlock si les scans s'entrecroisent
```

**Solution** : Index sur `orders.customer_id` √©limine le probl√®me.

### V√©rifier les statistiques d'index FK

```sql
-- V√©rifier l'utilisation des index FK
SELECT
    TABLE_NAME,
    INDEX_NAME,
    CARDINALITY,
    INDEX_TYPE
FROM INFORMATION_SCHEMA.STATISTICS
WHERE TABLE_SCHEMA = 'your_database'
  AND INDEX_NAME LIKE '%customer%'
ORDER BY TABLE_NAME, INDEX_NAME;
```

---

## Checklist pour l'indexation des FK

### ‚úÖ Bonnes pratiques

- [ ] **Cr√©er un index sur toute colonne FK** (r√®gle absolue)
- [ ] **Cr√©er l'index AVANT la contrainte FK** (performances cr√©ation)
- [ ] **Utiliser `ALGORITHM=INPLACE`** pour tables existantes volumineuses
- [ ] **Envisager des index composites** (FK + colonnes fr√©quentes)
- [ ] **Indexer les deux c√¥t√©s** d'une relation many-to-many
- [ ] **V√©rifier les FK apr√®s cr√©ation de table** (audit r√©gulier)
- [ ] **Monitorer les slow queries** li√©es aux jointures
- [ ] **Tester les performances DELETE/UPDATE** avec FK cascade

### ‚ö†Ô∏è Points de vigilance

- [ ] **FK composite** : index doit contenir toutes les colonnes
- [ ] **Ordre des colonnes** dans FK composite = ordre dans l'index
- [ ] **Soft deletes** : pas de ON DELETE CASCADE
- [ ] **Imports massifs** : `FOREIGN_KEY_CHECKS = 0` temporaire uniquement
- [ ] **Cl√©s primaires** : d√©j√† index√©es automatiquement (InnoDB clustered index)
- [ ] **Deadlocks** : souvent caus√©s par FK sans index

---

## Benchmarking : Impact mesurable

### Exemple comparatif sur vraies donn√©es

```sql
-- Table orders : 1 million de lignes
-- Table customers : 100 000 lignes

-- Sc√©nario 1 : SANS index sur orders.customer_id
-- Requ√™te : SELECT COUNT(*) FROM orders o JOIN customers c ON o.customer_id = c.customer_id;
-- Temps : 15-20 secondes
-- Rows examined : 100,000,000,000 (1M √ó 100k)

-- Sc√©nario 2 : AVEC index sur orders.customer_id
CREATE INDEX idx_orders_customer_id ON orders(customer_id);

-- M√™me requ√™te
-- Temps : 250-400 ms
-- Rows examined : 1,000,000 (utilise index)
-- Am√©lioration : x40-80
```

üí° **R√©sultat** : Sur grandes tables, l'index FK peut am√©liorer les performances de **2 √† 3 ordres de grandeur** (x100 √† x1000).

---

## ‚úÖ Points cl√©s √† retenir

- **MariaDB ne cr√©e PAS automatiquement d'index sur FK** : cr√©ation manuelle obligatoire
- **Toute colonne FK doit avoir un index** : am√©lioration de x50-x1000 sur jointures
- **Impact critique sur DELETE/UPDATE cascade** : sans index = verrouillage table enti√®re
- **Index composites pr√©f√©rables** : (FK, colonnes fr√©quentes) pour requ√™tes complexes
- **Many-to-many** : indexer les deux FK (ou utiliser PK composite)
- **FK composites** : index doit contenir toutes les colonnes dans le bon ordre
- **Monitoring essentiel** : d√©tecter FK manquants via INFORMATION_SCHEMA
- **Deadlocks** : souvent caus√©s par FK sans index lors d'op√©rations cascade

---

## üîó Ressources et r√©f√©rences

- [üìñ MariaDB Foreign Keys](https://mariadb.com/kb/en/foreign-keys/)
- [üìñ InnoDB Foreign Key Constraints](https://mariadb.com/kb/en/innodb-foreign-keys/)
- [üìñ ALTER TABLE ALGORITHM=INPLACE](https://mariadb.com/kb/en/alter-table/#algorithm)
- [üìñ INFORMATION_SCHEMA.KEY_COLUMN_USAGE](https://mariadb.com/kb/en/information-schema-key_column_usage-table/)
- [üìñ Deadlock Detection](https://mariadb.com/kb/en/deadlocks/)
- [üõ†Ô∏è pt-duplicate-key-checker](https://www.percona.com/doc/percona-toolkit/LATEST/pt-duplicate-key-checker.html)

---

## ‚û°Ô∏è Section suivante

**5.5.3 Index pour ORDER BY et GROUP BY** : Optimiser les requ√™tes de tri et d'agr√©gation en utilisant les index pour √©viter les op√©rations filesort co√ªteuses.

‚è≠Ô∏è [Index pour ORDER BY et GROUP BY](/05-index-et-performance/05.3-index-order-group.md)
