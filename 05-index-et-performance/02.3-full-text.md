üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.2.3 Full-Text : Recherche textuelle

> **Niveau** : Interm√©diaire
> **Dur√©e estim√©e** : 2-2.5 heures

> **Pr√©requis** :
> - Section 5.1 - Fonctionnement des index B-Tree
> - Section 5.2.1 - B-Tree : Le standard
> - Compr√©hension des requ√™tes SQL et expressions r√©guli√®res (basique)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Comprendre le fonctionnement des index Full-Text et leur structure interne
- Cr√©er et configurer des index Full-Text sur des colonnes textuelles
- Utiliser les 3 modes de recherche (Natural Language, Boolean, Query Expansion)
- Ma√Ætriser les op√©rateurs de recherche bool√©enne (+, -, *, "", etc.)
- Configurer les param√®tres Full-Text (stopwords, longueur minimale)
- Optimiser les requ√™tes Full-Text pour de meilleures performances
- Identifier quand utiliser Full-Text vs B-Tree vs solutions externes (Elasticsearch)

---

## Introduction

Les index **Full-Text** sont sp√©cialis√©s dans la **recherche de mots-cl√©s** dans des textes longs. Ils permettent de rechercher efficacement du contenu textuel avec scoring de pertinence, gestion des mots vides (stopwords), et support de recherches complexes.

### Pourquoi Full-Text ?

```sql
-- ‚ùå Recherche avec LIKE : tr√®s inefficace sur texte long
SELECT * FROM articles
WHERE content LIKE '%performance%'
AND content LIKE '%database%';
-- Probl√®mes :
-- 1. Full scan (index B-Tree inutilisable)
-- 2. Pas de scoring de pertinence
-- 3. Pas de gestion des variations (pluriels, etc.)
-- 4. Tr√®s lent sur grandes tables

-- ‚úÖ Recherche Full-Text : optimis√©e et intelligente
SELECT *, MATCH(title, content) AGAINST('performance database') AS relevance
FROM articles
WHERE MATCH(title, content) AGAINST('performance database')
ORDER BY relevance DESC;
-- Avantages :
-- 1. Index sp√©cialis√© (rapide)
-- 2. Scoring automatique de pertinence
-- 3. Gestion des stopwords
-- 4. Op√©rateurs avanc√©s
```

### Cas d'usage typiques

- üìù **Blogs et CMS** : Recherche d'articles, posts
- üìö **Documentation** : Knowledge base, FAQ, guides
- üé´ **Syst√®mes de support** : Tickets, solutions, questions
- üõí **E-commerce** : Recherche produits par description
- üì∞ **Actualit√©s** : Archives d'articles
- üí¨ **Forums** : Recherche de discussions

---

## Fonctionnement d'un index Full-Text

### Structure interne : Index invers√©

Un index Full-Text utilise un **index invers√©** (inverted index) qui mappe chaque mot vers les documents qui le contiennent :

```
Structure d'un index Full-Text :

Documents (table articles) :
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ID ‚îÇ Content                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1  ‚îÇ "MariaDB performance tuning"       ‚îÇ
‚îÇ 2  ‚îÇ "Database optimization guide"      ‚îÇ
‚îÇ 3  ‚îÇ "MariaDB index strategies"         ‚îÇ
‚îÇ 4  ‚îÇ "Performance monitoring tools"     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Index invers√© :
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Mot         ‚îÇ Documents       ‚îÇ Fr√©quence     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ mariadb     ‚îÇ [1, 3]          ‚îÇ 2             ‚îÇ
‚îÇ performance ‚îÇ [1, 4]          ‚îÇ 2             ‚îÇ
‚îÇ tuning      ‚îÇ [1]             ‚îÇ 1             ‚îÇ
‚îÇ database    ‚îÇ [2]             ‚îÇ 1             ‚îÇ
‚îÇ optimization‚îÇ [2]             ‚îÇ 1             ‚îÇ
‚îÇ guide       ‚îÇ [2]             ‚îÇ 1             ‚îÇ
‚îÇ index       ‚îÇ [3]             ‚îÇ 1             ‚îÇ
‚îÇ strategies  ‚îÇ [3]             ‚îÇ 1             ‚îÇ
‚îÇ monitoring  ‚îÇ [4]             ‚îÇ 1             ‚îÇ
‚îÇ tools       ‚îÇ [4]             ‚îÇ 1             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Recherche "mariadb performance" :
1. Trouver documents avec "mariadb" : [1, 3]
2. Trouver documents avec "performance" : [1, 4]
3. Intersection : [1]
4. Calculer score de pertinence pour document 1
5. Retourner r√©sultats tri√©s par pertinence
```

### Tokenisation et normalisation

Avant indexation, le texte est **tokenis√©** (d√©coup√© en mots) et **normalis√©** :

```sql
-- Texte original
"MariaDB's Performance-Tuning Guide: Optimizing Queries!"

-- Apr√®s tokenisation et normalisation :
-- 1. D√©coupage : ["MariaDB's", "Performance-Tuning", "Guide", "Optimizing", "Queries"]
-- 2. Minuscules : ["mariadb's", "performance-tuning", "guide", "optimizing", "queries"]
-- 3. Suppression ponctuation : ["mariadb", "performance", "tuning", "guide", "optimizing", "queries"]
-- 4. Suppression stopwords : ["mariadb", "performance", "tuning", "guide", "optimizing", "queries"]
-- 5. Indexation de chaque token
```

### Calcul de pertinence (Relevance Scoring)

MariaDB utilise un algorithme de scoring bas√© sur **TF-IDF** (Term Frequency-Inverse Document Frequency) :

```
Score de pertinence = TF * IDF

TF (Term Frequency) :
- Combien de fois le terme appara√Æt dans le document
- Plus le terme est fr√©quent, plus le score est √©lev√©

IDF (Inverse Document Frequency) :
- Raret√© du terme dans l'ensemble des documents
- Les termes rares ont plus de poids

Exemple :
- "the" appara√Æt dans 99% des documents ‚Üí IDF faible ‚Üí score faible
- "mariadb" appara√Æt dans 5% des documents ‚Üí IDF √©lev√© ‚Üí score √©lev√©
```

**Formule simplifi√©e** :

```
relevance = Œ£ (tf * idf * document_quality)

O√π :
- tf = fr√©quence du terme dans le document
- idf = log(total_documents / documents_avec_terme)
- document_quality = facteur qualit√© (longueur, etc.)
```

---

## Cr√©ation d'index Full-Text

### Syntaxe de base

```sql
-- Cr√©ation lors de la d√©finition de table
CREATE TABLE articles (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255),
    content TEXT,
    author VARCHAR(100),
    published_at DATETIME,
    FULLTEXT INDEX idx_content (title, content)
) ENGINE=InnoDB;

-- Ajout d'index Full-Text sur table existante
ALTER TABLE articles
ADD FULLTEXT INDEX idx_search (title, content);

-- Ou avec CREATE INDEX
CREATE FULLTEXT INDEX idx_search ON articles(title, content);
```

### Index sur une ou plusieurs colonnes

```sql
-- Index sur colonne unique
CREATE FULLTEXT INDEX idx_title ON articles(title);

-- Index sur plusieurs colonnes (recommand√©)
CREATE FULLTEXT INDEX idx_full_search ON articles(title, content, tags);
-- Permet de chercher simultan√©ment dans title, content et tags
```

üí° **Best practice** : Cr√©er un index multi-colonnes plut√¥t que plusieurs index simples pour r√©duire l'overhead.

### Moteurs support√©s

| Moteur | Support Full-Text | Notes |
|--------|-------------------|-------|
| **InnoDB** | ‚úÖ Oui (depuis MariaDB 10.0.5) | Recommand√©, transactionnel |
| **MyISAM** | ‚úÖ Oui | Historique, non-transactionnel |
| **Aria** | ‚úÖ Oui | Alternative √† MyISAM |
| **MEMORY** | ‚ùå Non | - |

```sql
-- InnoDB (recommand√©)
CREATE TABLE docs (
    id INT PRIMARY KEY,
    content TEXT,
    FULLTEXT INDEX idx_content (content)
) ENGINE=InnoDB;
```

---

## Modes de recherche Full-Text

### 1. Natural Language Mode (par d√©faut)

Mode le plus simple et le plus courant, avec scoring automatique de pertinence.

```sql
-- Syntaxe de base
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST('database performance');

-- Avec score de pertinence
SELECT
    id,
    title,
    MATCH(title, content) AGAINST('database performance') AS relevance
FROM articles
WHERE MATCH(title, content) AGAINST('database performance')
ORDER BY relevance DESC;
```

**Caract√©ristiques** :
- ‚úÖ Scoring automatique (TF-IDF)
- ‚úÖ Ignore les stopwords automatiquement
- ‚úÖ Recherche tous les mots (OR implicite)
- ‚ùå Pas d'op√©rateurs sp√©ciaux
- ‚ùå 50% threshold : mots pr√©sents dans >50% des docs sont ignor√©s

**Exemple d√©taill√©** :

```sql
CREATE TABLE blog_posts (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255),
    body TEXT,
    published BOOLEAN,
    FULLTEXT INDEX idx_search (title, body)
);

INSERT INTO blog_posts (title, body, published) VALUES
('MariaDB Performance Tuning', 'Learn how to optimize MariaDB performance...', TRUE),
('Database Indexing Strategies', 'Effective indexing for better performance...', TRUE),
('SQL Query Optimization', 'Advanced techniques for query performance...', TRUE);

-- Recherche en mode Natural Language
SELECT
    id,
    title,
    MATCH(title, body) AGAINST('performance optimization' IN NATURAL LANGUAGE MODE) AS score
FROM blog_posts
WHERE MATCH(title, body) AGAINST('performance optimization' IN NATURAL LANGUAGE MODE)
ORDER BY score DESC;

-- R√©sultats tri√©s par pertinence :
-- 1. "SQL Query Optimization" (score: 2.45) - contient les 2 mots
-- 2. "MariaDB Performance Tuning" (score: 1.82) - contient "performance"
-- 3. "Database Indexing Strategies" (score: 1.12) - contexte similaire
```

### 2. Boolean Mode

Mode avanc√© avec **op√©rateurs bool√©ens** pour contr√¥ler pr√©cis√©ment la recherche.

```sql
-- Syntaxe
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST('+mariadb +performance -mysql' IN BOOLEAN MODE);
```

**Op√©rateurs disponibles** :

| Op√©rateur | Signification | Exemple |
|-----------|---------------|---------|
| `+` | Mot **obligatoire** | `+database` |
| `-` | Mot **exclu** | `-deprecated` |
| `*` | **Wildcard** (pr√©fixe) | `optim*` (trouve optimize, optimization) |
| `""` | **Phrase exacte** | `"full text search"` |
| `()` | **Groupement** | `+(database mysql) +performance` |
| `>` | **Augmente** le poids | `>important` |
| `<` | **Diminue** le poids | `<optional` |
| `~` | Effet **n√©gatif** (pas exclu mais p√©nalis√©) | `~rarely` |

**Exemples d'utilisation** :

```sql
-- 1. Recherche obligatoire + exclusion
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST('+mariadb +performance -mysql' IN BOOLEAN MODE);
-- Doit contenir "mariadb" ET "performance", MAIS PAS "mysql"

-- 2. Phrase exacte
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST('"database optimization"' IN BOOLEAN MODE);
-- Trouve uniquement "database optimization" dans cet ordre exact

-- 3. Wildcard pour variantes
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST('optim*' IN BOOLEAN MODE);
-- Trouve : optimize, optimization, optimal, optimum, etc.

-- 4. Combinaison complexe
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST(
    '+(database mariadb mysql) +(performance optimization) -deprecated'
    IN BOOLEAN MODE
);
-- (database OU mariadb OU mysql) ET (performance OU optimization) SANS deprecated

-- 5. Pond√©ration
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST(
    '>critical +security <outdated'
    IN BOOLEAN MODE
);
-- "critical" = poids √©lev√©, "security" = obligatoire, "outdated" = poids faible

-- 6. N√©gation soft
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST(
    '+tutorial ~advanced'
    IN BOOLEAN MODE
);
-- Doit contenir "tutorial", p√©nalise (mais n'exclut pas) "advanced"
```

**Avantages Boolean Mode** :
- ‚úÖ Contr√¥le pr√©cis de la recherche
- ‚úÖ Combinaisons logiques complexes
- ‚úÖ Wildcards pour variations
- ‚úÖ Phrases exactes

**Limitations** :
- ‚ùå Pas de scoring de pertinence automatique
- ‚ùå Syntaxe plus complexe

### 3. Query Expansion Mode

Mode qui **√©largit automatiquement** la recherche en trouvant des termes reli√©s.

```sql
-- Syntaxe
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST(
    'database'
    WITH QUERY EXPANSION
);
-- Ou forme longue :
-- IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION
```

**Fonctionnement** :

```
√âtape 1 : Recherche initiale
‚Üí Trouver les documents contenant "database"

√âtape 2 : Analyse des r√©sultats
‚Üí Extraire les termes fr√©quents dans ces documents
‚Üí Exemple : "sql", "query", "table", "index"

√âtape 3 : Recherche √©largie
‚Üí Re-rechercher avec les termes originaux + termes reli√©s
‚Üí Trouver plus de documents pertinents

R√©sultat : Plus de r√©sultats, potentiellement plus pertinents
```

**Exemple concret** :

```sql
-- Sans Query Expansion
SELECT title, MATCH(title, content) AGAINST('mariadb') AS score
FROM articles
WHERE MATCH(title, content) AGAINST('mariadb')
ORDER BY score DESC;
-- R√©sultats : 12 articles contenant exactement "mariadb"

-- Avec Query Expansion
SELECT title, MATCH(title, content) AGAINST('mariadb' WITH QUERY EXPANSION) AS score
FROM articles
WHERE MATCH(title, content) AGAINST('mariadb' WITH QUERY EXPANSION)
ORDER BY score DESC;
-- R√©sultats : 45 articles contenant "mariadb", "mysql", "database", "sql", etc.
```

**Quand utiliser Query Expansion ?**

‚úÖ **Bon pour** :
- Bases de connaissances avec terminologie riche
- Recherches exploratoires
- Corpus de documents bien structur√©s

‚ùå **√âviter pour** :
- Termes ambigus (trop de r√©sultats non pertinents)
- Recherches pr√©cises
- Grandes bases (performance d√©grad√©e)

‚ö†Ô∏è **Attention** : Query Expansion **double le co√ªt** de la recherche (2 passes).

---

## Configuration Full-Text

### Variables syst√®me importantes

```sql
-- Afficher toutes les variables Full-Text
SHOW VARIABLES LIKE 'ft_%';

-- Variables principales :
SHOW VARIABLES LIKE 'ft_min_word_len';      -- Longueur minimale des mots
SHOW VARIABLES LIKE 'ft_max_word_len';      -- Longueur maximale des mots
SHOW VARIABLES LIKE 'ft_stopword_file';     -- Fichier des stopwords
SHOW VARIABLES LIKE 'ft_boolean_syntax';    -- Syntaxe des op√©rateurs bool√©ens
SHOW VARIABLES LIKE 'innodb_ft_%';          -- Variables InnoDB Full-Text
```

### Longueur minimale des mots (ft_min_word_len)

Par d√©faut, les mots de **moins de 4 caract√®res** sont ignor√©s :

```sql
-- V√©rifier la valeur actuelle
SHOW VARIABLES LIKE 'ft_min_word_len';
-- D√©faut : 4

-- Cons√©quences :
-- "SQL" ‚Üí ignor√© (3 caract√®res)
-- "API" ‚Üí ignor√© (3 caract√®res)
-- "PHP" ‚Üí ignor√© (3 caract√®res)
```

**Modifier ft_min_word_len** :

```sql
-- 1. Modifier dans my.cnf
[mysqld]
ft_min_word_len = 3

-- 2. Red√©marrer MariaDB

-- 3. Reconstruire les index Full-Text existants
REPAIR TABLE articles QUICK;
-- Ou
ALTER TABLE articles DROP INDEX idx_content;
ALTER TABLE articles ADD FULLTEXT INDEX idx_content (title, content);
```

üí° **Recommandation** :
- D√©faut (4) : Bon pour textes g√©n√©raux (blogs, articles)
- 3 : Bon pour contenu technique (SQL, API, etc.)
- 2 : Langues avec mots courts (chinois, codes)

### Stopwords (mots vides)

Les **stopwords** sont des mots tr√®s courants automatiquement ignor√©s :

```
Stopwords par d√©faut (extrait) :
"a", "an", "and", "are", "as", "at", "be", "by", "for", "from",
"has", "he", "in", "is", "it", "its", "of", "on", "that", "the",
"to", "was", "will", "with", etc.
```

**Personnaliser les stopwords** :

```sql
-- 1. Cr√©er un fichier custom stopwords
-- /etc/mysql/custom_stopwords.txt
the
and
or
-- (une liste personnalis√©e)

-- 2. Configurer dans my.cnf
[mysqld]
ft_stopword_file = '/etc/mysql/custom_stopwords.txt'

-- 3. Red√©marrer et reconstruire index

-- 4. D√©sactiver compl√®tement les stopwords
[mysqld]
ft_stopword_file = ''
```

**Voir les stopwords actifs** :

```sql
-- Table syst√®me des stopwords (InnoDB)
SELECT * FROM information_schema.INNODB_FT_DEFAULT_STOPWORD;
```

### Optimisation InnoDB Full-Text

```sql
-- Variables InnoDB sp√©cifiques
SHOW VARIABLES LIKE 'innodb_ft_%';

-- Cache pour construction d'index
SHOW VARIABLES LIKE 'innodb_ft_cache_size';
-- D√©faut : 8 MB, augmenter pour grandes tables

SET GLOBAL innodb_ft_cache_size = 67108864;  -- 64 MB

-- Taille max d'un token
SHOW VARIABLES LIKE 'innodb_ft_max_token_size';
-- D√©faut : 84 caract√®res

-- Nombre de threads pour construction parall√®le
SHOW VARIABLES LIKE 'innodb_ft_sort_pll_degree';
-- D√©faut : 2
```

---

## Requ√™tes et patterns avanc√©s

### Pattern 1 : Recherche avec filtres suppl√©mentaires

```sql
-- Combiner Full-Text avec WHERE classique
SELECT
    id,
    title,
    category,
    MATCH(title, content) AGAINST('performance') AS relevance
FROM articles
WHERE MATCH(title, content) AGAINST('performance')
AND published = TRUE
AND category IN ('Tutorial', 'Guide')
AND published_at > DATE_SUB(NOW(), INTERVAL 1 YEAR)
ORDER BY relevance DESC
LIMIT 20;
```

### Pattern 2 : Pagination des r√©sultats

```sql
-- Pagination avec Full-Text
SET @search_query = 'database optimization';

-- Page 1 (0-20)
SELECT id, title,
       MATCH(title, content) AGAINST(@search_query) AS score
FROM articles
WHERE MATCH(title, content) AGAINST(@search_query)
ORDER BY score DESC
LIMIT 20 OFFSET 0;

-- Page 2 (20-40)
SELECT id, title,
       MATCH(title, content) AGAINST(@search_query) AS score
FROM articles
WHERE MATCH(title, content) AGAINST(@search_query)
ORDER BY score DESC
LIMIT 20 OFFSET 20;
```

### Pattern 3 : Recherche multi-tables

```sql
-- Rechercher dans plusieurs tables
(
    SELECT 'article' AS type, id, title,
           MATCH(title, content) AGAINST('mariadb') AS relevance
    FROM articles
    WHERE MATCH(title, content) AGAINST('mariadb')
)
UNION ALL
(
    SELECT 'post' AS type, id, title,
           MATCH(title, body) AGAINST('mariadb') AS relevance
    FROM blog_posts
    WHERE MATCH(title, body) AGAINST('mariadb')
)
ORDER BY relevance DESC
LIMIT 50;
```

### Pattern 4 : Highlighting (mise en √©vidence)

```sql
-- Simuler le highlighting des r√©sultats
SELECT
    id,
    title,
    SUBSTRING(content,
        LOCATE('performance', LOWER(content)) - 50,
        100
    ) AS excerpt,
    MATCH(title, content) AGAINST('performance') AS score
FROM articles
WHERE MATCH(title, content) AGAINST('performance')
ORDER BY score DESC;

-- Pour un vrai highlighting, utiliser c√¥t√© application
-- Ou consid√©rer des solutions comme Elasticsearch
```

### Pattern 5 : Recherche avec seuil de pertinence

```sql
-- Filtrer par score minimum
SELECT
    id,
    title,
    MATCH(title, content) AGAINST('database') AS relevance
FROM articles
WHERE MATCH(title, content) AGAINST('database')
HAVING relevance > 1.0  -- Seuil de pertinence
ORDER BY relevance DESC;
```

---

## Performance et optimisation

### Analyser les requ√™tes Full-Text

```sql
-- EXPLAIN sur requ√™te Full-Text
EXPLAIN SELECT * FROM articles
WHERE MATCH(title, content) AGAINST('performance')\G

-- Informations importantes :
-- - type: fulltext (utilise l'index Full-Text)
-- - key: idx_content (nom de l'index utilis√©)
-- - rows: estimation du nombre de lignes
```

### Optimiser la construction d'index

```sql
-- 1. Augmenter le cache lors de la cr√©ation
SET GLOBAL innodb_ft_cache_size = 134217728;  -- 128 MB

-- 2. Cr√©er l'index avec ALGORITHM (11.x+)
ALTER TABLE articles
ADD FULLTEXT INDEX idx_content (title, content)
ALGORITHM=INPLACE, LOCK=NONE;

-- 3. Pour grandes tables : traitement par lots
-- D√©sactiver temporairement les mises √† jour Full-Text
SET GLOBAL innodb_ft_enable_stopword = 0;
-- Ins√©rer les donn√©es
-- R√©activer et reconstruire
SET GLOBAL innodb_ft_enable_stopword = 1;
OPTIMIZE TABLE articles;
```

### Maintenance des index Full-Text

```sql
-- Reconstruire l'index Full-Text
OPTIMIZE TABLE articles;

-- V√©rifier la fragmentation
SHOW TABLE STATUS LIKE 'articles'\G

-- Analyser la table
ANALYZE TABLE articles;

-- Statistiques Full-Text (InnoDB)
SELECT
    table_name,
    index_name,
    stat_value
FROM mysql.innodb_index_stats
WHERE table_name = 'articles'
AND index_name LIKE 'FTS_%';
```

### Cas particuliers de performance

**Probl√®me : Recherche lente sur grandes tables**

```sql
-- ‚ùå Mauvais : Full-Text sur table enti√®re
SELECT * FROM huge_table
WHERE MATCH(content) AGAINST('keyword');
-- Lent si des millions de lignes

-- ‚úÖ Solution 1 : Filtrer d'abord avec index classique
SELECT * FROM huge_table
WHERE category_id = 5  -- Index B-Tree
AND MATCH(content) AGAINST('keyword');

-- ‚úÖ Solution 2 : Partitionnement
CREATE TABLE huge_table (
    id INT,
    created_at DATE,
    content TEXT,
    FULLTEXT INDEX idx_content (content)
) PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026)
);
```

---

## Limitations et alternatives

### Limitations des index Full-Text MariaDB

| Limitation | Description | Impact |
|------------|-------------|--------|
| **Longueur minimale** | Mots < 4 caract√®res ignor√©s par d√©faut | Codes, acronymes non trouv√©s |
| **Stopwords** | Mots courants ignor√©s | "to be or not to be" ‚Üí vide |
| **Pas de fuzzy search** | Pas de tol√©rance aux fautes | "performence" ne trouve pas "performance" |
| **Pas de stemming** | Pas de variations morphologiques | "running" ne trouve pas "run" |
| **50% threshold** | Mots trop fr√©quents ignor√©s | Peu de documents = probl√®me |
| **Pas de synonymes** | Pas de recherche s√©mantique | "car" ne trouve pas "automobile" |
| **Highlighting limit√©** | Pas de mise en √©vidence native | Impl√©mentation c√¥t√© application |

### Quand consid√©rer des alternatives

**Elasticsearch** (moteur de recherche d√©di√©) :

‚úÖ **Utiliser Elasticsearch si** :
- Besoin de fuzzy search (tol√©rance aux fautes)
- Stemming et lemmatisation n√©cessaires
- Recherche multi-langues avanc√©e
- Synonymes et recherche s√©mantique
- Highlighting natif performant
- Analytics et aggregations complexes
- Scaling horizontal n√©cessaire

```sql
-- Au lieu de Full-Text MariaDB
SELECT * FROM articles WHERE MATCH(content) AGAINST('database');

-- Avec Elasticsearch (via API REST)
GET /articles/_search
{
  "query": {
    "match": {
      "content": {
        "query": "database",
        "fuzziness": "AUTO"  -- Tol√©rance aux fautes
      }
    }
  },
  "highlight": {
    "fields": {"content": {}}
  }
}
```

**Apache Solr** (alternative √† Elasticsearch) :
- Fonctionnalit√©s similaires √† Elasticsearch
- Meilleure gestion des facettes
- Plus mature (depuis 2006)

**Meilisearch** (moderne, open-source) :
- Ultra-rapide et simple
- Tol√©rance aux fautes native
- Typo-tolerance
- Excellent pour petites/moyennes applications

### Approche hybride : MariaDB + moteur externe

```sql
-- MariaDB : stockage des donn√©es
CREATE TABLE articles (
    id INT PRIMARY KEY,
    title VARCHAR(255),
    content TEXT,
    published_at DATETIME
) ENGINE=InnoDB;

-- Elasticsearch : index de recherche
-- Synchronisation via :
-- 1. Triggers MariaDB ‚Üí Queue ‚Üí Elasticsearch
-- 2. CDC (Change Data Capture) avec Debezium
-- 3. Batch synchronisation p√©riodique

-- Application :
-- - Recherche ‚Üí Elasticsearch (IDs)
-- - R√©cup√©ration donn√©es ‚Üí MariaDB (par IDs)
```

---

## Cas pratiques

### Cas 1 : Blog avec recherche d'articles

```sql
CREATE TABLE blog_articles (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    slug VARCHAR(255) UNIQUE,
    content LONGTEXT,
    excerpt TEXT,
    author_id INT,
    category_id INT,
    tags VARCHAR(500),
    published BOOLEAN DEFAULT FALSE,
    published_at DATETIME,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    INDEX idx_author (author_id),
    INDEX idx_category (category_id),
    INDEX idx_published (published, published_at),
    FULLTEXT INDEX idx_search (title, content, excerpt, tags)
) ENGINE=InnoDB;

-- Recherche d'articles publi√©s
SELECT
    id,
    title,
    excerpt,
    published_at,
    MATCH(title, content, excerpt, tags) AGAINST('+mariadb +tutorial' IN BOOLEAN MODE) AS relevance
FROM blog_articles
WHERE published = TRUE
AND MATCH(title, content, excerpt, tags) AGAINST('+mariadb +tutorial' IN BOOLEAN MODE)
ORDER BY relevance DESC, published_at DESC
LIMIT 10;
```

### Cas 2 : Syst√®me de tickets de support

```sql
CREATE TABLE support_tickets (
    ticket_id INT PRIMARY KEY AUTO_INCREMENT,
    subject VARCHAR(500),
    description TEXT,
    resolution TEXT,
    category VARCHAR(100),
    status ENUM('open', 'in_progress', 'resolved', 'closed'),
    priority ENUM('low', 'medium', 'high', 'urgent'),
    created_at DATETIME,
    resolved_at DATETIME,

    INDEX idx_status (status),
    INDEX idx_category (category),
    FULLTEXT INDEX idx_search (subject, description, resolution)
) ENGINE=InnoDB;

-- Recherche de solutions dans tickets r√©solus
SELECT
    ticket_id,
    subject,
    resolution,
    MATCH(subject, description, resolution) AGAINST('connection timeout error') AS score
FROM support_tickets
WHERE status = 'resolved'
AND resolution IS NOT NULL
AND MATCH(subject, description, resolution) AGAINST('connection timeout error')
ORDER BY score DESC
LIMIT 5;

-- Recherche avec variations
SELECT
    ticket_id,
    subject,
    MATCH(subject, description, resolution)
        AGAINST('+connection +(timeout error failure) database' IN BOOLEAN MODE) AS score
FROM support_tickets
WHERE status = 'resolved'
AND MATCH(subject, description, resolution)
    AGAINST('+connection +(timeout error failure) database' IN BOOLEAN MODE)
ORDER BY score DESC;
```

### Cas 3 : Documentation technique

```sql
CREATE TABLE documentation (
    doc_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255),
    slug VARCHAR(255) UNIQUE,
    content LONGTEXT,
    category VARCHAR(100),
    version VARCHAR(20),
    language CHAR(2) DEFAULT 'en',
    keywords VARCHAR(500),
    last_updated DATETIME,

    INDEX idx_category (category),
    INDEX idx_version (version),
    FULLTEXT INDEX idx_fullsearch (title, content, keywords)
) ENGINE=InnoDB;

-- Recherche dans la documentation avec wildcards
SELECT
    doc_id,
    title,
    category,
    MATCH(title, content, keywords) AGAINST('index* optim*' IN BOOLEAN MODE) AS relevance
FROM documentation
WHERE version = '11.8'
AND language = 'en'
AND MATCH(title, content, keywords) AGAINST('index* optim*' IN BOOLEAN MODE)
ORDER BY relevance DESC
LIMIT 20;
```

### Cas 4 : E-commerce - Recherche produits

```sql
CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255),
    description TEXT,
    long_description LONGTEXT,
    brand VARCHAR(100),
    category VARCHAR(100),
    price DECIMAL(10,2),
    stock INT,
    active BOOLEAN DEFAULT TRUE,

    INDEX idx_brand (brand),
    INDEX idx_category (category),
    INDEX idx_price (price),
    FULLTEXT INDEX idx_search (name, description, long_description, brand)
) ENGINE=InnoDB;

-- Recherche produits avec filtres
SELECT
    product_id,
    name,
    brand,
    price,
    MATCH(name, description, long_description, brand)
        AGAINST('+wireless +headphones -wired' IN BOOLEAN MODE) AS relevance
FROM products
WHERE active = TRUE
AND stock > 0
AND price BETWEEN 50 AND 200
AND MATCH(name, description, long_description, brand)
    AGAINST('+wireless +headphones -wired' IN BOOLEAN MODE)
ORDER BY relevance DESC, price ASC
LIMIT 24;
```

---

## ‚úÖ Points cl√©s √† retenir

- üìù **Full-Text = Recherche textuelle** : Sp√©cialis√© pour mots-cl√©s dans textes longs
- üîç **Index invers√©** : Structure qui mappe mots ‚Üí documents (inverted index)
- üìä **Scoring TF-IDF** : Calcul automatique de pertinence des r√©sultats
- üéØ **3 modes** : Natural Language (d√©faut), Boolean (op√©rateurs), Query Expansion (√©largi)
- ‚ûï **Op√©rateurs Boolean** : +obligatoire, -exclu, *wildcard, ""phrase, ()groupement
- üî§ **ft_min_word_len = 4** : Mots < 4 caract√®res ignor√©s par d√©faut (configurable)
- üö´ **Stopwords** : Mots courants ignor√©s ("the", "and", etc.), personnalisable
- üí° **Multi-colonnes** : Un index sur plusieurs colonnes est plus efficace que plusieurs index
- ‚ö° **InnoDB support√©** : Depuis MariaDB 10.0.5, transactionnel
- üé™ **Cas d'usage** : Blogs, documentation, support, e-commerce, forums
- ‚ö†Ô∏è **Limitations** : Pas de fuzzy search, pas de stemming, pas de synonymes natifs
- üîß **Alternatives** : Elasticsearch/Solr/Meilisearch pour besoins avanc√©s
- üèóÔ∏è **Approche hybride** : MariaDB (donn√©es) + moteur externe (recherche)

---

## üîó Ressources et r√©f√©rences

### Documentation officielle MariaDB

- [üìñ Full-Text Indexes](https://mariadb.com/kb/en/fulltext-index-overview/)
- [üìñ MATCH AGAINST](https://mariadb.com/kb/en/match-against/)
- [üìñ Full-Text Search Functions](https://mariadb.com/kb/en/full-text-search-functions/)
- [üìñ InnoDB Full-Text Indexes](https://mariadb.com/kb/en/innodb-full-text-indexes/)
- [üìñ Full-Text Stopwords](https://mariadb.com/kb/en/full-text-stopwords/)

### Articles techniques

- [Full-Text Search in MySQL](https://dev.mysql.com/doc/refman/8.0/en/fulltext-search.html)
- [Understanding TF-IDF](https://en.wikipedia.org/wiki/Tf%E2%80%93idf)
- [Full-Text Performance Tips](https://www.percona.com/blog/)

### Alternatives et comparaisons

- [Elasticsearch Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)
- [Apache Solr](https://solr.apache.org/)
- [Meilisearch](https://www.meilisearch.com/)
- [MariaDB vs Elasticsearch](https://mariadb.org/full-text-search/)

---

## ‚û°Ô∏è Section suivante

**[5.2.4 Spatial : Donn√©es g√©ographiques](./02.4-spatial.md)**

D√©couvrez les index Spatial (R-Tree) optimis√©s pour les donn√©es g√©ographiques : types g√©om√©triques (POINT, POLYGON, LINESTRING), fonctions spatiales (ST_Distance, ST_Contains, ST_Intersects), et cas d'usage pour applications de cartographie, livraison et localisation.

---


‚è≠Ô∏è [Spatial : Donn√©es g√©ographiques](/05-index-et-performance/02.4-spatial.md)
