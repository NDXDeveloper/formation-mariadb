ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 18.4.1 VIRTUAL vs STORED : Colonnes GÃ©nÃ©rÃ©es

> **Niveau** : AvancÃ©  
> **DurÃ©e estimÃ©e** : 2-3 heures  
> **PrÃ©requis** : 
> - MaÃ®trise des types de donnÃ©es MariaDB
> - ComprÃ©hension des index et performances
> - Connaissance des expressions SQL
> - Bases de l'optimisation de requÃªtes

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre la diffÃ©rence entre colonnes VIRTUAL et STORED
- Choisir le type appropriÃ© selon le cas d'usage
- ImplÃ©menter des colonnes gÃ©nÃ©rÃ©es pour optimiser les requÃªtes
- CrÃ©er des index sur colonnes virtuelles
- Identifier les cas oÃ¹ les colonnes gÃ©nÃ©rÃ©es amÃ©liorent les performances
- Ã‰viter les piÃ¨ges courants liÃ©s aux colonnes calculÃ©es

---

## Introduction

Les **colonnes gÃ©nÃ©rÃ©es** (ou colonnes calculÃ©es) sont des colonnes dont la valeur est **dÃ©rivÃ©e automatiquement** d'une expression basÃ©e sur d'autres colonnes de la mÃªme table. Contrairement aux colonnes classiques, leur valeur n'est jamais insÃ©rÃ©e ou mise Ã  jour manuellement : elle est toujours **calculÃ©e par le moteur**.

### Pourquoi utiliser des colonnes gÃ©nÃ©rÃ©es ?

Les colonnes gÃ©nÃ©rÃ©es rÃ©solvent plusieurs problÃ©matiques :

- **Normalisation et dÃ©normalisation contrÃ´lÃ©e** : Stocker des valeurs calculÃ©es sans briser la cohÃ©rence
- **Optimisation de requÃªtes** : Ã‰viter de recalculer des expressions complexes
- **Indexation d'expressions** : CrÃ©er des index sur des calculs
- **Simplification applicative** : DÃ©placer la logique mÃ©tier dans la base
- **Performances** : PrÃ©calcul de valeurs coÃ»teuses

ğŸ’¡ **Cas d'usage typiques** : 
- Champs dÃ©rivÃ©s (prix TTC depuis prix HT)
- Extraction de parties de JSON/XML
- Calculs gÃ©omÃ©triques
- Normalisation de donnÃ©es (uppercase, trim)
- CatÃ©gorisation automatique

---

## Concept fondamental

### DÃ©finition

Une colonne gÃ©nÃ©rÃ©e se dÃ©finit par :

```sql
colonne_name type_donnees [GENERATED ALWAYS] AS (expression) [VIRTUAL | STORED]
```

**Ã‰lÃ©ments clÃ©s :**
- `type_donnees` : Type de donnÃ©es du rÃ©sultat de l'expression
- `GENERATED ALWAYS` : Optionnel, rend explicite que c'est une colonne gÃ©nÃ©rÃ©e
- `expression` : Expression SQL calculant la valeur
- `VIRTUAL` : CalculÃ©e Ã  la lecture (non stockÃ©e)
- `STORED` : CalculÃ©e Ã  l'Ã©criture et stockÃ©e physiquement

### Syntaxe minimale

```sql
CREATE TABLE products (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    price_ht DECIMAL(10,2),
    -- Colonne gÃ©nÃ©rÃ©e : prix TTC (TVA 20%)
    price_ttc DECIMAL(10,2) AS (price_ht * 1.20)
);
```

Par dÃ©faut, sans spÃ©cifier `VIRTUAL` ou `STORED`, MariaDB utilise **VIRTUAL**.

---

## VIRTUAL : Calcul Ã  la lecture

### Principe de fonctionnement

Les colonnes **VIRTUAL** ne sont **jamais stockÃ©es physiquement** sur disque. Leur valeur est calculÃ©e **dynamiquement** Ã  chaque lecture.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Stockage disque (table)                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚ id â”‚ name   â”‚ price_ht â”‚             â”‚
â”‚  â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤             â”‚
â”‚  â”‚ 1  â”‚ Laptop â”‚ 800.00   â”‚             â”‚
â”‚  â”‚ 2  â”‚ Mouse  â”‚  25.00   â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                         â”‚
â”‚  price_ttc VIRTUAL â†’ calculÃ© Ã  la volÃ©e â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SELECT price_ttc FROM products WHERE id = 1;
â†’ Calcul : 800.00 * 1.20 = 960.00 (en mÃ©moire)
```

### Syntaxe et exemple

```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    quantity INT NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    discount_pct DECIMAL(5,2) DEFAULT 0,
    
    -- Colonnes VIRTUAL
    subtotal DECIMAL(10,2) AS (quantity * unit_price) VIRTUAL,
    discount_amount DECIMAL(10,2) AS (subtotal * discount_pct / 100) VIRTUAL,
    total DECIMAL(10,2) AS (subtotal - discount_amount) VIRTUAL
);

-- Insertion : seules les colonnes rÃ©elles
INSERT INTO orders (quantity, unit_price, discount_pct)
VALUES (5, 100.00, 10);

-- Lecture : colonnes VIRTUAL calculÃ©es automatiquement
SELECT order_id, quantity, unit_price, subtotal, discount_amount, total
FROM orders WHERE order_id = 1;

-- RÃ©sultat :
-- order_id | quantity | unit_price | subtotal | discount_amount | total
-- ---------|----------|------------|----------|-----------------|-------
-- 1        | 5        | 100.00     | 500.00   | 50.00           | 450.00
```

### CaractÃ©ristiques VIRTUAL

| Aspect | Comportement |
|--------|--------------|
| **Stockage** | Aucun (0 octets sur disque) |
| **Calcul** | Ã€ chaque SELECT (lecture) |
| **INSERT/UPDATE** | Pas de recalcul (pas de stockage) |
| **Performance lecture** | LÃ©gÃ¨rement plus lent (calcul runtime) |
| **Performance Ã©criture** | Optimal (pas de calcul) |
| **Espace disque** | Gain maximal |
| **Index** | Possible (index sur expression) |

### Avantages VIRTUAL

âœ… **Ã‰conomie d'espace** : Aucun stockage physique  
âœ… **CohÃ©rence garantie** : Toujours synchronisÃ© avec les colonnes sources  
âœ… **INSERT/UPDATE rapides** : Pas de calcul lors des Ã©critures  
âœ… **Maintenance simplifiÃ©e** : Changer l'expression affecte immÃ©diatement toutes les lectures

### InconvÃ©nients VIRTUAL

âŒ **Overhead lecture** : Calcul Ã  chaque SELECT (peut Ãªtre coÃ»teux)  
âŒ **Pas de statistiques** : ANALYZE TABLE ne gÃ©nÃ¨re pas de stats  
âŒ **Limite index** : Index nÃ©cessite plus de mÃ©moire (calcul lors de l'indexation)

---

## STORED : Calcul Ã  l'Ã©criture

### Principe de fonctionnement

Les colonnes **STORED** sont calculÃ©es lors de l'**INSERT ou UPDATE** et **stockÃ©es physiquement** sur disque comme une colonne classique.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Stockage disque (table)                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ id â”‚ name   â”‚ price_ht â”‚ price_ttc â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚ 1  â”‚ Laptop â”‚ 800.00   â”‚ 960.00    â”‚ â”‚
â”‚  â”‚ 2  â”‚ Mouse  â”‚  25.00   â”‚  30.00    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                         â”‚
â”‚  price_ttc STORED â†’ stockÃ© physiquement â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

INSERT INTO products VALUES (3, 'Keyboard', 120.00);
â†’ Calcul : 120.00 * 1.20 = 144.00 â†’ stockÃ© dans price_ttc

SELECT price_ttc FROM products WHERE id = 3;
â†’ Lecture directe : 144.00 (pas de calcul)
```

### Syntaxe et exemple

```sql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    birth_date DATE,
    
    -- Colonnes STORED
    full_name VARCHAR(101) AS (CONCAT(first_name, ' ', last_name)) STORED,
    age INT AS (TIMESTAMPDIFF(YEAR, birth_date, CURDATE())) STORED,
    age_category VARCHAR(20) AS (
        CASE 
            WHEN age < 30 THEN 'Junior'
            WHEN age BETWEEN 30 AND 45 THEN 'Senior'
            ELSE 'Expert'
        END
    ) STORED
);

-- Insertion
INSERT INTO employees (first_name, last_name, birth_date)
VALUES ('John', 'Doe', '1990-05-15');

-- Les colonnes STORED sont calculÃ©es et stockÃ©es immÃ©diatement
-- SELECT ultra-rapide (lecture directe, pas de calcul)
SELECT employee_id, full_name, age, age_category
FROM employees;
```

### CaractÃ©ristiques STORED

| Aspect | Comportement |
|--------|--------------|
| **Stockage** | Physique (occupe espace disque) |
| **Calcul** | Ã€ chaque INSERT/UPDATE |
| **SELECT** | Lecture directe (aucun calcul) |
| **Performance lecture** | Optimal (lecture standard) |
| **Performance Ã©criture** | Plus lent (calcul + stockage) |
| **Espace disque** | Consommation selon type de donnÃ©es |
| **Index** | Standard (comme colonne normale) |
| **Statistiques** | ComplÃ¨tes (ANALYZE TABLE) |

### Avantages STORED

âœ… **Performance lecture** : Aucun calcul lors des SELECT  
âœ… **Indexation standard** : Index comme sur colonne classique  
âœ… **Statistiques complÃ¨tes** : ANALYZE TABLE gÃ©nÃ¨re des stats  
âœ… **Tri et GROUP BY** : Optimal (pas de recalcul)  
âœ… **Fonctions non-dÃ©terministes** : Peut utiliser CURDATE(), RAND()  

### InconvÃ©nients STORED

âŒ **Consommation disque** : Espace proportionnel au type de donnÃ©es  
âŒ **INSERT/UPDATE plus lents** : Calcul + Ã©criture systÃ©matique  
âŒ **Risque dÃ©synchronisation** : Si expression modifiÃ©e, nÃ©cessite rebuild  
âŒ **Overhead mÃ©moire** : Buffer pool contient les valeurs calculÃ©es

---

## Tableau comparatif dÃ©taillÃ©

| CritÃ¨re | VIRTUAL | STORED |
|---------|---------|--------|
| **Stockage disque** | 0 octets | Taille type de donnÃ©es |
| **Calcul SELECT** | Oui (runtime) | Non (lecture directe) |
| **Calcul INSERT/UPDATE** | Non | Oui |
| **Performance SELECT** | -10 Ã  -30% | 100% (optimal) |
| **Performance INSERT/UPDATE** | 100% (optimal) | -5 Ã  -20% |
| **Indexation** | SupportÃ© mais coÃ»teux | Standard |
| **Statistiques** | Non | Oui (ANALYZE TABLE) |
| **ANALYZE TABLE** | Pas d'effet | Met Ã  jour stats |
| **Fonctions dÃ©terministes** | Oui | Oui |
| **Fonctions non-dÃ©terministes** | Non (CURDATE, RAND...) | Oui |
| **Ordre de calcul** | Lecture (aprÃ¨s WHERE) | Ã‰criture (avant stockage) |
| **Impact buffer pool** | Minimal | Standard |
| **Backup** | Minimal | Complet |

---

## RÃ¨gles de choix : VIRTUAL ou STORED ?

### Utiliser VIRTUAL quand :

âœ… **Ã‰conomie d'espace critique** : Millions de lignes, stockage limitÃ©  
âœ… **Calcul lÃ©ger** : Expression simple (multiplication, concatenation simple)  
âœ… **Peu de lectures** : Colonnes rarement SELECTÃ©es  
âœ… **Ã‰critures frÃ©quentes** : INSERT/UPDATE intensifs  
âœ… **DonnÃ©es volatiles** : Changements frÃ©quents des colonnes sources

**Exemple typique VIRTUAL :**
```sql
CREATE TABLE products (
    id INT PRIMARY KEY,
    price_ht DECIMAL(10,2),
    tax_rate DECIMAL(5,4) DEFAULT 0.20,
    
    -- VIRTUAL : calcul simple, Ã©conomie espace
    price_ttc DECIMAL(10,2) AS (price_ht * (1 + tax_rate)) VIRTUAL
);
```

### Utiliser STORED quand :

âœ… **Performance lecture prioritaire** : RequÃªtes frÃ©quentes sur la colonne  
âœ… **Calcul complexe** : Expression coÃ»teuse (regex, JSON, fonctions multiples)  
âœ… **Indexation nÃ©cessaire** : Index critique pour performances  
âœ… **Statistiques requises** : Optimiseur a besoin de cardinalitÃ© prÃ©cise  
âœ… **Fonctions non-dÃ©terministes** : CURDATE(), RAND(), USER()

**Exemple typique STORED :**
```sql
CREATE TABLE logs (
    log_id BIGINT PRIMARY KEY,
    log_data JSON,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- STORED : extraction JSON coÃ»teuse, souvent filtrÃ©e
    severity VARCHAR(20) AS (JSON_UNQUOTE(JSON_EXTRACT(log_data, '$.severity'))) STORED,
    
    INDEX idx_severity (severity) -- Index standard car STORED
);
```

### Matrice de dÃ©cision

```
                    FrÃ©quence lecture
                    Faible    â”‚    Ã‰levÃ©e
                    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Calcul simple    â”‚  VIRTUAL  â”‚  VIRTUAL*
                 â”‚           â”‚  ou STORED
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Calcul complexe  â”‚  VIRTUAL  â”‚  STORED
```

*Si Ã©conomie espace non critique et lectures trÃ¨s frÃ©quentes â†’ considÃ©rer STORED

---

## Cas d'usage pratiques

### 1. Extraction de donnÃ©es JSON (STORED)

```sql
-- Contexte : logs applicatifs avec mÃ©tadonnÃ©es JSON
CREATE TABLE application_logs (
    log_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    log_payload JSON,
    
    -- Extraction STORED pour indexation et filtrage rapide
    app_name VARCHAR(100) AS (JSON_UNQUOTE(JSON_EXTRACT(log_payload, '$.app'))) STORED,
    log_level VARCHAR(20) AS (JSON_UNQUOTE(JSON_EXTRACT(log_payload, '$.level'))) STORED,
    user_id INT AS (JSON_EXTRACT(log_payload, '$.user_id')) STORED,
    
    INDEX idx_app_level (app_name, log_level),
    INDEX idx_user (user_id)
);

-- Insertion
INSERT INTO application_logs (log_payload) VALUES
('{"app": "api-gateway", "level": "ERROR", "user_id": 12345, "message": "Timeout"}');

-- RequÃªte optimisÃ©e grÃ¢ce aux index sur colonnes STORED
SELECT log_id, created_at, log_level, log_payload
FROM application_logs
WHERE app_name = 'api-gateway'
AND log_level = 'ERROR'
AND created_at > DATE_SUB(NOW(), INTERVAL 1 HOUR);
-- â†’ Index idx_app_level utilisÃ©
```

**Justification STORED** : Extraction JSON coÃ»teuse, filtrage frÃ©quent, index essentiel.

### 2. Normalisation de donnÃ©es (VIRTUAL)

```sql
-- Contexte : recherche insensible Ã  la casse
CREATE TABLE customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(255) NOT NULL,
    
    -- VIRTUAL : normalisation pour recherche
    email_normalized VARCHAR(255) AS (LOWER(TRIM(email))) VIRTUAL,
    
    UNIQUE INDEX idx_email_normalized (email_normalized)
);

-- Insertion avec email mal formatÃ©
INSERT INTO customers (email) VALUES ('  John.Doe@Example.COM  ');

-- Recherche normalisÃ©e
SELECT * FROM customers
WHERE email_normalized = LOWER('john.doe@example.com');
-- â†’ Index utilisÃ©, email normalisÃ© automatiquement
```

**Justification VIRTUAL** : Calcul simple (LOWER + TRIM), Ã©conomie d'espace.

### 3. Calculs financiers complexes (STORED)

```sql
-- Contexte : calcul de commissions multi-paliers
CREATE TABLE sales (
    sale_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    sale_amount DECIMAL(15,2),
    customer_segment ENUM('bronze', 'silver', 'gold', 'platinum'),
    
    -- STORED : calcul complexe avec CASE imbriquÃ©s
    commission DECIMAL(15,2) AS (
        CASE 
            WHEN customer_segment = 'bronze' THEN 
                CASE 
                    WHEN sale_amount < 1000 THEN sale_amount * 0.02
                    WHEN sale_amount < 5000 THEN sale_amount * 0.03
                    ELSE sale_amount * 0.04
                END
            WHEN customer_segment = 'silver' THEN
                CASE 
                    WHEN sale_amount < 1000 THEN sale_amount * 0.03
                    WHEN sale_amount < 5000 THEN sale_amount * 0.045
                    ELSE sale_amount * 0.055
                END
            WHEN customer_segment = 'gold' THEN sale_amount * 0.07
            ELSE sale_amount * 0.10
        END
    ) STORED,
    
    INDEX idx_commission (commission)
);

-- Rapports de commissions ultra-rapides
SELECT 
    customer_segment,
    COUNT(*) AS nb_sales,
    SUM(sale_amount) AS total_sales,
    SUM(commission) AS total_commission,
    AVG(commission) AS avg_commission
FROM sales
GROUP BY customer_segment;
-- â†’ Pas de recalcul, lecture directe des commissions stockÃ©es
```

**Justification STORED** : Expression trÃ¨s complexe, agrÃ©gations frÃ©quentes, reporting.

### 4. GÃ©olocalisation et distance (STORED)

```sql
-- Contexte : calcul de distance depuis un point de rÃ©fÃ©rence
CREATE TABLE stores (
    store_id INT PRIMARY KEY,
    store_name VARCHAR(100),
    latitude DECIMAL(10,8),
    longitude DECIMAL(11,8),
    
    -- Distance depuis Paris (48.8566, 2.3522) en km
    distance_from_paris DECIMAL(10,2) AS (
        6371 * ACOS(
            COS(RADIANS(48.8566)) * COS(RADIANS(latitude)) *
            COS(RADIANS(longitude) - RADIANS(2.3522)) +
            SIN(RADIANS(48.8566)) * SIN(RADIANS(latitude))
        )
    ) STORED,
    
    INDEX idx_distance (distance_from_paris)
);

-- Recherche magasins dans rayon 50km de Paris
SELECT store_id, store_name, distance_from_paris
FROM stores
WHERE distance_from_paris <= 50
ORDER BY distance_from_paris
LIMIT 10;
-- â†’ Index idx_distance utilisÃ©, pas de recalcul trigonomÃ©trique
```

**Justification STORED** : Calcul trigonomÃ©trique trÃ¨s coÃ»teux, filtrage frÃ©quent.

### 5. Full-text search normalisÃ© (VIRTUAL + STORED)

```sql
-- Contexte : recherche full-text avec normalisation
CREATE TABLE articles (
    article_id INT PRIMARY KEY,
    title VARCHAR(200),
    content TEXT,
    
    -- VIRTUAL : concatÃ©nation pour recherche
    searchable_text TEXT AS (CONCAT(title, ' ', content)) VIRTUAL,
    
    -- STORED : hash pour dÃ©duplication
    content_hash CHAR(32) AS (MD5(content)) STORED,
    
    FULLTEXT INDEX ft_search (searchable_text),
    UNIQUE INDEX idx_hash (content_hash)
);

-- Recherche full-text
SELECT article_id, title
FROM articles
WHERE MATCH(searchable_text) AGAINST ('MariaDB optimization' IN BOOLEAN MODE);

-- DÃ©tecter doublons
SELECT content_hash, COUNT(*) 
FROM articles 
GROUP BY content_hash 
HAVING COUNT(*) > 1;
```

**Justification mixte** : 
- VIRTUAL pour searchable_text : Ã©vite de dupliquer title+content
- STORED pour hash : MD5 coÃ»teux, utilisÃ© pour contrainte UNIQUE

### 6. CatÃ©gorisation automatique (STORED)

```sql
-- Contexte : e-commerce avec catÃ©gorisation prix
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(200),
    price DECIMAL(10,2),
    
    -- CatÃ©gories de prix
    price_range VARCHAR(20) AS (
        CASE
            WHEN price < 50 THEN 'Budget'
            WHEN price < 200 THEN 'Standard'
            WHEN price < 500 THEN 'Premium'
            ELSE 'Luxury'
        END
    ) STORED,
    
    INDEX idx_price_range (price_range)
);

-- Rapports par catÃ©gorie
SELECT 
    price_range,
    COUNT(*) AS nb_products,
    MIN(price) AS min_price,
    MAX(price) AS max_price,
    AVG(price) AS avg_price
FROM products
GROUP BY price_range
ORDER BY 
    FIELD(price_range, 'Budget', 'Standard', 'Premium', 'Luxury');
```

**Justification STORED** : GROUP BY frÃ©quent, statistiques nÃ©cessaires.

---

## Indexation de colonnes gÃ©nÃ©rÃ©es

### Index sur colonne VIRTUAL

```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    email VARCHAR(255),
    
    -- Colonne VIRTUAL
    email_domain VARCHAR(100) AS (SUBSTRING_INDEX(email, '@', -1)) VIRTUAL,
    
    -- Index sur colonne VIRTUAL (supportÃ© depuis MariaDB 10.2)
    INDEX idx_domain (email_domain)
);

-- L'index fonctionne normalement
SELECT user_id, email 
FROM users 
WHERE email_domain = 'example.com';
-- â†’ idx_domain utilisÃ©

EXPLAIN SELECT user_id FROM users WHERE email_domain = 'gmail.com';
-- type: ref
-- key: idx_domain
-- Extra: Using index (covering index)
```

âš ï¸ **Contrainte** : L'expression doit Ãªtre **dÃ©terministe** (pas de CURDATE(), RAND(), etc.).

### Index sur colonne STORED

```sql
CREATE TABLE documents (
    doc_id BIGINT PRIMARY KEY,
    doc_content TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- STORED : extraction premiÃ¨re ligne
    first_line VARCHAR(255) AS (
        SUBSTRING_INDEX(doc_content, '\n', 1)
    ) STORED,
    
    -- Index standard
    INDEX idx_first_line (first_line)
);

-- Index fonctionne comme sur colonne normale
SELECT doc_id, first_line 
FROM documents 
WHERE first_line LIKE 'Important:%';
```

ğŸ’¡ **DiffÃ©rence performance** : Index sur STORED est plus rapide (pas de calcul lors de l'utilisation de l'index).

---

## Limitations et contraintes

### Expressions interdites

```sql
-- âŒ ERREUR : Colonnes gÃ©nÃ©rÃ©es ne peuvent rÃ©fÃ©rencer d'autres colonnes gÃ©nÃ©rÃ©es
CREATE TABLE test (
    a INT,
    b INT AS (a * 2) STORED,
    c INT AS (b * 3) STORED -- âŒ Interdit
);

-- âœ… CORRECT : Calculer directement depuis colonnes de base
CREATE TABLE test (
    a INT,
    b INT AS (a * 2) STORED,
    c INT AS (a * 6) STORED -- âœ… OK (a * 2 * 3 = a * 6)
);
```

### Fonctions non-dÃ©terministes (VIRTUAL)

```sql
-- âŒ ERREUR : VIRTUAL ne peut utiliser fonctions non-dÃ©terministes
CREATE TABLE events (
    event_id INT PRIMARY KEY,
    event_date DATE,
    days_ago INT AS (DATEDIFF(CURDATE(), event_date)) VIRTUAL -- âŒ Interdit
);

-- âœ… SOLUTION : Utiliser STORED
CREATE TABLE events (
    event_id INT PRIMARY KEY,
    event_date DATE,
    days_ago INT AS (DATEDIFF(CURDATE(), event_date)) STORED -- âœ… OK
);
-- Note : days_ago sera fixe (valeur au moment INSERT/UPDATE)
```

### Sous-requÃªtes interdites

```sql
-- âŒ ERREUR : Pas de sous-requÃªtes dans colonnes gÃ©nÃ©rÃ©es
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    total DECIMAL(10,2) AS (
        SELECT SUM(quantity * price) FROM order_items WHERE order_id = orders.order_id
    ) STORED; -- âŒ Interdit
);

-- âœ… ALTERNATIVE : Utiliser des triggers ou vues matÃ©rialisÃ©es
```

### RÃ©fÃ©rences de tables externes

```sql
-- âŒ ERREUR : Pas de rÃ©fÃ©rence Ã  d'autres tables
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    category_id INT,
    discount DECIMAL(5,2) AS (
        (SELECT default_discount FROM categories WHERE id = category_id)
    ) STORED; -- âŒ Interdit

-- âœ… ALTERNATIVE : Jointure ou trigger
```

---

## Performance : Benchmarks

### Test comparatif : 1 million de lignes

```sql
-- Configuration test
CREATE TABLE perf_test_virtual (
    id INT PRIMARY KEY AUTO_INCREMENT,
    value1 DECIMAL(10,2),
    value2 DECIMAL(10,2),
    result DECIMAL(10,2) AS (value1 * value2 / 100) VIRTUAL
) ENGINE=InnoDB;

CREATE TABLE perf_test_stored (
    id INT PRIMARY KEY AUTO_INCREMENT,
    value1 DECIMAL(10,2),
    value2 DECIMAL(10,2),
    result DECIMAL(10,2) AS (value1 * value2 / 100) STORED
) ENGINE=InnoDB;

-- Insertion 1M lignes
INSERT INTO perf_test_virtual (value1, value2)
SELECT RAND() * 1000, RAND() * 1000
FROM seq_1_to_1000000;

INSERT INTO perf_test_stored (value1, value2)
SELECT RAND() * 1000, RAND() * 1000
FROM seq_1_to_1000000;
```

**RÃ©sultats typiques :**

| OpÃ©ration | VIRTUAL | STORED | DiffÃ©rence |
|-----------|---------|--------|------------|
| **INSERT 1M rows** | 18s | 23s | +28% STORED |
| **SELECT result (1M rows)** | 3.2s | 0.8s | +300% VIRTUAL |
| **SELECT avec WHERE** | 0.05s | 0.02s | +150% VIRTUAL |
| **Espace disque** | 54 MB | 62 MB | +15% STORED |
| **Buffer pool** | 54 MB | 62 MB | +15% STORED |

ğŸ’¡ **Conclusion** : 
- VIRTUAL gagne sur Ã©critures et espace
- STORED gagne sur lectures (facteur 3-4Ã—)

### Cas complexe : Extraction JSON

```sql
-- 100K lignes avec JSON volumineux
CREATE TABLE json_test_virtual (
    id INT PRIMARY KEY AUTO_INCREMENT,
    data JSON,
    extracted VARCHAR(100) AS (JSON_UNQUOTE(JSON_EXTRACT(data, '$.complex.path.value'))) VIRTUAL
);

CREATE TABLE json_test_stored (
    id INT PRIMARY KEY AUTO_INCREMENT,
    data JSON,
    extracted VARCHAR(100) AS (JSON_UNQUOTE(JSON_EXTRACT(data, '$.complex.path.value'))) STORED
);

-- RÃ©sultats :
-- INSERT 100K : VIRTUAL 5s vs STORED 12s
-- SELECT avec filtrage : VIRTUAL 8s vs STORED 0.3s
-- â†’ STORED 26Ã— plus rapide en lecture !
```

---

## Modification de colonnes gÃ©nÃ©rÃ©es

### Modifier l'expression (VIRTUAL)

```sql
-- Changer l'expression d'une colonne VIRTUAL = instantanÃ©
ALTER TABLE products 
MODIFY COLUMN price_ttc DECIMAL(10,2) AS (price_ht * 1.055) VIRTUAL;
-- â†’ ImmÃ©diat, pas de rebuild

-- Prochains SELECT utiliseront nouvelle formule automatiquement
```

### Modifier l'expression (STORED)

```sql
-- Changer l'expression d'une colonne STORED = rebuild table complet
ALTER TABLE products 
MODIFY COLUMN price_ttc DECIMAL(10,2) AS (price_ht * 1.055) STORED;
-- â†’ REBUILD complet de la table (peut Ãªtre trÃ¨s long)

-- Alternative : migration avec downtime
ALTER TABLE products DROP COLUMN price_ttc;
ALTER TABLE products ADD COLUMN price_ttc DECIMAL(10,2) AS (price_ht * 1.055) STORED;
```

### Conversion VIRTUAL â†” STORED

```sql
-- VIRTUAL â†’ STORED : rebuild table
ALTER TABLE products 
MODIFY COLUMN price_ttc DECIMAL(10,2) AS (price_ht * 1.20) STORED;

-- STORED â†’ VIRTUAL : supprime donnÃ©es stockÃ©es
ALTER TABLE products 
MODIFY COLUMN price_ttc DECIMAL(10,2) AS (price_ht * 1.20) VIRTUAL;
```

âš ï¸ **Attention** : Ces opÃ©rations peuvent prendre des heures sur grosses tables â†’ planifier maintenance.

---

## Bonnes pratiques

### âœ… Recommandations

1. **DÃ©marrer VIRTUAL par dÃ©faut**
   ```sql
   -- Commencer VIRTUAL, passer STORED si performance lecture insuffisante
   ALTER TABLE ... ADD COLUMN col AS (expr) VIRTUAL;
   ```

2. **Monitorer performance**
   ```sql
   -- Mesurer temps requÃªtes avant/aprÃ¨s
   SET profiling = 1;
   SELECT ... WHERE generated_column = ...;
   SHOW PROFILES;
   ```

3. **Documenter les expressions**
   ```sql
   ALTER TABLE products ADD COLUMN 
       price_ttc DECIMAL(10,2) AS (price_ht * 1.20) VIRTUAL
       COMMENT 'Prix TTC avec TVA 20% - Formule: HT * 1.20';
   ```

4. **Indexer les colonnes filtrÃ©es**
   ```sql
   -- Si WHERE sur colonne gÃ©nÃ©rÃ©e â†’ indexer
   ALTER TABLE logs ADD INDEX idx_severity (severity);
   ```

5. **Utiliser pour normalisation**
   ```sql
   -- Normaliser emails, URLs, etc.
   email_normalized AS (LOWER(TRIM(email))) VIRTUAL
   ```

6. **Expressions dÃ©terministes pour VIRTUAL**
   ```sql
   -- âœ… OK
   full_name AS (CONCAT(first, ' ', last)) VIRTUAL
   
   -- âŒ Interdit
   created_ago AS (DATEDIFF(CURDATE(), created)) VIRTUAL
   ```

### âš ï¸ PiÃ¨ges Ã  Ã©viter

1. **Colonnes gÃ©nÃ©rÃ©es rÃ©fÃ©renÃ§ant d'autres gÃ©nÃ©rÃ©es**
2. **Expressions trop complexes en VIRTUAL** â†’ ralentit toutes les lectures
3. **STORED sans nÃ©cessitÃ©** â†’ gaspillage disque
4. **Oublier ANALYZE TABLE** sur STORED â†’ stats incorrectes
5. **Modifier expressions STORED en production** â†’ downtime
6. **NÃ©gliger les index** sur colonnes gÃ©nÃ©rÃ©es frÃ©quemment filtrÃ©es

---

## Cas d'usage avancÃ©s

### 1. Audit automatique avec STORED

```sql
CREATE TABLE sensitive_data (
    id INT PRIMARY KEY AUTO_INCREMENT,
    ssn VARCHAR(11), -- NumÃ©ro sÃ©curitÃ© sociale
    
    -- Hash pour recherche sans rÃ©vÃ©ler donnÃ©es
    ssn_hash CHAR(64) AS (SHA2(ssn, 256)) STORED,
    
    -- Masquage partiel
    ssn_masked VARCHAR(11) AS (
        CONCAT('***-**-', SUBSTRING(ssn, -4))
    ) VIRTUAL,
    
    UNIQUE INDEX idx_ssn_hash (ssn_hash)
);

-- Recherche sÃ©curisÃ©e
SELECT id, ssn_masked FROM sensitive_data
WHERE ssn_hash = SHA2('123-45-6789', 256);
```

### 2. Partitionnement sur colonne gÃ©nÃ©rÃ©e

```sql
CREATE TABLE time_series (
    ts TIMESTAMP,
    value DECIMAL(10,2),
    
    -- STORED nÃ©cessaire pour partitionnement
    ts_year INT AS (YEAR(ts)) STORED,
    ts_month INT AS (MONTH(ts)) STORED
)
PARTITION BY RANGE (ts_year) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026)
);
```

### 3. Tri personnalisÃ© avec STORED

```sql
CREATE TABLE tasks (
    task_id INT PRIMARY KEY,
    priority ENUM('low', 'medium', 'high', 'critical'),
    
    -- Ordre numÃ©rique pour tri
    priority_order INT AS (
        CASE priority
            WHEN 'critical' THEN 1
            WHEN 'high' THEN 2
            WHEN 'medium' THEN 3
            WHEN 'low' THEN 4
        END
    ) STORED,
    
    INDEX idx_priority (priority_order)
);

SELECT * FROM tasks ORDER BY priority_order LIMIT 10;
```

---

## âœ… Points clÃ©s Ã  retenir

- **VIRTUAL** : CalculÃ©e Ã  la lecture, 0 stockage, optimal pour Ã©critures
- **STORED** : CalculÃ©e Ã  l'Ã©criture, stockÃ©e physiquement, optimal pour lectures
- **RÃ¨gle d'or** : VIRTUAL par dÃ©faut, STORED si performance lecture critique
- Les colonnes gÃ©nÃ©rÃ©es **simplifient la logique applicative**
- **L'indexation** est possible sur les deux types
- VIRTUAL ne peut utiliser **fonctions non-dÃ©terministes** (CURDATE, RAND...)
- STORED consomme de l'**espace disque** comme une colonne normale
- Modifier une expression STORED = **rebuild complet** de la table
- Les colonnes gÃ©nÃ©rÃ©es ne peuvent **rÃ©fÃ©rencer d'autres tables**
- **Documenter les expressions** pour maintenance future

---

## ğŸ”— Ressources et rÃ©fÃ©rences

- [ğŸ“– MariaDB - Generated (Virtual and Stored) Columns](https://mariadb.com/kb/en/generated-columns/)
- [ğŸ“– CREATE TABLE - Generated Columns](https://mariadb.com/kb/en/create-table/#generated-columns)
- [ğŸ“– Indexes on Generated Columns](https://mariadb.com/kb/en/generated-columns/#indexes-on-generated-columns)
- [ğŸ“– ALTER TABLE - Modifying Generated Columns](https://mariadb.com/kb/en/alter-table/#modifying-generated-columns)
- [ğŸ”§ Performance Considerations](https://mariadb.com/kb/en/generated-columns/#performance)

---

## â¡ï¸ Section suivante

**18.4.2 [Indexation de colonnes gÃ©nÃ©rÃ©es](./04.2-indexation-colonnes-generees.md)** : Approfondissez les stratÃ©gies d'indexation sur colonnes VIRTUAL et STORED, avec optimisations avancÃ©es pour expressions complexes, JSON et full-text search.

â­ï¸ [Indexation de colonnes gÃ©nÃ©rÃ©es](/18-fonctionnalites-avancees/04.2-indexation-colonnes-generees.md)
