üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.2.2 Requ√™tes Temporelles (AS OF, BETWEEN, FROM...TO)

> **Niveau** : Avanc√©  
> **Dur√©e estim√©e** : 2-3 heures  
> **Pr√©requis** : 
> - Section 18.2.1 - Cr√©ation et configuration des System-Versioned Tables
> - Ma√Ætrise des requ√™tes SELECT avanc√©es
> - Compr√©hension des JOINs et sous-requ√™tes
> - Connaissance des fonctions de dates et timestamps

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Interroger l'historique √† un instant pr√©cis (AS OF)
- Analyser l'√©volution des donn√©es sur une p√©riode (BETWEEN, FROM...TO)
- Combiner des requ√™tes temporelles avec des JOINs complexes
- Optimiser les performances des requ√™tes historiques
- Impl√©menter des cas d'usage m√©tier (audit, reporting, analyse)

---

## Introduction

Les **requ√™tes temporelles** permettent d'interroger l'historique des System-Versioned Tables en utilisant la syntaxe standard **SQL:2011**. Contrairement aux requ√™tes classiques qui retournent uniquement l'√©tat actuel, les requ√™tes temporelles donnent acc√®s √† **toutes les versions pass√©es** des donn√©es.

### Pourquoi des requ√™tes temporelles ?

Les requ√™tes temporelles r√©pondent √† des questions m√©tier critiques :

- **"Quel √©tait le solde de ce compte le 15 mars √† 14h00 ?"** ‚Üí AS OF
- **"Quelles modifications ont √©t√© apport√©es ce mois-ci ?"** ‚Üí BETWEEN
- **"Comment le prix de ce produit a-t-il √©volu√© en 2024 ?"** ‚Üí FROM...TO
- **"Afficher toutes les versions de cette commande"** ‚Üí ALL
- **"Qui a modifi√© quoi et quand ?"** ‚Üí Audit trail complet

üí° **Transparence applicative** : Les requ√™tes temporelles utilisent la m√™me syntaxe SELECT que les requ√™tes normales, avec simplement une clause `FOR SYSTEM_TIME` suppl√©mentaire.

---

## Syntaxe g√©n√©rale

La clause `FOR SYSTEM_TIME` s'ajoute apr√®s le nom de la table dans la requ√™te SELECT :

```sql
SELECT colonnes
FROM table_name FOR SYSTEM_TIME <clause_temporelle>
WHERE conditions;
```

### Les quatre clauses temporelles

| Clause | Description | Cas d'usage |
|--------|-------------|-------------|
| `AS OF timestamp` | √âtat exact √† un instant T | Point-in-time recovery, audit |
| `BETWEEN t1 AND t2` | Versions actives pendant l'intervalle | Analyse de p√©riode |
| `FROM t1 TO t2` | Versions dont la p√©riode chevauche [t1, t2] | Recherche de modifications |
| `ALL` | Toutes les versions (courante + historique) | Analyse compl√®te |

---

## AS OF : Requ√™te √† un instant pr√©cis

### Syntaxe et fonctionnement

```sql
SELECT * FROM table_name
FOR SYSTEM_TIME AS OF 'timestamp'
WHERE conditions;
```

**Comportement** : Retourne les lignes qui √©taient **valides** au moment sp√©cifi√©, c'est-√†-dire :
- `sys_start <= timestamp`
- `sys_end > timestamp`

### Exemples pratiques

#### 1. √âtat d'une table √† une date donn√©e

```sql
-- Configuration initiale
CREATE TABLE inventory (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(100),
    quantity INT,
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end)
) WITH SYSTEM VERSIONING;

-- Donn√©es actuelles
INSERT INTO inventory VALUES 
(1, 'Laptop Dell XPS', 50, NOW()),
(2, 'iPhone 15 Pro', 120, NOW()),
(3, 'Samsung Galaxy S24', 80, NOW());

-- Modifications ult√©rieures...
UPDATE inventory SET quantity = 45 WHERE product_id = 1;
UPDATE inventory SET quantity = 95 WHERE product_id = 2;

-- Requ√™te : √©tat du stock le 10 d√©cembre 2025 √† 10h00
SELECT 
    product_id,
    product_name,
    quantity
FROM inventory
FOR SYSTEM_TIME AS OF '2025-12-10 10:00:00'
ORDER BY product_id;
```

#### 2. Comparaison avant/apr√®s

```sql
-- Comparer l'√©tat actuel avec l'√©tat d'il y a 24 heures
SELECT 
    c.product_id,
    c.product_name,
    h.quantity AS quantity_24h_ago,
    c.quantity AS quantity_now,
    c.quantity - h.quantity AS variation
FROM inventory c
LEFT JOIN (
    SELECT product_id, quantity 
    FROM inventory 
    FOR SYSTEM_TIME AS OF DATE_SUB(NOW(), INTERVAL 24 HOUR)
) h ON c.product_id = h.product_id
WHERE c.quantity - h.quantity != 0;
```

#### 3. Audit : qui a modifi√© quoi ?

```sql
-- Table avec tra√ßabilit√© utilisateur
CREATE TABLE customer_data (
    customer_id INT PRIMARY KEY,
    email VARCHAR(100),
    phone VARCHAR(20),
    modified_by VARCHAR(50) DEFAULT USER(),
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end)
) WITH SYSTEM VERSIONING;

-- Audit : √©tat du client 12345 au moment de la r√©clamation
SELECT 
    customer_id,
    email,
    phone,
    modified_by,
    sys_start AS valid_from,
    sys_end AS valid_to
FROM customer_data
FOR SYSTEM_TIME AS OF '2025-11-15 14:30:00'
WHERE customer_id = 12345;
```

üí° **Conseil** : Stocker `USER()` ou l'ID utilisateur applicatif dans une colonne permet de savoir **qui** a fait la modification.

---

## BETWEEN : Versions actives dans un intervalle

### Syntaxe et fonctionnement

```sql
SELECT * FROM table_name
FOR SYSTEM_TIME BETWEEN 't1' AND 't2'
WHERE conditions;
```

**Comportement** : Retourne les lignes qui √©taient **actives √† un moment quelconque** dans l'intervalle [t1, t2] :
- `sys_start <= t2`
- `sys_end > t1`

‚ö†Ô∏è **Important** : Une m√™me ligne peut appara√Ætre **plusieurs fois** si elle a √©t√© modifi√©e dans l'intervalle.

### Exemples pratiques

#### 1. Modifications pendant une p√©riode

```sql
-- Table de prix
CREATE TABLE product_prices (
    product_id INT PRIMARY KEY,
    price DECIMAL(10,2),
    currency CHAR(3) DEFAULT 'EUR',
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end)
) WITH SYSTEM VERSIONING;

-- Historique des prix d'un produit en novembre 2025
SELECT 
    product_id,
    price,
    currency,
    sys_start AS price_valid_from,
    sys_end AS price_valid_to,
    TIMESTAMPDIFF(MINUTE, sys_start, sys_end) AS duration_minutes
FROM product_prices
FOR SYSTEM_TIME BETWEEN '2025-11-01 00:00:00' AND '2025-11-30 23:59:59'
WHERE product_id = 42
ORDER BY sys_start;
```

#### 2. Nombre de modifications par enregistrement

```sql
-- Analyse : quels clients ont √©t√© modifi√©s le plus souvent cette semaine ?
SELECT 
    customer_id,
    email,
    COUNT(*) AS nb_modifications,
    MIN(sys_start) AS first_change,
    MAX(sys_start) AS last_change
FROM customer_data
FOR SYSTEM_TIME BETWEEN 
    DATE_SUB(NOW(), INTERVAL 7 DAY) 
    AND NOW()
GROUP BY customer_id, email
HAVING COUNT(*) > 1
ORDER BY nb_modifications DESC;
```

#### 3. D√©tection de modifications suspectes

```sql
-- Alertes : comptes bancaires modifi√©s plus de 5 fois en 1 heure
SELECT 
    account_id,
    COUNT(*) AS nb_changes,
    GROUP_CONCAT(DISTINCT modified_by) AS users_involved,
    MIN(sys_start) AS period_start,
    MAX(sys_start) AS period_end
FROM bank_accounts
FOR SYSTEM_TIME BETWEEN 
    DATE_SUB(NOW(), INTERVAL 1 HOUR) 
    AND NOW()
GROUP BY account_id
HAVING COUNT(*) > 5
ORDER BY nb_changes DESC;
```

---

## FROM...TO : P√©riode de validit√© qui chevauche

### Syntaxe et fonctionnement

```sql
SELECT * FROM table_name
FOR SYSTEM_TIME FROM 't1' TO 't2'
WHERE conditions;
```

**Diff√©rence avec BETWEEN** :
- `BETWEEN` : Lignes actives **√† un moment** dans [t1, t2]
- `FROM...TO` : Lignes dont la **p√©riode de validit√© chevauche** [t1, t2] (s√©mantique l√©g√®rement diff√©rente selon impl√©mentation)

üí° **En pratique** : Dans MariaDB, `FROM t1 TO t2` est similaire √† `BETWEEN t1 AND t2` mais avec une s√©mantique plus stricte sur les bornes.

### Exemple : Analyse de prix sur p√©riode

```sql
-- Prix en vigueur pendant le Black Friday 2025
SELECT 
    p.product_id,
    p.product_name,
    pp.price,
    pp.sys_start AS valid_from,
    pp.sys_end AS valid_to
FROM products p
JOIN product_prices pp 
    ON p.product_id = pp.product_id
FOR SYSTEM_TIME FROM '2025-11-25 00:00:00' TO '2025-11-30 23:59:59'
WHERE p.category = 'Electronics'
ORDER BY p.product_id, pp.sys_start;
```

---

## ALL : Historique complet

### Syntaxe et fonctionnement

```sql
SELECT * FROM table_name
FOR SYSTEM_TIME ALL
WHERE conditions;
```

**Comportement** : Retourne **toutes les versions** (table courante + table d'historique), dans l'ordre chronologique.

‚ö†Ô∏è **Attention** : Peut retourner un **volume massif** de donn√©es sur des tables tr√®s actives.

### Exemples pratiques

#### 1. Historique complet d'un enregistrement

```sql
-- Toutes les versions d'une commande
SELECT 
    order_id,
    status,
    total_amount,
    sys_start AS valid_from,
    sys_end AS valid_to,
    CASE 
        WHEN sys_end = '2038-01-19 03:14:07.999999' THEN 'CURRENT'
        ELSE 'HISTORY'
    END AS version_type
FROM orders
FOR SYSTEM_TIME ALL
WHERE order_id = 98765
ORDER BY sys_start;
```

**R√©sultat attendu :**
```
order_id | status    | total_amount | valid_from          | valid_to            | version_type
---------|-----------|--------------|---------------------|---------------------|-------------
98765    | pending   | 150.00       | 2025-12-01 10:30:00 | 2025-12-01 11:00:00 | HISTORY
98765    | confirmed | 150.00       | 2025-12-01 11:00:00 | 2025-12-02 09:15:00 | HISTORY
98765    | shipped   | 150.00       | 2025-12-02 09:15:00 | 2025-12-03 14:20:00 | HISTORY
98765    | delivered | 150.00       | 2025-12-03 14:20:00 | 2038-01-19 03:14:07 | CURRENT
```

#### 2. Analyse de dur√©e de vie des statuts

```sql
-- Temps moyen pass√© dans chaque statut
SELECT 
    status,
    COUNT(*) AS nb_occurrences,
    AVG(TIMESTAMPDIFF(SECOND, sys_start, sys_end)) AS avg_duration_seconds,
    MIN(TIMESTAMPDIFF(SECOND, sys_start, sys_end)) AS min_duration_seconds,
    MAX(TIMESTAMPDIFF(SECOND, sys_start, sys_end)) AS max_duration_seconds
FROM orders
FOR SYSTEM_TIME ALL
WHERE sys_end != '2038-01-19 03:14:07.999999' -- Exclure version courante
GROUP BY status
ORDER BY avg_duration_seconds DESC;
```

#### 3. Timeline compl√®te avec utilisateur

```sql
-- Historique d√©taill√© avec qui a fait quoi
SELECT 
    sys_start AS timestamp,
    customer_id,
    email,
    phone,
    modified_by AS user,
    LAG(email) OVER (PARTITION BY customer_id ORDER BY sys_start) AS previous_email,
    LAG(phone) OVER (PARTITION BY customer_id ORDER BY sys_start) AS previous_phone
FROM customer_data
FOR SYSTEM_TIME ALL
WHERE customer_id = 5678
ORDER BY sys_start;
```

---

## Combinaisons avec JOINs

### JOINs sur requ√™tes temporelles

```sql
-- Joindre deux tables avec historique synchronis√©
SELECT 
    o.order_id,
    o.status,
    o.total_amount,
    c.customer_name,
    c.email
FROM orders o
FOR SYSTEM_TIME AS OF '2025-12-01 15:00:00'
JOIN customers c
FOR SYSTEM_TIME AS OF '2025-12-01 15:00:00'
    ON o.customer_id = c.customer_id
WHERE o.status = 'pending';
```

üí° **Coh√©rence temporelle** : Utiliser le **m√™me timestamp** sur toutes les tables pour garantir une vue coh√©rente.

### Analyse de corr√©lation temporelle

```sql
-- D√©tection : modifications simultan√©es sur commande et client
SELECT 
    o.order_id,
    o.status AS order_status,
    o.sys_start AS order_modified,
    c.email AS customer_email,
    c.sys_start AS customer_modified,
    TIMESTAMPDIFF(SECOND, o.sys_start, c.sys_start) AS time_diff_seconds
FROM orders o
FOR SYSTEM_TIME BETWEEN '2025-12-01' AND '2025-12-31'
JOIN customers c
FOR SYSTEM_TIME BETWEEN '2025-12-01' AND '2025-12-31'
    ON o.customer_id = c.customer_id
WHERE ABS(TIMESTAMPDIFF(SECOND, o.sys_start, c.sys_start)) < 300 -- ¬±5 min
ORDER BY o.order_id, o.sys_start;
```

### Reconstruction d'√©tat global

```sql
-- Vue compl√®te d'un syst√®me √† un instant T
CREATE VIEW system_snapshot_2025_12_15 AS
SELECT 
    o.order_id,
    o.status,
    o.total_amount,
    c.customer_name,
    c.email,
    p.product_name,
    p.price
FROM orders o
FOR SYSTEM_TIME AS OF '2025-12-15 00:00:00'
JOIN customers c
FOR SYSTEM_TIME AS OF '2025-12-15 00:00:00'
    ON o.customer_id = c.customer_id
JOIN order_items oi
FOR SYSTEM_TIME AS OF '2025-12-15 00:00:00'
    ON o.order_id = oi.order_id
JOIN products p
FOR SYSTEM_TIME AS OF '2025-12-15 00:00:00'
    ON oi.product_id = p.product_id;
```

---

## Optimisation des requ√™tes temporelles

### 1. Indexation appropri√©e

```sql
-- Index sur les colonnes de p√©riode pour performances
ALTER TABLE orders_history 
ADD INDEX idx_sys_period (sys_start, sys_end);

-- Index composite pour requ√™tes filtr√©es
ALTER TABLE orders_history
ADD INDEX idx_customer_period (customer_id, sys_start, sys_end);
```

**Impact performance :**
- Sans index : Full table scan sur l'historique
- Avec index : Recherche optimis√©e par p√©riode

### 2. Partitionnement de l'historique

```sql
-- Partitionner par ann√©e pour pruning automatique
ALTER TABLE orders_history
PARTITION BY RANGE (YEAR(sys_end)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- Requ√™te ciblant une seule partition
EXPLAIN SELECT * FROM orders
FOR SYSTEM_TIME AS OF '2024-06-15'
WHERE order_id = 12345;
-- ‚Üí Partition pruning : seule p2024 sera scann√©e
```

### 3. Limitation du scope temporel

```sql
-- ‚ùå MAUVAIS : Scan complet de l'historique
SELECT * FROM orders
FOR SYSTEM_TIME ALL
WHERE customer_id = 999;

-- ‚úÖ MEILLEUR : Limiter √† une p√©riode raisonnable
SELECT * FROM orders
FOR SYSTEM_TIME BETWEEN 
    DATE_SUB(NOW(), INTERVAL 90 DAY) 
    AND NOW()
WHERE customer_id = 999;
```

### 4. Utilisation de colonnes g√©n√©r√©es index√©es

```sql
-- Colonne g√©n√©r√©e pour ann√©e/mois d'historisation
ALTER TABLE orders ADD COLUMN 
    history_month VARCHAR(7) 
    GENERATED ALWAYS AS (DATE_FORMAT(sys_end, '%Y-%m'))
    VIRTUAL;

ALTER TABLE orders_history ADD INDEX idx_history_month (history_month);

-- Requ√™te optimis√©e
SELECT * FROM orders
FOR SYSTEM_TIME ALL
WHERE history_month = '2025-11'
AND customer_id = 999;
```

---

## Cas d'usage avanc√©s

### 1. Reporting financier point-in-time

```sql
-- Bilan comptable au 31 d√©cembre 2024 √† minuit
SELECT 
    account_type,
    SUM(balance) AS total_balance
FROM accounts
FOR SYSTEM_TIME AS OF '2024-12-31 23:59:59'
GROUP BY account_type
ORDER BY account_type;

-- Comparaison inter-annuelle
SELECT 
    account_type,
    SUM(balance_2024) AS balance_2024,
    SUM(balance_2023) AS balance_2023,
    SUM(balance_2024 - balance_2023) AS variation
FROM (
    SELECT 
        account_type,
        balance AS balance_2024,
        0 AS balance_2023
    FROM accounts
    FOR SYSTEM_TIME AS OF '2024-12-31 23:59:59'
    
    UNION ALL
    
    SELECT 
        account_type,
        0 AS balance_2024,
        balance AS balance_2023
    FROM accounts
    FOR SYSTEM_TIME AS OF '2023-12-31 23:59:59'
) combined
GROUP BY account_type;
```

### 2. D√©tection de fraude par analyse de patterns

```sql
-- D√©tection : modifications multiples rapides (pattern de fraude)
WITH rapid_changes AS (
    SELECT 
        account_id,
        balance,
        sys_start,
        LAG(sys_start) OVER (PARTITION BY account_id ORDER BY sys_start) 
            AS previous_change,
        TIMESTAMPDIFF(SECOND, 
            LAG(sys_start) OVER (PARTITION BY account_id ORDER BY sys_start),
            sys_start
        ) AS seconds_since_last_change
    FROM bank_accounts
    FOR SYSTEM_TIME BETWEEN 
        DATE_SUB(NOW(), INTERVAL 1 DAY) 
        AND NOW()
)
SELECT 
    account_id,
    COUNT(*) AS nb_rapid_changes,
    MIN(seconds_since_last_change) AS min_interval_seconds,
    GROUP_CONCAT(sys_start ORDER BY sys_start) AS change_timestamps
FROM rapid_changes
WHERE seconds_since_last_change IS NOT NULL 
AND seconds_since_last_change < 60 -- Moins d'1 minute entre modifs
GROUP BY account_id
HAVING COUNT(*) >= 3
ORDER BY nb_rapid_changes DESC;
```

### 3. Analyse de tendances temporelles

```sql
-- √âvolution du panier moyen par mois
SELECT 
    DATE_FORMAT(sys_start, '%Y-%m') AS month,
    AVG(total_amount) AS avg_order_value,
    COUNT(*) AS nb_orders,
    SUM(total_amount) AS total_revenue
FROM orders
FOR SYSTEM_TIME ALL
WHERE status = 'completed'
AND sys_end != '2038-01-19 03:14:07.999999' -- Historique uniquement
GROUP BY DATE_FORMAT(sys_start, '%Y-%m')
ORDER BY month DESC
LIMIT 12;
```

### 4. Audit trail pour conformit√© RGPD

```sql
-- Rapport : toutes les modifications de donn√©es personnelles
CREATE VIEW gdpr_audit_trail AS
SELECT 
    customer_id,
    email,
    phone,
    address,
    modified_by,
    sys_start AS modification_timestamp,
    CASE 
        WHEN sys_end = '2038-01-19 03:14:07.999999' THEN 'ACTIVE'
        ELSE 'ARCHIVED'
    END AS record_status,
    CASE
        WHEN LAG(email) OVER (PARTITION BY customer_id ORDER BY sys_start) != email 
            THEN 'Email changed'
        WHEN LAG(phone) OVER (PARTITION BY customer_id ORDER BY sys_start) != phone 
            THEN 'Phone changed'
        WHEN LAG(address) OVER (PARTITION BY customer_id ORDER BY sys_start) != address 
            THEN 'Address changed'
        ELSE 'Other'
    END AS change_type
FROM customer_data
FOR SYSTEM_TIME ALL
ORDER BY customer_id, sys_start;

-- Requ√™te RGPD : "Montrez-moi toutes les donn√©es vous concernant"
SELECT * FROM gdpr_audit_trail
WHERE customer_id = 12345
ORDER BY modification_timestamp DESC;
```

### 5. Reconstruction de sc√©nario incident

```sql
-- Incident : commande annul√©e par erreur ‚Üí reconstituer la chronologie
SELECT 
    o.order_id,
    o.status,
    o.total_amount,
    o.sys_start AS timestamp,
    o.modified_by,
    TIMESTAMPDIFF(MINUTE, 
        LAG(o.sys_start) OVER (ORDER BY o.sys_start), 
        o.sys_start
    ) AS minutes_since_previous_change
FROM orders o
FOR SYSTEM_TIME ALL
WHERE o.order_id = 45678
ORDER BY o.sys_start;

-- R√©sultat permet de voir :
-- - Qui a annul√© la commande
-- - √Ä quel moment exact
-- - Quel √©tait le statut avant annulation
-- - Restaurer l'√©tat pr√©c√©dent si n√©cessaire
```

---

## Requ√™tes temporelles avec CTEs

### Analyse comparative multi-p√©riodes

```sql
WITH current_state AS (
    SELECT product_id, price 
    FROM products
),
yesterday_state AS (
    SELECT product_id, price 
    FROM products
    FOR SYSTEM_TIME AS OF DATE_SUB(NOW(), INTERVAL 1 DAY)
),
last_week_state AS (
    SELECT product_id, price 
    FROM products
    FOR SYSTEM_TIME AS OF DATE_SUB(NOW(), INTERVAL 7 DAY)
)
SELECT 
    p.product_id,
    p.product_name,
    c.price AS current_price,
    y.price AS yesterday_price,
    w.price AS last_week_price,
    c.price - y.price AS change_24h,
    c.price - w.price AS change_7d,
    ROUND((c.price - w.price) / w.price * 100, 2) AS pct_change_7d
FROM products p
JOIN current_state c ON p.product_id = c.product_id
LEFT JOIN yesterday_state y ON p.product_id = y.product_id
LEFT JOIN last_week_state w ON p.product_id = w.product_id
WHERE c.price != w.price
ORDER BY pct_change_7d DESC;
```

---

## Performances et limitations

### M√©triques de performance

```sql
-- √âvaluation du co√ªt d'une requ√™te temporelle
EXPLAIN SELECT * FROM orders
FOR SYSTEM_TIME AS OF '2025-01-15'
WHERE customer_id = 999;

-- Comparaison avec requ√™te standard
EXPLAIN SELECT * FROM orders
WHERE customer_id = 999;
```

**Ordre de grandeur overhead :**
- AS OF avec index : +10-30% vs requ√™te normale
- BETWEEN sur 1 mois : +50-100% 
- ALL sur table tr√®s active : +200-500%

### Limites pratiques

| Aspect | Limitation | Recommandation |
|--------|-----------|----------------|
| **Taille historique** | Peut atteindre 10√ó table courante | Partitionnement + purges |
| **Performance ALL** | Tr√®s lent sur gros historiques | Limiter avec BETWEEN |
| **Pr√©cision temps** | TIMESTAMP(6) recommand√© | √âviter TIMESTAMP(0) |
| **Timestamp limite** | 2038 (standard), 2106 (11.8) üÜï | Planifier migration |

---

## Bonnes pratiques

### ‚úÖ Recommandations

1. **Indexation strat√©gique**
   ```sql
   -- Toujours indexer les colonnes de p√©riode
   ALTER TABLE table_history 
   ADD INDEX idx_period (sys_start, sys_end);
   ```

2. **Limitation temporelle**
   ```sql
   -- Pr√©f√©rer BETWEEN avec dates raisonnables √† ALL
   FOR SYSTEM_TIME BETWEEN 
       DATE_SUB(NOW(), INTERVAL 90 DAY) AND NOW()
   ```

3. **Coh√©rence multi-tables**
   ```sql
   -- Utiliser le m√™me timestamp pour JOINs
   SET @snapshot_time = '2025-12-15 10:00:00';
   SELECT ... 
   FROM t1 FOR SYSTEM_TIME AS OF @snapshot_time
   JOIN t2 FOR SYSTEM_TIME AS OF @snapshot_time ...
   ```

4. **Filtrage pr√©coce**
   ```sql
   -- Filtrer AVANT la clause temporelle quand possible
   WHERE customer_id = 999 -- Index standard
   FOR SYSTEM_TIME AS OF '2025-01-15'
   ```

5. **Utilisation de vues**
   ```sql
   -- Encapsuler les requ√™tes temporelles complexes
   CREATE VIEW monthly_snapshots AS
   SELECT DATE_FORMAT(sys_start, '%Y-%m') AS month, ...
   FROM orders FOR SYSTEM_TIME ALL;
   ```

### ‚ö†Ô∏è Pi√®ges √† √©viter

1. **FOR SYSTEM_TIME ALL sans filtre** ‚Üí Peut retourner des millions de lignes
2. **Timestamp impr√©cis** ‚Üí R√©sultats incoh√©rents avec TIMESTAMP(0)
3. **Absence d'index** ‚Üí Full scan de l'historique
4. **Comparaisons NULL sur sys_end** ‚Üí Utiliser la valeur max exacte
5. **Oublier le partitionnement** ‚Üí D√©gradation performance avec le temps

---

## Interaction avec autres features

### System-Versioned + Partitioning

```sql
-- Partitionnement de la table courante ET de l'historique
CREATE TABLE sales (
    sale_id BIGINT,
    region VARCHAR(50),
    amount DECIMAL(10,2),
    sale_date DATE,
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end)
) WITH SYSTEM VERSIONING
PARTITION BY RANGE (YEAR(sale_date)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026)
);

-- Requ√™te b√©n√©ficie du double pruning
SELECT * FROM sales
FOR SYSTEM_TIME AS OF '2024-06-15'
WHERE sale_date BETWEEN '2024-01-01' AND '2024-12-31';
-- ‚Üí Pruning temporel + partition pruning
```

### System-Versioned + JSON

```sql
CREATE TABLE user_preferences (
    user_id INT PRIMARY KEY,
    preferences JSON,
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end)
) WITH SYSTEM VERSIONING;

-- Historique d'une pr√©f√©rence JSON sp√©cifique
SELECT 
    user_id,
    preferences->>'$.theme' AS theme,
    preferences->>'$.language' AS language,
    sys_start
FROM user_preferences
FOR SYSTEM_TIME ALL
WHERE user_id = 789
AND preferences->>'$.theme' IS NOT NULL
ORDER BY sys_start DESC;
```

---

## ‚úÖ Points cl√©s √† retenir

- **AS OF** retourne l'√©tat exact √† un instant T (point-in-time recovery)
- **BETWEEN** retourne toutes les versions actives dans un intervalle
- **FROM...TO** est similaire √† BETWEEN avec s√©mantique l√©g√®rement diff√©rente
- **ALL** retourne l'int√©gralit√© de l'historique (utiliser avec pr√©caution)
- Les requ√™tes temporelles utilisent la **syntaxe SQL:2011 standard**
- **L'indexation** des colonnes sys_start/sys_end est **critique** pour les performances
- Le **partitionnement** de l'historique am√©liore drastiquement les requ√™tes
- Les **JOINs temporels** n√©cessitent le m√™me timestamp pour coh√©rence
- **Limiter le scope temporel** (BETWEEN plut√¥t que ALL) pour √©viter les scans massifs
- Les requ√™tes temporelles sont **transparentes** pour l'application (m√™me syntaxe SELECT)

---

## üîó Ressources et r√©f√©rences

- [üìñ MariaDB - Temporal Tables: Querying Historical Data](https://mariadb.com/kb/en/temporal-tables/)
- [üìñ SQL:2011 - Temporal Features](https://www.iso.org/standard/53681.html)
- [üìñ FOR SYSTEM_TIME Syntax](https://mariadb.com/kb/en/select/#for-system_time)
- [üìñ Optimizing Temporal Queries](https://mariadb.com/kb/en/temporal-tables-optimizing/)
- [üîß EXPLAIN and Temporal Queries](https://mariadb.com/kb/en/explain/)

---

## ‚û°Ô∏è Section suivante

**18.2.3 [Partitionnement des donn√©es historiques](./02.3-partitionnement-historique.md)** : D√©couvrez les strat√©gies de partitionnement pour g√©rer efficacement la croissance de l'historique, optimiser les performances et faciliter la maintenance (purges, archivage).

‚è≠Ô∏è [Partitionnement des donn√©es historiques](/18-fonctionnalites-avancees/02.3-partitionnement-historique.md)
