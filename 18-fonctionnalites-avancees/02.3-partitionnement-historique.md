üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.2.3 Partitionnement des Donn√©es Historiques

> **Niveau** : Avanc√©  
> **Dur√©e estim√©e** : 2-3 heures  
> **Pr√©requis** : 
> - Sections 18.2.1 et 18.2.2 - System-Versioned Tables
> - Chapitre 15.9 - Partitionnement de tables
> - Compr√©hension des strat√©gies de maintenance
> - Connaissance des contraintes de stockage

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Concevoir une strat√©gie de partitionnement adapt√©e √† l'historique
- Impl√©menter le partitionnement par p√©riode sur les tables d'historique
- Automatiser la gestion du cycle de vie des partitions
- Optimiser les performances des requ√™tes temporelles
- Mettre en place des politiques de r√©tention et d'archivage
- Dimensionner l'infrastructure pour la croissance de l'historique

---

## Introduction

Les **tables d'historique** des System-Versioned Tables croissent **ind√©finiment** si aucune strat√©gie de gestion n'est mise en place. Sur des tables √† forte activit√©, l'historique peut rapidement repr√©senter **10 √† 100 fois** le volume de la table courante, posant des d√©fis majeurs :

### Probl√©matiques sans partitionnement

- **Croissance incontr√¥l√©e** : L'historique grossit sans limite ‚Üí saturation disque
- **D√©gradation des performances** : Les requ√™tes temporelles ralentissent avec le volume
- **Complexit√© de maintenance** : OPTIMIZE TABLE, sauvegardes deviennent impossibles
- **Co√ªt de stockage** : Donn√©es froides sur disques performants ‚Üí inefficience
- **Purges lentes** : DELETE massif sur table monolithique ‚Üí blocage prolong√©

### B√©n√©fices du partitionnement

- ‚úÖ **Performance** : Partition pruning acc√©l√®re les requ√™tes temporelles
- ‚úÖ **Maintenance facilit√©e** : Purge par DROP PARTITION (instantan√© vs DELETE lent)
- ‚úÖ **Archivage granulaire** : D√©placer des partitions vers stockage froid
- ‚úÖ **Tiering automatique** : Hot/warm/cold data selon l'√¢ge
- ‚úÖ **Optimisation co√ªts** : Compression diff√©renci√©e par partition

üí° **Principe cl√©** : Partitionner l'historique par **p√©riode temporelle** (mois, trimestre, ann√©e) align√©e avec la politique de r√©tention m√©tier.

---

## Strat√©gies de partitionnement

### 1. Partitionnement par p√©riode (RANGE)

Le partitionnement **RANGE** sur les colonnes de temps (`sys_start` ou `sys_end`) est l'approche standard pour l'historique.

#### Choix de la colonne de partitionnement

```sql
-- Option 1 : Partitionner sur sys_end (date de fin de validit√©)
-- ‚úÖ RECOMMAND√â : Facilite les purges par p√©riode
ALTER TABLE orders_history
PARTITION BY RANGE (YEAR(sys_end)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- Option 2 : Partitionner sur sys_start (date de d√©but de validit√©)
-- Utile pour analyse de "quand la donn√©e a √©t√© cr√©√©e"
ALTER TABLE audit_log_history
PARTITION BY RANGE (UNIX_TIMESTAMP(sys_start)) (
    PARTITION p202401 VALUES LESS THAN (UNIX_TIMESTAMP('2024-02-01')),
    PARTITION p202402 VALUES LESS THAN (UNIX_TIMESTAMP('2024-03-01')),
    PARTITION p202403 VALUES LESS THAN (UNIX_TIMESTAMP('2024-04-01'))
    -- ...
);
```

**Comparaison sys_start vs sys_end :**

| Crit√®re | sys_end | sys_start |
|---------|---------|-----------|
| **Purge** | ‚úÖ Parfait (purge donn√©es anciennes) | ‚ö†Ô∏è Complexe (donn√©es actives dispers√©es) |
| **Requ√™tes AS OF** | ‚úÖ Optimal | ‚úÖ Optimal |
| **Requ√™tes BETWEEN** | ‚úÖ Tr√®s bon | ‚úÖ Tr√®s bon |
| **Archivage** | ‚úÖ Naturel | ‚ö†Ô∏è N√©cessite logique m√©tier |

üí° **Recommandation** : **sys_end** pour 95% des cas d'usage.

### 2. Granularit√© de partitionnement

#### Partitionnement mensuel

```sql
-- Cr√©ation avec partitions mensuelles
CREATE TABLE transactions (
    transaction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    account_id INT NOT NULL,
    amount DECIMAL(15,2),
    transaction_date DATE,
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end)
) ENGINE=InnoDB
WITH SYSTEM VERSIONING;

-- Partitionnement mensuel de l'historique
ALTER TABLE transactions_history
PARTITION BY RANGE (TO_DAYS(sys_end)) (
    PARTITION p202301 VALUES LESS THAN (TO_DAYS('2023-02-01')),
    PARTITION p202302 VALUES LESS THAN (TO_DAYS('2023-03-01')),
    PARTITION p202303 VALUES LESS THAN (TO_DAYS('2023-04-01')),
    PARTITION p202304 VALUES LESS THAN (TO_DAYS('2023-05-01')),
    PARTITION p202305 VALUES LESS THAN (TO_DAYS('2023-06-01')),
    PARTITION p202306 VALUES LESS THAN (TO_DAYS('2023-07-01')),
    -- ... continuer pour toute l'ann√©e
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**Cas d'usage** : Tables √† activit√© mod√©r√©e √† √©lev√©e, r√©tention 6-24 mois.

#### Partitionnement trimestriel

```sql
-- Granularit√© trimestrielle
ALTER TABLE customer_data_history
PARTITION BY RANGE (QUARTER(sys_end) + 4 * (YEAR(sys_end) - 2020)) (
    PARTITION p2023_q1 VALUES LESS THAN (13), -- Q1 2023 = 4*(2023-2020) + 1 = 13
    PARTITION p2023_q2 VALUES LESS THAN (14),
    PARTITION p2023_q3 VALUES LESS THAN (15),
    PARTITION p2023_q4 VALUES LESS THAN (16),
    PARTITION p2024_q1 VALUES LESS THAN (17),
    -- ...
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**Cas d'usage** : Donn√©es archiv√©es long terme, faible volum√©trie.

#### Partitionnement annuel

```sql
-- Granularit√© annuelle pour tr√®s long terme
ALTER TABLE historical_sales_history
PARTITION BY RANGE (YEAR(sys_end)) (
    PARTITION p2020 VALUES LESS THAN (2021),
    PARTITION p2021 VALUES LESS THAN (2022),
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**Cas d'usage** : Archivage r√©glementaire 7-10 ans, analyses annuelles.

### 3. Choix de la granularit√©

| Volume quotidien | R√©tention | Granularit√© recommand√©e |
|------------------|-----------|-------------------------|
| < 10 000 lignes/jour | 1-2 ans | Trimestrielle |
| 10K - 100K lignes/jour | 1-3 ans | Mensuelle |
| 100K - 1M lignes/jour | 6-18 mois | Mensuelle |
| > 1M lignes/jour | 3-6 mois | Hebdomadaire ou mensuelle |

üí° **Formule** : Viser **10-50 partitions actives** maximum pour l'√©quilibre performance/maintenance.

---

## Impl√©mentation pratique

### Configuration initiale avec partitionnement

```sql
-- 1. Cr√©er la table avec versionnement
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(200),
    price DECIMAL(10,2),
    category VARCHAR(100),
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end)
) ENGINE=InnoDB
WITH SYSTEM VERSIONING;

-- 2. Partitionner imm√©diatement la table d'historique
ALTER TABLE products_history
PARTITION BY RANGE (YEAR(sys_end) * 100 + MONTH(sys_end)) (
    PARTITION p202312 VALUES LESS THAN (202401), -- D√©c 2023
    PARTITION p202401 VALUES LESS THAN (202402), -- Jan 2024
    PARTITION p202402 VALUES LESS THAN (202403), -- F√©v 2024
    PARTITION p202403 VALUES LESS THAN (202404), -- Mar 2024
    PARTITION p202404 VALUES LESS THAN (202405), -- Avr 2024
    PARTITION p202405 VALUES LESS THAN (202406), -- Mai 2024
    PARTITION p202406 VALUES LESS THAN (202407), -- Juin 2024
    PARTITION p202407 VALUES LESS THAN (202408), -- Juil 2024
    PARTITION p202408 VALUES LESS THAN (202409), -- Ao√ªt 2024
    PARTITION p202409 VALUES LESS THAN (202410), -- Sep 2024
    PARTITION p202410 VALUES LESS THAN (202411), -- Oct 2024
    PARTITION p202411 VALUES LESS THAN (202412), -- Nov 2024
    PARTITION p202412 VALUES LESS THAN (202501), -- D√©c 2024
    PARTITION p202501 VALUES LESS THAN (202502), -- Jan 2025
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

### Migration d'une table existante

```sql
-- Sc√©nario : table d'historique non partitionn√©e existante avec 10M+ lignes

-- 1. Cr√©er une nouvelle table d'historique partitionn√©e
CREATE TABLE orders_history_new LIKE orders_history;

ALTER TABLE orders_history_new
PARTITION BY RANGE (YEAR(sys_end) * 100 + MONTH(sys_end)) (
    PARTITION p202301 VALUES LESS THAN (202302),
    PARTITION p202302 VALUES LESS THAN (202303),
    -- ... toutes les partitions n√©cessaires
    PARTITION p202512 VALUES LESS THAN (202601),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- 2. Migrer les donn√©es par lots (pour √©viter lock prolong√©)
-- Option A : INSERT ... SELECT par partition
INSERT INTO orders_history_new
SELECT * FROM orders_history
WHERE sys_end >= '2023-01-01' AND sys_end < '2023-02-01';

INSERT INTO orders_history_new
SELECT * FROM orders_history
WHERE sys_end >= '2023-02-01' AND sys_end < '2023-03-01';
-- ... r√©p√©ter pour chaque mois

-- Option B : Utiliser pt-online-schema-change (Percona Toolkit)
-- pt-online-schema-change --alter "PARTITION BY ..." D=mydb,t=orders_history

-- 3. Basculer (n√©cessite downtime court)
RENAME TABLE 
    orders_history TO orders_history_old,
    orders_history_new TO orders_history;

-- 4. Modifier la table courante pour utiliser la nouvelle historique
ALTER TABLE orders DROP SYSTEM VERSIONING;
ALTER TABLE orders ADD SYSTEM VERSIONING HISTORY_TABLE = orders_history;

-- 5. V√©rification et nettoyage
SELECT COUNT(*) FROM orders_history;
SELECT COUNT(*) FROM orders_history_old;
-- Si OK : DROP TABLE orders_history_old;
```

---

## Gestion du cycle de vie des partitions

### Ajout automatique de nouvelles partitions

```sql
-- Event pour cr√©er automatiquement la partition du mois prochain
DELIMITER $$
CREATE EVENT add_monthly_partition
ON SCHEDULE EVERY 1 MONTH
STARTS '2025-01-01 00:00:00'
DO
BEGIN
    DECLARE next_month_year INT;
    DECLARE next_month_month INT;
    DECLARE partition_name VARCHAR(20);
    DECLARE partition_value INT;
    
    -- Calculer ann√©e et mois du mois suivant
    SET next_month_year = YEAR(DATE_ADD(NOW(), INTERVAL 2 MONTH));
    SET next_month_month = MONTH(DATE_ADD(NOW(), INTERVAL 2 MONTH));
    
    -- Nom de la partition et valeur limite
    SET partition_name = CONCAT('p', next_month_year, 
                                LPAD(next_month_month, 2, '0'));
    SET partition_value = next_month_year * 100 + next_month_month;
    
    -- Ajouter la partition
    SET @sql = CONCAT('ALTER TABLE products_history REORGANIZE PARTITION p_future INTO (',
                      'PARTITION ', partition_name, 
                      ' VALUES LESS THAN (', partition_value, '),',
                      'PARTITION p_future VALUES LESS THAN MAXVALUE)');
    
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END$$
DELIMITER ;
```

üí° **Conseil** : Cr√©er les partitions **2-3 mois √† l'avance** pour √©viter que les donn√©es tombent dans `p_future`.

### Purge automatique des anciennes partitions

```sql
-- Event pour purger les partitions > 12 mois
DELIMITER $$
CREATE EVENT purge_old_partitions
ON SCHEDULE EVERY 1 MONTH
STARTS '2025-01-15 02:00:00' -- Heure creuse
DO
BEGIN
    DECLARE cutoff_date INT;
    DECLARE partition_to_drop VARCHAR(20);
    
    -- Date limite : 12 mois en arri√®re
    SET cutoff_date = (YEAR(DATE_SUB(NOW(), INTERVAL 12 MONTH)) * 100) + 
                       MONTH(DATE_SUB(NOW(), INTERVAL 12 MONTH));
    
    -- G√©n√©rer nom partition √† supprimer
    SET partition_to_drop = CONCAT('p', cutoff_date);
    
    -- V√©rifier existence avant drop
    IF EXISTS (
        SELECT 1 FROM information_schema.partitions
        WHERE table_schema = DATABASE()
        AND table_name = 'products_history'
        AND partition_name = partition_to_drop
    ) THEN
        SET @sql = CONCAT('ALTER TABLE products_history DROP PARTITION ', 
                          partition_to_drop);
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        -- Logger l'op√©ration
        INSERT INTO partition_maintenance_log 
        VALUES (NOW(), 'products_history', partition_to_drop, 'DROPPED');
    END IF;
END$$
DELIMITER ;
```

### Archivage vers stockage froid

```sql
-- Proc√©dure d'archivage mensuel
DELIMITER $$
CREATE PROCEDURE archive_partition_to_cold_storage(
    IN p_table VARCHAR(64),
    IN p_partition VARCHAR(64),
    IN p_archive_path VARCHAR(255)
)
BEGIN
    DECLARE archive_file VARCHAR(300);
    
    -- G√©n√©rer nom fichier archive
    SET archive_file = CONCAT(p_archive_path, '/', p_table, '_', 
                              p_partition, '_', DATE_FORMAT(NOW(), '%Y%m%d'), '.sql.gz');
    
    -- 1. Export de la partition
    SET @export_sql = CONCAT(
        'SELECT * FROM ', p_table, 
        ' PARTITION (', p_partition, ') ',
        'INTO OUTFILE "', archive_file, '" ',
        'FIELDS TERMINATED BY "," ENCLOSED BY "\\"" ',
        'LINES TERMINATED BY "\\n"'
    );
    
    PREPARE stmt FROM @export_sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- 2. V√©rifier export r√©ussi (v√©rification m√©tier)
    -- ...
    
    -- 3. Drop partition
    SET @drop_sql = CONCAT('ALTER TABLE ', p_table, 
                           ' DROP PARTITION ', p_partition);
    PREPARE stmt FROM @drop_sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    -- 4. Logger
    INSERT INTO archive_log 
    VALUES (NOW(), p_table, p_partition, archive_file, 'SUCCESS');
END$$
DELIMITER ;

-- Utilisation
CALL archive_partition_to_cold_storage(
    'products_history', 
    'p202301', 
    '/mnt/cold_storage/mariadb_archives'
);
```

---

## Optimisation des performances

### Partition pruning : v√©rification

```sql
-- V√©rifier que le partition pruning fonctionne
EXPLAIN PARTITIONS
SELECT * FROM products_history
WHERE sys_end BETWEEN '2024-06-01' AND '2024-06-30';

-- R√©sultat attendu :
-- partitions: p202406
-- ‚úÖ Une seule partition scann√©e
```

### Indexation par partition

```sql
-- Index locaux par partition (automatique avec partitionnement)
ALTER TABLE products_history
ADD INDEX idx_product_period (product_id, sys_start, sys_end);

-- V√©rification de l'index sur chaque partition
SELECT 
    table_name,
    partition_name,
    index_name,
    cardinality
FROM information_schema.statistics
WHERE table_schema = DATABASE()
AND table_name = 'products_history'
AND index_name = 'idx_product_period'
ORDER BY partition_name;
```

### Compression diff√©renci√©e

```sql
-- Compression agressive sur anciennes partitions
-- Partition r√©cente : pas de compression (lecture/√©criture fr√©quentes)
ALTER TABLE products_history 
REORGANIZE PARTITION p202512 INTO (
    PARTITION p202512 VALUES LESS THAN (202601)
    ROW_FORMAT=DYNAMIC
);

-- Partitions 3-6 mois : compression mod√©r√©e
ALTER TABLE products_history 
REORGANIZE PARTITION p202409 INTO (
    PARTITION p202409 VALUES LESS THAN (202410)
    ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8
);

-- Partitions > 6 mois : compression maximale
ALTER TABLE products_history 
REORGANIZE PARTITION p202403 INTO (
    PARTITION p202403 VALUES LESS THAN (202404)
    ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=4
);
```

**Gains attendus :**
- Partition non compress√©e : 100% taille
- Compression 8K : ~40-60% taille
- Compression 4K : ~25-40% taille

### Moteur de stockage hybride

```sql
-- Table courante : InnoDB (ACID, transactions)
CREATE TABLE orders (
    order_id BIGINT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    total DECIMAL(10,2),
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end)
) ENGINE=InnoDB
WITH SYSTEM VERSIONING;

-- Historique : Aria (optimis√© lecture, crash-safe)
ALTER TABLE orders_history ENGINE=Aria;

-- Partitions anciennes : ColumnStore (analytique)
-- N√©cessite conversion manuelle partition par partition
ALTER TABLE orders_history 
EXCHANGE PARTITION p202301 
WITH TABLE orders_history_202301_columnstore;

CREATE TABLE orders_history_202301_columnstore 
ENGINE=ColumnStore 
SELECT * FROM orders_history_202301_temp;
```

---

## Monitoring et m√©triques

### Surveillance de la croissance

```sql
-- Vue consolid√©e des partitions
CREATE VIEW partition_health AS
SELECT 
    table_name,
    partition_name,
    partition_ordinal_position AS position,
    table_rows,
    ROUND(data_length / 1024 / 1024, 2) AS data_mb,
    ROUND(index_length / 1024 / 1024, 2) AS index_mb,
    ROUND((data_length + index_length) / 1024 / 1024, 2) AS total_mb,
    ROUND(data_free / 1024 / 1024, 2) AS free_mb,
    create_time,
    update_time
FROM information_schema.partitions
WHERE table_schema = DATABASE()
AND partition_name IS NOT NULL
ORDER BY table_name, partition_ordinal_position DESC;

-- Requ√™te monitoring quotidien
SELECT 
    table_name,
    partition_name,
    total_mb,
    table_rows,
    DATEDIFF(NOW(), update_time) AS days_since_update
FROM partition_health
WHERE table_name LIKE '%_history'
ORDER BY total_mb DESC
LIMIT 20;
```

### Alertes sur partitions

```sql
-- D√©tecter partitions p_future volumineuses (= oubli cr√©ation)
SELECT 
    table_name,
    partition_name,
    table_rows,
    total_mb
FROM partition_health
WHERE partition_name = 'p_future'
AND table_rows > 100000 -- Seuil √† ajuster
ORDER BY table_rows DESC;

-- D√©tecter partitions √† purger (selon politique r√©tention)
SELECT 
    table_name,
    partition_name,
    total_mb,
    days_since_update
FROM partition_health
WHERE days_since_update > 365 -- R√©tention 12 mois
AND partition_name != 'p_future'
ORDER BY days_since_update DESC;
```

### M√©triques de partition pruning

```sql
-- Performance compar√©e avec/sans partition pruning
-- SANS pruning (scan complet)
SET SESSION optimizer_switch='partition_pruning=off';
EXPLAIN SELECT COUNT(*) FROM products_history
WHERE sys_end BETWEEN '2024-06-01' AND '2024-06-30';

-- AVEC pruning (optimal)
SET SESSION optimizer_switch='partition_pruning=on';
EXPLAIN SELECT COUNT(*) FROM products_history
WHERE sys_end BETWEEN '2024-06-01' AND '2024-06-30';

-- Ratio am√©lioration = nb_partitions_total / nb_partitions_scann√©es
```

---

## Cas d'usage avanc√©s

### 1. Data tiering automatis√© (Hot/Warm/Cold)

```sql
-- Architecture 3 tiers
-- HOT : 0-3 mois, InnoDB non compress√©, SSD NVMe
-- WARM : 3-12 mois, InnoDB compress√©, SSD SATA
-- COLD : 12+ mois, Archive/ColumnStore, HDD

-- Event orchestration tiering
DELIMITER $$
CREATE EVENT data_tiering_orchestrator
ON SCHEDULE EVERY 1 WEEK
DO
BEGIN
    -- Migrer partitions 3 mois vers WARM (compression)
    CALL compress_partitions_older_than(90);
    
    -- Archiver partitions 12 mois vers COLD
    CALL archive_partitions_older_than(365);
    
    -- Purger partitions 24 mois (selon r√©glementation)
    CALL purge_partitions_older_than(730);
END$$
DELIMITER ;

-- Impl√©mentation compression WARM
DELIMITER $$
CREATE PROCEDURE compress_partitions_older_than(IN days INT)
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE p_name VARCHAR(64);
    DECLARE cutoff_yearmonth INT;
    
    -- Curseur sur partitions √† compresser
    DECLARE partition_cursor CURSOR FOR
        SELECT partition_name 
        FROM information_schema.partitions
        WHERE table_schema = DATABASE()
        AND table_name = 'orders_history'
        AND partition_name LIKE 'p20%'
        AND CAST(partition_description AS UNSIGNED) < cutoff_yearmonth;
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    -- Calculer cutoff
    SET cutoff_yearmonth = (YEAR(DATE_SUB(NOW(), INTERVAL days DAY)) * 100) +
                            MONTH(DATE_SUB(NOW(), INTERVAL days DAY));
    
    OPEN partition_cursor;
    
    read_loop: LOOP
        FETCH partition_cursor INTO p_name;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        -- Appliquer compression
        SET @sql = CONCAT('ALTER TABLE orders_history ',
                          'REORGANIZE PARTITION ', p_name, ' INTO (',
                          'PARTITION ', p_name, ' VALUES LESS THAN (',
                          'SELECT partition_description FROM information_schema.partitions ',
                          'WHERE table_name = "orders_history" AND partition_name = "', p_name, '") ',
                          'ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8)');
        
        PREPARE stmt FROM @sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    END LOOP;
    
    CLOSE partition_cursor;
END$$
DELIMITER ;
```

### 2. Purge RGPD avec tra√ßabilit√©

```sql
-- Purge donn√©es personnelles > dur√©e l√©gale avec audit
DELIMITER $$
CREATE PROCEDURE gdpr_compliant_purge(
    IN p_table VARCHAR(64),
    IN retention_months INT
)
BEGIN
    DECLARE purge_date DATE;
    DECLARE partition_list TEXT;
    
    SET purge_date = DATE_SUB(CURDATE(), INTERVAL retention_months MONTH);
    
    -- Logger intention
    INSERT INTO gdpr_purge_log (purge_date, table_name, retention_months, status)
    VALUES (NOW(), p_table, retention_months, 'STARTED');
    
    -- Identifier partitions √† purger
    SELECT GROUP_CONCAT(partition_name) INTO partition_list
    FROM information_schema.partitions
    WHERE table_schema = DATABASE()
    AND table_name = p_table
    AND STR_TO_DATE(SUBSTRING(partition_name, 2), '%Y%m') < purge_date;
    
    -- Purger partition par partition avec audit
    -- ... (impl√©mentation d√©taill√©e)
    
    -- Logger succ√®s
    UPDATE gdpr_purge_log 
    SET status = 'COMPLETED', partitions_purged = partition_list
    WHERE purge_date = (SELECT MAX(purge_date) FROM gdpr_purge_log WHERE table_name = p_table);
END$$
DELIMITER ;
```

### 3. R√©partition g√©ographique de l'historique

```sql
-- Partitionnement composite : p√©riode + r√©gion
CREATE TABLE global_transactions_history (
    transaction_id BIGINT,
    region ENUM('EMEA', 'AMER', 'APAC'),
    amount DECIMAL(15,2),
    sys_start TIMESTAMP(6),
    sys_end TIMESTAMP(6)
)
PARTITION BY RANGE (YEAR(sys_end))
SUBPARTITION BY LIST (region) (
    PARTITION p2024 VALUES LESS THAN (2025) (
        SUBPARTITION p2024_emea VALUES IN ('EMEA'),
        SUBPARTITION p2024_amer VALUES IN ('AMER'),
        SUBPARTITION p2024_apac VALUES IN ('APAC')
    ),
    PARTITION p2025 VALUES LESS THAN (2026) (
        SUBPARTITION p2025_emea VALUES IN ('EMEA'),
        SUBPARTITION p2025_amer VALUES IN ('AMER'),
        SUBPARTITION p2025_apac VALUES IN ('APAC')
    )
);

-- B√©n√©fice : requ√™tes r√©gionales ultra-optimis√©es
SELECT * FROM global_transactions_history
WHERE region = 'EMEA' 
AND sys_end BETWEEN '2024-01-01' AND '2024-12-31';
-- ‚Üí Scan uniquement p2024_emea
```

### 4. Analyse de tendances avec window functions

```sql
-- √âvolution volum√©trique par partition
WITH partition_growth AS (
    SELECT 
        partition_name,
        table_rows,
        total_mb,
        LAG(table_rows) OVER (ORDER BY partition_ordinal_position) AS prev_rows,
        LAG(total_mb) OVER (ORDER BY partition_ordinal_position) AS prev_mb
    FROM partition_health
    WHERE table_name = 'orders_history'
    AND partition_name LIKE 'p2024%'
)
SELECT 
    partition_name,
    table_rows,
    total_mb,
    table_rows - prev_rows AS row_growth,
    total_mb - prev_mb AS mb_growth,
    ROUND((table_rows - prev_rows) / NULLIF(prev_rows, 0) * 100, 2) AS pct_growth
FROM partition_growth
WHERE prev_rows IS NOT NULL
ORDER BY partition_name;
```

---

## Strat√©gies de restauration

### Restauration s√©lective par partition

```sql
-- Sc√©nario : corruption partition p202406
-- 1. D√©tacher partition corrompue
ALTER TABLE orders_history 
EXCHANGE PARTITION p202406 
WITH TABLE orders_history_p202406_broken;

-- 2. Cr√©er partition vide
CREATE TABLE orders_history_p202406_new LIKE orders_history;
ALTER TABLE orders_history_p202406_new REMOVE PARTITIONING;

-- 3. Restaurer depuis backup
-- mysqlpump --include-tables=orders_history_p202406 ... | mysql

-- 4. R√©attacher partition restaur√©e
ALTER TABLE orders_history 
EXCHANGE PARTITION p202406 
WITH TABLE orders_history_p202406_new;

-- 5. V√©rification
SELECT COUNT(*) FROM orders_history PARTITION (p202406);
```

### Point-in-time recovery granulaire

```sql
-- PITR sur une partition sp√©cifique (vs table enti√®re)
-- 1. Extraire binlogs concernant la partition
mysqlbinlog --database=mydb \
    --start-datetime="2024-06-01 00:00:00" \
    --stop-datetime="2024-06-30 23:59:59" \
    /var/log/mysql/binlog.* > restore_p202406.sql

-- 2. Filtrer uniquement orders_history
grep -A 5 "orders_history" restore_p202406.sql > restore_filtered.sql

-- 3. Appliquer sur partition isol√©e puis EXCHANGE
```

---

## Bonnes pratiques

### ‚úÖ Recommandations

1. **Planifier d√®s le d√©part**
   ```sql
   -- ‚úÖ Partitionner l'historique D√àS la cr√©ation
   CREATE TABLE ... WITH SYSTEM VERSIONING;
   ALTER TABLE ..._history PARTITION BY ...;
   ```

2. **Partition p_future obligatoire**
   ```sql
   -- Toujours avoir une partition MAXVALUE
   PARTITION p_future VALUES LESS THAN MAXVALUE
   ```

3. **Automatiser la maintenance**
   ```sql
   -- Events pour ajout/purge automatiques
   CREATE EVENT add_partition ...;
   CREATE EVENT purge_old_partitions ...;
   ```

4. **Indexer selon requ√™tes**
   ```sql
   -- Index adapt√©s aux requ√™tes temporelles
   ALTER TABLE ..._history ADD INDEX idx_period (sys_end, sys_start);
   ```

5. **Monitoring proactif**
   ```sql
   -- Alertes sur p_future volumineuse
   SELECT * FROM partition_health WHERE partition_name = 'p_future';
   ```

6. **Documenter la politique**
   ```sql
   -- Commentaires sur tables
   ALTER TABLE products COMMENT = 
   'History retention: 12 months, monthly partitions, auto-purge enabled';
   ```

7. **Tester les proc√©dures**
   ```bash
   # Tester purge/archivage en dev AVANT prod
   ```

### ‚ö†Ô∏è Pi√®ges √† √©viter

1. **Partition p_future d√©bordante** ‚Üí Cr√©er partitions √† l'avance
2. **Purge sans archivage** ‚Üí Backup avant DROP PARTITION
3. **DELETE au lieu de DROP PARTITION** ‚Üí 1000√ó plus lent
4. **Partitionnement sur sys_start** ‚Üí Purges complexes
5. **Trop de partitions** ‚Üí Overhead m√©tadata (limite ~1000)
6. **Oublier les index locaux** ‚Üí Performance d√©grad√©e
7. **Pas de monitoring** ‚Üí Saturation disque surprise

### üîç Checklist d√©ploiement

- [ ] Politique de r√©tention d√©finie (ex: 12 mois)
- [ ] Granularit√© adapt√©e au volume (mensuelle = standard)
- [ ] Partition p_future configur√©e
- [ ] Events de cr√©ation automatique activ√©s
- [ ] Events de purge programm√©s
- [ ] Archivage vers stockage froid si > 24 mois
- [ ] Index optimis√©s pour requ√™tes temporelles
- [ ] Compression diff√©renci√©e par √¢ge
- [ ] Monitoring dashboards configur√©s
- [ ] Proc√©dures de restauration test√©es
- [ ] Documentation politique de r√©tention

---

## Impact sur les performances

### Benchmarks comparatifs

```sql
-- Test 1 : Requ√™te AS OF sur 100M lignes historique
-- SANS partition : 45 secondes (full table scan)
-- AVEC partition mensuelle : 0.8 secondes (1 partition scann√©e)
-- ‚Üí Gain : 56√ó

-- Test 2 : Purge 10M lignes anciennes
-- DELETE FROM ... WHERE sys_end < ... : 25 minutes + OPTIMIZE TABLE
-- DROP PARTITION p202301 : 0.2 secondes
-- ‚Üí Gain : 7500√ó

-- Test 3 : Compression ancienne partition
-- Partition 5 Go non compress√©e : temps requ√™te = 2.1s
-- M√™me partition compress√©e 8K (2 Go) : temps requ√™te = 2.3s
-- ‚Üí Overhead lecture : +10%, Gain espace : 60%
```

### Dimensionnement infrastructure

```python
# Calcul capacit√© requise historique

def estimate_history_size(
    rows_per_day: int,
    avg_row_size_bytes: int,
    retention_months: int,
    compression_ratio: float = 0.5
) -> dict:
    """
    Exemple :
    - 100K lignes/jour
    - 500 bytes/ligne
    - R√©tention 12 mois
    - Compression 50%
    """
    days = retention_months * 30
    total_rows = rows_per_day * days
    raw_size_gb = (total_rows * avg_row_size_bytes) / (1024**3)
    compressed_size_gb = raw_size_gb * compression_ratio
    
    return {
        'total_rows': total_rows,
        'raw_size_gb': round(raw_size_gb, 2),
        'compressed_size_gb': round(compressed_size_gb, 2),
        'recommended_ssd_gb': round(compressed_size_gb * 1.5, 2),  # Marge 50%
    }

# Exemple : 100K lignes/jour, 500 bytes, 12 mois, compression 50%
print(estimate_history_size(100000, 500, 12, 0.5))
# Output: {
#   'total_rows': 36000000,
#   'raw_size_gb': 16.76,
#   'compressed_size_gb': 8.38,
#   'recommended_ssd_gb': 12.57
# }
```

---

## ‚úÖ Points cl√©s √† retenir

- Le **partitionnement par p√©riode** (RANGE sur sys_end) est la strat√©gie standard
- **Granularit√© mensuelle** convient √† la majorit√© des cas d'usage
- La **partition p_future** (MAXVALUE) est **obligatoire** pour capturer nouvelles donn√©es
- **DROP PARTITION** est 1000√ó plus rapide que DELETE pour purges
- L'**automatisation** (Events) est critique : ajout partitions + purges
- Le **partition pruning** acc√©l√®re drastiquement les requ√™tes temporelles
- La **compression diff√©renci√©e** optimise le ratio performance/co√ªt
- Le **monitoring** des partitions pr√©vient les saturations
- L'**archivage vers stockage froid** r√©duit les co√ªts long terme
- Une **politique de r√©tention document√©e** est obligatoire en production

---

## üîó Ressources et r√©f√©rences

- [üìñ MariaDB - Table Partitioning](https://mariadb.com/kb/en/partitioning/)
- [üìñ RANGE Partitioning](https://mariadb.com/kb/en/partitioning-types/#range-partitioning)
- [üìñ Partition Pruning](https://mariadb.com/kb/en/partition-pruning-and-selection/)
- [üìñ Managing Partitions](https://mariadb.com/kb/en/partition-maintenance/)
- [üîß Percona Toolkit - pt-online-schema-change](https://www.percona.com/doc/percona-toolkit/)
- [üìä Monitoring Partitions with sys schema](https://mariadb.com/kb/en/sys-schema/)

---

## ‚û°Ô∏è Section suivante

**18.3 [Application Time Period Tables](./03-application-time-period-tables.md)** : D√©couvrez les tables temporelles applicatives pour g√©rer des p√©riodes de validit√© m√©tier (contrats, tarifs, r√©servations) avec des contraintes d'int√©grit√© temporelle avanc√©es. üÜï

‚è≠Ô∏è [Application Time Period Tables](/18-fonctionnalites-avancees/03-application-time-period-tables.md)
