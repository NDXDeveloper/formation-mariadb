üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.10.4 Fonctions de Conversion Vectorielle

> **Niveau** : Avanc√©  
> **Dur√©e estim√©e** : 1-2 heures  
> **Pr√©requis** : 
> - Section 18.10.1 - Type de donn√©es VECTOR
> - Compr√©hension des formats de donn√©es (JSON, binaire, hexad√©cimal)
> - Bases de programmation (Python, JavaScript, Java)

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Convertir entre formats texte et VECTOR
- Utiliser les formats binaires pour optimiser les performances
- Valider les dimensions et d√©tecter les erreurs
- Int√©grer les conversions dans vos applications
- Choisir le format appropri√© selon le cas d'usage
- Optimiser les performances d'insertion et de lecture
- G√©rer les erreurs de conversion
- Impl√©menter des pipelines ETL pour embeddings

---

## Introduction

Les **fonctions de conversion** permettent de transformer les vecteurs entre diff√©rents formats pour le stockage, la transmission et l'affichage. MariaDB 11.8 LTS üÜï fournit plusieurs fonctions natives optimis√©es pour ces op√©rations.

### Formats support√©s

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Format TEXTE                                    ‚îÇ
‚îÇ  "[0.123, -0.456, 0.789, ...]"                   ‚îÇ
‚îÇ  - Lisible par humains                           ‚îÇ
‚îÇ  - Format JSON standard                          ‚îÇ
‚îÇ  - Pratique pour debug                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚Üï VEC_FromText / VEC_ToText
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Type VECTOR (interne MariaDB)                   ‚îÇ
‚îÇ  Binaire optimis√© en m√©moire                     ‚îÇ
‚îÇ  - Format natif InnoDB                           ‚îÇ
‚îÇ  - Calculs SIMD acc√©l√©r√©s                        ‚îÇ
‚îÇ  - Stockage compact                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚Üï VEC_ToBinary / VEC_FromBinary
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Format BINAIRE                                  ‚îÇ
‚îÇ  0x3D8F5C3EBD4CCCCD...                           ‚îÇ
‚îÇ  - Transmission r√©seau efficace                  ‚îÇ
‚îÇ  - APIs binaires                                 ‚îÇ
‚îÇ  - Int√©gration syst√®mes externes                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## VEC_FromText - Conversion texte vers VECTOR

### Syntaxe

```sql
VEC_FromText(text_string) ‚Üí VECTOR
VEC_FromText(text_string, expected_dimensions) ‚Üí VECTOR
```

### Format d'entr√©e

Le format texte accept√© est un tableau JSON de nombres :

```sql
-- Format standard : array JSON
VEC_FromText('[0.123, -0.456, 0.789]')

-- Espaces accept√©s
VEC_FromText('[0.123,   -0.456,    0.789]')

-- Notations scientifiques support√©es
VEC_FromText('[1.23e-2, -4.56e-1, 7.89e-1]')

-- Nombres entiers convertis en float
VEC_FromText('[1, -2, 3]')
-- √âquivalent √† [1.0, -2.0, 3.0]
```

### Exemples d'utilisation

```sql
-- Insertion simple
INSERT INTO documents (title, embedding)
VALUES (
    'Introduction to MariaDB Vector',
    VEC_FromText('[0.023, -0.145, 0.089, 0.234, -0.567]')
);

-- Insertion depuis variable
SET @embedding_str = '[0.1, 0.2, 0.3, 0.4, 0.5]';
INSERT INTO vectors (vec) VALUES (VEC_FromText(@embedding_str));

-- Insertion avec validation dimensions
INSERT INTO embeddings_1536 (data, vec)
VALUES (
    'Sample data',
    VEC_FromText('[0.1, 0.2, ...]', 1536)  -- Validation 1536 dims
);
```

### Validation automatique

```sql
-- ‚úÖ OK : Dimensions correctes
INSERT INTO docs (embedding) 
VALUES (VEC_FromText('[1, 2, 3]', 3));

-- ‚ùå ERREUR : Dimensions incorrectes
INSERT INTO docs (embedding) 
VALUES (VEC_FromText('[1, 2]', 3));
-- ERROR: Vector dimension mismatch: expected 3, got 2

-- ‚ùå ERREUR : Format invalide
INSERT INTO docs (embedding) 
VALUES (VEC_FromText('[1, 2, abc]'));
-- ERROR: Invalid number format in vector
```

### Gestion des erreurs

```sql
-- Fonction wrapper avec gestion d'erreur
DELIMITER $$
CREATE FUNCTION safe_vec_from_text(
    vec_str TEXT,
    expected_dims INT
)
RETURNS VECTOR(1536)
DETERMINISTIC
BEGIN
    DECLARE result VECTOR(1536);
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
        -- Retourner vecteur nul en cas d'erreur
        RETURN NULL;
    END;
    
    SET result = VEC_FromText(vec_str, expected_dims);
    
    -- V√©rifier dimensions
    IF VEC_Dimensions(result) != expected_dims THEN
        RETURN NULL;
    END IF;
    
    RETURN result;
END$$
DELIMITER ;

-- Utilisation
INSERT INTO docs (embedding)
SELECT safe_vec_from_text(@user_input, 1536)
WHERE safe_vec_from_text(@user_input, 1536) IS NOT NULL;
```

---

## VEC_ToText - Conversion VECTOR vers texte

### Syntaxe

```sql
VEC_ToText(vector) ‚Üí TEXT
```

### Format de sortie

```sql
-- Lecture vecteur en format texte
SELECT VEC_ToText(embedding) AS embedding_text
FROM documents
WHERE doc_id = 1;

-- R√©sultat :
-- embedding_text: [0.023,-0.145,0.089,0.234,-0.567]

-- Format : valeurs s√©par√©es par virgules, sans espaces
```

### Exemples d'utilisation

```sql
-- Affichage pour debug
SELECT 
    doc_id,
    title,
    VEC_ToText(embedding) AS embedding_readable
FROM documents
LIMIT 5;

-- Export vers JSON
SELECT JSON_OBJECT(
    'doc_id', doc_id,
    'title', title,
    'embedding', VEC_ToText(embedding)
) AS document_json
FROM documents;

-- R√©sultat :
-- {"doc_id": 1, "title": "Doc 1", "embedding": "[0.1,0.2,0.3]"}
```

### Extraction de dimensions sp√©cifiques

```sql
-- Extraire premi√®re dimension
SELECT 
    doc_id,
    CAST(
        SUBSTRING_INDEX(VEC_ToText(embedding), ',', 1)
    AS FLOAT) AS first_dimension
FROM documents;

-- Extraire dimension N
SET @n = 10;
SELECT 
    doc_id,
    CAST(
        SUBSTRING_INDEX(
            SUBSTRING_INDEX(VEC_ToText(embedding), ',', @n),
            ',', -1
        )
    AS FLOAT) AS dimension_n
FROM documents;
```

---

## VEC_FromBinary / VEC_ToBinary

### Format binaire

Le format binaire stocke chaque dimension comme un `FLOAT` (4 bytes, IEEE 754) :

```
Vecteur : [1.5, -2.3, 3.7]
         ‚Üì
Binaire : 0x3FC0000040133333404CCCCD
         ‚Üì
         1.5      -2.3      3.7
         (4 bytes)(4 bytes)(4 bytes)
```

### VEC_FromBinary

```sql
-- Conversion binaire vers VECTOR
SELECT VEC_FromBinary(0x3FC0000040133333404CCCCD) AS vec;

-- Insertion depuis binaire
INSERT INTO vectors (vec)
VALUES (VEC_FromBinary(UNHEX('3fc0000040133333404ccccd')));
```

### VEC_ToBinary

```sql
-- Conversion VECTOR vers binaire
SELECT HEX(VEC_ToBinary(embedding)) AS binary_hex
FROM documents
WHERE doc_id = 1;

-- R√©sultat :
-- binary_hex: 3FC0000040133333404CCCCD...
```

### Utilisation pour performance

```sql
-- Export binaire (plus efficace que texte)
SELECT 
    doc_id,
    VEC_ToBinary(embedding) AS embedding_binary
FROM documents
INTO OUTFILE '/tmp/embeddings.bin';

-- Import binaire
LOAD DATA INFILE '/tmp/embeddings.bin'
INTO TABLE documents_import
FIELDS TERMINATED BY ','
(doc_id, @binary_data)
SET embedding = VEC_FromBinary(@binary_data);
```

---

## VEC_Dimensions - Obtenir le nombre de dimensions

### Syntaxe

```sql
VEC_Dimensions(vector) ‚Üí INT
```

### Exemples

```sql
-- V√©rifier dimensions d'un vecteur
SELECT VEC_Dimensions(VEC_FromText('[1, 2, 3, 4, 5]'));
-- R√©sultat: 5

-- Audit dimensions dans la table
SELECT 
    VEC_Dimensions(embedding) AS dims,
    COUNT(*) AS count
FROM documents
GROUP BY dims
ORDER BY dims;

-- R√©sultat :
-- dims | count
-- -----|------
-- 384  | 1250
-- 768  | 3420
-- 1536 | 5830

-- D√©tecter vecteurs avec dimensions incorrectes
SELECT 
    doc_id,
    title,
    VEC_Dimensions(embedding) AS actual_dims
FROM documents
WHERE VEC_Dimensions(embedding) != 1536;
```

### Validation avec contrainte

```sql
-- Contrainte CHECK sur dimensions
ALTER TABLE documents
ADD CONSTRAINT chk_embedding_dims
CHECK (VEC_Dimensions(embedding) = 1536);

-- Trigger de validation (alternative)
DELIMITER $$
CREATE TRIGGER validate_embedding_dims
BEFORE INSERT ON documents
FOR EACH ROW
BEGIN
    IF VEC_Dimensions(NEW.embedding) != 1536 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Invalid embedding dimensions';
    END IF;
END$$
DELIMITER ;
```

---

## Int√©gration avec langages de programmation

### Python (numpy)

```python
import mysql.connector
import numpy as np
import struct

def numpy_to_mariadb_vector(arr):
    """Convertir numpy array vers format texte MariaDB"""
    if not isinstance(arr, np.ndarray):
        arr = np.array(arr, dtype=np.float32)
    
    # Format texte (lisible)
    text_format = '[' + ','.join(map(str, arr.tolist())) + ']'
    return text_format

def numpy_to_binary_vector(arr):
    """Convertir numpy array vers format binaire"""
    if not isinstance(arr, np.ndarray):
        arr = np.array(arr, dtype=np.float32)
    
    # Pack en IEEE 754 float (4 bytes par dimension)
    binary = struct.pack(f'{len(arr)}f', *arr)
    return binary

def mariadb_vector_to_numpy(text_str):
    """Convertir format texte MariaDB vers numpy"""
    # Enlever crochets et parser
    clean = text_str.strip('[]')
    values = [float(x.strip()) for x in clean.split(',')]
    return np.array(values, dtype=np.float32)

# Utilisation avec mysql.connector
conn = mysql.connector.connect(
    host='localhost',
    user='user',
    password='password',
    database='vector_db'
)
cursor = conn.cursor()

# Insertion avec numpy
embedding = np.random.rand(1536).astype(np.float32)
embedding_str = numpy_to_mariadb_vector(embedding)

cursor.execute("""
    INSERT INTO documents (title, embedding)
    VALUES (%s, VEC_FromText(%s))
""", ("Document title", embedding_str))

# Lecture vers numpy
cursor.execute("SELECT VEC_ToText(embedding) FROM documents WHERE doc_id = 1")
result = cursor.fetchone()[0]
embedding_np = mariadb_vector_to_numpy(result)

print(f"Embedding shape: {embedding_np.shape}")
# Embedding shape: (1536,)

conn.commit()
cursor.close()
conn.close()
```

### Python (optimis√© avec binaire)

```python
import struct
import mysql.connector

def pack_vector_binary(floats):
    """Convertir liste de floats en binaire pour MariaDB"""
    # Format : 'f' * len(floats) = s√©quence de floats 32-bit
    packed = struct.pack(f'{len(floats)}f', *floats)
    return packed

def unpack_vector_binary(binary_data):
    """Convertir binaire MariaDB en liste de floats"""
    n_floats = len(binary_data) // 4  # 4 bytes par float
    return list(struct.unpack(f'{n_floats}f', binary_data))

# Insertion binaire (plus rapide)
embedding = [0.1, 0.2, 0.3, ..., 1536 values]
binary_data = pack_vector_binary(embedding)

cursor.execute("""
    INSERT INTO documents (title, embedding)
    VALUES (%s, VEC_FromBinary(%s))
""", ("Title", binary_data))

# Lecture binaire
cursor.execute("SELECT VEC_ToBinary(embedding) FROM documents WHERE doc_id = 1")
binary_result = cursor.fetchone()[0]
embedding_list = unpack_vector_binary(binary_result)
```

### JavaScript / Node.js

```javascript
const mysql = require('mysql2/promise');

/**
 * Convertir array JavaScript en format texte MariaDB
 */
function arrayToVectorText(arr) {
    return '[' + arr.join(',') + ']';
}

/**
 * Convertir format texte MariaDB en array JavaScript
 */
function vectorTextToArray(text) {
    // Enlever crochets et parser
    const clean = text.replace(/[\[\]]/g, '');
    return clean.split(',').map(parseFloat);
}

/**
 * Convertir array en Buffer binaire
 */
function arrayToVectorBinary(arr) {
    const buffer = Buffer.allocUnsafe(arr.length * 4);
    arr.forEach((value, index) => {
        buffer.writeFloatLE(value, index * 4);
    });
    return buffer;
}

/**
 * Convertir Buffer binaire en array
 */
function vectorBinaryToArray(buffer) {
    const arr = [];
    for (let i = 0; i < buffer.length; i += 4) {
        arr.push(buffer.readFloatLE(i));
    }
    return arr;
}

// Utilisation
async function insertEmbedding() {
    const connection = await mysql.createConnection({
        host: 'localhost',
        user: 'user',
        password: 'password',
        database: 'vector_db'
    });
    
    // Embedding depuis mod√®le
    const embedding = [0.023, -0.145, 0.089, /* ... 1536 values */];
    const embeddingText = arrayToVectorText(embedding);
    
    // Insertion
    await connection.execute(
        `INSERT INTO documents (title, embedding) 
         VALUES (?, VEC_FromText(?))`,
        ['Document Title', embeddingText]
    );
    
    // Lecture
    const [rows] = await connection.execute(
        `SELECT VEC_ToText(embedding) as emb 
         FROM documents WHERE doc_id = ?`,
        [1]
    );
    
    const retrievedEmbedding = vectorTextToArray(rows[0].emb);
    console.log(`Retrieved ${retrievedEmbedding.length} dimensions`);
    
    await connection.end();
}
```

### Java

```java
import java.sql.*;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

public class VectorConverter {
    
    /**
     * Convertir float[] en String format MariaDB
     */
    public static String floatArrayToVectorText(float[] arr) {
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < arr.length; i++) {
            sb.append(arr[i]);
            if (i < arr.length - 1) {
                sb.append(",");
            }
        }
        sb.append("]");
        return sb.toString();
    }
    
    /**
     * Convertir String format MariaDB en float[]
     */
    public static float[] vectorTextToFloatArray(String text) {
        // Enlever crochets
        String clean = text.substring(1, text.length() - 1);
        String[] parts = clean.split(",");
        
        float[] result = new float[parts.length];
        for (int i = 0; i < parts.length; i++) {
            result[i] = Float.parseFloat(parts[i].trim());
        }
        return result;
    }
    
    /**
     * Convertir float[] en bytes (format binaire IEEE 754)
     */
    public static byte[] floatArrayToBinary(float[] arr) {
        ByteBuffer buffer = ByteBuffer.allocate(arr.length * 4);
        buffer.order(ByteOrder.LITTLE_ENDIAN);
        
        for (float value : arr) {
            buffer.putFloat(value);
        }
        
        return buffer.array();
    }
    
    /**
     * Convertir bytes en float[]
     */
    public static float[] binaryToFloatArray(byte[] bytes) {
        ByteBuffer buffer = ByteBuffer.wrap(bytes);
        buffer.order(ByteOrder.LITTLE_ENDIAN);
        
        float[] result = new float[bytes.length / 4];
        for (int i = 0; i < result.length; i++) {
            result[i] = buffer.getFloat();
        }
        
        return result;
    }
    
    // Exemple d'utilisation
    public static void main(String[] args) throws SQLException {
        Connection conn = DriverManager.getConnection(
            "jdbc:mariadb://localhost:3306/vector_db",
            "user", "password"
        );
        
        // Insertion
        float[] embedding = new float[1536];
        // ... remplir embedding
        
        String embeddingText = floatArrayToVectorText(embedding);
        
        PreparedStatement pstmt = conn.prepareStatement(
            "INSERT INTO documents (title, embedding) " +
            "VALUES (?, VEC_FromText(?))"
        );
        pstmt.setString(1, "Document Title");
        pstmt.setString(2, embeddingText);
        pstmt.executeUpdate();
        
        // Lecture
        PreparedStatement selectStmt = conn.prepareStatement(
            "SELECT VEC_ToText(embedding) FROM documents WHERE doc_id = ?"
        );
        selectStmt.setInt(1, 1);
        ResultSet rs = selectStmt.executeQuery();
        
        if (rs.next()) {
            String vectorText = rs.getString(1);
            float[] retrieved = vectorTextToFloatArray(vectorText);
            System.out.println("Retrieved " + retrieved.length + " dimensions");
        }
        
        conn.close();
    }
}
```

---

## Optimisations de performance

### Benchmark : Texte vs Binaire

```sql
-- Table de test
CREATE TABLE perf_test (
    id INT PRIMARY KEY AUTO_INCREMENT,
    vec VECTOR(1536)
) ENGINE=InnoDB;

-- Test 1 : Insertion format texte
-- 10,000 insertions
SET @start = NOW(6);

INSERT INTO perf_test (vec)
SELECT VEC_FromText('[0.1,0.2,0.3,...]')
FROM seq_1_to_10000;

SELECT TIMESTAMPDIFF(MICROSECOND, @start, NOW(6)) / 1000000.0 AS seconds;
-- R√©sultat : ~3.2 secondes

-- Test 2 : Insertion format binaire
TRUNCATE perf_test;
SET @start = NOW(6);

INSERT INTO perf_test (vec)
SELECT VEC_FromBinary(UNHEX('3d8f5c3ebd4c...'))
FROM seq_1_to_10000;

SELECT TIMESTAMPDIFF(MICROSECOND, @start, NOW(6)) / 1000000.0 AS seconds;
-- R√©sultat : ~1.8 secondes

-- ‚Üí Format binaire 1.8√ó plus rapide pour insertion
```

### Batch insert optimis√©

```python
# Python : Insertion par lots optimis√©e
import mysql.connector

def batch_insert_embeddings(embeddings, batch_size=1000):
    """
    Insertion optimis√©e par lots
    embeddings: liste de (title, embedding_array)
    """
    conn = mysql.connector.connect(...)
    cursor = conn.cursor()
    
    for i in range(0, len(embeddings), batch_size):
        batch = embeddings[i:i + batch_size]
        
        # Pr√©parer valeurs
        values = []
        for title, emb in batch:
            emb_str = '[' + ','.join(map(str, emb)) + ']'
            values.append(f"('{title}', VEC_FromText('{emb_str}'))")
        
        # Insertion batch
        sql = f"""
            INSERT INTO documents (title, embedding)
            VALUES {','.join(values)}
        """
        cursor.execute(sql)
    
    conn.commit()
    cursor.close()
    conn.close()

# Utilisation
embeddings = [
    ("Doc 1", [0.1, 0.2, ..., 1536 values]),
    ("Doc 2", [0.3, 0.4, ..., 1536 values]),
    # ... 10,000 embeddings
]

batch_insert_embeddings(embeddings, batch_size=500)
# Temps : ~2.5 secondes (vs ~8 secondes insertion une par une)
```

### Prepared statements

```python
# Utilisation de prepared statements (plus efficace)
cursor = conn.cursor()

# Pr√©parer statement
insert_stmt = """
    INSERT INTO documents (title, embedding)
    VALUES (%s, VEC_FromText(%s))
"""

# Ins√©rer par lots
embeddings_data = [
    ("Title 1", "[0.1,0.2,...]"),
    ("Title 2", "[0.3,0.4,...]"),
    # ...
]

cursor.executemany(insert_stmt, embeddings_data)
conn.commit()
```

---

## Validation et gestion d'erreurs

### Validation compl√®te

```sql
-- Fonction de validation robuste
DELIMITER $$
CREATE FUNCTION validate_vector_input(
    vec_text TEXT,
    expected_dims INT
)
RETURNS BOOLEAN
DETERMINISTIC
BEGIN
    DECLARE vec VECTOR(1536);
    DECLARE actual_dims INT;
    
    -- Handler pour erreurs de conversion
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
        RETURN FALSE;
    
    -- Tentative conversion
    SET vec = VEC_FromText(vec_text);
    
    -- V√©rifier non-NULL
    IF vec IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- V√©rifier dimensions
    SET actual_dims = VEC_Dimensions(vec);
    IF actual_dims != expected_dims THEN
        RETURN FALSE;
    END IF;
    
    -- V√©rifier valeurs finies (pas NaN ou Infinity)
    -- (v√©rification simplifi√©e)
    
    RETURN TRUE;
END$$
DELIMITER ;

-- Utilisation
SELECT validate_vector_input('[0.1, 0.2, 0.3]', 3);
-- TRUE

SELECT validate_vector_input('[0.1, 0.2]', 3);
-- FALSE (dimensions incorrectes)

SELECT validate_vector_input('[0.1, abc, 0.3]', 3);
-- FALSE (format invalide)
```

### Nettoyage et normalisation d'entr√©e

```sql
-- Proc√©dure de nettoyage et insertion s√ªre
DELIMITER $$
CREATE PROCEDURE safe_insert_embedding(
    IN p_title VARCHAR(200),
    IN p_embedding_text TEXT,
    IN p_expected_dims INT
)
BEGIN
    DECLARE v_embedding VECTOR(1536);
    DECLARE v_valid BOOLEAN;
    
    -- Validation
    SET v_valid = validate_vector_input(p_embedding_text, p_expected_dims);
    
    IF NOT v_valid THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Invalid embedding input';
    END IF;
    
    -- Conversion
    SET v_embedding = VEC_FromText(p_embedding_text);
    
    -- Normalisation optionnelle
    SET v_embedding = VEC_Normalize(v_embedding);
    
    -- Insertion
    INSERT INTO documents (title, embedding, created_at)
    VALUES (p_title, v_embedding, NOW());
    
    SELECT LAST_INSERT_ID() AS doc_id;
END$$
DELIMITER ;

-- Utilisation
CALL safe_insert_embedding(
    'My Document',
    '[0.1, 0.2, 0.3, ...]',
    1536
);
```

---

## Pipeline ETL pour embeddings

### Workflow complet

```python
# Pipeline ETL : Documents ‚Üí Embeddings ‚Üí MariaDB
import openai
import mysql.connector
from typing import List, Tuple
import time

class EmbeddingPipeline:
    def __init__(self, db_config, openai_api_key):
        self.db_config = db_config
        openai.api_key = openai_api_key
    
    def generate_embeddings(self, texts: List[str], 
                          model="text-embedding-3-small") -> List[List[float]]:
        """G√©n√©rer embeddings via OpenAI API"""
        embeddings = []
        
        # Batch processing (max 2048 par requ√™te OpenAI)
        batch_size = 100
        for i in range(0, len(texts), batch_size):
            batch = texts[i:i + batch_size]
            
            response = openai.embeddings.create(
                model=model,
                input=batch
            )
            
            batch_embeddings = [item.embedding for item in response.data]
            embeddings.extend(batch_embeddings)
            
            # Rate limiting
            time.sleep(0.1)
        
        return embeddings
    
    def insert_to_mariadb(self, documents: List[Tuple[str, str, List[float]]]):
        """
        Ins√©rer documents avec embeddings
        documents: [(title, content, embedding), ...]
        """
        conn = mysql.connector.connect(**self.db_config)
        cursor = conn.cursor()
        
        insert_stmt = """
            INSERT INTO documents (title, content, embedding, created_at)
            VALUES (%s, %s, VEC_FromText(%s), NOW())
        """
        
        # Pr√©parer donn√©es
        data = []
        for title, content, embedding in documents:
            emb_str = '[' + ','.join(map(str, embedding)) + ']'
            data.append((title, content, emb_str))
        
        # Insertion par lots
        batch_size = 500
        for i in range(0, len(data), batch_size):
            batch = data[i:i + batch_size]
            cursor.executemany(insert_stmt, batch)
            conn.commit()
            print(f"Inserted batch {i//batch_size + 1}")
        
        cursor.close()
        conn.close()
    
    def process_documents(self, documents: List[Tuple[str, str]]):
        """
        Pipeline complet : documents ‚Üí embeddings ‚Üí DB
        documents: [(title, content), ...]
        """
        print(f"Processing {len(documents)} documents...")
        
        # 1. Extraire textes
        texts = [content for _, content in documents]
        
        # 2. G√©n√©rer embeddings
        print("Generating embeddings...")
        embeddings = self.generate_embeddings(texts)
        
        # 3. Combiner avec documents
        docs_with_embeddings = [
            (title, content, embedding)
            for (title, content), embedding in zip(documents, embeddings)
        ]
        
        # 4. Ins√©rer dans MariaDB
        print("Inserting into MariaDB...")
        self.insert_to_mariadb(docs_with_embeddings)
        
        print(f"‚úì Processed {len(documents)} documents")

# Utilisation
pipeline = EmbeddingPipeline(
    db_config={
        'host': 'localhost',
        'user': 'user',
        'password': 'password',
        'database': 'vector_db'
    },
    openai_api_key='sk-...'
)

documents = [
    ("Doc 1", "MariaDB 11.8 introduces vector support..."),
    ("Doc 2", "HNSW provides fast approximate search..."),
    # ... thousands of documents
]

pipeline.process_documents(documents)
```

---

## Export et migration

### Export vers JSON

```sql
-- Export complet en JSON
SELECT JSON_OBJECT(
    'doc_id', doc_id,
    'title', title,
    'content', content,
    'embedding', VEC_ToText(embedding),
    'created_at', created_at
) AS document_json
FROM documents
INTO OUTFILE '/tmp/documents_export.json'
LINES TERMINATED BY '\n';
```

### Export CSV avec embeddings

```sql
-- Export CSV
SELECT 
    doc_id,
    title,
    REPLACE(content, ',', ';') AS content,  -- √âchapper virgules
    CONCAT('"', VEC_ToText(embedding), '"') AS embedding
FROM documents
INTO OUTFILE '/tmp/documents.csv'
FIELDS TERMINATED BY ','
ENCLOSED BY '"'
LINES TERMINATED BY '\n';
```

### Import depuis autre DB vectorielle

```python
# Migration depuis Pinecone/Qdrant vers MariaDB
import mysql.connector
from pinecone import Pinecone

def migrate_from_pinecone(index_name, db_config):
    """Migrer index Pinecone vers MariaDB"""
    
    # Connexion Pinecone
    pc = Pinecone(api_key="...")
    index = pc.Index(index_name)
    
    # Connexion MariaDB
    conn = mysql.connector.connect(**db_config)
    cursor = conn.cursor()
    
    # Fetch tous les vecteurs (par lots)
    batch_size = 100
    vectors_batch = []
    
    # Parcourir index Pinecone
    for ids_batch in index.list(limit=batch_size):
        fetch_result = index.fetch(ids_batch)
        
        for vector_id, vector_data in fetch_result['vectors'].items():
            embedding = vector_data['values']
            metadata = vector_data.get('metadata', {})
            
            emb_str = '[' + ','.join(map(str, embedding)) + ']'
            
            cursor.execute("""
                INSERT INTO documents (
                    external_id,
                    title,
                    content,
                    embedding,
                    metadata
                ) VALUES (%s, %s, %s, VEC_FromText(%s), %s)
            """, (
                vector_id,
                metadata.get('title', ''),
                metadata.get('content', ''),
                emb_str,
                json.dumps(metadata)
            ))
        
        conn.commit()
        print(f"Migrated batch")
    
    cursor.close()
    conn.close()
    print("Migration completed")
```

---

## Bonnes pratiques

### ‚úÖ Recommandations

1. **Valider avant insertion**
   ```python
   if not validate_dimensions(embedding, 1536):
       raise ValueError("Invalid embedding dimensions")
   ```

2. **Utiliser binaire pour performance**
   ```python
   # Pour gros volumes d'insertion
   binary_data = pack_vector_binary(embedding)
   cursor.execute("... VEC_FromBinary(%s)", (binary_data,))
   ```

3. **Batch processing**
   ```python
   # Ins√©rer par lots de 500-1000
   cursor.executemany(insert_stmt, batch_data)
   ```

4. **Normaliser si n√©cessaire**
   ```sql
   INSERT INTO docs (embedding)
   VALUES (VEC_Normalize(VEC_FromText('[...]')))
   ```

5. **Logger les conversions √©chou√©es**
   ```python
   try:
       vec = VEC_FromText(embedding_str)
   except Exception as e:
       logger.error(f"Conversion failed: {e}")
       # Continuer avec autres embeddings
   ```

6. **Utiliser prepared statements**
   ```python
   # Plus efficace que concat√©nation SQL
   cursor.executemany(stmt, data)
   ```

### ‚ö†Ô∏è Pi√®ges √† √©viter

1. **Concat√©nation SQL** ‚Üí Injection, erreurs parsing
2. **Pas de validation dimensions** ‚Üí Insertions silencieuses incorrectes
3. **Insertions une par une** ‚Üí 10√ó plus lent que batch
4. **Format texte pour gros volumes** ‚Üí Utiliser binaire
5. **Oubli normalisation** ‚Üí Distance cosinus incorrecte
6. **Pas de gestion erreurs** ‚Üí Pipeline crash sur 1 mauvaise valeur

---

## ‚úÖ Points cl√©s √† retenir

- **VEC_FromText()** convertit texte JSON vers VECTOR natif
- **VEC_ToText()** convertit VECTOR vers texte lisible
- Format texte : `"[0.1, -0.2, 0.3, ...]"` (JSON array standard)
- **Format binaire** 1.8√ó plus rapide pour insertion massive
- **VEC_Dimensions()** retourne nombre de dimensions, essentiel pour validation
- Validation automatique avec `VEC_FromText(text, expected_dims)`
- **Batch processing** crucial pour performance (500-1000 par lot)
- Int√©gration facile avec **Python, JavaScript, Java**
- **Pipeline ETL** : Documents ‚Üí Embeddings API ‚Üí MariaDB
- **Normalisation** recommand√©e pour distance cosinus

---

## üîó Ressources et r√©f√©rences

- [üìñ MariaDB - Vector Conversion Functions](https://mariadb.com/kb/en/vector-conversion-functions/)
- [üìñ VEC_FromText Documentation](https://mariadb.com/kb/en/vec_fromtext/)
- [üìñ VEC_ToText Documentation](https://mariadb.com/kb/en/vec_totext/)
- [üêç Python struct - Binary Data](https://docs.python.org/3/library/struct.html)
- [‚òï Java ByteBuffer Guide](https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html)
- [üü¢ Node.js Buffer Documentation](https://nodejs.org/api/buffer.html)

---


‚è≠Ô∏è [Optimisations SIMD (AVX2, AVX512, ARM, IBM Power10)](/18-fonctionnalites-avancees/10.5-optimisations-simd.md)
