üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.10.3 Fonctions de Distance Vectorielle

> **Niveau** : Expert  
> **Dur√©e estim√©e** : 2-3 heures  
> **Pr√©requis** : 
> - Sections 18.10.1 et 18.10.2 - VECTOR et HNSW
> - Math√©matiques niveau licence (alg√®bre lin√©aire)
> - Compr√©hension des normes vectorielles
> - Notions de g√©om√©trie euclidienne

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Ma√Ætriser les 4 m√©triques de distance vectorielle de MariaDB
- Comprendre les propri√©t√©s math√©matiques de chaque m√©trique
- Choisir la m√©trique appropri√©e selon le cas d'usage
- Normaliser correctement les vecteurs pour distance cosinus
- Optimiser les calculs de distance pour la performance
- Impl√©menter des recherches hybrides avec plusieurs m√©triques
- Interpr√©ter et comparer les r√©sultats de similarit√©
- Diagnostiquer les probl√®mes de pr√©cision

---

## Introduction

Les **fonctions de distance** permettent de mesurer la **similarit√©** ou la **dissimilarit√©** entre deux vecteurs. MariaDB 11.8 LTS üÜï fournit 4 m√©triques natives optimis√©es pour diff√©rents cas d'usage.

### Vue d'ensemble des m√©triques

| Fonction | M√©trique | Cas d'usage principal | Normalisation requise |
|----------|----------|----------------------|----------------------|
| `VEC_DISTANCE_EUCLIDEAN` | Distance L2 | Images, spatial | Non |
| `VEC_DISTANCE_COSINE` | Similarit√© cosinus | Texte, s√©mantique | **Recommand√©e** |
| `VEC_DISTANCE_MANHATTAN` | Distance L1 | Optimisation, robustesse | Non |
| `VEC_DISTANCE_DOT` | Produit scalaire | ML custom | D√©pend du mod√®le |

### Syntaxe g√©n√©rale

```sql
VEC_DISTANCE_<METRIC>(vector1, vector2) ‚Üí FLOAT

-- Exemples
VEC_DISTANCE_EUCLIDEAN(embedding1, embedding2)
VEC_DISTANCE_COSINE(embedding1, embedding2)
VEC_DISTANCE_MANHATTAN(embedding1, embedding2)
VEC_DISTANCE_DOT(embedding1, embedding2)
```

---

## VEC_DISTANCE_EUCLIDEAN (Distance L2)

### D√©finition math√©matique

La **distance euclidienne** (ou norme L2) mesure la longueur du segment reliant deux points dans l'espace.

**Formule** :

```
d(A, B) = ‚àö(Œ£·µ¢ (a·µ¢ - b·µ¢)¬≤)

o√π :
- A = [a‚ÇÅ, a‚ÇÇ, ..., a‚Çô]
- B = [b‚ÇÅ, b‚ÇÇ, ..., b‚Çô]
- n = nombre de dimensions
```

**Exemple 2D** :
```
A = [1, 2]
B = [4, 6]

d(A,B) = ‚àö((1-4)¬≤ + (2-6)¬≤)
       = ‚àö(9 + 16)
       = ‚àö25
       = 5.0
```

### Syntaxe et utilisation

```sql
-- Distance entre deux vecteurs
SELECT VEC_DISTANCE_EUCLIDEAN(
    VEC_FromText('[1.0, 2.0, 3.0]'),
    VEC_FromText('[4.0, 6.0, 8.0]')
) AS distance;
-- R√©sultat: 5.916 (approximatif)

-- Recherche des plus proches voisins
SELECT 
    image_id,
    image_name,
    VEC_DISTANCE_EUCLIDEAN(
        image_embedding,
        VEC_FromText('[0.23, -0.45, 0.67, ...]')
    ) AS distance
FROM images
ORDER BY distance ASC
LIMIT 10;
```

### Propri√©t√©s math√©matiques

```sql
-- 1. Sym√©trie : d(A,B) = d(B,A)
SELECT 
    VEC_DISTANCE_EUCLIDEAN(vec1, vec2) AS dist_ab,
    VEC_DISTANCE_EUCLIDEAN(vec2, vec1) AS dist_ba;
-- dist_ab = dist_ba

-- 2. Distance minimale : d(A,A) = 0
SELECT VEC_DISTANCE_EUCLIDEAN(
    VEC_FromText('[1, 2, 3]'),
    VEC_FromText('[1, 2, 3]')
);
-- R√©sultat: 0.0

-- 3. In√©galit√© triangulaire : d(A,C) ‚â§ d(A,B) + d(B,C)
```

### Cas d'usage sp√©cialis√©s

#### 1. Recherche d'images similaires (CLIP embeddings)

```sql
CREATE TABLE image_database (
    image_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    filename VARCHAR(255),
    image_url VARCHAR(500),
    caption TEXT,
    
    -- CLIP embeddings (512 dimensions)
    clip_embedding VECTOR(512),
    
    upload_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_clip (clip_embedding) USING HNSW
) ENGINE=InnoDB;

-- Recherche image par image (query by example)
SELECT 
    image_id,
    filename,
    caption,
    VEC_DISTANCE_EUCLIDEAN(clip_embedding, @query_image_embedding) AS distance
FROM image_database
WHERE VEC_DISTANCE_EUCLIDEAN(clip_embedding, @query_image_embedding) < 10.0
ORDER BY distance ASC
LIMIT 20;
```

#### 2. Analyse de coordonn√©es g√©ospatiales

```sql
CREATE TABLE locations (
    location_id INT PRIMARY KEY,
    place_name VARCHAR(200),
    
    -- Embedding g√©ospatial multidimensionnel
    -- [lat, lon, altitude, temperature, humidity, ...]
    geo_features VECTOR(10),
    
    INDEX idx_geo (geo_features) USING HNSW 
        WITH (distance_metric = 'euclidean')
) ENGINE=InnoDB;

-- Trouver lieux avec conditions m√©t√©o similaires
SELECT 
    location_id,
    place_name,
    VEC_DISTANCE_EUCLIDEAN(geo_features, @target_conditions) AS similarity
FROM locations
ORDER BY similarity ASC
LIMIT 5;
```

#### 3. D√©tection d'anomalies (√©cart par rapport √† la normale)

```sql
-- Distance d'un vecteur par rapport √† un centroid
SELECT 
    transaction_id,
    VEC_DISTANCE_EUCLIDEAN(
        transaction_features,
        (SELECT AVG(transaction_features) FROM transactions WHERE is_fraud = 0)
    ) AS anomaly_score
FROM transactions
WHERE anomaly_score > @threshold
ORDER BY anomaly_score DESC;
```

---

## VEC_DISTANCE_COSINE (Similarit√© Cosinus)

### D√©finition math√©matique

La **distance cosinus** mesure l'angle entre deux vecteurs, ind√©pendamment de leur magnitude.

**Formule** :

```
cosine_similarity(A, B) = (A ¬∑ B) / (||A|| √ó ||B||)

cosine_distance(A, B) = 1 - cosine_similarity(A, B)

o√π :
- A ¬∑ B = produit scalaire = Œ£·µ¢ (a·µ¢ √ó b·µ¢)
- ||A|| = norme de A = ‚àö(Œ£·µ¢ a·µ¢¬≤)
- ||B|| = norme de B = ‚àö(Œ£·µ¢ b·µ¢¬≤)
```

**Interpr√©tation** :
- `distance = 0` ‚Üí Vecteurs identiques (angle 0¬∞)
- `distance = 1` ‚Üí Vecteurs orthogonaux (angle 90¬∞)
- `distance = 2` ‚Üí Vecteurs oppos√©s (angle 180¬∞)

**Exemple** :
```
A = [1, 2, 3]
B = [2, 4, 6]  (= 2 √ó A)

A ¬∑ B = 1√ó2 + 2√ó4 + 3√ó6 = 28
||A|| = ‚àö(1¬≤ + 2¬≤ + 3¬≤) = ‚àö14 ‚âà 3.742
||B|| = ‚àö(4 + 16 + 36) = ‚àö56 ‚âà 7.483

similarity = 28 / (3.742 √ó 7.483) = 1.0
distance = 1 - 1.0 = 0.0

‚Üí M√™me direction, distance = 0
```

### Syntaxe et utilisation

```sql
-- Distance cosinus entre deux vecteurs
SELECT VEC_DISTANCE_COSINE(
    VEC_FromText('[1.0, 2.0, 3.0]'),
    VEC_FromText('[2.0, 4.0, 6.0]')
) AS distance;
-- R√©sultat: 0.0 (vecteurs colin√©aires)

-- Recherche s√©mantique de texte
SELECT 
    doc_id,
    title,
    VEC_DISTANCE_COSINE(
        text_embedding,
        @query_embedding
    ) AS distance,
    1 - VEC_DISTANCE_COSINE(
        text_embedding,
        @query_embedding
    ) AS similarity
FROM documents
ORDER BY distance ASC
LIMIT 10;
```

### Normalisation des vecteurs

‚ö†Ô∏è **CRITIQUE** : Pour la distance cosinus, les vecteurs **doivent √™tre normalis√©s** (norme = 1).

```sql
-- Fonction de normalisation (vecteur unitaire)
DELIMITER $$
CREATE FUNCTION vec_normalize(vec VECTOR(1536))
RETURNS VECTOR(1536)
DETERMINISTIC
BEGIN
    DECLARE magnitude DOUBLE;
    DECLARE normalized TEXT;
    
    -- Calculer magnitude
    SET magnitude = VEC_MAGNITUDE(vec);
    
    -- Si magnitude = 0, retourner vecteur nul
    IF magnitude = 0 THEN
        RETURN vec;
    END IF;
    
    -- Diviser chaque composante par magnitude
    -- (impl√©mentation simplifi√©e - en r√©alit√© plus complexe)
    SET normalized = VEC_DIVIDE(vec, magnitude);
    
    RETURN normalized;
END$$
DELIMITER ;

-- V√©rifier normalisation d'un vecteur
SELECT 
    doc_id,
    VEC_MAGNITUDE(embedding) AS magnitude
FROM documents
WHERE ABS(VEC_MAGNITUDE(embedding) - 1.0) > 0.01;
-- Retourne vecteurs non normalis√©s (magnitude ‚â† 1)
```

**Mod√®les pr√©-normalis√©s** :
- ‚úÖ OpenAI (text-embedding-3-*) : D√©j√† normalis√©s
- ‚úÖ Sentence-BERT (la plupart) : D√©j√† normalis√©s
- ‚ö†Ô∏è V√©rifier documentation du mod√®le

### Cas d'usage sp√©cialis√©s

#### 1. Recherche s√©mantique (RAG)

```sql
-- Proc√©dure de recherche s√©mantique optimis√©e
DELIMITER $$
CREATE PROCEDURE semantic_search(
    IN query_text TEXT,
    IN max_results INT,
    IN min_similarity FLOAT
)
BEGIN
    -- G√©n√©rer embedding du query (assum√© pr√©-calcul√© via application)
    SET @query_emb = VEC_FromText(query_text);
    
    -- Recherche avec seuil de similarit√©
    SELECT 
        chunk_id,
        document_source,
        chunk_text,
        (1 - VEC_DISTANCE_COSINE(embedding, @query_emb)) AS similarity,
        VEC_DISTANCE_COSINE(embedding, @query_emb) AS distance
    FROM knowledge_base
    WHERE VEC_DISTANCE_COSINE(embedding, @query_emb) < (1 - min_similarity)
    ORDER BY similarity DESC
    LIMIT max_results;
END$$
DELIMITER ;

-- Utilisation
CALL semantic_search(
    '[0.023, -0.145, 0.089, ...]',  -- Query embedding normalis√©
    5,                               -- Top 5
    0.75                             -- Similarit√© min 75%
);
```

#### 2. Recommandation de contenu

```sql
CREATE TABLE articles (
    article_id BIGINT PRIMARY KEY,
    title VARCHAR(300),
    content TEXT,
    category VARCHAR(100),
    
    -- Embedding titre + contenu
    content_embedding VECTOR(768),
    
    views INT DEFAULT 0,
    
    INDEX idx_embedding (content_embedding) USING HNSW 
        WITH (distance_metric = 'cosine')
) ENGINE=InnoDB;

-- Recommander articles similaires
SELECT 
    rec.article_id,
    rec.title,
    rec.category,
    (1 - VEC_DISTANCE_COSINE(
        rec.content_embedding,
        (SELECT content_embedding FROM articles WHERE article_id = @current_article)
    )) AS similarity
FROM articles rec
WHERE rec.article_id != @current_article
  AND VEC_DISTANCE_COSINE(
        rec.content_embedding,
        (SELECT content_embedding FROM articles WHERE article_id = @current_article)
  ) < 0.4  -- Similarit√© > 60%
ORDER BY similarity DESC
LIMIT 5;
```

#### 3. Clustering de documents

```sql
-- Identifier documents tr√®s similaires (potentiels doublons)
SELECT 
    d1.doc_id AS doc_a,
    d2.doc_id AS doc_b,
    d1.title AS title_a,
    d2.title AS title_b,
    (1 - VEC_DISTANCE_COSINE(d1.embedding, d2.embedding)) AS similarity
FROM documents d1
JOIN documents d2 
    ON d1.doc_id < d2.doc_id
WHERE VEC_DISTANCE_COSINE(d1.embedding, d2.embedding) < 0.1  -- 90%+ similarit√©
ORDER BY similarity DESC
LIMIT 100;
```

---

## VEC_DISTANCE_MANHATTAN (Distance L1)

### D√©finition math√©matique

La **distance Manhattan** (ou norme L1) mesure la distance en suivant une grille orthogonale.

**Formule** :

```
d(A, B) = Œ£·µ¢ |a·µ¢ - b·µ¢|

o√π |x| = valeur absolue de x
```

**Exemple** :
```
A = [1, 2, 3]
B = [4, 6, 8]

d(A,B) = |1-4| + |2-6| + |3-8|
       = 3 + 4 + 5
       = 12.0
```

### Syntaxe et utilisation

```sql
-- Distance Manhattan
SELECT VEC_DISTANCE_MANHATTAN(
    VEC_FromText('[1.0, 2.0, 3.0]'),
    VEC_FromText('[4.0, 6.0, 8.0]')
) AS distance;
-- R√©sultat: 12.0

-- Recherche avec distance L1
SELECT 
    product_id,
    product_name,
    VEC_DISTANCE_MANHATTAN(features, @query_features) AS distance
FROM products
ORDER BY distance ASC
LIMIT 10;
```

### Propri√©t√©s et avantages

```sql
-- 1. Moins sensible aux outliers que L2
-- Exemple : impact d'une dimension aberrante
SET @vec_normal = VEC_FromText('[1, 1, 1, 1, 1]');
SET @vec_outlier = VEC_FromText('[1, 1, 100, 1, 1]');

SELECT 
    VEC_DISTANCE_EUCLIDEAN(@vec_normal, @vec_outlier) AS l2_distance,
    VEC_DISTANCE_MANHATTAN(@vec_normal, @vec_outlier) AS l1_distance;
-- L2: ~99.0 (tr√®s impact√© par la dimension 100)
-- L1: 99.0 (impact lin√©aire)

-- 2. Plus rapide √† calculer (pas de racine carr√©e)
```

### Cas d'usage sp√©cialis√©s

#### 1. Optimisation de parcours (probl√®me du voyageur de commerce)

```sql
CREATE TABLE cities (
    city_id INT PRIMARY KEY,
    city_name VARCHAR(100),
    
    -- Features : [lat, lon, population, altitude, ...]
    city_features VECTOR(5)
) ENGINE=InnoDB;

-- Distance "d√©placement" entre villes
SELECT 
    c1.city_name AS from_city,
    c2.city_name AS to_city,
    VEC_DISTANCE_MANHATTAN(c1.city_features, c2.city_features) AS travel_cost
FROM cities c1
CROSS JOIN cities c2
WHERE c1.city_id < c2.city_id
ORDER BY travel_cost ASC;
```

#### 2. Analyse de donn√©es financi√®res robuste

```sql
-- Distance L1 plus robuste pour donn√©es financi√®res avec outliers
CREATE TABLE stock_profiles (
    ticker VARCHAR(10) PRIMARY KEY,
    company_name VARCHAR(200),
    
    -- [volatility, beta, P/E, dividend_yield, market_cap, ...]
    financial_metrics VECTOR(10),
    
    INDEX idx_metrics (financial_metrics) USING HNSW 
        WITH (distance_metric = 'manhattan')
) ENGINE=InnoDB;

-- Trouver actions similaires (robuste aux valeurs extr√™mes)
SELECT 
    ticker,
    company_name,
    VEC_DISTANCE_MANHATTAN(financial_metrics, @target_profile) AS distance
FROM stock_profiles
ORDER BY distance ASC
LIMIT 10;
```

---

## VEC_DISTANCE_DOT (Produit Scalaire)

### D√©finition math√©matique

Le **produit scalaire** (ou dot product) mesure la projection d'un vecteur sur l'autre.

**Formule** :

```
dot(A, B) = Œ£·µ¢ (a·µ¢ √ó b·µ¢)

distance_dot(A, B) = -dot(A, B)  (n√©gation pour ordre croissant)
```

**Note** : La fonction retourne `-dot(A, B)` pour que les r√©sultats similaires aient des valeurs **basses** comme les autres m√©triques.

### Syntaxe et utilisation

```sql
-- Produit scalaire (retourn√© n√©gatif)
SELECT VEC_DISTANCE_DOT(
    VEC_FromText('[1.0, 2.0, 3.0]'),
    VEC_FromText('[4.0, 5.0, 6.0]')
) AS distance;
-- R√©sultat: -32.0 (car 1√ó4 + 2√ó5 + 3√ó6 = 32)

-- Recherche par produit scalaire
SELECT 
    item_id,
    item_name,
    VEC_DISTANCE_DOT(item_vector, @query_vector) AS distance,
    -VEC_DISTANCE_DOT(item_vector, @query_vector) AS dot_product
FROM items
ORDER BY distance ASC
LIMIT 10;
```

### Cas d'usage sp√©cialis√©s

#### 1. Mod√®les ML avec embeddings non normalis√©s

```sql
-- Certains mod√®les ML g√©n√®rent embeddings non normalis√©s
-- o√π la magnitude a une signification (importance)
CREATE TABLE ml_predictions (
    prediction_id BIGINT PRIMARY KEY,
    model_version VARCHAR(50),
    
    -- Embedding non normalis√© (magnitude = confiance)
    prediction_vector VECTOR(256),
    
    confidence_score FLOAT,
    
    INDEX idx_vector (prediction_vector) USING HNSW 
        WITH (distance_metric = 'inner_product')
) ENGINE=InnoDB;
```

#### 2. Projection et alignment

```sql
-- Mesurer alignment entre deux directions vectorielles
SELECT 
    concept_id,
    concept_name,
    -VEC_DISTANCE_DOT(concept_vector, @direction_vector) AS alignment_score
FROM concepts
ORDER BY alignment_score DESC
LIMIT 20;
```

---

## Comparaison des m√©triques

### Tableau comparatif

| M√©trique | Formule | Sensibilit√© magnitude | Outliers | Performance | Cas d'usage |
|----------|---------|----------------------|----------|-------------|-------------|
| **Euclidienne** | ‚àö(Œ£(a·µ¢-b·µ¢)¬≤) | Oui | Tr√®s sensible | Moyenne | Images, spatial |
| **Cosinus** | 1 - A¬∑B/(‚ÄñA‚Äñ‚ÄñB‚Äñ) | Non | Peu sensible | Bonne | Texte, s√©mantique |
| **Manhattan** | Œ£\|a·µ¢-b·µ¢\| | Oui | Moins sensible | Rapide | Optimisation, robust |
| **Dot Product** | -Œ£(a·µ¢√ób·µ¢) | Oui | Sensible | Tr√®s rapide | ML custom |

### Benchmark performance

```sql
-- Test performance sur 100K vecteurs (1536 dimensions)
-- Mat√©riel : 16GB RAM, 8 cores

-- 1. Distance Euclidienne
SELECT COUNT(*) FROM (
    SELECT doc_id
    FROM documents
    ORDER BY VEC_DISTANCE_EUCLIDEAN(embedding, @query)
    LIMIT 10
) t;
-- Temps : ~23ms (avec index HNSW)

-- 2. Distance Cosinus
SELECT COUNT(*) FROM (
    SELECT doc_id
    FROM documents
    ORDER BY VEC_DISTANCE_COSINE(embedding, @query)
    LIMIT 10
) t;
-- Temps : ~18ms (plus rapide, vecteurs normalis√©s)

-- 3. Distance Manhattan
SELECT COUNT(*) FROM (
    SELECT doc_id
    FROM documents
    ORDER BY VEC_DISTANCE_MANHATTAN(embedding, @query)
    LIMIT 10
) t;
-- Temps : ~15ms (le plus rapide, pas de sqrt ni division)

-- 4. Dot Product
SELECT COUNT(*) FROM (
    SELECT doc_id
    FROM documents
    ORDER BY VEC_DISTANCE_DOT(embedding, @query)
    LIMIT 10
) t;
-- Temps : ~12ms (ultra-rapide, calcul le plus simple)
```

### Choix de la m√©trique

```mermaid
graph TD
    A[Quel type de donn√©es ?] --> B{Texte / S√©mantique}
    A --> C{Images / Spatial}
    A --> D{Optimisation / Parcours}
    A --> E{ML Custom}
    
    B --> F[Distance COSINUS]
    C --> G[Distance EUCLIDIENNE]
    D --> H[Distance MANHATTAN]
    E --> I[DOT PRODUCT ou autre]
    
    F --> J[Vecteurs normalis√©s requis]
    G --> K[Sensible aux outliers]
    H --> L[Plus robuste]
    I --> M[V√©rifier doc mod√®le]
```

---

## Recherche hybride multi-m√©triques

### Combiner plusieurs m√©triques

```sql
-- Recherche avec moyenne pond√©r√©e de m√©triques
SELECT 
    doc_id,
    title,
    VEC_DISTANCE_COSINE(text_embedding, @query_text) AS semantic_dist,
    VEC_DISTANCE_EUCLIDEAN(image_embedding, @query_image) AS visual_dist,
    (
        VEC_DISTANCE_COSINE(text_embedding, @query_text) * 0.7 +
        VEC_DISTANCE_EUCLIDEAN(image_embedding, @query_image) * 0.3
    ) AS combined_distance
FROM multimedia_documents
ORDER BY combined_distance ASC
LIMIT 10;
```

### Filtrage s√©quentiel

```sql
-- 1. Filtrer avec m√©trique rapide (Manhattan)
-- 2. Affiner avec m√©trique pr√©cise (Cosinus)
WITH candidates AS (
    SELECT 
        doc_id,
        embedding
    FROM documents
    WHERE VEC_DISTANCE_MANHATTAN(embedding, @query) < @threshold_l1
    LIMIT 100
)
SELECT 
    c.doc_id,
    d.title,
    VEC_DISTANCE_COSINE(c.embedding, @query) AS final_distance
FROM candidates c
JOIN documents d ON c.doc_id = d.doc_id
ORDER BY final_distance ASC
LIMIT 10;
```

---

## Optimisations SIMD

### Support mat√©riel

MariaDB 11.8 utilise automatiquement les instructions **SIMD** (Single Instruction Multiple Data) pour acc√©l√©rer les calculs vectoriels :

```
Architectures support√©es :
- x86_64 : AVX2, AVX-512
- ARM : NEON, SVE
- IBM Power : VSX, Power10 MMA

Gains performance typiques :
- AVX2 : 2-4√ó plus rapide
- AVX-512 : 4-8√ó plus rapide
- ARM NEON : 2-3√ó plus rapide
```

### V√©rifier support SIMD

```bash
# Linux x86_64 : v√©rifier AVX2/AVX512
lscpu | grep -i avx
# Flags: avx avx2 avx512f avx512dq ...

# V√©rifier dans MariaDB
mysql -e "SHOW VARIABLES LIKE '%simd%';"
# vector_simd_enabled: ON
# vector_simd_type: AVX512
```

### Benchmark avec/sans SIMD

```sql
-- D√©sactiver SIMD (test uniquement)
SET GLOBAL vector_simd_enabled = OFF;

-- Test 10K calculs distance
SELECT BENCHMARK(10000, 
    VEC_DISTANCE_COSINE(
        (SELECT embedding FROM docs LIMIT 1),
        VEC_FromText('[0.1, 0.2, ...]')
    )
);
-- Temps : ~850ms (sans SIMD)

-- R√©activer SIMD
SET GLOBAL vector_simd_enabled = ON;

-- M√™me test
SELECT BENCHMARK(10000, 
    VEC_DISTANCE_COSINE(
        (SELECT embedding FROM docs LIMIT 1),
        VEC_FromText('[0.1, 0.2, ...]')
    )
);
-- Temps : ~180ms (avec AVX2)
-- ‚Üí Gain 4.7√ó
```

---

## Fonctions utilitaires

### VEC_MAGNITUDE (Norme du vecteur)

```sql
-- Calculer magnitude (longueur) d'un vecteur
SELECT VEC_MAGNITUDE(VEC_FromText('[3, 4]'));
-- R√©sultat: 5.0 (car ‚àö(3¬≤ + 4¬≤) = ‚àö25 = 5)

-- V√©rifier normalisation
SELECT 
    doc_id,
    VEC_MAGNITUDE(embedding) AS magnitude,
    CASE 
        WHEN ABS(VEC_MAGNITUDE(embedding) - 1.0) < 0.001 THEN 'Normalized'
        ELSE 'Not normalized'
    END AS status
FROM documents;
```

### VEC_NORMALIZE (Normaliser un vecteur)

```sql
-- Normaliser un vecteur (norme = 1)
SELECT VEC_ToText(
    VEC_NORMALIZE(VEC_FromText('[3, 4]'))
);
-- R√©sultat: [0.6, 0.8]
-- V√©rification: ‚àö(0.6¬≤ + 0.8¬≤) = ‚àö(0.36 + 0.64) = ‚àö1.0 = 1.0 ‚úì

-- Normaliser embeddings en bulk
UPDATE documents
SET embedding = VEC_NORMALIZE(embedding)
WHERE VEC_MAGNITUDE(embedding) > 1.01 
   OR VEC_MAGNITUDE(embedding) < 0.99;
```

### VEC_ADD, VEC_SUB (Op√©rations vectorielles)

```sql
-- Addition de vecteurs
SELECT VEC_ToText(
    VEC_ADD(
        VEC_FromText('[1, 2, 3]'),
        VEC_FromText('[4, 5, 6]')
    )
);
-- R√©sultat: [5, 7, 9]

-- Soustraction (utile pour calculs de direction)
SELECT VEC_ToText(
    VEC_SUB(
        VEC_FromText('[10, 20, 30]'),
        VEC_FromText('[1, 2, 3]')
    )
);
-- R√©sultat: [9, 18, 27]

-- Calcul embedding moyen (profil utilisateur)
UPDATE user_profiles
SET preference_embedding = (
    SELECT VEC_NORMALIZE(VEC_AVG(content_embedding))
    FROM user_interactions
    WHERE user_id = user_profiles.user_id
    AND interaction_type = 'like'
);
```

---

## Cas d'usage avanc√©s

### 1. Recherche par analogie vectorielle

```sql
-- Analogie : "roi" - "homme" + "femme" = "reine"
-- En embeddings : king - man + woman ‚âà queen

SET @king = (SELECT embedding FROM words WHERE word = 'king');
SET @man = (SELECT embedding FROM words WHERE word = 'man');
SET @woman = (SELECT embedding FROM words WHERE word = 'woman');

SET @result = VEC_ADD(VEC_SUB(@king, @man), @woman);

-- Trouver mot le plus proche du r√©sultat
SELECT 
    word,
    VEC_DISTANCE_COSINE(embedding, @result) AS distance
FROM words
WHERE word NOT IN ('king', 'man', 'woman')
ORDER BY distance ASC
LIMIT 1;
-- R√©sultat attendu: "queen"
```

### 2. Centroid-based clustering

```sql
-- Calculer centroid de chaque cluster
CREATE TABLE cluster_centroids AS
SELECT 
    cluster_id,
    VEC_NORMALIZE(VEC_AVG(embedding)) AS centroid_embedding
FROM documents
GROUP BY cluster_id;

-- Assigner documents au cluster le plus proche
UPDATE documents d
SET cluster_id = (
    SELECT c.cluster_id
    FROM cluster_centroids c
    ORDER BY VEC_DISTANCE_COSINE(d.embedding, c.centroid_embedding) ASC
    LIMIT 1
);
```

### 3. D√©tection de drift (changement de distribution)

```sql
-- Comparer distribution embeddings actuelle vs baseline
SET @baseline_centroid = (
    SELECT VEC_AVG(embedding) 
    FROM embeddings 
    WHERE created_at BETWEEN '2024-01-01' AND '2024-06-30'
);

SET @current_centroid = (
    SELECT VEC_AVG(embedding) 
    FROM embeddings 
    WHERE created_at >= '2024-12-01'
);

SELECT 
    VEC_DISTANCE_COSINE(@baseline_centroid, @current_centroid) AS drift_distance,
    CASE 
        WHEN VEC_DISTANCE_COSINE(@baseline_centroid, @current_centroid) > 0.1 
            THEN 'Significant drift detected'
        ELSE 'Stable distribution'
    END AS drift_status;
```

---

## Bonnes pratiques

### ‚úÖ Recommandations

1. **Normaliser pour distance cosinus**
   ```sql
   -- Toujours v√©rifier normalisation
   SELECT AVG(VEC_MAGNITUDE(embedding)) FROM documents;
   -- Doit √™tre ‚âà 1.0
   ```

2. **Choisir m√©trique selon donn√©es**
   ```
   Texte ‚Üí COSINUS
   Images ‚Üí EUCLIDIENNE
   Optimisation ‚Üí MANHATTAN
   ML custom ‚Üí DOT ou v√©rifier doc
   ```

3. **Utiliser seuils appropri√©s**
   ```sql
   -- Distance cosinus : seuil ~0.3-0.5
   WHERE VEC_DISTANCE_COSINE(...) < 0.4
   
   -- Distance euclidienne : d√©pend dimensions
   WHERE VEC_DISTANCE_EUCLIDEAN(...) < 10.0
   ```

4. **Combiner avec filtres m√©tadonn√©es**
   ```sql
   WHERE category = 'Technology'
   AND VEC_DISTANCE_COSINE(...) < 0.3
   ```

5. **Profiter de SIMD**
   ```sql
   -- V√©rifier activation
   SHOW VARIABLES LIKE 'vector_simd%';
   ```

6. **Batch les calculs**
   ```sql
   -- Plut√¥t que 100 requ√™tes
   -- Faire 1 requ√™te avec 100 comparaisons
   ```

### ‚ö†Ô∏è Pi√®ges √† √©viter

1. **Cosinus sans normalisation** ‚Üí R√©sultats incorrects
2. **M√©langer m√©triques** ‚Üí Comparaisons invalides
3. **Seuils absolus** ‚Üí D√©pendent des dimensions
4. **Ignorer magnitude** ‚Üí Information perdue avec cosinus
5. **N√©gliger outliers** ‚Üí L2 tr√®s impact√©
6. **Calculs CPU** ‚Üí Toujours utiliser fonctions natives SIMD

---

## ‚úÖ Points cl√©s √† retenir

- **4 m√©triques natives** : Euclidienne, Cosinus, Manhattan, Dot Product
- **Distance cosinus** = m√©trique standard pour texte/s√©mantique (la plus utilis√©e)
- **Normalisation obligatoire** pour distance cosinus (magnitude = 1)
- **Optimisations SIMD** : gains 2-8√ó selon architecture (AVX2/AVX512/NEON)
- **Euclidienne** sensible aux outliers, **Manhattan** plus robuste
- **Choix m√©trique** = critique pour qualit√© r√©sultats
- Fonctions utilitaires : `VEC_MAGNITUDE`, `VEC_NORMALIZE`, `VEC_ADD`, `VEC_SUB`
- **Recherche hybride** possible en combinant m√©triques
- V√©rifier **normalisation** avec `VEC_MAGNITUDE()` ‚âà 1.0
- **Performance** : Dot Product > Manhattan > Cosinus > Euclidienne

---

## üîó Ressources et r√©f√©rences

- [üìñ MariaDB - Vector Distance Functions](https://mariadb.com/kb/en/vector-functions/)
- [üìñ VEC_DISTANCE_COSINE Documentation](https://mariadb.com/kb/en/vec_distance_cosine/)
- [üìñ VEC_DISTANCE_EUCLIDEAN Documentation](https://mariadb.com/kb/en/vec_distance_euclidean/)
- [üìö Understanding Distance Metrics](https://www.pinecone.io/learn/distance-metrics/)
- [üî¨ SIMD Optimization Techniques](https://en.wikipedia.org/wiki/SIMD)
- [üìä Metric Selection Guide](https://www.sbert.net/docs/usage/semantic_textual_similarity.html)

---

## ‚û°Ô∏è Section suivante

**18.10.5 [Optimisations SIMD (AVX2, AVX512, ARM, IBM Power10)](./10.5-optimisations-simd.md)** : Plongez dans les d√©tails des optimisations mat√©rielles pour calculs vectoriels, benchmarks par architecture et configuration avanc√©e. üÜï

‚è≠Ô∏è [Fonctions de conversion (VEC_FromText, VEC_ToText)](/18-fonctionnalites-avancees/10.4-fonctions-conversion.md)
