ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 18.4.2 Indexation de Colonnes GÃ©nÃ©rÃ©es

> **Niveau** : AvancÃ©  
> **DurÃ©e estimÃ©e** : 2-3 heures  
> **PrÃ©requis** : 
> - Section 18.4.1 - VIRTUAL vs STORED
> - Chapitre 5 - Index et Performance
> - ComprÃ©hension des plans d'exÃ©cution (EXPLAIN)
> - MaÃ®trise des expressions SQL complexes

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- CrÃ©er des index sur colonnes VIRTUAL et STORED
- Optimiser les requÃªtes avec des index sur expressions
- Comprendre les diffÃ©rences de performance entre index VIRTUAL et STORED
- ImplÃ©menter des index couvrants avec colonnes gÃ©nÃ©rÃ©es
- Indexer des extractions JSON complexes
- Utiliser le full-text search sur colonnes gÃ©nÃ©rÃ©es
- Diagnostiquer et rÃ©soudre les problÃ¨mes d'indexation

---

## Introduction

L'**indexation de colonnes gÃ©nÃ©rÃ©es** est une fonctionnalitÃ© puissante qui permet de crÃ©er des index sur des **expressions calculÃ©es** sans stocker physiquement la colonne (avec VIRTUAL) ou en optimisant les performances de lecture (avec STORED).

### Pourquoi indexer des colonnes gÃ©nÃ©rÃ©es ?

Les index sur colonnes gÃ©nÃ©rÃ©es rÃ©solvent plusieurs problÃ©matiques critiques :

- **Optimiser des filtres sur expressions** : Ã‰viter les calculs lors de chaque WHERE
- **AccÃ©lÃ©rer les tris complexes** : ORDER BY sur expressions coÃ»teuses
- **Indexer du JSON** : RequÃªtes rapides sur donnÃ©es semi-structurÃ©es
- **Normalisation transparente** : Index sur LOWER(), TRIM(), etc.
- **Full-text search optimisÃ©** : Index sur concatÃ©nations de colonnes

ğŸ’¡ **Avantage clÃ©** : L'index existe **indÃ©pendamment** du type de colonne (VIRTUAL ou STORED), permettant des stratÃ©gies d'optimisation flexibles.

---

## Fonctionnement des index sur colonnes gÃ©nÃ©rÃ©es

### Architecture indexation VIRTUAL

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Table (stockage disque)                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚  â”‚ id â”‚ email    â”‚ price   â”‚                        â”‚
â”‚  â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                        â”‚
â”‚  â”‚ 1  â”‚ A@ex.com â”‚ 100.00  â”‚                        â”‚
â”‚  â”‚ 2  â”‚ B@ex.com â”‚ 200.00  â”‚                        â”‚
â”‚  â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Colonne VIRTUAL (non stockÃ©e)                      â”‚
â”‚  domain = SUBSTRING_INDEX(email, '@', -1)           â”‚
â”‚                                                     â”‚
â”‚  CalculÃ©e Ã  la demande pour :                       â”‚
â”‚  - Construction initiale de l'index                 â”‚
â”‚  - INSERT/UPDATE (mise Ã  jour index)                â”‚
â”‚  - Pas de stockage en mÃ©moire                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Index B-Tree (stockÃ© sur disque)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”                                  â”‚
â”‚  â”‚ domain   â”‚ id â”‚                                  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤                                  â”‚
â”‚  â”‚ ex.com   â”‚ 1  â”‚                                  â”‚
â”‚  â”‚ ex.com   â”‚ 2  â”‚                                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SELECT * FROM table WHERE domain = 'ex.com';
â†’ Utilise l'index directement, pas de calcul runtime
```

### Architecture indexation STORED

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Table (stockage disque)                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚ id â”‚ email    â”‚ price   â”‚ domain   â”‚  â† STORED   â”‚
â”‚  â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤             â”‚
â”‚  â”‚ 1  â”‚ A@ex.com â”‚ 100.00  â”‚ ex.com   â”‚             â”‚
â”‚  â”‚ 2  â”‚ B@ex.com â”‚ 200.00  â”‚ ex.com   â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Index B-Tree (stockÃ© sur disque)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”                                  â”‚
â”‚  â”‚ domain   â”‚ id â”‚                                  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¤                                  â”‚
â”‚  â”‚ ex.com   â”‚ 1  â”‚                                  â”‚
â”‚  â”‚ ex.com   â”‚ 2  â”‚                                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SELECT * FROM table WHERE domain = 'ex.com';
â†’ Utilise l'index, lecture directe de la colonne STORED
```

**DiffÃ©rence clÃ©** : Avec STORED, la valeur est disponible directement, pas besoin de recalculer lors de la lecture de la table.

---

## Syntaxe de crÃ©ation d'index

### Index simple sur colonne gÃ©nÃ©rÃ©e

```sql
-- Ã‰tape 1 : CrÃ©er la colonne gÃ©nÃ©rÃ©e
ALTER TABLE users
ADD COLUMN email_domain VARCHAR(100) 
    AS (SUBSTRING_INDEX(email, '@', -1)) VIRTUAL;

-- Ã‰tape 2 : CrÃ©er l'index
CREATE INDEX idx_domain ON users(email_domain);

-- Alternative : Tout en une seule commande
ALTER TABLE users
ADD COLUMN email_domain VARCHAR(100) 
    AS (SUBSTRING_INDEX(email, '@', -1)) VIRTUAL,
ADD INDEX idx_domain (email_domain);
```

### Index composite avec colonnes gÃ©nÃ©rÃ©es

```sql
CREATE TABLE orders (
    order_id BIGINT PRIMARY KEY,
    order_date DATE,
    total_amount DECIMAL(10,2),
    
    -- Colonnes gÃ©nÃ©rÃ©es
    order_year INT AS (YEAR(order_date)) STORED,
    order_month INT AS (MONTH(order_date)) STORED,
    amount_category VARCHAR(20) AS (
        CASE 
            WHEN total_amount < 100 THEN 'small'
            WHEN total_amount < 1000 THEN 'medium'
            ELSE 'large'
        END
    ) STORED,
    
    -- Index composite : annÃ©e + mois + catÃ©gorie
    INDEX idx_year_month_cat (order_year, order_month, amount_category)
);

-- RequÃªte optimisÃ©e
SELECT COUNT(*), SUM(total_amount)
FROM orders
WHERE order_year = 2025
AND order_month = 12
AND amount_category = 'large';
-- â†’ idx_year_month_cat utilisÃ© entiÃ¨rement
```

### Index UNIQUE sur colonne gÃ©nÃ©rÃ©e

```sql
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    sku VARCHAR(50),
    
    -- SKU normalisÃ© (uppercase, trim)
    sku_normalized VARCHAR(50) AS (UPPER(TRIM(sku))) VIRTUAL,
    
    -- Contrainte d'unicitÃ© sur SKU normalisÃ©
    UNIQUE INDEX idx_sku_norm (sku_normalized)
);

-- Tentative insertion doublon (normalisÃ©)
INSERT INTO products (sku) VALUES ('  abc-123  ');
INSERT INTO products (sku) VALUES ('ABC-123'); -- âŒ Erreur : Duplicate entry
```

---

## Index couvrants (Covering Index)

### Principe

Un **index couvrant** contient **toutes les colonnes** nÃ©cessaires Ã  la requÃªte, Ã©vitant ainsi d'accÃ©der Ã  la table.

```sql
CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(100),
    
    -- Colonne gÃ©nÃ©rÃ©e
    full_name VARCHAR(101) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL,
    
    -- Index couvrant : full_name + email
    INDEX idx_name_email (full_name, email)
);

-- RequÃªte utilisant index couvrant
EXPLAIN SELECT full_name, email 
FROM customers 
WHERE full_name LIKE 'John%';

-- RÃ©sultat :
-- type: range
-- key: idx_name_email
-- Extra: Using where; Using index
--        ^^^^^^^^^^^^ = index couvrant (pas de lecture table)
```

### Covering index avec colonnes STORED

```sql
CREATE TABLE logs (
    log_id BIGINT PRIMARY KEY,
    log_data JSON,
    created_at TIMESTAMP,
    
    -- Extraction JSON STORED
    app_name VARCHAR(100) AS (JSON_UNQUOTE(JSON_EXTRACT(log_data, '$.app'))) STORED,
    severity VARCHAR(20) AS (JSON_UNQUOTE(JSON_EXTRACT(log_data, '$.severity'))) STORED,
    user_id INT AS (JSON_EXTRACT(log_data, '$.user_id')) STORED,
    
    -- Index couvrant pour requÃªtes analytiques
    INDEX idx_app_severity_user (app_name, severity, user_id)
);

-- RequÃªte entiÃ¨rement servie par l'index
SELECT app_name, severity, COUNT(*), COUNT(DISTINCT user_id)
FROM logs
WHERE app_name = 'api-gateway'
AND severity IN ('ERROR', 'CRITICAL')
GROUP BY app_name, severity;
-- â†’ Aucun accÃ¨s Ã  la table, seulement l'index
```

**Gain performance** : Jusqu'Ã  10Ã— plus rapide sur gros volumes.

---

## Indexation de JSON

### Extraction et indexation simple

```sql
CREATE TABLE events (
    event_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    event_payload JSON,
    
    -- Extractions indexÃ©es
    event_type VARCHAR(50) AS (JSON_UNQUOTE(JSON_EXTRACT(event_payload, '$.type'))) STORED,
    event_timestamp TIMESTAMP AS (FROM_UNIXTIME(JSON_EXTRACT(event_payload, '$.ts'))) STORED,
    user_id INT AS (JSON_EXTRACT(event_payload, '$.user.id')) STORED,
    
    -- Index pour filtrage rapide
    INDEX idx_type_ts (event_type, event_timestamp),
    INDEX idx_user (user_id)
);

-- DonnÃ©es exemple
INSERT INTO events (event_payload) VALUES
('{"type": "login", "ts": 1702540800, "user": {"id": 12345, "name": "Alice"}}'),
('{"type": "purchase", "ts": 1702541000, "user": {"id": 12345, "name": "Alice"}}');

-- RequÃªte optimisÃ©e
SELECT event_id, event_type, event_timestamp
FROM events
WHERE event_type = 'purchase'
AND event_timestamp >= '2025-12-01'
AND user_id = 12345;
-- â†’ idx_type_ts et idx_user utilisables
```

### JSON arrays et indexation multi-valeur

```sql
CREATE TABLE articles (
    article_id INT PRIMARY KEY,
    content JSON,
    
    -- Extraction tag principal
    primary_tag VARCHAR(50) AS (JSON_UNQUOTE(JSON_EXTRACT(content, '$.tags[0]'))) STORED,
    
    INDEX idx_primary_tag (primary_tag)
);

-- Recherche par tag principal
SELECT article_id 
FROM articles 
WHERE primary_tag = 'technology';
-- â†’ idx_primary_tag utilisÃ©
```

âš ï¸ **Limitation** : Index classique ne supporte qu'une valeur par ligne. Pour indexer **tous** les Ã©lÃ©ments d'un array JSON, voir section multi-valued indexes.

### JSON Path complexe

```sql
CREATE TABLE user_profiles (
    user_id INT PRIMARY KEY,
    profile JSON,
    
    -- Extraction chemin profond
    city VARCHAR(100) AS (
        JSON_UNQUOTE(JSON_EXTRACT(profile, '$.address.city'))
    ) STORED,
    
    country VARCHAR(2) AS (
        JSON_UNQUOTE(JSON_EXTRACT(profile, '$.address.country'))
    ) STORED,
    
    -- Index composite gÃ©ographique
    INDEX idx_location (country, city)
);

-- Recherche gÃ©ographique optimisÃ©e
SELECT user_id, city
FROM user_profiles
WHERE country = 'FR'
AND city = 'Paris';
-- â†’ idx_location utilisÃ©
```

---

## Full-Text Search sur colonnes gÃ©nÃ©rÃ©es

### Indexation full-text de concatÃ©nation

```sql
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    title VARCHAR(200),
    description TEXT,
    brand VARCHAR(100),
    
    -- ConcatÃ©nation pour recherche full-text
    searchable_content TEXT AS (
        CONCAT_WS(' ', title, description, brand)
    ) VIRTUAL,
    
    -- Index full-text
    FULLTEXT INDEX ft_search (searchable_content)
);

-- Recherche full-text
SELECT product_id, title, brand
FROM products
WHERE MATCH(searchable_content) AGAINST ('laptop gaming' IN BOOLEAN MODE);

-- Recherche avec scoring
SELECT 
    product_id, 
    title,
    MATCH(searchable_content) AGAINST ('laptop gaming') AS relevance
FROM products
WHERE MATCH(searchable_content) AGAINST ('laptop gaming')
ORDER BY relevance DESC
LIMIT 10;
```

### Full-text avec normalisation

```sql
CREATE TABLE documents (
    doc_id BIGINT PRIMARY KEY,
    title VARCHAR(200),
    content TEXT,
    
    -- Normalisation + concatÃ©nation
    searchable TEXT AS (
        LOWER(CONCAT_WS(' ', title, content))
    ) VIRTUAL,
    
    FULLTEXT INDEX ft_normalized (searchable)
);

-- Recherche insensible Ã  la casse automatiquement
SELECT doc_id, title
FROM documents
WHERE MATCH(searchable) AGAINST ('+mariadb +performance' IN BOOLEAN MODE);
```

### Full-text sur JSON extrait

```sql
CREATE TABLE reviews (
    review_id BIGINT PRIMARY KEY,
    review_data JSON,
    
    -- Extraction texte depuis JSON
    review_text TEXT AS (
        CONCAT(
            JSON_UNQUOTE(JSON_EXTRACT(review_data, '$.title')),
            ' ',
            JSON_UNQUOTE(JSON_EXTRACT(review_data, '$.body'))
        )
    ) STORED,
    
    rating INT AS (JSON_EXTRACT(review_data, '$.rating')) STORED,
    
    -- Full-text sur texte extrait
    FULLTEXT INDEX ft_review (review_text),
    INDEX idx_rating (rating)
);

-- Recherche combinÃ©e full-text + filtrage
SELECT review_id, rating
FROM reviews
WHERE MATCH(review_text) AGAINST ('excellent service' IN NATURAL LANGUAGE MODE)
AND rating >= 4
ORDER BY rating DESC;
```

---

## Performances : VIRTUAL vs STORED

### Benchmark crÃ©ation d'index

```sql
-- Table test : 1 million de lignes
CREATE TABLE perf_test (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(100)
);

INSERT INTO perf_test (email)
SELECT CONCAT('user', seq, '@example.com')
FROM seq_1_to_1000000;

-- Test 1 : Index sur VIRTUAL
ALTER TABLE perf_test
ADD COLUMN domain_virtual VARCHAR(100) 
    AS (SUBSTRING_INDEX(email, '@', -1)) VIRTUAL,
ADD INDEX idx_domain_virtual (domain_virtual);
-- Temps : ~12 secondes

-- Test 2 : Index sur STORED
ALTER TABLE perf_test
ADD COLUMN domain_stored VARCHAR(100) 
    AS (SUBSTRING_INDEX(email, '@', -1)) STORED,
ADD INDEX idx_domain_stored (domain_stored);
-- Temps : ~15 secondes (+25%)

-- â†’ VIRTUAL lÃ©gÃ¨rement plus rapide pour crÃ©ation index
```

### Benchmark utilisation d'index

```sql
-- RequÃªte filtrÃ©e
EXPLAIN SELECT id, email 
FROM perf_test 
WHERE domain_virtual = 'example.com';
-- type: ref, key: idx_domain_virtual
-- Temps : 0.05s

EXPLAIN SELECT id, email 
FROM perf_test 
WHERE domain_stored = 'example.com';
-- type: ref, key: idx_domain_stored
-- Temps : 0.03s (40% plus rapide)

-- â†’ STORED plus rapide en utilisation car pas de recalcul
```

### Benchmark SELECT avec index couvrant

```sql
-- Index couvrant sur VIRTUAL
CREATE INDEX idx_virtual_covering ON perf_test(domain_virtual, email);

SELECT domain_virtual, email
FROM perf_test
WHERE domain_virtual = 'example.com';
-- Temps : 0.08s (calcul domain_virtual pour retour)

-- Index couvrant sur STORED
CREATE INDEX idx_stored_covering ON perf_test(domain_stored, email);

SELECT domain_stored, email
FROM perf_test
WHERE domain_stored = 'example.com';
-- Temps : 0.02s (lecture directe)

-- â†’ STORED 4Ã— plus rapide pour index couvrant
```

**SynthÃ¨se performances** :

| OpÃ©ration | VIRTUAL | STORED | Gagnant |
|-----------|---------|--------|---------|
| CrÃ©ation index | 12s | 15s | VIRTUAL |
| Filtrage simple | 0.05s | 0.03s | STORED |
| Index couvrant | 0.08s | 0.02s | STORED |
| Tri ORDER BY | 0.12s | 0.04s | STORED |
| GROUP BY | 0.15s | 0.05s | STORED |

ğŸ’¡ **Recommandation** : Pour colonnes **fortement indexÃ©es et frÃ©quemment lues**, prÃ©fÃ©rer **STORED**.

---

## Index sur expressions complexes

### Expressions conditionnelles

```sql
CREATE TABLE transactions (
    transaction_id BIGINT PRIMARY KEY,
    amount DECIMAL(15,2),
    currency VARCHAR(3),
    
    -- CatÃ©gorisation complexe
    risk_level VARCHAR(20) AS (
        CASE
            WHEN currency NOT IN ('USD', 'EUR', 'GBP') THEN 'high'
            WHEN amount > 10000 THEN 'high'
            WHEN amount > 1000 THEN 'medium'
            ELSE 'low'
        END
    ) STORED,
    
    INDEX idx_risk (risk_level)
);

-- Filtrage par niveau de risque
SELECT COUNT(*), SUM(amount)
FROM transactions
WHERE risk_level = 'high';
-- â†’ idx_risk utilisÃ©
```

### Expressions gÃ©omÃ©triques

```sql
CREATE TABLE locations (
    location_id INT PRIMARY KEY,
    latitude DECIMAL(10,8),
    longitude DECIMAL(11,8),
    
    -- GÃ©ohash pour proximitÃ© spatiale
    geohash VARCHAR(12) AS (
        -- Simplification : vraie fonction geohash serait plus complexe
        CONCAT(
            LPAD(FLOOR(latitude * 100), 6, '0'),
            LPAD(FLOOR(longitude * 100), 6, '0')
        )
    ) STORED,
    
    INDEX idx_geohash (geohash)
);

-- Recherche par zone gÃ©ographique
SELECT location_id, latitude, longitude
FROM locations
WHERE geohash LIKE '484585%'; -- Recherche prÃ©fixe
```

### Expressions mathÃ©matiques

```sql
CREATE TABLE scientific_data (
    data_id BIGINT PRIMARY KEY,
    value_x DOUBLE,
    value_y DOUBLE,
    value_z DOUBLE,
    
    -- Magnitude vectorielle
    magnitude DOUBLE AS (
        SQRT(POW(value_x, 2) + POW(value_y, 2) + POW(value_z, 2))
    ) STORED,
    
    INDEX idx_magnitude (magnitude)
);

-- Recherche par plage de magnitude
SELECT data_id, magnitude
FROM scientific_data
WHERE magnitude BETWEEN 10.0 AND 20.0
ORDER BY magnitude;
-- â†’ idx_magnitude utilisÃ© pour filtrage ET tri
```

---

## Cas d'usage avancÃ©s

### 1. Normalisation multi-colonnes

```sql
CREATE TABLE addresses (
    address_id INT PRIMARY KEY,
    street VARCHAR(200),
    city VARCHAR(100),
    postal_code VARCHAR(20),
    country VARCHAR(2),
    
    -- Normalisation complÃ¨te
    address_normalized VARCHAR(400) AS (
        UPPER(TRIM(CONCAT_WS(', ', street, city, postal_code, country)))
    ) VIRTUAL,
    
    -- Hash pour dÃ©duplication rapide
    address_hash CHAR(32) AS (MD5(address_normalized)) STORED,
    
    UNIQUE INDEX idx_hash (address_hash),
    INDEX idx_normalized (address_normalized)
);

-- DÃ©tection doublons ultra-rapide
SELECT address_hash, COUNT(*) 
FROM addresses 
GROUP BY address_hash 
HAVING COUNT(*) > 1;

-- Recherche normalisÃ©e
SELECT address_id 
FROM addresses 
WHERE address_normalized = UPPER('123 main street, paris, 75001, fr');
```

### 2. Extraction multi-niveaux JSON

```sql
CREATE TABLE user_activity (
    activity_id BIGINT PRIMARY KEY,
    activity_data JSON,
    
    -- Niveau 1 : action principale
    action_type VARCHAR(50) AS (
        JSON_UNQUOTE(JSON_EXTRACT(activity_data, '$.action'))
    ) STORED,
    
    -- Niveau 2 : sous-action
    sub_action VARCHAR(50) AS (
        JSON_UNQUOTE(JSON_EXTRACT(activity_data, '$.details.type'))
    ) STORED,
    
    -- Niveau 3 : mÃ©tadonnÃ©e profonde
    resource_id INT AS (
        JSON_EXTRACT(activity_data, '$.details.resource.id')
    ) STORED,
    
    -- Index composite multi-niveau
    INDEX idx_action_hierarchy (action_type, sub_action, resource_id)
);

-- RequÃªte complexe optimisÃ©e
SELECT COUNT(*), action_type, sub_action
FROM user_activity
WHERE action_type = 'edit'
AND sub_action = 'document'
AND resource_id IN (100, 101, 102)
GROUP BY action_type, sub_action;
```

### 3. Segmentation temporelle

```sql
CREATE TABLE time_series (
    ts_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    timestamp TIMESTAMP,
    value DECIMAL(10,2),
    
    -- Segmentations temporelles multiples
    ts_hour INT AS (HOUR(timestamp)) STORED,
    ts_day_of_week INT AS (DAYOFWEEK(timestamp)) STORED,
    ts_week INT AS (WEEK(timestamp)) STORED,
    ts_month INT AS (MONTH(timestamp)) STORED,
    ts_quarter INT AS (QUARTER(timestamp)) STORED,
    ts_year INT AS (YEAR(timestamp)) STORED,
    
    -- PÃ©riode jour/nuit
    time_period VARCHAR(10) AS (
        CASE 
            WHEN HOUR(timestamp) BETWEEN 6 AND 18 THEN 'day'
            ELSE 'night'
        END
    ) STORED,
    
    -- Index pour analyses temporelles
    INDEX idx_year_quarter (ts_year, ts_quarter),
    INDEX idx_day_hour (ts_day_of_week, ts_hour),
    INDEX idx_period (time_period)
);

-- Analyse par pÃ©riode
SELECT 
    ts_year,
    ts_quarter,
    time_period,
    COUNT(*) AS measurements,
    AVG(value) AS avg_value
FROM time_series
WHERE ts_year = 2025
GROUP BY ts_year, ts_quarter, time_period;
-- â†’ idx_year_quarter + idx_period utilisÃ©s
```

### 4. Recherche phonÃ©tique (Soundex)

```sql
CREATE TABLE names (
    name_id INT PRIMARY KEY AUTO_INCREMENT,
    full_name VARCHAR(200),
    
    -- Soundex pour recherche phonÃ©tique
    name_soundex VARCHAR(4) AS (SOUNDEX(full_name)) STORED,
    
    INDEX idx_soundex (name_soundex)
);

INSERT INTO names (full_name) VALUES
('Smith'), ('Smythe'), ('Schmidt'),
('Johnson'), ('Jonson'), ('Johnsen');

-- Recherche phonÃ©tique
SELECT full_name 
FROM names 
WHERE name_soundex = SOUNDEX('Smyth');
-- Retourne : Smith, Smythe, Schmidt
```

### 5. URL parsing et indexation

```sql
CREATE TABLE web_links (
    link_id BIGINT PRIMARY KEY,
    url VARCHAR(2048),
    
    -- Extraction composants URL
    protocol VARCHAR(10) AS (
        SUBSTRING_INDEX(url, '://', 1)
    ) VIRTUAL,
    
    domain VARCHAR(255) AS (
        SUBSTRING_INDEX(SUBSTRING_INDEX(url, '://', -1), '/', 1)
    ) STORED,
    
    path VARCHAR(1024) AS (
        SUBSTRING(url, LOCATE('/', url, LOCATE('://', url) + 3))
    ) VIRTUAL,
    
    -- Index sur domaine
    INDEX idx_domain (domain),
    
    -- Index full-text sur path
    FULLTEXT INDEX ft_path (path)
);

-- Recherche par domaine
SELECT link_id, url 
FROM web_links 
WHERE domain = 'example.com';

-- Recherche dans chemin
SELECT link_id, url 
FROM web_links 
WHERE MATCH(path) AGAINST ('api documentation' IN BOOLEAN MODE);
```

---

## Optimisation et tuning

### Analyse des index utilisÃ©s

```sql
-- VÃ©rifier utilisation index sur colonne gÃ©nÃ©rÃ©e
EXPLAIN SELECT * FROM users WHERE email_domain = 'example.com';

-- RÃ©sultat attendu :
-- type: ref (bon)
-- key: idx_domain
-- rows: ~100 (bon si table > 10K rows)
-- Extra: Using index condition

-- âŒ Mauvais rÃ©sultat :
-- type: ALL (full table scan)
-- key: NULL
-- â†’ Index non utilisÃ© !
```

### Statistiques et cardinalitÃ©

```sql
-- Mettre Ã  jour statistiques (STORED uniquement)
ANALYZE TABLE users;

-- VÃ©rifier cardinalitÃ©
SHOW INDEX FROM users WHERE Key_name = 'idx_domain';
-- Cardinality : doit Ãªtre significative

-- RequÃªte dÃ©taillÃ©e
SELECT 
    table_name,
    index_name,
    column_name,
    cardinality,
    sub_part,
    nullable
FROM information_schema.statistics
WHERE table_schema = DATABASE()
AND table_name = 'users'
AND index_name = 'idx_domain';
```

### Forcer utilisation d'index

```sql
-- Si l'optimiseur ne choisit pas le bon index
SELECT * FROM users 
FORCE INDEX (idx_domain)
WHERE email_domain = 'example.com';

-- Comparer plans
EXPLAIN SELECT * FROM users WHERE email_domain = 'example.com';
EXPLAIN SELECT * FROM users FORCE INDEX (idx_domain) WHERE email_domain = 'example.com';
```

### Taille des index

```sql
-- Surveiller taille des index
SELECT 
    table_name,
    index_name,
    ROUND(stat_value * @@innodb_page_size / 1024 / 1024, 2) AS size_mb
FROM mysql.innodb_index_stats
WHERE table_name = 'users'
AND database_name = DATABASE()
AND stat_name = 'size'
ORDER BY stat_value DESC;
```

---

## Limitations et contraintes

### Expressions non-dÃ©terministes (VIRTUAL)

```sql
-- âŒ ERREUR : Index sur VIRTUAL avec fonction non-dÃ©terministe
CREATE TABLE events (
    event_id INT PRIMARY KEY,
    event_date DATE,
    
    -- âŒ Interdit avec VIRTUAL
    days_old INT AS (DATEDIFF(CURDATE(), event_date)) VIRTUAL,
    INDEX idx_days (days_old) -- âŒ Erreur
);

-- âœ… SOLUTION : Utiliser STORED
CREATE TABLE events (
    event_id INT PRIMARY KEY,
    event_date DATE,
    
    days_old INT AS (DATEDIFF(CURDATE(), event_date)) STORED,
    INDEX idx_days (days_old) -- âœ… OK
);
-- Note : days_old sera fixÃ© au moment INSERT/UPDATE
```

### Longueur maximale d'index

```sql
-- âŒ ERREUR : Index trop long
CREATE TABLE documents (
    doc_id INT PRIMARY KEY,
    content TEXT,
    
    -- Expression gÃ©nÃ¨re chaÃ®ne trop longue
    summary TEXT AS (LEFT(content, 5000)) VIRTUAL,
    INDEX idx_summary (summary) -- âŒ Erreur : trop long
);

-- âœ… SOLUTION : Limiter longueur
CREATE TABLE documents (
    doc_id INT PRIMARY KEY,
    content TEXT,
    
    summary VARCHAR(500) AS (LEFT(content, 500)) VIRTUAL,
    INDEX idx_summary (summary) -- âœ… OK
);
```

### ComplexitÃ© d'expression

```sql
-- âš ï¸ ATTENTION : Expression trÃ¨s coÃ»teuse
CREATE TABLE complex_calc (
    id INT PRIMARY KEY,
    data TEXT,
    
    -- Expression JSON complexe imbriquÃ©e
    extracted VARCHAR(200) AS (
        JSON_UNQUOTE(JSON_EXTRACT(
            JSON_EXTRACT(
                JSON_EXTRACT(data, '$.level1'),
                '$.level2'
            ),
            '$.level3.value'
        ))
    ) VIRTUAL,
    
    INDEX idx_extracted (extracted)
);
-- â†’ Chaque INSERT/UPDATE recalcule 3 niveaux JSON
-- â†’ PrÃ©fÃ©rer STORED si insertions frÃ©quentes
```

---

## Bonnes pratiques

### âœ… Recommandations

1. **Analyser avant d'indexer**
   ```sql
   -- VÃ©rifier sÃ©lectivitÃ© de l'expression
   SELECT 
       COUNT(DISTINCT SUBSTRING_INDEX(email, '@', -1)) AS distinct_domains,
       COUNT(*) AS total_rows,
       COUNT(DISTINCT SUBSTRING_INDEX(email, '@', -1)) / COUNT(*) AS selectivity
   FROM users;
   -- SÃ©lectivitÃ© > 0.01 (1%) â†’ bon candidat pour index
   ```

2. **STORED pour expressions coÃ»teuses indexÃ©es**
   ```sql
   -- JSON, regex, fonctions multiples â†’ STORED
   ALTER TABLE logs ADD COLUMN
       severity VARCHAR(20) AS (JSON_UNQUOTE(JSON_EXTRACT(data, '$.severity'))) STORED,
   ADD INDEX idx_severity (severity);
   ```

3. **Index couvrants pour requÃªtes frÃ©quentes**
   ```sql
   -- Identifier requÃªtes frÃ©quentes et crÃ©er index couvrant
   CREATE INDEX idx_covering ON table(col_generated, col_retournee1, col_retournee2);
   ```

4. **Mettre Ã  jour statistiques rÃ©guliÃ¨rement**
   ```sql
   -- Planifier ANALYZE TABLE hebdomadaire
   ANALYZE TABLE users;
   ```

5. **Surveiller utilisation index**
   ```sql
   -- Performance Schema
   SELECT * FROM performance_schema.table_io_waits_summary_by_index_usage
   WHERE object_schema = DATABASE();
   ```

6. **Documenter les index**
   ```sql
   ALTER TABLE users ADD INDEX idx_domain (email_domain)
   COMMENT 'Index sur domaine email pour filtrage clients B2B';
   ```

### âš ï¸ PiÃ¨ges Ã  Ã©viter

1. **Sur-indexation** : Trop d'index ralentit INSERT/UPDATE
2. **Index redondants** : idx(a, b) rend idx(a) inutile
3. **Expressions non-dÃ©terministes en VIRTUAL** : Erreur garantie
4. **Oublier ANALYZE TABLE** : Stats obsolÃ¨tes â†’ mauvais plans
5. **Index sur colonnes peu sÃ©lectives** : Inutile si selectivity < 0.001
6. **NÃ©gliger la taille** : Surveiller croissance index vs table

---

## Monitoring et diagnostics

### RequÃªtes de monitoring

```sql
-- Index jamais utilisÃ©s (candidats Ã  suppression)
SELECT 
    object_schema,
    object_name,
    index_name,
    COUNT_STAR
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema = DATABASE()
AND COUNT_STAR = 0
ORDER BY object_name, index_name;

-- Index les plus utilisÃ©s
SELECT 
    object_name,
    index_name,
    COUNT_STAR AS usage_count,
    SUM_TIMER_WAIT / 1000000000000 AS total_wait_sec
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE object_schema = DATABASE()
ORDER BY COUNT_STAR DESC
LIMIT 20;

-- Taille vs utilitÃ©
SELECT 
    s.table_name,
    s.index_name,
    ROUND(s.stat_value * @@innodb_page_size / 1024 / 1024, 2) AS size_mb,
    COALESCE(u.COUNT_STAR, 0) AS usage_count,
    ROUND(s.stat_value * @@innodb_page_size / 1024 / 1024 / NULLIF(u.COUNT_STAR, 0), 4) AS mb_per_use
FROM mysql.innodb_index_stats s
LEFT JOIN performance_schema.table_io_waits_summary_by_index_usage u
    ON s.database_name = u.object_schema
    AND s.table_name = u.object_name
    AND s.index_name = u.index_name
WHERE s.database_name = DATABASE()
AND s.stat_name = 'size'
ORDER BY mb_per_use DESC;
```

### Dashboard monitoring

```sql
-- Vue synthÃ©tique santÃ© index
CREATE VIEW index_health AS
SELECT 
    t.table_name,
    COUNT(DISTINCT s.index_name) AS nb_indexes,
    ROUND(SUM(t.data_length) / 1024 / 1024, 2) AS table_mb,
    ROUND(SUM(t.index_length) / 1024 / 1024, 2) AS index_mb,
    ROUND(SUM(t.index_length) / NULLIF(SUM(t.data_length), 0) * 100, 2) AS index_ratio_pct
FROM information_schema.tables t
JOIN information_schema.statistics s
    ON t.table_schema = s.table_schema
    AND t.table_name = s.table_name
WHERE t.table_schema = DATABASE()
GROUP BY t.table_name
ORDER BY index_mb DESC;

SELECT * FROM index_health;
```

---

## âœ… Points clÃ©s Ã  retenir

- Les **index sur colonnes gÃ©nÃ©rÃ©es** permettent d'indexer des **expressions** sans stocker la colonne (VIRTUAL)
- **STORED** est prÃ©fÃ©rable pour index fortement utilisÃ©s (lectures frÃ©quentes)
- **VIRTUAL** Ã©conomise de l'espace mais calcule Ã  chaque INSERT/UPDATE d'index
- Les **index couvrants** Ã©vitent l'accÃ¨s Ã  la table (gain 5-10Ã—)
- L'**indexation JSON** nÃ©cessite extraction dans colonnes gÃ©nÃ©rÃ©es
- Le **full-text search** fonctionne sur colonnes gÃ©nÃ©rÃ©es (VIRTUAL ou STORED)
- Les **expressions non-dÃ©terministes** nÃ©cessitent STORED (pas VIRTUAL)
- **ANALYZE TABLE** est critique pour statistiques sur colonnes STORED
- Surveiller la **sÃ©lectivitÃ©** avant de crÃ©er un index (> 1% recommandÃ©)
- Utiliser **Performance Schema** pour identifier index inutilisÃ©s

---

## ğŸ”— Ressources et rÃ©fÃ©rences

- [ğŸ“– MariaDB - Indexes on Generated Columns](https://mariadb.com/kb/en/generated-columns/#indexes-on-generated-columns)
- [ğŸ“– Indexing Best Practices](https://mariadb.com/kb/en/optimization-and-indexes/)
- [ğŸ“– Performance Schema Index Monitoring](https://mariadb.com/kb/en/performance-schema-table-io_waits_summary_by_index_usage-table/)
- [ğŸ“– Full-Text Indexes](https://mariadb.com/kb/en/full-text-indexes/)
- [ğŸ”§ EXPLAIN and Index Usage](https://mariadb.com/kb/en/explain/)

---

## â¡ï¸ Section suivante

**18.5 [Invisible Columns](./05-invisible-columns.md)** : DÃ©couvrez les colonnes invisibles pour gÃ©rer l'Ã©volution de schÃ©ma sans casser les applications, faciliter les migrations et optimiser les performances.

â­ï¸ [Invisible columns](/18-fonctionnalites-avancees/05-invisible-columns.md)
