üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.2.1 Cr√©ation et Configuration des System-Versioned Tables

> **Niveau** : Avanc√©  
> **Dur√©e estim√©e** : 2-3 heures  
> **Pr√©requis** : 
> - Ma√Ætrise de CREATE TABLE et ALTER TABLE
> - Compr√©hension des concepts de transactions et MVCC
> - Connaissance des contraintes et triggers

## üéØ Objectifs d'apprentissage

√Ä l'issue de cette section, vous serez capable de :
- Cr√©er des tables temporelles avec historisation automatique
- Configurer les colonnes de versionnement syst√®me
- Choisir la strat√©gie de stockage de l'historique appropri√©e
- G√©rer le cycle de vie des donn√©es historiques
- Impl√©menter des cas d'usage d'audit et de conformit√©

---

## Introduction

Les **System-Versioned Tables** (tables temporelles syst√®me) constituent une fonctionnalit√© puissante de MariaDB permettant l'**historisation automatique** de toutes les modifications apport√©es aux donn√©es. Contrairement aux approches manuelles avec triggers, cette fonctionnalit√© est native, performante et standardis√©e selon SQL:2011.

### Pourquoi utiliser les tables temporelles ?

Les System-Versioned Tables r√©pondent √† plusieurs besoins critiques en production :

- **Audit et conformit√©** : Tra√ßabilit√© compl√®te des modifications (RGPD, SOX, HIPAA)
- **Analyse temporelle** : Comprendre l'√©volution des donn√©es dans le temps
- **Restauration point-in-time** : R√©cup√©rer l'√©tat exact des donn√©es √† un instant T
- **D√©tection d'anomalies** : Identifier des modifications suspectes ou erron√©es
- **Reporting historique** : G√©n√©rer des rapports sur des donn√©es pass√©es

üí° **Avantage cl√©** : L'historisation est **transparente** pour les applications. Les requ√™tes INSERT, UPDATE, DELETE fonctionnent normalement, et l'historique est g√©r√© automatiquement par le moteur.

---

## Concept et fonctionnement

### Architecture de versionnement

Une table temporelle syst√®me se compose de :

1. **Table courante** : Contient les donn√©es actuelles (version la plus r√©cente)
2. **Table d'historique** : Stocke toutes les versions ant√©rieures
3. **Colonnes de p√©riode** : Deux colonnes timestamp d√©finissant la validit√© temporelle

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Table courante (t1)                ‚îÇ
‚îÇ  - Donn√©es actuelles uniquement     ‚îÇ
‚îÇ  - row_start, row_end (SYSTEM_TIME) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ
           ‚îÇ Modifications (UPDATE/DELETE)
           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Table d'historique (t1_history)    ‚îÇ
‚îÇ  - Toutes versions ant√©rieures      ‚îÇ
‚îÇ  - M√™me structure que table courante‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### M√©canisme de versionnement

Lors d'une modification :
1. **UPDATE** : L'ancienne version est d√©plac√©e vers l'historique, la nouvelle version reste dans la table courante
2. **DELETE** : La ligne est d√©plac√©e vers l'historique avec row_end = maintenant
3. **INSERT** : Nouvelle ligne cr√©√©e avec row_start = maintenant, row_end = max timestamp

---

## Syntaxe de cr√©ation

### Cr√©ation basique

```sql
-- Cr√©ation d'une table temporelle avec historisation automatique
CREATE TABLE employees (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    department VARCHAR(50),
    salary DECIMAL(10,2),
    -- Colonnes de versionnement syst√®me (automatiques)
    row_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    row_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(row_start, row_end)
) WITH SYSTEM VERSIONING;
```

**√âl√©ments cl√©s :**
- `row_start` : Timestamp de d√©but de validit√© (cr√©ation ou modification)
- `row_end` : Timestamp de fin de validit√© (modification ou suppression)
- `GENERATED ALWAYS AS ROW START/END` : Colonnes g√©r√©es automatiquement
- `PERIOD FOR SYSTEM_TIME` : D√©finit la p√©riode de validit√©
- `WITH SYSTEM VERSIONING` : Active le versionnement syst√®me

### Cr√©ation avec nom de colonnes personnalis√©s

```sql
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(200),
    price DECIMAL(10,2),
    stock INT DEFAULT 0,
    -- Noms personnalis√©s pour les colonnes temporelles
    valid_from TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    valid_to TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(valid_from, valid_to)
) WITH SYSTEM VERSIONING;
```

üí° **Conseil** : Utilisez des noms explicites (`valid_from`, `valid_to`) plut√¥t que `row_start`/`row_end` pour am√©liorer la lisibilit√© du code m√©tier.

### Pr√©cision temporelle

```sql
-- Utilisation de TIMESTAMP(6) pour pr√©cision microseconde
CREATE TABLE financial_transactions (
    transaction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    account_id INT NOT NULL,
    amount DECIMAL(15,2),
    transaction_type ENUM('debit', 'credit'),
    -- Pr√©cision microseconde (6 d√©cimales) pour audit financier
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end)
) WITH SYSTEM VERSIONING;
```

‚ö†Ô∏è **Important** : La pr√©cision `TIMESTAMP(6)` (microseconde) est **fortement recommand√©e** pour √©viter les conflits lors de modifications rapproch√©es.

---

## Configuration de la table d'historique

### Historique par d√©faut (table automatique)

Par d√©faut, MariaDB cr√©e automatiquement une table d'historique avec le suffixe `_history` :

```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT,
    order_date DATE,
    total DECIMAL(10,2),
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end)
) WITH SYSTEM VERSIONING;

-- MariaDB cr√©e automatiquement : orders_history
```

### Historique avec nom personnalis√©

```sql
CREATE TABLE contracts (
    contract_id INT PRIMARY KEY,
    client_name VARCHAR(100),
    start_date DATE,
    end_date DATE,
    value DECIMAL(12,2),
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end)
) WITH SYSTEM VERSIONING 
  HISTORY_TABLE = contract_audit_log;
```

### Historique dans une table existante

```sql
-- 1. Cr√©er la table d'historique manuellement
CREATE TABLE price_history (
    product_id INT,
    product_name VARCHAR(200),
    price DECIMAL(10,2),
    stock INT,
    valid_from TIMESTAMP(6),
    valid_to TIMESTAMP(6)
) ENGINE=InnoDB;

-- 2. Cr√©er la table courante en r√©f√©ren√ßant l'historique
CREATE TABLE prices (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(200),
    price DECIMAL(10,2),
    stock INT,
    valid_from TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    valid_to TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(valid_from, valid_to)
) WITH SYSTEM VERSIONING 
  HISTORY_TABLE = price_history;
```

üí° **Cas d'usage** : Utile pour migrer des donn√©es historiques existantes ou pour g√©rer l'historique dans une base de donn√©es s√©par√©e.

---

## Ajout du versionnement √† une table existante

### Migration d'une table standard

```sql
-- Table existante sans versionnement
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE,
    email VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Ajout du versionnement syst√®me
ALTER TABLE users ADD COLUMN
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
ADD COLUMN
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
ADD PERIOD FOR SYSTEM_TIME(sys_start, sys_end),
ADD SYSTEM VERSIONING;
```

**Comportement :**
- Les lignes existantes re√ßoivent `sys_start = maintenant` et `sys_end = 2038-01-19 03:14:07.999999`
- L'historique commence √† partir de l'activation du versionnement
- Aucune donn√©e historique n'est cr√©√©e pour les modifications pass√©es

### Migration avec pr√©servation de l'historique

```sql
-- 1. Cr√©er une nouvelle table avec versionnement
CREATE TABLE users_v2 (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE,
    email VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end)
) WITH SYSTEM VERSIONING;

-- 2. Migrer les donn√©es
INSERT INTO users_v2 (user_id, username, email, created_at)
SELECT user_id, username, email, created_at FROM users;

-- 3. Renommer (avec downtime)
RENAME TABLE users TO users_old, users_v2 TO users;
```

‚ö†Ô∏è **Attention** : Cette migration n√©cessite un **downtime** pour garantir la coh√©rence.

---

## Configuration avanc√©e

### Choix du moteur de stockage

```sql
-- Table courante en InnoDB (transactionnel)
-- Historique en Aria (optimis√© lecture, compression)
CREATE TABLE audit_logs (
    log_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    action VARCHAR(50),
    details TEXT,
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end)
) ENGINE=InnoDB
WITH SYSTEM VERSIONING 
HISTORY_ENGINE=Aria;
```

**Recommandations moteur historique :**
- **Aria** : Bon compromis performance/espace, crash-safe
- **MyISAM** : Lectures rapides mais non transactionnel (d√©conseill√©)
- **ColumnStore** : Pour analytics sur gros volumes historiques
- **Archive** : Compression maximale pour archivage long terme

### Partitionnement de l'historique

```sql
-- Table courante standard
CREATE TABLE sales (
    sale_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    product_id INT,
    quantity INT,
    sale_date DATE,
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end)
) ENGINE=InnoDB
WITH SYSTEM VERSIONING;

-- Partitionner l'historique par ann√©e
ALTER TABLE sales_history
PARTITION BY RANGE (YEAR(sys_end)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

üí° **Avantage** : Permet de purger facilement l'historique ancien en droppant des partitions.

### Compression de l'historique

```sql
-- Historique compress√© pour √©conomiser l'espace
CREATE TABLE documents (
    doc_id INT PRIMARY KEY,
    title VARCHAR(200),
    content TEXT,
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end)
) ENGINE=InnoDB
WITH SYSTEM VERSIONING;

-- Activer la compression sur la table d'historique
ALTER TABLE documents_history 
ROW_FORMAT=COMPRESSED 
KEY_BLOCK_SIZE=8;
```

---

## Gestion du cycle de vie de l'historique

### R√©tention et purge

```sql
-- Cr√©ation avec politique de r√©tention document√©e
CREATE TABLE user_sessions (
    session_id VARCHAR(64) PRIMARY KEY,
    user_id INT,
    ip_address VARCHAR(45),
    user_agent VARCHAR(255),
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end),
    -- Documentation de la politique de r√©tention
    INDEX idx_sys_end (sys_end)
) WITH SYSTEM VERSIONING;

-- Purge de l'historique > 90 jours (via event planifi√©)
CREATE EVENT purge_old_sessions
ON SCHEDULE EVERY 1 DAY
DO
DELETE FROM user_sessions_history
WHERE sys_end < DATE_SUB(NOW(), INTERVAL 90 DAY);
```

### Archivage dans une table froide

```sql
-- Event d'archivage mensuel
DELIMITER $$
CREATE EVENT archive_old_history
ON SCHEDULE EVERY 1 MONTH
DO
BEGIN
    -- Archiver donn√©es > 1 an dans table Archive engine
    INSERT INTO documents_archive
    SELECT * FROM documents_history
    WHERE sys_end < DATE_SUB(NOW(), INTERVAL 1 YEAR);
    
    -- Purger de l'historique actif
    DELETE FROM documents_history
    WHERE sys_end < DATE_SUB(NOW(), INTERVAL 1 YEAR);
END$$
DELIMITER ;
```

---

## Cas d'usage sp√©cialis√©s

### 1. Audit de conformit√© RGPD

```sql
-- Table avec tra√ßabilit√© compl√®te pour conformit√© RGPD
CREATE TABLE customer_consents (
    consent_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT NOT NULL,
    consent_type ENUM('marketing', 'analytics', 'third_party'),
    consent_given BOOLEAN,
    consent_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ip_address VARCHAR(45),
    -- Versionnement pour audit complet
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end),
    INDEX idx_customer (customer_id)
) WITH SYSTEM VERSIONING;

-- Requ√™te d'audit : "Quel consentement avait ce client le 15 mars 2024 ?"
SELECT * FROM customer_consents
FOR SYSTEM_TIME AS OF '2024-03-15 00:00:00'
WHERE customer_id = 12345;
```

### 2. D√©tection de fraude financi√®re

```sql
CREATE TABLE account_balances (
    account_id INT PRIMARY KEY,
    balance DECIMAL(15,2),
    currency CHAR(3) DEFAULT 'EUR',
    last_transaction_id BIGINT,
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end)
) WITH SYSTEM VERSIONING;

-- D√©tection d'anomalies : variations brutales de solde
SELECT 
    account_id,
    sys_start,
    balance,
    LAG(balance) OVER (PARTITION BY account_id ORDER BY sys_start) as previous_balance,
    balance - LAG(balance) OVER (PARTITION BY account_id ORDER BY sys_start) as variation
FROM account_balances_history
WHERE account_id = 98765
ORDER BY sys_start DESC;
```

### 3. Analyse de changements de prix

```sql
CREATE TABLE product_catalog (
    sku VARCHAR(50) PRIMARY KEY,
    product_name VARCHAR(200),
    category VARCHAR(100),
    price DECIMAL(10,2),
    cost DECIMAL(10,2),
    sys_start TIMESTAMP(6) GENERATED ALWAYS AS ROW START,
    sys_end TIMESTAMP(6) GENERATED ALWAYS AS ROW END,
    PERIOD FOR SYSTEM_TIME(sys_start, sys_end)
) WITH SYSTEM VERSIONING;

-- Analyse : combien de fois le prix a chang√© cette ann√©e ?
SELECT 
    sku,
    product_name,
    COUNT(*) as price_changes,
    MIN(price) as min_price,
    MAX(price) as max_price,
    AVG(price) as avg_price
FROM product_catalog_history
WHERE sys_start >= '2025-01-01'
GROUP BY sku, product_name
HAVING COUNT(*) > 5
ORDER BY price_changes DESC;
```

### 4. Restauration de donn√©es corrompues

```sql
-- Sc√©nario : erreur de batch qui a mis salary = 0 pour certains employ√©s

-- 1. Identifier les employ√©s affect√©s
SELECT DISTINCT id, name 
FROM employees 
WHERE salary = 0;

-- 2. Restaurer depuis l'historique (avant l'erreur)
UPDATE employees e
JOIN (
    SELECT id, salary
    FROM employees
    FOR SYSTEM_TIME AS OF '2025-12-10 14:30:00'
    WHERE salary > 0
) h ON e.id = h.id
SET e.salary = h.salary
WHERE e.salary = 0;
```

---

## Bonnes pratiques

### ‚úÖ Recommandations

1. **Pr√©cision temporelle** : Toujours utiliser `TIMESTAMP(6)` pour √©viter les collisions
2. **Indexation** : Indexer `sys_end` pour optimiser les purges
3. **Moteur historique** : Aria ou ColumnStore selon le volume
4. **Partitionnement** : Partitionner l'historique par p√©riode pour faciliter la maintenance
5. **Documentation** : Documenter la politique de r√©tention dans les commentaires de table
6. **Monitoring** : Surveiller la taille de l'historique (peut cro√Ætre rapidement)

### ‚ö†Ô∏è Pi√®ges √† √©viter

1. **Oubli de purge** : L'historique grossit ind√©finiment ‚Üí planifier des purges
2. **M√™me moteur partout** : InnoDB pour l'historique peut √™tre sous-optimal
3. **Absence d'index** : L'historique non index√© rend les requ√™tes temporelles lentes
4. **Colonnes row_start/end modifiables** : Toujours `GENERATED ALWAYS`
5. **Versionnement sur toutes les tables** : Co√ªt en espace ‚Üí n'historiser que le n√©cessaire

### üîç Performance

```sql
-- V√©rification de la taille de l'historique
SELECT 
    table_name,
    ROUND(data_length / 1024 / 1024, 2) AS data_mb,
    ROUND(index_length / 1024 / 1024, 2) AS index_mb,
    ROUND((data_length + index_length) / 1024 / 1024, 2) AS total_mb
FROM information_schema.tables
WHERE table_name LIKE '%_history'
ORDER BY (data_length + index_length) DESC;
```

---

## Configuration syst√®me

### Variables pertinentes

```sql
-- Dur√©e maximale de transaction avant timeout
SET SESSION max_statement_time = 300; -- 5 minutes

-- Pour requ√™tes temporelles complexes
SET SESSION query_cache_type = OFF; -- Query cache incompatible
```

### Limites et contraintes

- **Limites de TIMESTAMP** : 1970-2038 (standard), 2106 avec extension MariaDB 11.8 üÜï
- **Performance** : Overhead ~5-10% sur UPDATE/DELETE
- **Espace disque** : L'historique peut repr√©senter 3-10√ó la table courante
- **Triggers** : Compatibles mais attention aux interactions

üÜï **MariaDB 11.8** : L'extension TIMESTAMP jusqu'en 2106 r√©sout le probl√®me Y2038 pour les System-Versioned Tables !

---

## ‚úÖ Points cl√©s √† retenir

- Les System-Versioned Tables offrent une **historisation automatique native** sans triggers
- La syntaxe standard SQL:2011 garantit la **portabilit√©**
- Les colonnes `GENERATED ALWAYS AS ROW START/END` sont g√©r√©es **transparentement**
- Le choix du **moteur d'historique** (Aria, ColumnStore) impacte performance et co√ªt
- Le **partitionnement** de l'historique facilite la maintenance et les purges
- La **pr√©cision TIMESTAMP(6)** est essentielle pour √©viter les conflits
- Une **politique de r√©tention** document√©e et automatis√©e est obligatoire en production
- L'historique peut cro√Ætre rapidement : **monitoring et purges r√©guli√®res** indispensables

---

## üîó Ressources et r√©f√©rences

- [üìñ Documentation MariaDB - System-Versioned Tables](https://mariadb.com/kb/en/system-versioned-tables/)
- [üìñ SQL:2011 Temporal Tables Specification](https://www.iso.org/standard/53681.html)
- [üìñ Temporal Data Management](https://mariadb.com/kb/en/temporal-data-tables/)
- [üîß ALTER TABLE ADD SYSTEM VERSIONING](https://mariadb.com/kb/en/alter-table/#add-system-versioning)
- [üÜï MariaDB 11.8 - TIMESTAMP Extension 2106](https://mariadb.com/kb/en/timestamp-data-type/)

---

## ‚û°Ô∏è Section suivante

**18.2.2 [Requ√™tes temporelles (AS OF, BETWEEN, FROM...TO)](./02.2-requetes-temporelles.md)** : D√©couvrez comment interroger l'historique avec les clauses temporelles SQL:2011, effectuer des analyses point-in-time et comparer des √©tats √† diff√©rentes p√©riodes.

‚è≠Ô∏è [Requ√™tes temporelles (AS OF, BETWEEN, FROM...TO)](/18-fonctionnalites-avancees/02.2-requetes-temporelles.md)
