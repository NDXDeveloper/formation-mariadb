ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 18.10.5 Optimisations SIMD pour Calculs Vectoriels

> **Niveau** : Expert  
> **DurÃ©e estimÃ©e** : 2-3 heures  
> **PrÃ©requis** : 
> - Sections 18.10.1 Ã  18.10.4 - MariaDB Vector
> - ComprÃ©hension de l'architecture CPU
> - Notions d'optimisations bas niveau
> - ExpÃ©rience en administration systÃ¨me

## ğŸ¯ Objectifs d'apprentissage

Ã€ l'issue de cette section, vous serez capable de :
- Comprendre le principe des instructions SIMD
- Identifier le support SIMD de votre matÃ©riel
- Activer et configurer les optimisations SIMD dans MariaDB
- Mesurer les gains de performance SIMD
- Choisir le bon hardware pour calculs vectoriels
- Benchmarker diffÃ©rentes architectures (x86, ARM, Power)
- Optimiser les dÃ©ploiements selon l'architecture
- Diagnostiquer les problÃ¨mes de performance SIMD

---

## Introduction

**SIMD** (Single Instruction Multiple Data) est une technique de parallÃ©lisation qui permet d'effectuer la **mÃªme opÃ©ration** sur **plusieurs donnÃ©es simultanÃ©ment** en une seule instruction CPU.

### Principe de fonctionnement

```
Sans SIMD (Scalaire) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Calcul : A[0] + B[0] = C[0]                     â”‚
â”‚ Cycle 1: Charger A[0], B[0] â†’ Additionner       â”‚
â”‚ Cycle 2: Charger A[1], B[1] â†’ Additionner       â”‚
â”‚ Cycle 3: Charger A[2], B[2] â†’ Additionner       â”‚
â”‚ Cycle 4: Charger A[3], B[3] â†’ Additionner       â”‚
â”‚                                                 â”‚
â”‚ Total : 4 cycles pour 4 additions               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Avec SIMD (AVX2 - 256 bits) :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Calcul vectorisÃ© :                                 â”‚
â”‚ [A[0], A[1], A[2], A[3]] + [B[0], B[1], B[2], B[3]]â”‚
â”‚                           â†“                        â”‚
â”‚        [C[0], C[1], C[2], C[3]]                    â”‚
â”‚                                                    â”‚
â”‚ Cycle 1: Une seule instruction traite 4 floats     â”‚
â”‚                                                    â”‚
â”‚ Total : 1 cycle pour 4 additions (4Ã— plus rapide)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Impact sur les vecteurs d'embeddings

Pour un vecteur de **1536 dimensions** :

```
Produit scalaire (A Â· B = Î£ aáµ¢ Ã— báµ¢) :

Sans SIMD :
- 1536 multiplications sÃ©quentielles
- 1536 additions sÃ©quentielles
- ~3000 cycles CPU

Avec AVX-512 (512 bits = 16 floats) :
- 1536 Ã· 16 = 96 multiplications vectorielles
- 96 additions vectorielles
- ~200 cycles CPU

â†’ Gain thÃ©orique : ~15Ã— plus rapide
â†’ Gain pratique : 4-8Ã— (avec overhead)
```

---

## Architectures et extensions SIMD

### x86_64 (Intel / AMD)

#### SSE (Streaming SIMD Extensions)

```
Largeur registre : 128 bits
Floats par registre : 4 (4 Ã— 32 bits)
GÃ©nÃ©rations :
- SSE (1999) : Pentium III
- SSE2 (2001) : Pentium 4
- SSE3 (2004), SSSE3 (2006), SSE4 (2007)

OpÃ©rations supportÃ©es :
- Addition, soustraction, multiplication
- Division (lente)
- Comparaisons
```

#### AVX (Advanced Vector Extensions)

```
Largeur registre : 256 bits
Floats par registre : 8 (8 Ã— 32 bits)
GÃ©nÃ©rations :
- AVX (2011) : Sandy Bridge
- AVX2 (2013) : Haswell
  * Instructions FMA (Fused Multiply-Add)
  * Gather/scatter

Support MariaDB :
âœ… AVX2 = Standard recommandÃ© (2013+)
âš ï¸ AVX1 = Support partiel
```

#### AVX-512

```
Largeur registre : 512 bits
Floats par registre : 16 (16 Ã— 32 bits)
GÃ©nÃ©rations :
- AVX-512F (Foundation) : Xeon Phi (2016)
- AVX-512 Skylake-SP (2017)
- AVX-512 Ice Lake (2019)
- AVX-512 Sapphire Rapids (2023)

Support MariaDB :
âœ… AVX-512 = Performance maximale x86
âš ï¸ NÃ©cessite CPU server rÃ©cent
âš ï¸ DÃ©sactivÃ© sur certains CPU consumer (throttling thermique)
```

### ARM

#### NEON

```
Largeur registre : 128 bits (ARMv7, ARMv8)
Floats par registre : 4 (4 Ã— 32 bits)
DisponibilitÃ© :
- ARMv7-A : Cortex-A8+ (2005+)
- ARMv8-A : Cortex-A53+ (2012+)
- Apple Silicon : M1, M2, M3, M4

Support MariaDB :
âœ… NEON = Standard ARM64
âœ… Apple Silicon optimisÃ©
```

#### SVE (Scalable Vector Extension)

```
Largeur registre : Variable (128-2048 bits)
Floats par registre : 4-64 selon implementation
DisponibilitÃ© :
- ARMv9 : Neoverse V1 (2021+)
- Fujitsu A64FX (2019)

Support MariaDB :
ğŸ”„ SVE = Support expÃ©rimental (11.9+)
```

### IBM Power

#### VSX (Vector Scalar Extension)

```
Largeur registre : 128 bits
Floats par registre : 4 (4 Ã— 32 bits)
DisponibilitÃ© :
- POWER7 (2010)
- POWER8 (2013)
- POWER9 (2017)
```

#### Power10 MMA (Matrix Math Accelerator)

```
OpÃ©rations matricielles accÃ©lÃ©rÃ©es
Support :
- POWER10 (2021)
- Accumulation 4Ã—4 matrices

Support MariaDB :
âœ… POWER10 MMA = Optimisations spÃ©cifiques
ğŸš€ Excellent pour dot products
```

---

## DÃ©tection du support matÃ©riel

### Linux x86_64

```bash
# VÃ©rifier flags CPU
lscpu | grep -E 'avx|sse|fma'

# RÃ©sultat exemple :
# Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca 
#        cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht 
#        tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art 
#        arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc 
#        cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx 
#        smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 
#        sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave 
#        avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault 
#        invpcid_single pti ssbd ibrs ibpb stibp tpr_shadow vnmi 
#        flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 
#        avx2 smep bmi2 erms invpcid mpx rdseed adx smap 
#        clflushopt intel_pt xsaveopt xsavec xgetbv1 xsaves dtherm 
#        ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp

# DÃ©tail par extension
cat /proc/cpuinfo | grep flags | head -1 | grep -o 'sse[^ ]*'
cat /proc/cpuinfo | grep flags | head -1 | grep -o 'avx[^ ]*'

# VÃ©rifier AVX-512
cat /proc/cpuinfo | grep flags | grep -q avx512f && echo "AVX-512 supported" || echo "AVX-512 not supported"
```

### Linux ARM64

```bash
# VÃ©rifier support NEON
cat /proc/cpuinfo | grep -i neon

# Apple Silicon
sysctl -a | grep cpu.features
# machdep.cpu.features: FPU VME DE PSE TSC MSR PAE MCE CX8 APIC SEP 
#                       MTRR PGE MCA CMOV PAT PSE36 CLFSH DS ACPI 
#                       MMX FXSR SSE SSE2 SS HTT TM PBE SSE3 PCLMULQDQ 
#                       DTES64 MON DSCPL VMX SMX EST TM2 SSSE3 FMA 
#                       CX16 TPR PDCM SSE4.1 SSE4.2 x2APIC MOVBE POPCNT 
#                       AES PCID XSAVE OSXSAVE SEGLIM64 TSCTMR AVX1.0 
#                       RDRAND F16C

# ARMv8 features
cat /proc/cpuinfo | grep Features
# Features : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp 
#            asimdhp cpuid asimdrdm lrcpc dcpop asimddp ssbs
```

### IBM Power

```bash
# VÃ©rifier VSX
cat /proc/cpuinfo | grep -i vsx

# Power10 MMA
ppc64_cpu --info | grep -i mma
```

---

## Configuration MariaDB

### Variables de configuration

```ini
# /etc/mysql/my.cnf

[mysqld]
# Activation SIMD (ON par dÃ©faut si supportÃ©)
vector_simd_enabled = ON

# Type SIMD utilisÃ© (dÃ©tection automatique)
# Options: NONE, SSE2, SSE3, SSE4, AVX, AVX2, AVX512, NEON, SVE, VSX, MMA
# vector_simd_type = AUTO  (par dÃ©faut)

# Forcer un type spÃ©cifique (rarement nÃ©cessaire)
# vector_simd_type = AVX2

# Niveau de logging SIMD (debug)
# vector_simd_log_level = 0  (0=OFF, 1=INFO, 2=DEBUG)
```

### VÃ©rification configuration

```sql
-- VÃ©rifier support SIMD
SHOW VARIABLES LIKE 'vector_simd%';

-- RÃ©sultat exemple (Intel Xeon Skylake) :
-- Variable_name          | Value
-- -----------------------|-------
-- vector_simd_enabled    | ON
-- vector_simd_type       | AVX512
-- vector_simd_log_level  | 0

-- RÃ©sultat exemple (Apple M2) :
-- Variable_name          | Value
-- -----------------------|-------
-- vector_simd_enabled    | ON
-- vector_simd_type       | NEON
-- vector_simd_log_level  | 0

-- Informations dÃ©taillÃ©es
SHOW GLOBAL STATUS LIKE 'vector_simd%';

-- Variable_name                  | Value
-- -------------------------------|-------
-- vector_simd_distance_calls     | 458923
-- vector_simd_operations_total   | 703456123
-- vector_simd_cycles_saved       | 2814524492
```

### DÃ©sactivation temporaire (test/debug)

```sql
-- DÃ©sactiver SIMD pour comparaison
SET GLOBAL vector_simd_enabled = OFF;

-- Tester performance
SELECT BENCHMARK(10000, 
    VEC_DISTANCE_COSINE(
        (SELECT embedding FROM docs LIMIT 1),
        VEC_FromText('[0.1, 0.2, ...]')
    )
);
-- Temps sans SIMD : ~2500ms

-- RÃ©activer
SET GLOBAL vector_simd_enabled = ON;

-- Tester Ã  nouveau
SELECT BENCHMARK(10000, 
    VEC_DISTANCE_COSINE(
        (SELECT embedding FROM docs LIMIT 1),
        VEC_FromText('[0.1, 0.2, ...]')
    )
);
-- Temps avec AVX2 : ~650ms (3.8Ã— plus rapide)
```

---

## Benchmarks par architecture

### MÃ©thodologie

```sql
-- Table de test standardisÃ©e
CREATE TABLE simd_benchmark (
    id INT PRIMARY KEY AUTO_INCREMENT,
    vec VECTOR(1536)
) ENGINE=InnoDB;

-- Peupler avec 10K vecteurs alÃ©atoires
INSERT INTO simd_benchmark (vec)
SELECT VEC_FromText(CONCAT('[', 
    GROUP_CONCAT(RAND() SEPARATOR ','),
']'))
FROM seq_1_to_10000;

-- ProcÃ©dure de benchmark
DELIMITER $$
CREATE PROCEDURE benchmark_simd(
    IN iterations INT,
    IN simd_enabled BOOLEAN
)
BEGIN
    DECLARE start_time TIMESTAMP(6);
    DECLARE end_time TIMESTAMP(6);
    DECLARE duration_ms DOUBLE;
    
    -- Configuration SIMD
    SET GLOBAL vector_simd_enabled = simd_enabled;
    
    -- Warmup
    SELECT COUNT(*) FROM (
        SELECT VEC_DISTANCE_COSINE(vec, @query_vec)
        FROM simd_benchmark
        LIMIT 100
    ) t;
    
    -- Benchmark
    SET start_time = NOW(6);
    
    SELECT COUNT(*) FROM (
        SELECT VEC_DISTANCE_COSINE(vec, @query_vec)
        FROM simd_benchmark
        ORDER BY VEC_DISTANCE_COSINE(vec, @query_vec)
        LIMIT 10
    ) t;
    
    SET end_time = NOW(6);
    SET duration_ms = TIMESTAMPDIFF(MICROSECOND, start_time, end_time) / 1000.0;
    
    SELECT 
        CASE WHEN simd_enabled THEN 'SIMD ON' ELSE 'SIMD OFF' END AS mode,
        duration_ms,
        @@vector_simd_type AS simd_type;
END$$
DELIMITER ;
```

### RÃ©sultats x86_64

#### Intel Xeon Skylake-SP (AVX-512)

```sql
-- Configuration : Intel Xeon Platinum 8180
-- Cores : 28 Ã— 2.5 GHz
-- SIMD : AVX-512

SET @query_vec = VEC_FromText('[random 1536 floats]');

-- Sans SIMD
CALL benchmark_simd(1, FALSE);
-- mode     | duration_ms | simd_type
-- SIMD OFF | 3456.78     | NONE

-- Avec AVX-512
CALL benchmark_simd(1, TRUE);
-- mode    | duration_ms | simd_type
-- SIMD ON | 428.92      | AVX512

-- Gain : 8.06Ã— plus rapide avec AVX-512
```

#### Intel Core i7 (AVX2)

```sql
-- Configuration : Intel Core i7-12700K
-- Cores : 12 (8P + 4E) Ã— 3.6 GHz
-- SIMD : AVX2

-- Sans SIMD
-- duration_ms : 2876.34

-- Avec AVX2
-- duration_ms : 687.21

-- Gain : 4.19Ã— plus rapide avec AVX2
```

#### AMD Ryzen 9 (AVX2)

```sql
-- Configuration : AMD Ryzen 9 5950X
-- Cores : 16 Ã— 3.4 GHz
-- SIMD : AVX2

-- Sans SIMD
-- duration_ms : 2654.87

-- Avec AVX2
-- duration_ms : 623.45

-- Gain : 4.26Ã— plus rapide avec AVX2
```

### RÃ©sultats ARM64

#### Apple M3 Pro (NEON)

```sql
-- Configuration : Apple M3 Pro
-- Cores : 12 (6P + 6E)
-- SIMD : NEON (optimisÃ© Apple)

-- Sans SIMD
-- duration_ms : 2234.56

-- Avec NEON
-- duration_ms : 512.34

-- Gain : 4.36Ã— plus rapide avec NEON
```

#### AWS Graviton3 (NEON)

```sql
-- Configuration : AWS Graviton3
-- Cores : 64 Ã— 2.6 GHz (Neoverse V1)
-- SIMD : NEON + SVE

-- Sans SIMD
-- duration_ms : 2987.23

-- Avec NEON
-- duration_ms : 734.12

-- Gain : 4.07Ã— plus rapide avec NEON
```

### RÃ©sultats IBM Power

#### Power10 (MMA)

```sql
-- Configuration : IBM Power10
-- Cores : 15 Ã— 3.0 GHz
-- SIMD : VSX + MMA

-- Sans SIMD
-- duration_ms : 3124.45

-- Avec MMA
-- duration_ms : 487.89

-- Gain : 6.40Ã— plus rapide avec Power10 MMA
```

### Tableau comparatif

| Architecture | CPU | SIMD | Sans SIMD (ms) | Avec SIMD (ms) | Gain |
|--------------|-----|------|----------------|----------------|------|
| **x86 Server** | Xeon Skylake | AVX-512 | 3457 | 429 | **8.06Ã—** |
| **x86 Desktop** | Core i7-12700K | AVX2 | 2876 | 687 | 4.19Ã— |
| **x86 AMD** | Ryzen 9 5950X | AVX2 | 2655 | 623 | 4.26Ã— |
| **ARM Apple** | M3 Pro | NEON | 2235 | 512 | 4.36Ã— |
| **ARM Server** | Graviton3 | NEON | 2987 | 734 | 4.07Ã— |
| **Power** | Power10 | MMA | 3124 | 488 | **6.40Ã—** |

ğŸ’¡ **Meilleur choix** : Intel Xeon avec AVX-512 ou IBM Power10 pour performance maximale.

---

## Optimisations par opÃ©ration

### Distance euclidienne

```
Sans SIMD (pseudo-code) :
float distance = 0.0;
for (int i = 0; i < 1536; i++) {
    float diff = a[i] - b[i];
    distance += diff * diff;
}
distance = sqrt(distance);

Avec AVX-512 (16 floats par cycle) :
__m512 sum = _mm512_setzero_ps();
for (int i = 0; i < 1536; i += 16) {
    __m512 va = _mm512_load_ps(&a[i]);
    __m512 vb = _mm512_load_ps(&b[i]);
    __m512 diff = _mm512_sub_ps(va, vb);
    sum = _mm512_fmadd_ps(diff, diff, sum);  // FMA: diffÂ² + sum
}
float distance = sqrt(horizontal_sum(sum));

Cycles CPU :
- Sans SIMD : ~4600 cycles
- AVX-512 : ~300 cycles
- Gain : 15.3Ã— plus rapide
```

### Distance cosinus

```
Sans SIMD :
float dot = 0.0, norm_a = 0.0, norm_b = 0.0;
for (int i = 0; i < 1536; i++) {
    dot += a[i] * b[i];
    norm_a += a[i] * a[i];
    norm_b += b[i] * b[i];
}
float cosine = 1.0 - (dot / (sqrt(norm_a) * sqrt(norm_b)));

Avec AVX-512 (optimisÃ© pour vecteurs normalisÃ©s) :
__m512 sum = _mm512_setzero_ps();
for (int i = 0; i < 1536; i += 16) {
    __m512 va = _mm512_load_ps(&a[i]);
    __m512 vb = _mm512_load_ps(&b[i]);
    sum = _mm512_fmadd_ps(va, vb, sum);  // a*b + sum
}
float cosine = 1.0 - horizontal_sum(sum);

Cycles CPU (vecteurs normalisÃ©s) :
- Sans SIMD : ~3100 cycles
- AVX-512 : ~200 cycles
- Gain : 15.5Ã— plus rapide
```

### Distance Manhattan

```
Avec AVX-512 (absolute difference) :
__m512 sum = _mm512_setzero_ps();
for (int i = 0; i < 1536; i += 16) {
    __m512 va = _mm512_load_ps(&a[i]);
    __m512 vb = _mm512_load_ps(&b[i]);
    __m512 diff = _mm512_sub_ps(va, vb);
    __m512 abs_diff = _mm512_abs_ps(diff);
    sum = _mm512_add_ps(sum, abs_diff);
}
float manhattan = horizontal_sum(sum);

Gain : ~14Ã— plus rapide (pas de sqrt)
```

---

## Choix du hardware

### Serveur dÃ©diÃ© calculs vectoriels

**Option 1 : Intel Xeon Sapphire Rapids (2023+)**

```
Processeur : Intel Xeon Platinum 8480+
Cores : 56 Ã— 2.0 GHz (3.8 GHz boost)
SIMD : AVX-512 (toutes extensions)
MÃ©moire : 8 canaux DDR5-4800
Prix : ~$12,000 par socket

Avantages :
âœ… AVX-512 complet (meilleure performance)
âœ… MÃ©moire DDR5 rapide
âœ… AMX (AI accelerator) pour ML

InconvÃ©nients :
âŒ Prix Ã©levÃ©
âŒ Consommation Ã©levÃ©e (350W TDP)

Cas d'usage :
- Recherche sÃ©mantique 24/7
- Millions de vecteurs
- Latence critique (<10ms)
```

**Option 2 : AMD EPYC Genoa (2022+)**

```
Processeur : AMD EPYC 9654
Cores : 96 Ã— 2.4 GHz (3.7 GHz boost)
SIMD : AVX2 (pas AVX-512 complet)
MÃ©moire : 12 canaux DDR5-4800
Prix : ~$11,000 par socket

Avantages :
âœ… Plus de cores (96 vs 56)
âœ… EfficacitÃ© Ã©nergÃ©tique meilleure
âœ… Prix/performance compÃ©titif

InconvÃ©nients :
âŒ AVX-512 incomplet
âŒ SIMD lÃ©gÃ¨rement moins performant

Cas d'usage :
- ParallÃ©lisation massive
- Budget optimisÃ©
- Workloads mixtes
```

**Option 3 : IBM Power10**

```
Processeur : IBM Power10
Cores : 15 Ã— 3.0 GHz (SMT-8)
SIMD : VSX + MMA
MÃ©moire : jusqu'Ã  4TB
Prix : ~$15,000+ par socket

Avantages :
âœ… MMA trÃ¨s efficace (dot products)
âœ… SMT-8 (120 threads logiques)
âœ… Excellente bande passante mÃ©moire

InconvÃ©nients :
âŒ Prix trÃ¨s Ã©levÃ©
âŒ Ã‰cosystÃ¨me limitÃ©
âŒ Moins de support logiciel

Cas d'usage :
- Entreprises dÃ©jÃ  sur Power
- Charges trÃ¨s intensives
- IA/ML enterprise
```

### Cloud instances

**AWS EC2**

```sql
-- c7i.16xlarge (Intel Sapphire Rapids)
vCPU : 64 (AVX-512)
RAM : 128 GB
Prix : ~$2.88/heure ($2,113/mois)

-- c7g.16xlarge (Graviton3)
vCPU : 64 (NEON + SVE)
RAM : 128 GB
Prix : ~$2.31/heure ($1,696/mois)
Ã‰conomie : 20% vs Intel

-- Benchmark production (1M vecteurs, recherche top-10) :
-- c7i.16xlarge : ~12ms latence moyenne
-- c7g.16xlarge : ~16ms latence moyenne
-- â†’ Intel 25% plus rapide, mais 20% plus cher
```

**Google Cloud**

```sql
-- n2d-highcpu-64 (AMD EPYC Milan)
vCPU : 64 (AVX2)
RAM : 64 GB
Prix : ~$2.15/heure

-- c3-highcpu-176 (Intel Sapphire Rapids)
vCPU : 176 (AVX-512)
RAM : 352 GB
Prix : ~$6.50/heure
```

**Azure**

```sql
-- Standard_D64as_v5 (AMD EPYC Genoa)
vCPU : 64 (AVX2)
RAM : 256 GB
Prix : ~$3.50/heure

-- Standard_FX48mds_v2 (Intel Ice Lake)
vCPU : 48 (AVX-512)
RAM : 1.5 TB
Prix : ~$7.00/heure
```

---

## Monitoring et diagnostics

### MÃ©triques SIMD

```sql
-- Vue monitoring SIMD
CREATE VIEW simd_performance AS
SELECT 
    @@vector_simd_enabled AS simd_enabled,
    @@vector_simd_type AS simd_type,
    
    -- Compteurs globaux
    (SELECT variable_value FROM information_schema.global_status 
     WHERE variable_name = 'vector_simd_distance_calls') AS distance_calls,
    
    (SELECT variable_value FROM information_schema.global_status 
     WHERE variable_name = 'vector_simd_operations_total') AS operations_total,
    
    (SELECT variable_value FROM information_schema.global_status 
     WHERE variable_name = 'vector_simd_cycles_saved') AS cycles_saved,
    
    -- Calcul gain performance
    (SELECT variable_value FROM information_schema.global_status 
     WHERE variable_name = 'vector_simd_cycles_saved') /
    (SELECT variable_value FROM information_schema.global_status 
     WHERE variable_name = 'vector_simd_operations_total') AS avg_speedup;

-- Consulter
SELECT * FROM simd_performance;
```

### DÃ©tection de rÃ©gression

```sql
-- Historique performance
CREATE TABLE simd_benchmarks (
    benchmark_id INT PRIMARY KEY AUTO_INCREMENT,
    benchmark_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    simd_type VARCHAR(20),
    operations INT,
    duration_ms DOUBLE,
    throughput_ops_sec DOUBLE,
    
    INDEX idx_date (benchmark_date)
) ENGINE=InnoDB;

-- ProcÃ©dure benchmark automatique
DELIMITER $$
CREATE PROCEDURE run_simd_benchmark()
BEGIN
    DECLARE start_time TIMESTAMP(6);
    DECLARE end_time TIMESTAMP(6);
    DECLARE duration DOUBLE;
    DECLARE ops_count INT DEFAULT 10000;
    
    SET start_time = NOW(6);
    
    -- ExÃ©cuter 10K calculs distance
    SELECT COUNT(*) INTO @dummy FROM (
        SELECT VEC_DISTANCE_COSINE(embedding, @query_vec)
        FROM documents
        LIMIT 10000
    ) t;
    
    SET end_time = NOW(6);
    SET duration = TIMESTAMPDIFF(MICROSECOND, start_time, end_time) / 1000.0;
    
    -- Enregistrer rÃ©sultat
    INSERT INTO simd_benchmarks 
    (simd_type, operations, duration_ms, throughput_ops_sec)
    VALUES (
        @@vector_simd_type,
        ops_count,
        duration,
        ops_count / (duration / 1000.0)
    );
END$$
DELIMITER ;

-- Planifier benchmark quotidien
CREATE EVENT daily_simd_benchmark
ON SCHEDULE EVERY 1 DAY
DO CALL run_simd_benchmark();

-- Analyser Ã©volution
SELECT 
    DATE(benchmark_date) AS date,
    simd_type,
    AVG(throughput_ops_sec) AS avg_throughput,
    MIN(throughput_ops_sec) AS min_throughput,
    MAX(throughput_ops_sec) AS max_throughput
FROM simd_benchmarks
WHERE benchmark_date >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY DATE(benchmark_date), simd_type
ORDER BY date DESC;
```

---

## Troubleshooting

### ProblÃ¨me : SIMD non dÃ©tectÃ©

```bash
# SymptÃ´me
mysql> SHOW VARIABLES LIKE 'vector_simd_type';
# vector_simd_type | NONE

# VÃ©rification 1 : CPU supporte SIMD ?
lscpu | grep -i avx
# Si vide â†’ CPU ne supporte pas AVX

# VÃ©rification 2 : MariaDB compilÃ© avec support SIMD ?
mysql -V | grep -i simd
# MariaDB Server 11.8.0 ... (simd: avx2, avx512)

# VÃ©rification 3 : DÃ©sactivÃ© dans configuration ?
grep vector_simd /etc/mysql/my.cnf
# vector_simd_enabled = OFF  â† problÃ¨me trouvÃ©

# Solution
SET GLOBAL vector_simd_enabled = ON;
```

### ProblÃ¨me : Performance dÃ©gradÃ©e

```sql
-- SymptÃ´me : Latence 2Ã— plus Ã©levÃ©e qu'attendu

-- Diagnostic 1 : VÃ©rifier activation
SHOW VARIABLES LIKE 'vector_simd_enabled';
-- Si OFF, activer

-- Diagnostic 2 : VÃ©rifier type SIMD
SHOW VARIABLES LIKE 'vector_simd_type';
-- Si SSE2 au lieu de AVX2 â†’ problÃ¨me dÃ©tection

-- Diagnostic 3 : Thermal throttling (AVX-512)
# Sur systÃ¨me Linux
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq
# Comparer avec scaling_max_freq

# Si frÃ©quence baisse significativement sous charge AVX-512
# â†’ CPU throttle thermiquement

-- Solution : Forcer AVX2 au lieu de AVX-512
SET GLOBAL vector_simd_type = 'AVX2';
```

### ProblÃ¨me : Corruption de donnÃ©es

```sql
-- SymptÃ´me : RÃ©sultats incohÃ©rents

-- Diagnostic : VÃ©rifier alignement mÃ©moire
-- (rarement un problÃ¨me, mais possible)

-- Test simple
SELECT VEC_DISTANCE_COSINE(
    VEC_FromText('[1, 0, 0]'),
    VEC_FromText('[0, 1, 0]')
);
-- Doit retourner : 1.0 (vecteurs orthogonaux)

-- Si rÃ©sultat != 1.0 â†’ problÃ¨me SIMD

-- Solution temporaire
SET GLOBAL vector_simd_enabled = OFF;

-- Rapporter bug Ã  MariaDB
```

---

## Bonnes pratiques

### âœ… Recommandations

1. **Laisser dÃ©tection automatique**
   ```ini
   # my.cnf - laisser dÃ©faut
   vector_simd_enabled = ON
   # vector_simd_type = AUTO (dÃ©faut)
   ```

2. **VÃ©rifier support aprÃ¨s installation**
   ```sql
   SELECT @@vector_simd_type;
   -- Doit retourner : AVX2, AVX512, NEON, etc.
   ```

3. **Benchmarker avant production**
   ```sql
   CALL run_simd_benchmark();
   -- Ã‰tablir baseline performance
   ```

4. **Monitorer rÃ©gression**
   ```sql
   -- Event quotidien
   CREATE EVENT daily_benchmark ...
   ```

5. **Choisir CPU avec SIMD rÃ©cent**
   ```
   Minimum : AVX2 (Intel Haswell 2013+, AMD Excavator 2015+)
   Optimal : AVX-512 (Intel Skylake-SP 2017+)
   ARM : NEON (obligatoire sur ARM64)
   ```

6. **Attention thermal throttling AVX-512**
   ```bash
   # Surveiller tempÃ©ratures
   sensors | grep -i core
   ```

### âš ï¸ PiÃ¨ges Ã  Ã©viter

1. **DÃ©sactiver SIMD sans raison** â†’ Perte 4-8Ã— performance
2. **Ignorer architecture CPU** â†’ Sous-utiliser hardware
3. **Pas de benchmarks** â†’ Pas de baseline
4. **MÃ©langer architectures** â†’ RÃ©sultats incohÃ©rents
5. **NÃ©gliger refroidissement** â†’ Throttling AVX-512
6. **VM sans flags CPU** â†’ SIMD dÃ©sactivÃ©

---

## âœ… Points clÃ©s Ã  retenir

- **SIMD** = Single Instruction Multiple Data, parallÃ©lisation matÃ©rielle
- **Gains typiques** : 4-8Ã— plus rapide selon architecture
- **x86 : AVX-512** = meilleur (8Ã—), AVX2 = standard (4Ã—)
- **ARM : NEON** = standard (4Ã—), SVE = futur
- **Power : MMA** = excellent pour dot products (6Ã—)
- **DÃ©tection automatique** dans MariaDB 11.8+
- **Activation par dÃ©faut** si CPU supporte
- **Intel Xeon AVX-512** = meilleur choix serveur vectoriel
- **ARM Graviton** = excellent rapport prix/performance cloud
- **Monitoring** crucial pour dÃ©tecter rÃ©gressions
- **Benchmarks** essentiels avant dÃ©ploiement production

---

## ğŸ”— Ressources et rÃ©fÃ©rences

- [ğŸ“– MariaDB - SIMD Optimizations](https://mariadb.com/kb/en/vector-simd-optimizations/)
- [ğŸ”¬ Intel Intrinsics Guide](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/)
- [ğŸ”¬ ARM NEON Programming](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon)
- [ğŸ“š SIMD Wikipedia](https://en.wikipedia.org/wiki/SIMD)
- [âš¡ AVX-512 Deep Dive](https://en.wikichip.org/wiki/x86/avx-512)
- [ğŸš€ Power10 MMA](https://www.ibm.com/docs/en/power10)

---


â­ï¸ [IntÃ©gration avec LLMs (OpenAI, Claude, LLaMA)](/18-fonctionnalites-avancees/10.6-integration-llms.md)
